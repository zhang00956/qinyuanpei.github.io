<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>PayneQin&#39;s Blog</title>
  
  <subtitle>人生到处知何似，应似飞鸿踏雪泥</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://qinyuanpei.github.io/"/>
  <updated>2018-08-24T05:39:27.482Z</updated>
  <id>http://qinyuanpei.github.io/</id>
  
  <author>
    <name>Payne</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>长安不见使人愁</title>
    <link href="http://qinyuanpei.github.io/posts/3417652955/"/>
    <id>http://qinyuanpei.github.io/posts/3417652955/</id>
    <published>2018-08-10T20:42:23.000Z</published>
    <updated>2018-08-24T05:39:27.482Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>&emsp;&emsp;“大道如青天，我独不得出”。这是唐朝大诗人李白在《行路难》(其二)中的感慨，相比“长风破浪直济沧海”的豪迈，这首诗反而显得矫情啦，仿佛生活就应该陪着大家一起笑，我这种神经兮兮的文艺Boy，就只有这片手机屏幕大小的地方，来说些不合时宜的冷笑话。这大概是博客能让我坚持写下去的理由，因为它的的确确是属于你的，那么请原谅我，因为我要在这里写点矫情的话。</p><p>&emsp;&emsp;上周一个人独自从公司办理完离职手续，原来那天下午是可以不用下班打卡的，这种感觉就好像是，你坚持并且在乎了很久的一件事情，在某一瞬间突然变得不再重要。我突然意识到，我居然已经在这个城市里生活了两年多。两年多是种什么体验呢？或许是曾经说过再见的朋友再没有见过面，又或许是曾经拒绝过你的女孩子终于结了婚，又或许是青龙寺里的樱花们开了一年又一年，又或许是遗址公园里石榴又从青色变成了红色……你脑海中的记忆越来越浅，而额头上的皱纹越来越深，记忆果真都被时间从额头上凿了去吗？</p><p>&emsp;&emsp;和朋友们聊天的时候，他们一如既往地感慨着自己婚后的月光生活，一如既往地羡慕着我接近他们三倍的高薪工资，总要在聊天快要结束时侯，一如既往地问我：真的不打算回来了吗？也许，等到银西高铁通车的时候，我终于不用再坐将近12个小时的火车回家。“鸟倦飞而知还”，可我是否是《阿飞正传》里的那一只，那只没有脚的鸟，它只能够一直飞呀飞呀，飞累了就在风里睡觉。我认识的人里，有从大学时代就在这个城市驻足的人，有远离故乡在这个城市扎根的人，无一例外的是，我们都离故乡越来越远，交通的便利和发达，并不足以弥补这种心灵上的距离，就像你从地图上看各个省份好像都离得不远。可没法在一起的人们啊，连最后一步都会觉得遥远啊！我不得不承认，没有人天生会是一个无忧无虑的漂泊者，无论是洛阳还是长安，对我而言都不是故乡。</p><p>&emsp;&emsp;早已忘记是从什么时候开始不吃辣的，真正令我感到神奇的，是这种习惯终于让我带去到不同的城市，就像你很难说清楚，喜欢一个人有多少是来自喜欢，又有多少是来自习惯。周末基本固定的去书店看书，看书的同时亦看匆匆的行人。小寨和钟楼永远不乏光鲜亮丽的男男女女，俨然是这个城市里最繁华的地带，人们的自拍无一不透露着时尚与精致，在某一瞬间，让我这个来自三四线小城市的人，相形见绌到沉默不言。想象下大唐盛世里的长安城，最繁华的市集无外东西两市，马亲王的《长安十二时辰》所展现的盛唐风物，对真实的历史而言，不过是雪泥鸿爪、惊鸿一瞥。如今西市为商业街所包围，一座大唐西市博物馆悄立其中，其形堪称寂寥否？西安遍地都是商场、购物中心，其盛堪比大唐否？</p><p>&emsp;&emsp;我曾经开玩笑地和朋友说，我现在喜欢观察路上行人们的穿搭，仿佛这样能让我喜欢的女孩子愿意看我一眼，朋友不无嘲讽地说，“你这是在东施效颦啊”，就连我喜欢的女孩子都说，“每个人都会有自己喜欢的风格啊”。可其实，我只有一点能确定，我明确知道我不喜欢那种风格，倘若真要问我喜欢什么，我真的不知道啊！不要以为只有女孩子，会在面对琳琅满目的商品时选择困难，在这个选择多样化的时代，明确知道自己想要什么，对每一个人而言，反倒是一种相当稀缺的品质。就像人只有长大了以后才会明白，做一个优秀的男人是多么困难的事情，做学生的时候比的是学习成绩，做男人的时候则是比社会化综合测评。初到长安“居之不易”的白居易，和此时的你我是何其相似，彼时长安是大唐的首都，此时西安是新新一线城市，历史啊，果然都是相似的嘛，所不同的只是当事人。</p><p>&emsp;&emsp;朋友们都希望我可以“自信”点，可终于有这样一天，你做到了曾经想做而不敢做的事情，这一切又是否真的会如你所愿。人啊，总是情愿活在借口里。我有位朋友常常“一语惊人”，简直就是“语不惊人死不休”的典型代表，他说，“不管男人的话还是女人的话，都不要相信”。大意就是说，人家就是那么随口一说，你这还当真了不是。姜文《让子弹飞》里有一个情节，小六子被诬陷吃了两碗凉粉却给了一碗凉粉钱，百口莫辩的小六子，不得已剖开肚子来自证清白。其实，世上好多事情都是没有道理的，你证明了你可以做到某一件事情又能怎么样呢？时过境迁，当一切都重新归于平静，也许人家就是那么随口一说，也许人家早都忘记了说过这句话，而你却守着这个可笑的执念等到花儿都谢了。人呐，偶尔狠下心来，是因为这样很爽吗？就像人们喜欢暴力一样。其实，真正的自信应该是温柔的，很多时候你以为的自信，无非是任性罢了。一个小孩子，会因为你帮他捡起掉在地上的扇子，而对你微笑，即使他还不会说话。</p><p>&emsp;&emsp;有时候，我会想人们对于一件事物的评价标准为何会存在差异，这是否是因为我们根本不了解自己。人类其实和猴子差不了多少，对这个世界总是充满好奇，似乎什么都想要去尝试。喜欢吃喝玩乐会被认为是懂得享受生活，而喜欢独处内省则会被认为是乏味无趣，可其实大家都是第一次做人，都是第一次面对这个存活了上亿年的星球。当北极圈里开始出现30度的高温，大概在这个世界上并不存在绝对的事情。当所有的标准都被满足，这是否意味着无论对方是谁都可以，我们明明都在执着于找寻唯一的东西，却为何选择了原本和唯一无关的标准。因为但凡有标准存在的地方，它们就注定难以成为独一无二的东西。就像《小偷家族》里的“父亲”，自认为什么都不会除了盗窃，却教会了祥太关于青春期的一切。很多时候爱不像我们想象地拥有一个标准模板，就像这个并不“标准”的家庭，却拥有足以打动我们的情感一样。或许，追求“标准”本来就是件愚蠢的事情，我们自以为个性独立，实际上永远被各种“虚拟”的东西束缚着，正如卢梭所言：“人生而自由，而无往不在枷锁之中”。</p><p>&emsp;&emsp;我想，李白抒发“不见长安”的愁绪时，大抵不会想到日后遇赦时的快意，更不会想到被玄宗逐出长安时的失意。可当你真的了解了你所要面对的人生，是否还有勇气会像现在这样选择。对于我的人生，我不知道今后会是什么样子，我唯一能做的，就是接受我已经失去的一切，长安并不足以安，你会有一个可以令你心安的人出现吗？长安不见，你愿意让我见到你吗？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="生活感悟" scheme="http://qinyuanpei.github.io/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="感悟" scheme="http://qinyuanpei.github.io/tags/%E6%84%9F%E6%82%9F/"/>
    
      <category term="西安" scheme="http://qinyuanpei.github.io/tags/%E8%A5%BF%E5%AE%89/"/>
    
      <category term="矫情" scheme="http://qinyuanpei.github.io/tags/%E7%9F%AB%E6%83%85/"/>
    
  </entry>
  
  <entry>
    <title>基于WebSocket和Redis实现Bilibili弹幕效果</title>
    <link href="http://qinyuanpei.github.io/posts/3269605707/"/>
    <id>http://qinyuanpei.github.io/posts/3269605707/</id>
    <published>2018-08-10T14:07:23.000Z</published>
    <updated>2018-08-24T05:39:27.478Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>&emsp;&emsp;嗨，大家好，欢迎大家关注我的博客，我是Payne，我的博客地址是<a href="https://qinyuanpei.github.io">https://qinyuanpei.github.io</a>。在上一篇博客中，我们使用了.NET Core和Vue搭建了一个基于WebSocket的聊天室。在今天这篇文章中，我们会继续深入这个话题。博主研究WebSocket的初衷是，我们的项目上有需要实时去推送数据来完成图表展示的业务，而博主本人对这个内容比较感兴趣，因为博主有对爬虫抓取的内容进行数据可视化(<strong>ECharts</strong>)的想法。可遗憾的是，这些数据量都不算太大，因为难以支持实时推送这个想法，当然更遗憾的是，我无法在项目中验证以上脑洞，所以，最终退而求其次，博主打算用Redis和WebSocket做一个弹幕的Demo，之所以用Redis，是因为博主懒到不想折腾RabbitMQ。的确，这世界上有很多事情都是没有道理的啊……</p><p>&emsp;&emsp;其实，作为一个业余的数据分析爱好者，我是非常乐意看到炫酷的ECharts图表呈现在我的面前的，可当你无法从一个项目中收获到什么的时候，你唯一的选择就是项目以外的地方啦，所以，在今天这样一个精细化分工的时代，即使你没有机会独立地完成一个项目，我依然鼓励大家去了解项目的“上下文”，因为单单了解一个点并不足以了解事物的全貌。好了，下面我们来简单说明下这个Demo整体的设计思路，即我们通过Redis来“模拟”一个简单的消息队列，客户端发送的弹幕会被推送到消息队列中。当WebSocket完成握手以后，我们定时从消息队列中取出弹幕，并推送到所有客户端。当客户端接收到服务端推送的消息后，我们通过Canvas API完成对弹幕的绘制，这样就可以实现一个基本的弹幕系统啦！</p><h1 id="编写消息推送中间件"><a href="#编写消息推送中间件" class="headerlink" title="编写消息推送中间件"></a>编写消息推送中间件</h1><p>&emsp;&emsp;首先，我们来实现服务端的消息推送，其基本原理是：在客户端和服务端完成“握手”后，我们循环地从消息队列中取出消息，并将消息群发至每一个客户端，这样就完成了消息的推送。同上一篇文章一样，我们继续基于“中间件”的形式，来编写消息推送相关的服务。这样，两个WebSocket服务可以独立运行而不受到相互的干扰，因为我们将采用两个不同的路由。在上一篇文章中，我们给“聊天”中间件WebSocketChat配置的路由为<strong>/ws</strong>ws。这里，我们将“消息推送”中间件WebSocketPush配置的路由为<strong>/push</strong>。这块儿我们做了简化，不再对所有WebSocket的连接状态进行维护，因为对一个弹幕系统而言，它不需要让别人了解某个用户的状态是否发生了变化。所以，这里我们给出关键的代码。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">Invoke</span>(<span class="params">HttpContext context</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!IsWebSocket(context))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> _next.Invoke(context);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> webSocket = <span class="keyword">await</span> context.WebSockets.AcceptWebSocketAsync();</span><br><span class="line">    _socketList.Add(webSocket);</span><br><span class="line">    <span class="keyword">while</span> (webSocket.State == WebSocketState.Open)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> message = _messageQueue.Pull(<span class="string">"barrage"</span>,TimeSpan.FromMilliseconds(<span class="number">2</span>));</span><br><span class="line">        <span class="keyword">foreach</span>(<span class="keyword">var</span> socket <span class="keyword">in</span> _socketList)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">await</span> SendMessage(socket,message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, <span class="string">"Close"</span>, <span class="keyword">default</span>(CancellationToken));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样地，我们需要在Startup类中添加WebSocketPush中间件。按照ASP.NET Core中的惯例，我们为IAppBuilder接口增加一个名为UseWebSocketPush的扩展方法。这样，可以让我们直接使用该方法完成中间件的注册。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">UseWebSocketPush</span>(<span class="params"><span class="keyword">this</span> IApplicationBuilder app</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    app.UseMiddleware&lt;WebSocketPush&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Redis打造的消息队列"><a href="#Redis打造的消息队列" class="headerlink" title="Redis打造的消息队列"></a>Redis打造的消息队列</h1><p>&emsp;&emsp;OK，在编写“消息推送”中间件的时候，我们会注意到，我们使用了一个名为SimpleMessageQueue的类来取得消息，而服务端会负责将该消息群发到所有的客户端。这个其实就是博主写的一个简单的消息队列啦，如此简洁直白的命名证明它的确非常简单。有多简单呢？我想一会儿大家就会找到答案。在此之前，我想和大家讨论这样一个问题。其实，聊天室和弹幕挺像的吧，理论上服务端接收到客户端发的消息，就可以直接群发过去啊，为什么要搞一个消息队列在这里呢？而且更扯的一点是，既然博主你选择用Redis啦，你难道不知道Redis天生就支持发布订阅(<strong>Pub-Sub</strong>)吗？为什么要搞一个消息队列在这里呢？</p><p>&emsp;&emsp;对这个问题，我的想法其实是这样的，我最初想做的是：后端定期推送数据到前端，再由前端通过这些数据来绘制图表。此时，无论后端还是前端，其实都是数据的消费者，这些数据当然不能一股脑儿全给它们啊，这吃撑着了可怎么办，所以，为了避免它们消化不良，我得有一个东西帮助它维持秩序啊，这就是消息队列啊。简单来说，如果数据量超过程序的处理能力，这个时候我们就需要消息队列在前面帮忙“挡”一下。想象一下，如果去银行办理业务的人，都不排队一股脑儿涌向柜台，银行柜员大概会感到崩溃。我们的程序模拟的是现实生活，所以，我们需要消息队列。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/mq01.png" alt="为什么需要消息队列" title="">                </div>                <div class="image-caption">为什么需要消息队列</div>            </figure><p>&emsp;&emsp;那么，有朋友要问啦，就算你要用消息队列，那博主你为什么不用RibbitMQ，再不济可以考虑微软自带的MQ啊，为什么要用Redis做一个MQ呢？就算你坚持要用Redis做MQ，为什么不考虑用的Redis的发布-订阅(<strong>Pub-Sub</strong>)呢？对于第一个问题，你可以理解为我穷或者懒(<strong>穷个什么鬼啊，你特么就是懒<em>(:з」∠)</em></strong>)。我就是懒得去搞RabbitMQ，谁让我电脑C盘都快爆炸了呢，自从我把玩了几次<strong>Docker for Windows</strong>以后，而且我们项目上还真有不被允许用MQ的情况。所以，基于以上原因，我选择了Redis。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/mq02.png" alt="Redis中的Pub-Sub" title="">                </div>                <div class="image-caption">Redis中的Pub-Sub</div>            </figure><p>&emsp;&emsp;那么，为什么不用发布-订阅(<strong>Pub-Sub</strong>)呢，因为观察者模式的一个前提是，订阅者和主题必须在同一个上下文，即消息的发送方和接受方都必须同时“在线”。可Bilibili的弹幕和用户的在线与否无关，这意味着发弹幕与接收弹幕可以不在同一个时刻，所以，在设计上我们是提供了一个API接口来发送弹幕，而不是直接通过WebSocket来发送。否则，消息都到达服务端了，再通过一个消息队列来取消息，这就真的有点奇怪了不是吗？</p><p>&emsp;&emsp;下面给出这个消息队列的实现，原理上是这样的，每一个消息所在的Channel，实际上都是一个列表，我们使用Channel的名称作为这个列表的键。接下来，ServiceStack提供的Redis客户端中，提供了名为BlockingListItem()的方法，它可以提供类似消息队列的功能，我们在这个基础上实现了一个简单的消息队列。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SimpleMessageQueue</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">string</span> _connectionString;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> BasicRedisClientManager _clientManager;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleMessageQueue</span>(<span class="params"><span class="keyword">string</span> connectionString</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _connectionString = connectionString;</span><br><span class="line">        _clientManager = <span class="keyword">new</span> BasicRedisClientManager(_connectionString);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Push</span>(<span class="params"><span class="keyword">string</span> channel, <span class="keyword">string</span> messsage</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">var</span> client = _clientManager.GetClient())</span><br><span class="line">        &#123;</span><br><span class="line">            client.PushItemToList(channel, messsage);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Push</span>(<span class="params"><span class="keyword">string</span> channel, IEnumerable&lt;<span class="keyword">string</span>&gt; messages</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">var</span> client = _clientManager.GetClient())</span><br><span class="line">        &#123;</span><br><span class="line">            client.AddRangeToList(channel, messages.ToList());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">Pull</span>(<span class="params"><span class="keyword">string</span> channel,TimeSpan interval</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">var</span> client = _clientManager.GetClient())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> client.BlockingDequeueItemFromList(channel,interval);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相应地，在WebSocketPush中间件中，我们通过Pull()方法来取得消息，时间间隔为2s。在MessageController中，我们提供了用以发送弹幕的API接口，它实际上调用了Push()方法，这个非常简单啦，我们不再做详细说明。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">HttpPost</span>]</span><br><span class="line">[<span class="meta">Route(<span class="meta-string">"/api/message/publish/barrage"</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> IActionResult <span class="title">Publish</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stream stream = HttpContext.Request.Body;</span><br><span class="line">    <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[HttpContext.Request.ContentLength.Value];</span><br><span class="line">    stream.Read(buffer, <span class="number">0</span>, buffer.Length);</span><br><span class="line">    <span class="keyword">string</span> message = System.Text.Encoding.UTF8.GetString(buffer);</span><br><span class="line">    _redisPublisher.Push(<span class="string">"barrage"</span>, message);</span><br><span class="line">    Response.Headers.Add(<span class="string">"Access-Control-Allow-Origin"</span>, <span class="string">"*"</span>);</span><br><span class="line">    <span class="keyword">return</span> Ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用Canvas绘制弹幕"><a href="#使用Canvas绘制弹幕" class="headerlink" title="使用Canvas绘制弹幕"></a>使用Canvas绘制弹幕</h1><p>&emsp;&emsp;好啦，截止到目前为止，我们所有后端的开发已基本就绪。现在，我们来关注下前端的实现。关于WebSocket原生API的使用，在上一篇文章中，我们已经讲过啦，这里我们重点放在客户端提交弹幕以及绘制弹幕。</p><p>&emsp;&emsp;首先来说，客户端提交弹幕到服务器，因为我们已经编写了相应的Web API，所以这里我们简单调用下它就好。和上一篇文章一样，我们继续使用Vue作为我们的前端框架，这对一个不会写ES6和CSS的伪前端来说，是非常友好的一种体验。因为现在是2018年，所以，我们要坚决地放弃jQuery，虽然它的ajax的确很好用，可这里我们还是要使用Axios：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">axios.post(<span class="string">"http://localhost:8002/api/message/publish/barrage"</span>,&#123;</span><br><span class="line">    value: self.value,</span><br><span class="line">    color: self.color,</span><br><span class="line">    time: self.video.currentTime</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接下来，说说弹幕绘制。我们知道，HTML5中提供了基于Canvas的绘图API，所以，我们这里可以用它来完成弹幕的绘制。基本思路是：根据video标签计算出弹幕出现的范围，然后让弹幕从右侧向左逐渐移动，而弹幕的垂直位置则可以是顶部/底部/随机，当弹幕移动到屏幕左侧时，我们从弹幕集合中移除掉这个元素即可。下面给出基本代码，绘图相关的接口可以参考<a href="http://www.w3school.com.cn/tags/html_ref_canvas.asp" target="_blank" rel="noopener">这里</a>，弹幕相关参考了这篇<a href="https://www.zhangxinxu.com/wordpress/2017/09/html5-canvas-video-barrage/" target="_blank" rel="noopener">文章</a>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> context = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">context.shadowColor = <span class="string">'rgba(0,0,0,'</span> + <span class="keyword">this</span>.opacity + <span class="string">')'</span>;</span><br><span class="line">context.shadowBlur = <span class="number">2</span>;</span><br><span class="line">context.font = <span class="keyword">this</span>.fontSize + <span class="string">'px "microsoft yahei", sans-serif'</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="regexp">/rgb\(/</span>.test(<span class="keyword">this</span>.color)) &#123;</span><br><span class="line"> context.fillStyle = <span class="string">'rgba('</span> + <span class="keyword">this</span>.color.split(<span class="string">'('</span>)[<span class="number">1</span>].split(<span class="string">')'</span>)[<span class="number">0</span>] + <span class="string">','</span> + <span class="keyword">this</span>.opacity + <span class="string">')'</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> context.fillStyle = <span class="keyword">this</span>.color;</span><br><span class="line">&#125;</span><br><span class="line">context.fillText(<span class="keyword">this</span>.value, <span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br></pre></td></tr></table></figure><h1 id="翻滚吧，弹幕！"><a href="#翻滚吧，弹幕！" class="headerlink" title="翻滚吧，弹幕！"></a>翻滚吧，弹幕！</h1><p>&emsp;&emsp;OK，现在我们来一起看看最终的效果，如你所见，在视频播放过程中，我们可以通过视频下方的输入框发送弹幕，弹幕会首先经由Redis缓存起来，当到达一定的时间间隔以后，我们就会将消息推送到客户端，这样所有的客户端都会看到这条弹幕，而对于客户端来说，它在和服务端建立WebSocket连接以后，唯一要做的事情就是在onmessage回调中取得弹幕数据，并将其追加到弹幕数组中，关于弹幕绘制的细节，我们在本文的第三节已经做了相关说明，在此不再赘述。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/barrage.gif" alt="弹幕效果展示" title="">                </div>                <div class="image-caption">弹幕效果展示</div>            </figure><br>&emsp;&emsp;这里，我们采用了前后端分离的设计，即使我们没有并使用主流的ES6去实现客户端。因此，这是客户端实际上是一个静态页面，在本地开发阶段，我们可以通过打开多个浏览器窗口来模拟多用户。那么，如果我们希望让更多人来访问这个页面该怎么做呢？这就要说到ASP.NET Core中的静态文件中间件。无论是IIS还是Apache，对静态页面进行展示，是一个Web服务器最基本的能力。在ASP.NET Core中，我们是通过静态文件中间件来实现这个功能，简而言之，通过这个功能，我们就可以让别人通过IP或者域名来访问wwwroot目录下的内容。具体代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.UseDirectoryBrowser();</span><br><span class="line">app.UseStaticFiles();</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;当然，这里有一个细节是为了让别人可以通过IP或者域名来访问你的服务，你需要修改下WebHostBuilder中URL。此外，因为我们在前端界面中使用了绝对的URL去访问WebAPI，因此，当前端页面和WebAPI不在一个域中时，就会出现所谓垮域的问题，这方面的内容非常丰富，因为这是一个再常见不过的问题，身处在这个时代，80%的问题都已经被解决过了，这到底是我们的幸运还是不幸呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WebHost.CreateDefaultBuilder(args)</span><br><span class="line">   .UseStartup&lt;Startup&gt;()</span><br><span class="line">   .UseUrls(<span class="string">"http://*:8002"</span>);</span><br></pre></td></tr></table></figure><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>&emsp;&emsp;本文在<a href="https://qinyuanpei.github.io/posts/1989654282/">上一篇</a>的基础上，借助Redis和WebSocket实现了一个简单的弹幕系统。博主的初衷是想一个数据可视化的小项目，可以通过WebSocket实时地刷新图表，因为在博主看来，数据分析同样是有趣的事情。这篇文章选取博主在工作中遇到的实际场景作为切入点，试图发掘出WebSocket在实时应用方面更多的可能性。</p><p>&emsp;&emsp;首先，我们编写了“消息推送”中间件，并通过不同的路由来处理各自的业务，实现了模块间的相互独立。接下来，我们讨论了Redis作为消息队列的可行性，并基于Redis编写了一个简单的消息队列。最终，通Canvas API完成客户端弹幕的绘制，实现了从后端到前端的方案整合。藉由这个小项目，可以引出ASP.NET Core相关的话题，譬如静态文件中间件、部署、跨域等等的话题，感兴趣的朋友可以自己去做进一步的了解，以上就是这篇博客的全部内容啦，谢谢大家！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="编程语言" scheme="http://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Redis" scheme="http://qinyuanpei.github.io/tags/Redis/"/>
    
      <category term="WebSocket" scheme="http://qinyuanpei.github.io/tags/WebSocket/"/>
    
      <category term=".NET Core" scheme="http://qinyuanpei.github.io/tags/NET-Core/"/>
    
  </entry>
  
  <entry>
    <title>使用.NET Core和Vue搭建WebSocket聊天室</title>
    <link href="http://qinyuanpei.github.io/posts/1989654282/"/>
    <id>http://qinyuanpei.github.io/posts/1989654282/</id>
    <published>2018-08-01T15:42:23.000Z</published>
    <updated>2018-08-24T05:39:27.474Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>&emsp;&emsp;Hi，大家好，我是Payne，欢迎大家关注我的博客，我的博客地址是：<a href="https://qinyuanpei.github.io">https://qinyuanpei.github.io</a>。今天这篇博客，我们来说说WebSocket。各位可能会疑惑，为什么我会突然间对WebSocket感兴趣，这是因为最近接触到了部分“实时”的业务场景，譬如：用户希望在远程视频通话过程中，实时地监控接入方的通话状态，实时地将接入方的响应时间、通话时长以及接通率等信息推送到后台。与此同时，用户可以通过监控平台看到实时变化着的图表。坦白地讲，这种业务场景陌生吗？不，每一年的双11，都能见到小伙伴们实时地“剁手”。所以，在今天这篇文章中，我们会以WebSocket聊天室为例，来讲解如何基于WebSocket构建实时应用。</p><h1 id="WebSocket概述"><a href="#WebSocket概述" class="headerlink" title="WebSocket概述"></a>WebSocket概述</h1><p>&emsp;&emsp;WebSocket是HTML5标准中的一部分，从Socket这个字眼我们就可以知道，这是一种网络通信协议。WebSocket是为了弥补HTTP协议的不足而产生的，我们知道，HTTP协议有一个重要的缺陷，即：请求只能由客户端发起。这是因为HTTP协议采用了经典的请求-响应模型，这就限制了服务端主动向客户端推送消息的可能。与此同时，HTTP协议是无状态的，这意味着连接在请求得到响应以后就关闭了，所以，每次请求都是独立的、上下文无关的请求。这种单向请求的特点，注定了客户端无法实时地获取服务端的状态变化，如果服务端的状态发生连续地变化，客户端就不得不通过“轮询”的方式来获知这种变化。毫无疑问，轮询的方式不仅效率低下，而且浪费网络资源，在这种背景下，WebSocket应运而生。</p><p>&emsp;&emsp;WebSocket协议最早于2008年被提出，并于2011年成为国际标准。目前，主流的浏览器都已经提供了对WebSocket的支持。在WebSocket协议中，客户端和服务器之间只需要做一次握手操作，就可以在客户端和服务器之间实现双向通信，所以，WebSocket可以作为<strong><a href="https://en.wikipedia.org/wiki/Push_technology" target="_blank" rel="noopener">服务器推送</a></strong>的实现技术之一。因为它本身以HTTP协议为基础，所以对HTTP协议有着更好的兼容性，无论是通信效率还是传输的安全性都能得到保证。WebSocket没有同源限制，客户端可以和任意服务器端进行通信，因此具备通过一个单一连接来支持上下游通信的能力。从本质上来讲，WebSocket是一个在握手阶段使用HTTP协议的TCP/IP协议，换句话说，一旦握手成功，WebSocket就和HTTP协议再无瓜葛，下图展示了它与HTTP协议的区别：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/201881bg2017051502.png" alt="HTTP与WebSocket的区别" title="">                </div>                <div class="image-caption">HTTP与WebSocket的区别</div>            </figure><h1 id="构建一个聊天室"><a href="#构建一个聊天室" class="headerlink" title="构建一个聊天室"></a>构建一个聊天室</h1><p>&emsp;&emsp;OK，在对WebSocket有了一个基本的认识以后，接下来，我们以一个最简单的场景来体验下WebSocket。这个场景是什么呢？你已经知道了，答案就是网络聊天室。这是一个非常典型的实时场景。这里我们分为服务端实现和客户端实现，其中：服务端实现自豪地采用.NET Core，而客户端实现采用Vue的双向绑定特性。现在是公元2018年了，当jQuery已成往事，操作DOM这种事情交给框架去做就好，而且我本人很喜欢MVVM这种模式，Vue的渐进式框架，非常适合我这种不会写ES6的伪前端。</p><h2 id="NET-Core与中间件"><a href="#NET-Core与中间件" class="headerlink" title=".NET Core与中间件"></a>.NET Core与中间件</h2><p>&emsp;&emsp;关于.NET Core中对WebSocket的支持，这里主要参考了<a href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/websockets?view=aspnetcore-2.1" target="_blank" rel="noopener">官方文档</a>，在这篇文档中，演示了一个最基本的Echo示例，即服务端如何接收客户端消息并返回消息给客户端。这里，我们首先需要安装<strong>Microsoft.AspNetCore.WebSockets</strong>这个库，直接通过Visual Studio Code内置的终端安装即可。接下来，我们需要在<strong>Startup</strong>类的<strong>Configure</strong>方法中添加WebSocket中间件：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.UseWebSockets()</span><br></pre></td></tr></table></figure></p><p>更一般地，我们可以配置以下两个配置，其中，KeepAliveInterval表示向客户端发送Ping帧的时间间隔；ReceiveBufferSize表示接收数据的缓冲区大小：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> webSocketOptions = <span class="keyword">new</span> WebSocketOptions()</span><br><span class="line">&#123;</span><br><span class="line">    KeepAliveInterval = TimeSpan.FromSeconds(<span class="number">120</span>),</span><br><span class="line">    ReceiveBufferSize = <span class="number">4</span> * <span class="number">1024</span></span><br><span class="line">&#125;;</span><br><span class="line">app.UseWebSockets(webSocketOptions);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;好了，那么怎么接收一个来自客户端的请求呢？这里以官方文档中的示例代码为例来说明。首先，我们需要判断下请求的地址，这是客户端和服务端约定好的地址，默认为<strong>/</strong>，这里我们以<strong>/ws</strong>为例；接下来，我们需要判断当前的请求上下文是否为WebSocket请求，通过<strong>context.WebSockets.IsWebSocketRequest</strong>来判断。当这两个条件同时满足时，我们就可以通过<strong>context.WebSockets.AcceptWebSocketAsync()</strong>方法来得到WebSocket对象，这样就表示“握手”完成，这样我们就可以开始接收或者发送消息啦。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (context.Request.Path == <span class="string">"/ws"</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (context.WebSockets.IsWebSocketRequest)</span><br><span class="line">    &#123;</span><br><span class="line">        WebSocket webSocket = <span class="keyword">await</span> context.WebSockets.AcceptWebSocketAsync();</span><br><span class="line">        <span class="comment">//TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;一旦建立了Socket连接，客户端和服务端之间就可以开始通信，这是我们从Socket中收获的经验，这个经验同样适用于WebSocket。这里分别给出WebSocket发送和接收消息的实现，并针对代码做简单的分析。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">async</span> Task SendMessage&lt;TEntity&gt;(WebSocket webSocket, TEntity entity)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> Json = JsonConvert.SerializeObject(entity);</span><br><span class="line">    <span class="keyword">var</span> bytes = Encoding.UTF8.GetBytes(Json);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> webSocket.SendAsync(</span><br><span class="line">        <span class="keyword">new</span> ArraySegment&lt;<span class="keyword">byte</span>&gt;(bytes),</span><br><span class="line">        WebSocketMessageType.Text,</span><br><span class="line">        <span class="literal">true</span>,</span><br><span class="line">        CancellationToken.None</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这里我们提供一个泛型方法，它负责对消息进行序列化并转化为byte[]，最终调用<strong>SendAsync()</strong>方法发送消息。与之相对应地，客户端会在<strong>onmessage()</strong>回调中就会接受到消息，这一点我们放在后面再说。WebSocket接收消息的方式，和传统的Socket非常相似，我们需要将字节流循环读取到一个缓存区里，直至所有数据都被接收完。下面给出基本的代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buffer = <span class="keyword">new</span> ArraySegment&lt;<span class="keyword">byte</span>&gt;(<span class="keyword">new</span> <span class="keyword">byte</span>[bufferSize]);</span><br><span class="line"><span class="keyword">var</span> result = <span class="keyword">await</span> webSocket.ReceiveAsync(buffer, CancellationToken.None);</span><br><span class="line"><span class="keyword">while</span> (!result.EndOfMessage)</span><br><span class="line">&#123;</span><br><span class="line">result = <span class="keyword">await</span> webSocket.ReceiveAsync(buffer, <span class="keyword">default</span>(CancellationToken));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> json = Encoding.UTF8.GetString(buffer.Array);</span><br><span class="line">json = json.Replace(<span class="string">"\0"</span>, <span class="string">""</span>).Trim();</span><br><span class="line"><span class="keyword">return</span> JsonConvert.DeserializeObject&lt;TEntity&gt;(json, <span class="keyword">new</span> JsonSerializerSettings()</span><br><span class="line">&#123;</span><br><span class="line">    DateTimeZoneHandling = DateTimeZoneHandling.Local</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;虽然不大清楚，为什么这里反序列化后的内容中会有大量的<strong>\0</strong>，以及这个全新的类型ArraySegment到底是个什么鬼，不过程序员的一生无非都在纠结这样两个问题，“it works” 和 “it doesn’t works”，就像人生里会让你纠结的无非是”她喜欢你“和”她不喜欢我“这样的问题。有时候，这样的问题简直就是玄学，五柳先生好读书而不求甚解，我想这个道理在这里同样适用，截止到我写这篇博客前，这个代码一直工作得很好，所以，这两个问题我们可以暂时先放在一边，因为眼下还有比这更为重要的事情。</p><p>&emsp;&emsp;通过这篇<a href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/websockets?view=aspnetcore-2.1" target="_blank" rel="noopener">文档</a>，我们可以非常容易地构建出一个”实时应用“，可是它离我们这篇文章中的目标依然有点距离，如果各位足够细心的话，就会发现这样一个问题，即示例中的代码都是写在<strong>app.Use()</strong>方法中的，这样会使我们的Startup类显得臃肿，而熟悉OWIN或者ASP.NET Core的朋友，就会知道Startup类是一个非常重要的东西，我们通常会在这里配置相关的组件。在ASP.NET Core中，我们可以通过<strong>Configure()</strong>方法来为<strong>IApplicationBuilder</strong>增加相关组件，这种组件通常被称为中间件。那么，什么是中间件呢？</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/201882request-delegate-pipeline.png" alt="中间件示意图" title="">                </div>                <div class="image-caption">中间件示意图</div>            </figure><p>&emsp;&emsp;从这张图中可以看出，中间件实际上是指在HTTP请求管道中处理请求和响应的组件，每个组件都可以决定是否要将请求传递给下一个组件，比如身份认证、日志记录就是最为常见的中间件。在ASP.NET Core中，我们通过app.Use()方法来定义一个Func&lt;RequestDelegate,RequestDelegate&gt;类型的参数，所以，我们可以简单地认为，在ASP.NET Core中，Func&lt;RequestDelegate,RequestDelegate&gt;就是一个中间件，而通过app.Use()方法，这些中间件会根据注册的先后顺序组成一个链表，每一个中间件的输入是上一个中间件的输出，每一个中间件的输出则会成为下一个中间件的输入。简而言之，每一个RequestDelegate对象不仅包含了自身对请求的处理，而且包含了后续中间件对请求的处理，我们来看一个简单的例子：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">app.Use(<span class="keyword">async</span> (context,next)=&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">await</span> context.Response.WriteAsync(<span class="string">"这是第一个中间件\r\n"</span>);</span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.Use(<span class="keyword">async</span> (context,next)=&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">await</span> context.Response.WriteAsync(<span class="string">"这是第二个中间件\r\n"</span>);</span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.Use(<span class="keyword">async</span> (context,next)=&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">await</span> context.Response.WriteAsync(<span class="string">"这是第三个中间件\r\n"</span>);</span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;通过Postman或者任意客户端发起请求，我们就可以得到下面的结果，现在想象一下，如果我们在第一种中间件中不调用next()会怎么样呢？答案是中间件之间的链路会被打断，这意味着后续的第二个、第三个中间件都不会被执行。什么时候我们会遇到这种场景呢？当我们的认证中间件认为一个请求非法的时候，此时我们不应该让用户访问后续的资源，所以直接返回403对该请求进行拦截。在大多数情况下，我们需要让请求随着中间件的链路传播下去，所以，对于每一个中间件来说，除了完成自身的处理逻辑以外，还至少需要调用一次next()，以保证下一个中间件会被调用，这其实和职责链模式非常相近，可以让数据在不同的处理管道中进行传播。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/201882WeChat_20180802122032.jpg" alt="ASP.NET Core中间件示例" title="">                </div>                <div class="image-caption">ASP.NET Core中间件示例</div>            </figure><p>&emsp;&emsp;OK，这里我们继续遵从这个约定，将整个聊天室相关的逻辑写到一个中间件里，这样做的好处是，我们可以将不同的WebSocket互相隔离开，同时可以为我们的Startup类”减负“。事实证明，这是一个正确的决定，在开发基于WebSocket的弹幕功能时，我们就是用这种方式开发了新的中间件。这里，我们给出的是WebSocketChat中间件中最为关键的部分，详细的代码我已经放在<a href="https://github.com/qinyuanpei/dotnetcore-pritices" target="_blank" rel="noopener">Github</a>上啦，大家可以参考<a href="https://github.com/qinyuanpei/dotnetcore-pritices/blob/master/hello-webapi-1/Middlewares/WebSocketChat.cs" target="_blank" rel="noopener">WebSocketChat</a>类，其基本原理是：使用一个字典来存储每一个聊天室中的会话(Socket)，当用户打开或者关闭一个WebSocket连接时，会向服务器端发送一个事件(Event)，这样客户端中持有的用户列表将被更新，而根据发送的消息，可以决定这条消息是被发给指定联系人还是群发：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">Invoke</span>(<span class="params">HttpContext context</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!IsWebSocket(context))</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">await</span> _next.Invoke(context);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> userName = context.Request.Query[<span class="string">"username"</span>].ToArray()[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">var</span> webSocket = <span class="keyword">await</span> context.WebSockets.AcceptWebSocketAsync();</span><br><span class="line">    <span class="keyword">while</span> (webSocket.State == WebSocketState.Open)</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="keyword">var</span> entity = <span class="keyword">await</span> Receiveentity&lt;MessageEntity&gt;(webSocket);</span><br><span class="line">         <span class="keyword">switch</span> (entity.Type)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">case</span> MessageType.Chat:</span><br><span class="line">                  <span class="keyword">await</span> HandleChat(webSocket, entity);</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">             <span class="keyword">case</span> MessageType.Event:</span><br><span class="line">                  <span class="keyword">await</span> HandleEvent(webSocket, entity);</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, <span class="string">"Close"</span>, <span class="keyword">default</span>(CancellationToken));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其中，HandleEvent负责对事件进行处理，HandleChat负责对消息进行处理。当有用户加入聊天室的时候，首先会向所有客户端广播一条消息，告诉大家有新用户加入了聊天室，与此同时，为了让大家可以和新用户进行通信，必须将新的用户列表推送到客户端。同理，当有用户离开聊天室的时候，服务器端会有类似的事件推送到客户端。事件同样是基于消息来实现的，不过这两种采用的数据结构不同，具体大家可以通过源代码来了解。发送消息就非常简单啦，给指定用户发送消息是通过用户名来找WebSocket对象，而群发消息就是遍历字典中的所有WebSocket对象，这一点我们不再详细说啦！</p><h2 id="Vue驱动的客户端"><a href="#Vue驱动的客户端" class="headerlink" title="Vue驱动的客户端"></a>Vue驱动的客户端</h2><p>&emsp;&emsp;在实现服务端的WebSocket以后，我们就可以着手客户端的开发啦！这里我们采用原生的WebSocket API来开发相关功能。具体来讲，我们只需要实例化一个WebSocket类，并设置相应地回调函数就可以了，我们一起来看下面的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> username = <span class="string">"PayneQin"</span></span><br><span class="line"><span class="keyword">var</span> websocket = <span class="keyword">new</span> WebSocket(<span class="string">"ws://localhost:8002/ws?username="</span> + username);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里我们使用<strong>/s</strong>这个路由来访问WebSocket，相应地，在服务端代码中我们需要判断<strong>context.Request.Path</strong>，WebSocket在握手阶段是基于HTTP协议的，所以我们可以以QueryString的形式给后端传递一个参数，这里我们需要一个用户名，它将作为服务端存储WebSocket时的一个键。一旦建立了WebSocket，我们就可以通过回调函数来监听服务器端的响应，或者是发送消息给服务器端。主要的回调函数有onopen、onmessage、onerror和onclose四个，基本使用方法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">websocket.onopen = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"WebSocket连接成功"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">websocket.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"接收到服务端消息："</span> + event.data)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">websocket.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"WebSocket连接发生错误"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">websocket.onclose = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"WebSocket连接关闭"</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;原生的WebSocket API只有两个方法，即send()和close()，这两个方法非常的简单，我们这里不再说明。需要说明的是，客户端使用了Vue来做界面相关的绑定，作为一个不会写CSS、不会写ES6的伪前端，我做了一个相当简洁(简陋)的前端页面，下面给出主要的页面结构，ViewModel层的代码比较多，大家可以参考<a href="https://github.com/qinyuanpei/dotnetcore-pritices/blob/master/client/websocket/index.html" target="_blank" rel="noopener">这里</a>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    Hi，&#123;&#123; username &#125;&#125;。欢迎来到WebSocket聊天室！</span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>/&gt;</span> 发送给：</span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">"sendTo"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"All"</span>&gt;</span>全部<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">v-for</span>=<span class="string">"user in userList"</span> <span class="attr">:value</span>=<span class="string">"user"</span>&gt;</span>&#123;&#123;user&#125;&#125;<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"text"</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"message"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"sendMessage"</span>&gt;</span>发送消息<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"openWebSocket"</span>&gt;</span>打开WebSocket连接<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"closeWebSocket"</span>&gt;</span>关闭WebSocket连接<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"clearMessageList"</span>&gt;</span>清空聊天记录<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"messageList"</span> <span class="attr">v-html</span>=<span class="string">"messageList"</span>&gt;</span></span><br><span class="line">        &#123;&#123; messageList &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;下面是实际的运行效果，果然是非常简洁呢，哈哈:laughing:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/201882WeChat_20180802152612.png" alt="WebSocket聊天室展示" title="">                </div>                <div class="image-caption">WebSocket聊天室展示</div>            </figure><h2 id="再看Websocket"><a href="#再看Websocket" class="headerlink" title="再看Websocket"></a>再看Websocket</h2><p>&emsp;&emsp;好了，我们花了如此大的篇幅来讲WebSocket，那么你对WebSocket了解了多少呢？或许通过这个聊天室的实例，我们对WebSocket有了一个相对直观的认识，可你是否想过换一个角度来认识它呢？我们说过，WebSocket是以HTTP协议为基础的，那么至少可以在握手阶段捕获到相关请求吧！果断在Chrome中打开”开发者工具“，在面板上选择监听”WebSocket”，然后我们就会得到下面的内容。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/201882WeChat_20180802155719.png" alt="WebSocket的秘密-请求" title="">                </div>                <div class="image-caption">WebSocket的秘密-请求</div>            </figure><p>&emsp;&emsp;相比HTTP协议，WebSocket在握手阶段的请求有所变化，主要体现在Upgrade、Connection这两个字段，以及Sec-WebSocket系列的这些字段。下面来分别解释下这些字段的含义，Upgrade和Connection这两个字段，是最为关键的两个字段，它的目的是告诉Apache、Nginx这些服务器，这是一个WebSocket请求。接下来，是Sec-WebSocket-Key、Sec-WebSocket-Protocol和Sec-WebSocket-Version这三个字段，其中Sec-WebSocket-Key是一个由浏览器采用Base64算法随机生成的字符串，目的是验证服务器是否真的支持WebSocket；Sec-WebSocket-Protocol则是一个由用户指定的字符串，目的是区分同一URL下，不同服务所需要的协议；Sec-WebSocket-Version是告诉服务器浏览器支持的WebSocket版本，标准规定9-12的版本号是保留字段，所以在这里我们看到的版本号是13.</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/201882WeChat_20180802155755.png" alt="WebSocket的秘密-响应" title="">                </div>                <div class="image-caption">WebSocket的秘密-响应</div>            </figure><p>&emsp;&emsp;那么，对于这个浏览器发起的这个请求，服务端是如何做出响应的呢？这就要来看看服务端返回的内容。 和客户端发起的请求类似，服务端返回的内容中依然会有Upgrade和Connection这两个字段，它们和请求中的含义是完全一致的。这里需要说明的是Sec-WebSocket-Accept这个字段，我们前面提到，浏览器会通过WebSocket-Key检验服务器是否真的支持WebSocket，具体怎么检验呢？是通过下面的算法。除此之外，一个特殊的地方是这个Response的状态码是101，这表示服务端说：下面我们就按照WebSocket协议来通信吧！当然，一个更为残酷的现实是，从这里开始，就不再是HTTP协议的势力范围了啊：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sec-websocket-accept = base64(hsa1(sec-websocket-key + 258EAFA5-E914-47DA-95CA-C5AB0DC85B11))</span><br></pre></td></tr></table></figure><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>&emsp;&emsp;这篇文章选取了“实时应用”这样一个业务场景作为切入点，引出了本文的主题——WebSocket。WebSocket是一种建立在HTTP协议基础上的双向通信协议，它弥补了以“请求-响应”模型为基础的HTTP协议先天上的不足，客户端无需再通过“轮询”这种方式来获取服务端的状态变化。WebSocket在完成“握手”后，即可以长连接的方式在客户端和服务端间构建双向通道，因而WebSocket可以在实时应用场景下，作为服务器推送技术的一种方案选择。本文以一个WebSocket聊天室的案例，来讲解WebSocket在实际项目中的应用，在这里我们使用ASP.NET Core来完成服务端WebSocket的实现，而客户端选用原生WebSocket API和Vue来实现，在此基础上，我们讲解了ASP.NET Core下中间件的概念，并将服务器端WebSocket以中间件的形式实现。在下一篇文章中，我们将偏重于服务器端的数据推送，客户端将作为数据展现层而存在。好了，以上就是这篇文章的全部内容啦，谢谢大家，让我们一起期待下一篇文章吧！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="编程语言" scheme="http://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="WebSocket" scheme="http://qinyuanpei.github.io/tags/WebSocket/"/>
    
      <category term=".NET Core" scheme="http://qinyuanpei.github.io/tags/NET-Core/"/>
    
      <category term="Vue" scheme="http://qinyuanpei.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>草食系程序员的穿搭指南</title>
    <link href="http://qinyuanpei.github.io/posts/94443781/"/>
    <id>http://qinyuanpei.github.io/posts/94443781/</id>
    <published>2018-07-25T10:11:35.000Z</published>
    <updated>2018-08-24T05:39:27.482Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script>    <div id="aplayer-sXZcoyhN" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="432821964" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="false" data-listmaxheight="340px" data-preload="none" data-theme="#ad7a86"></div><p>&emsp;&emsp;最近一直在看《逃避虽可耻但有用》(逃げるは恥だが役に立つ)这部日剧，当我们感慨各种脑洞都满足不了人类的好奇心时，日剧依然在老老实实地讲述着故事，即使这个故事离普通人依旧很遥远。可我认为，这是一部以轻喜剧为载体的温情剧，不管你是单身、恋爱中还是已婚，你都能从这部剧中找到自己对应的部分。所以，对于这部日剧而言，我个人是推荐大家去看一看的。原谅我不肯用我贫乏的语言去评价这部电视剧，因为我相信“此中不足为外人道也”。所谓“如人饮水，冷暖自知”，感情这件事情，懂的人自然会懂，不懂的人假装懂。</p><p>&emsp;&emsp;剧中男主津崎平匡是一个“典型”的程序员，因为外表无攻击性，一脸的人畜无害，而被女主森山实栗称为“草食系”男人。男主的长相在主流审美中或许谈不上帅，因为这个世界更欣赏的，是风见君这样帅气的男人。程序员群体木讷而内向的性格，其实都是大众给贴上去的标签。人们不喜欢被贴上各种标签，可人们喜欢给别人贴各种标签，因为这样子区分不同的人最省事儿。我们无法指责这个世界用五官和三观来割裂地看待一个人，我们唯一能做的，就是去改变留在人们心中的刻板印象。剧中男主在很多方面是比我们优秀的，向他学习不能保证我们会娶到Gakki，可能让我们变得更优秀。</p><p>&emsp;&emsp;好了，下面就由我带大家一起来盘点男主在剧中的穿搭，所以，这是一篇总结向的草食系程序员穿搭指南。考虑到这部剧中室内场景比室外场景更多，季节主要集中在秋冬季，所以，我们将从环境、季节、种类等多个维度，对男主在剧中的穿搭进行盘点。活在一个看脸的时代最大的悲哀就是，那些长得比你好看，明明可以靠颜值，非要靠才华的人，永远都比你更努力。虽然津崎先生经常被人说“低情商”和“屌丝”，可我相信他比我们大多数“屌丝”要优秀得多。当然，这些优点需要大家在剧中去发掘。我只是希望，通过这种方式来提升自我。面对来自这个世界的恶意，争辩是没有意义的，你只能努力去纠正这种偏见。</p><h1 id="室内篇"><a href="#室内篇" class="headerlink" title="室内篇"></a>室内篇</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/20180724012456548-101-2018725.jpg" alt="20180724012456548-101-2018725" title="">                </div>                <div class="image-caption">20180724012456548-101-2018725</div>            </figure><p>1、深蓝色衬衣 + 深绿色休闲裤。作为职场日常穿搭，在第一集中出现，中年已婚男士池日在男主津崎面前炫耀“爱妻便当”，高情商的田沼先生替男主解围，安慰男主要好好吃饭。建议搭配：休闲皮鞋 + 一条优质皮带。同样地，我想说的是，一个人更要好好吃饭。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/20180724012544572102-2018725.jpg" alt="20180724012544572102-2018725" title="">                </div>                <div class="image-caption">20180724012544572102-2018725</div>            </figure><p>2、蓝色衬衣 + 西裤，俨然是雇主与雇员的上下级关系。女主森山实栗通过试用期考核，指令清晰、有条不紊给女主留下良好印象。作为职场常规搭配，搭配黑框眼睛，给人一种斯文儒雅的感觉，建议根据个人肤色，选择合适的颜色，具体来讲，如果你皮肤较白，建议选择明亮的色彩；如果你皮肤较黑，建议选择中性的色彩。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/20180724012633880103-2018725.jpg" alt="20180724012633880103-2018725" title="">                </div>                <div class="image-caption">20180724012633880103-2018725</div>            </figure><p>3、因为业务需求发生变更，男主被公司安排加班，在大家的共同努力下，项目终于按时完成，男主小心翼翼地在同事面前测试程序，衬衣领口的双色纹路，避免了视觉上的枯燥感，同事们在身后欢呼，男主深藏功与名，穿一件白衬衣，幻想自己是阿泰尔，千军万马避白袍，写程序没有Bug。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/20180724012656554104-2018725.jpg" alt="20180724012656554104-2018725" title="">                </div>                <div class="image-caption">20180724012656554104-2018725</div>            </figure><p>4、每个程序员都会有一件格子衬衫，仙剑之父姚壮宪更是穿了一辈子格子衬衫。讲道理，男主穿格子衬衫难看吗？为什么程序员穿格子衬衫和特步鞋就要被黑到异次元呢？其实，只要不是浮夸的大格子衬衫，穿起来一样萌萌哒，关键是合体！当然，只要一胖就完啦。所以，穿搭是技巧，健身是根本啊。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/20180724012839470105-2018725.jpg" alt="20180724012839470105-2018725" title="">                </div>                <div class="image-caption">20180724012839470105-2018725</div>            </figure><p>5、女人变美只需要一只口红，而男人变帅只需要一条领带。男女主决定协议结婚后，召集双方父母商议结婚事宜。一套贴合肩线的西装，搭配一件白色衬衫，视觉上给人成熟稳重的感觉，男主虽然在剧中表现得很“怂”，可这并不影响他的“帅”啊，这套衣服最多算彩排，真正的新郎礼服请关注第11集……(嗯，这是最后一集，日剧追起来很快呦)</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/20180724012746230106-2018725.jpg" alt="20180724012746230106-2018725" title="">                </div>                <div class="image-caption">20180724012746230106-2018725</div>            </figure><p>6、简洁到不能再简洁的短袖衬衣 + 牛仔裤。前一秒的踌躇满志，同下一秒的惊慌失措，莫名地戳中萌点，明明同事就在眼前，非要学人家卷福发短信。请女生们不要再吐槽男生穿衣服“土”，你告诉我，除了长裤和短裤我们还有什么？对了，短裤是不能穿的哦……，尤其是花花绿绿的那种🙃</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/20180724012906742107-2018725.jpg" alt="20180724012906742107-2018725" title="">                </div>                <div class="image-caption">20180724012906742107-2018725</div>            </figure><p>7、蓝白相间的衬衣，相比普通蓝色衬衣，平添了一种活泼的感觉，就连工牌卡的绳子都来凑热闹。你知道怎么快速从人群中识别一名程序员吗？牛仔裤 + 双肩包 + 工牌卡。不，我拒绝这种符号化的穿搭，大隐隐于市，忘了这套新手村装备吧……当然，如果你包里还是各种数据线……好像换汤不换药啊(逃</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/20180724013156508108-2018725.jpg" alt="20180724013156508108-2018725" title="">                </div>                <div class="image-caption">20180724013156508108-2018725</div>            </figure><p>8、任何领域都会鄙视链的存在，像津崎先生这样优秀的工程师，自然远非某某培训班的学生们。如何做一名优雅的学院派呢？你需要一件毛衣或者是一件马甲，而且一定要套在衬衣上。你问我为什么这么穿，因为通常教授们都这样穿，请参考卷福主演的电影《模仿游戏》，负责破译德军恩尼格码密码机的专家们，都是这样的穿着，同样的，还有《万物李军》里剑桥的教授们……</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/20180724013332938109-2018725.jpg" alt="20180724013332938109-2018725" title="">                </div>                <div class="image-caption">20180724013332938109-2018725</div>            </figure><p>9、同样是毛衣和衬衣的搭配，圆领和V领是一种风格，是否翻出衬衣领又是一种风格。而我们的男主，显然可以同时驾驭这两种风格，再搭配一件休闲外套，试问还有谁？风见君帅是帅了，不过他的衣服好像永远都是针织衫啊，难道说有钱人都喜欢买一堆一样的衣服？恩，我说的就是老乔和小扎这种有钱人……</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/20180724013332940110-2018725.jpg" alt="20180724013332940110-2018725" title="">                </div>                <div class="image-caption">20180724013332940110-2018725</div>            </figure><p>10、果然，有圆领就会有V领，强迫症对工牌卡挂绳莫名地充满好感，这个“V”字完美地贴合衣领。针织衫和衬衣，需要有一定的层次感，比如备受我们嫌弃的格子衬衫，如果搭配针织衫效果还是非常不错的，唯一的要求或许是肩膀不能过宽，因为这样会显得整体线条僵硬。我有一个问题，像女主这样宽肩膀的女生，穿一字肩真的不怕滑下来吗？😂</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/20180724013332943111-2018725.jpg" alt="20180724013332943111-2018725" title="">                </div>                <div class="image-caption">20180724013332943111-2018725</div>            </figure><p>11、这种“假领”的毛衣，穿出来同样好看，我严重怀疑，这个创意是来自上海静安区同福里的老马。如果你的脖子比较长，可以考虑尝试下高领毛衣，请注意，我不是在教你，去做一名女装大佬。话说回来，衬衣上套毛衣最大的缺点是，需要挤上衬衣最上面的扣子，所以买衬衣时，请确保可以放入两根手指，这样子不会像《杀破狼2》里的张晋一样被“帅”死。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/20180724013332944112-1-2018725.jpg" alt="20180724013332944112-1-2018725" title="">                </div>                <div class="image-caption">20180724013332944112-1-2018725</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/20180724013332946112-2-2018725.jpg" alt="20180724013332946112-2-2018725" title="">                </div>                <div class="image-caption">20180724013332946112-2-2018725</div>            </figure><p>12、这里分别是针织衫和毛背心搭配格子衬衫的正确示例，简而言之，衣服的搭配上需要体现出层次感，切忌选择色调过于接近的颜色，衬衣一定要修身，否则搭配毛衣会让你显得臃肿不堪。我要立一个flag，等我瘦到120斤，我就奖励自己一件针织衫。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/20180724013332949113-1-2018725.jpg" alt="20180724013332949113-1-2018725" title="">                </div>                <div class="image-caption">20180724013332949113-1-2018725</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/20180724013332951113-2-2018725.jpg" alt="20180724013332951113-2-2018725" title="">                </div>                <div class="image-caption">20180724013332951113-2-2018725</div>            </figure><p>13、毛衣和针织衫真的是搭配率超级高的优质单品，穿出来真的非常好看。我知圆领T恤是夏天最常见的穿搭，可如果你想尝试下不同的风格，我建议你买一件衬衣或者是Polo衫或者是针织衫，这些都能带给你不一样的感觉。我一直想尝试皮夹克或者是牛仔外套，可我自我感觉不适合这样硬朗的风格，谁让我是一个温柔的蓝孩纸呢……</p><h1 id="室外篇"><a href="#室外篇" class="headerlink" title="室外篇"></a>室外篇</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/20180724013619267201-2018725.jpg" alt="20180724013619267201-2018725" title="">                </div>                <div class="image-caption">20180724013619267201-2018725</div>            </figure><p>1、这种材质的衣服应该很容易脏，而且大概率会让你显得臃肿(胖)，可不得不说，这一身和女主站一起挺搭的，我们学习穿搭只有两个目的，找到女朋友和不给女朋友丢脸(🙃)。作为围巾控，这身搭配我觉得可以尝试一下。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/20180724013619269202-2018725.jpg" alt="20180724013619269202-2018725" title="">                </div>                <div class="image-caption">20180724013619269202-2018725</div>            </figure><p>2、一个男人，只要有一件合身的西装，就已经在变帅的路上迈出一大步。这一款的话，毛衣黑白两种颜色，和衬衣蓝灰白的色调蛮接近的，所以基本上看不出层次感来。其实一直不明白男主为什么如此沉闷的颜色，难道是因为向女主表白以后变成熟了吗？😂</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/20180724013619273203-2018725.jpg" alt="20180724013619273203-2018725" title="">                </div>                <div class="image-caption">20180724013619273203-2018725</div>            </figure><p>3、你看，这件衣服再次发挥了格子衬衫的伟大魅力，而在这件蓝色的针织衫的衬托下，可以明显地感觉到男主变“白”了，当90后们开始步入中年职场，不妨尝试穿一点靓丽的颜色，因为我们还可以再年轻一下。池日先生又讲了一句“名言”，你看津崎先生这震惊的小眼神。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/20180724013619275204-1-2018725.jpg" alt="20180724013619275204-1-2018725" title="">                </div>                <div class="image-caption">20180724013619275204-1-2018725</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/20180724013619277204-2-2018725.jpg" alt="20180724013619277204-2-2018725" title="">                </div>                <div class="image-caption">20180724013619277204-2-2018725</div>            </figure><p>4、这一次，男女主在众人“陪伴”下开展了一次小旅行，男主所穿的这件短袖衬衣真的是最普通的衣服，目测在某澜之家就可以找到同款，搭配这斜挎的帆布包简直是减龄神器，我真心羡慕那些三十多岁还会被认成学生的“大叔”们，在下高中刚毕业就被叫叔叔到现在，人家明明想被叫做“哥哥”😓</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/20180724013619279205-1-2018725.jpg" alt="20180724013619279205-1-2018725" title="">                </div>                <div class="image-caption">20180724013619279205-1-2018725</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/20180724013619281205-2-2018725.jpg" alt="20180724013619281205-2-2018725" title="">                </div>                <div class="image-caption">20180724013619281205-2-2018725</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/20180724013619283205-3-2018725.jpg" alt="20180724013619283205-3-2018725" title="">                </div>                <div class="image-caption">20180724013619283205-3-2018725</div>            </figure><p>5、为什么这三件毛衣给人越来越帅的感觉？因为你发现它的颜色越来越纯粹，纯粹到最后就剩下一种颜色，所以，人家建议衣服上不要有Logo不无道理啊，在下有一位朋友，喜欢穿各种印有二次元图案的T恤，30多岁了永远都给人萌萌哒的感觉，你说到底听谁的好呢？总之，我计划今天买一件纯色毛衣，你呢？</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/20180724013619285206-2018725.jpg" alt="20180724013619285206-2018725" title="">                </div>                <div class="image-caption">20180724013619285206-2018725</div>            </figure><p>6、呃……这件应该被称为棒球衫还是夹克呢？我个人不太喜欢这种拼接的样式，我更喜欢那种纯色的简洁的夹克。说起这一集，男主因为错过女主的生日而自责，独自到商城里为女主挑选礼物，面对琳琅满目的商品，男主一脸茫然……有时，女生会嫌弃男生分不清口红色号什么的，并送给男生一个“直男”称号，其实，面对不熟悉的领域，谦虚而大方的承认就好了，我们当然是直的，难道你们喜欢弯的吗？</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/20180724013619286207-2018725.jpg" alt="20180724013619286207-2018725" title="">                </div>                <div class="image-caption">20180724013619286207-2018725</div>            </figure><p>7、你一定觉得像男主这样西装革履的高薪人士，每天都是坐在电脑前喝喝咖啡写写代码。其实，我们是一群连星巴克都不舍得去的人，每一次紧急加班，都是咖啡因转换为二进制代码的过程。我们并不是不会花钱，我们在数码产品、电子设备等方面的投入，完全不亚于你们买衣服、做美甲等等。有判词云：钱多、话少、死得快</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/20180724013619288208-2018725.jpg" alt="20180724013619288208-2018725" title="">                </div>                <div class="image-caption">20180724013619288208-2018725</div>            </figure><p>8、嗯，这件怎么评价呢？中规中矩的秋冬款外套。我一直有一个愿望，等瘦下来以后买件卫衣穿，因为我实在怀疑自己，穿任何套头的衣服都会显得胖。不过好在这是秋冬季节，大家一起胖呀，这种衣服应该会比较容易脏，因为在下就有一件差不多的，果然直男审美啊，呵呵🙃</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/20180724013619290209-2018725.jpg" alt="20180724013619290209-2018725" title="">                </div>                <div class="image-caption">20180724013619290209-2018725</div>            </figure><p>9、这个世界对长得高的人相当宽容，即使他们长得并不好看，可他们长得高穿衣服好看啊。从此刻开始，我希望你打破这种认知，谁说矮个子男生不能穿长款的衣服，男主这就是活生生的例子啊，我知道女生都喜欢175+的男生，可我希望你能找到我除了不能举高高以外的优点，女主到菜场就买了棵葱回来，男主赶紧接过来拎在手里，真是适合过日子的人啊</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/20180724233648400210-2018725.jpg" alt="20180724233648400210-2018725" title="">                </div>                <div class="image-caption">20180724233648400210-2018725</div>            </figure><p>10、这是整部剧出镜率最高的一套衣服。什么？你问我这是哪一集？话说，你们都不看片尾曲的吗？由男主演唱的单曲《恋》，着实为抖音贡献了大量流量，这舞蹈难道不可爱吗？这衣服难道不好看吗？我说过了，衬衣 + 背心是学院派的典型穿法，男主果然是个文艺的男孩子，他的帅你Get到了吗？</p><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>&emsp;&emsp;这或许是我写过的最“八卦”的一篇博客啦，有时候，越是轻松的东西越容易被人接受。程序员，他们并不是情商低，并不是内向，并不是不会撩妹，仅仅是因为这个世界不单单需要娱乐精神，同样需要严谨和专注。搅动一个人的情绪，无非是分泌出某种荷尔蒙；而真正驱动这个世界的，是严格甚至苛刻的规则。面对不熟悉的领域，应该保持敬畏心，而非以标签化的定义以讹传讹；如果靠贴标签就可以给人分类，那么谁是好人谁又是坏人？谁代表了正义谁又代表了邪恶？哦哦，对了，我们不会修电脑以及做任何你认为简单的事情……</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="生活感悟" scheme="http://qinyuanpei.github.io/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="程序员" scheme="http://qinyuanpei.github.io/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
      <category term="日剧" scheme="http://qinyuanpei.github.io/tags/%E6%97%A5%E5%89%A7/"/>
    
      <category term="穿搭" scheme="http://qinyuanpei.github.io/tags/%E7%A9%BF%E6%90%AD/"/>
    
  </entry>
  
  <entry>
    <title>邪不压正：本我的发现之旅</title>
    <link href="http://qinyuanpei.github.io/posts/1099762326/"/>
    <id>http://qinyuanpei.github.io/posts/1099762326/</id>
    <published>2018-07-23T10:48:48.000Z</published>
    <updated>2018-08-24T05:39:27.482Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>&emsp;&emsp;一直想约朋友去看场电影，可是要找一部两个人都喜欢看的电影，当真是一件非常困难的事情。直到遇上了姜文的新片《邪不压正》，愿望终于在这个周末达成。说到姜文的电影，总是不可避免地提到“政治隐喻”这个词汇，所以，对这部电影而言，导演自成一体的独特风格，让其在与普通商业片拉开差距的同时，更将观众推向了一个略显尴尬的境地，以至于散场时朋友的第一反应是：好像完全没有看懂。</p><p>&emsp;&emsp;电影一开始，茫茫雪地里闪现出两个模糊的背影，向着雪地深处无限地延伸。而此时此刻，在火红的灯笼的映衬下，屋内一众人正忙着为师父庆贺寿辰，两位不速之客的到访，让一切瞬间化为烈焰中的修罗场。可以说，开篇这一场极具暴力美学的戏份，的确是可以吸引人眼球的戏份。姜文电影里有一种与生俱来的英雄主义，所谓的硬汉精神，于是你看到了身负东西方文化的李天然，是握着一把武士刀参与刺杀任务，而信奉武士道精神的根本一郎，果真是单刀赴会，说让三刀就是三刀。可这位武术名家，甚至连出手的机会都没有，就被手枪击中了头颅，武术在坚船利炮前又算得了什么呢？</p><p>&emsp;&emsp;不知道大家有没有注意到这样一个细节，朱潜龙和根本一郎闯到师父家里时，师父说了句：没听到狗叫，这是否是因为，在向师父祝寿时，跪拜的声音掩盖了炸弹的声音。联想到《让子弹飞》里，张牧之到鹅城上任，对老百姓说，“不许跪，皇帝都没有了，没有人值得你们跪……”。同样地，朱潜龙在师父面前，一样跪得可谓是以头抢地，可下一秒子弹就在师父脑袋上留下弹孔……其实，人蠢一点没有关系，毕竟都跪了几千年，可偏偏人还有点儿坏。师父问朱潜龙为什么日本人不在日本种植鸦片，朱潜龙说日本是文明的国家。</p><p>&emsp;&emsp;日本从明治维新以后，自上而下全面效仿西方国家，因为他们看到曾经最为强大的中华帝国，在鸦片和战争的侵蚀下早已满目疮痍。日本大河剧《坂上之云》里有一个片段，男主秋山真之在东京街头看到英国人欺负日本人，他愤怒地质问老师，为什么英国人在这里不讲绅士文化，他的老师不无遗憾地说，唯有强者有资格讲绅士文化。当时的日本不见得有多么文明，但那种全民参与到战争中的举动，在当时的世界格局里无出其右者，譬如日本曾担心和美国发生战争，起初民众讨论的是如何避免这场战争，后来则变成能否打赢这场战争，最后则变为如何打赢这场战争。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/2018725p2524092619.jpg" alt="廖凡饰演的朱潜龙" title="">                </div>                <div class="image-caption">廖凡饰演的朱潜龙</div>            </figure><p>&emsp;&emsp;朱潜龙在影片中是一个典型的汉奸，他帮日本人种鸦片，是希望在日本人的扶持下做个傀儡皇帝。在七七事变前，日本人借助麻姑囤事件，杀死了不愿意合作的张作霖，而朱潜龙自认为是大明后裔，一心想着要反清复明，可讽刺的是，溥仪在日本人的扶持下建立了伪满洲国政权，他居然天真地相信，日本人会允许两个傀儡政权同时存在。于是，在裁缝铺里李天然看到“龙袍”，导演不无幽默地说，这是准备去参加巴黎时装周的，仔细想起来，这是否是在讽刺某位穿着“龙袍”去参加电影节的演员呢？可朕的大清都灭亡了，你反什么清复什么明嘛，真有种《天龙八部》里慕容世家妄图兴复一个灭亡100余年的大燕国的痴狂劲儿。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/2018725p2528300128.jpg" alt="姜文镜头下的北平城" title="">                </div>                <div class="image-caption">姜文镜头下的北平城</div>            </figure><p>&emsp;&emsp;姜文一心想要还原一个老北京的全貌，可我感觉在这部电影里看到的北京整体偏“白”一点，印象最深刻的地方是，老亨得利带着儿子从火车站回来，镜头里的北京好像刚下过雪一样。可或许是我们本不了解北京，故宫那种红墙青瓦的印象是从新中国成立以后的啦。梁思诚夫妇当年在战争中保护下来的古建筑群，或许本来就是这个样子的。于是，在姜文导演的镜头里，我们看到带着京味儿的北京胡同，看到了发生过无数故事的东交民巷，看到了曲折蜿蜒的八达岭长城，看到了古香古色的钟楼牌坊。李天然在屋顶跟踪朱潜龙的汽车时，我开玩笑地对朋友说，“以后刺客信条要出中国近代史系列游戏，完全可以参考李天然这个设定”。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/2018725p2524092603.jpg" alt="姜文饰演的蓝青峰" title="">                </div>                <div class="image-caption">姜文饰演的蓝青峰</div>            </figure><p>&emsp;&emsp;这一次姜文饰演的蓝青峰，这个角色在我看来相当复杂：想要除掉朱潜龙和根本一郎，但私底下跟这两个人都有来往；和老亨得利有25年的交情，因为李天然身份暴露对其痛下杀手；被朱潜龙禁锢在家中无法自救，个人实力强弱被敌人查探地一清二楚；作为参加过辛亥革命的前辈，有且只有李天然一个下级……凡次种种，不一而足。从他的名字，我联想到“青出于蓝而胜于蓝”以及“青峰侠”，电影里李天然的英文名字叫做布鲁斯，他和师兄比武时致敬了李小龙的《龙争虎斗》，黑色的中国传统服饰，李小龙标志性的步法动作。可其实说到底，蓝青峰在精神上是懦弱的，因为他完全不清楚自己要做什么，那时国内外形势风起云涌，可他到底能真正地依赖谁，或许连他自己都不知道，他觉得李天然对他有用，就花了十余年时间去布局，李天然不过是他的一枚棋子……</p><p>&emsp;&emsp;蓝青峰的计划是让朱潜龙和根本一郎产生矛盾，朱潜龙杀死根本一郎后，再用李天然做交换。按照这个计划，李天然回国的确是来送死的，除非他可以在交换后杀死朱潜龙。蓝青峰害怕杀死根本一郎会引发战争，可从电影中来看，根本一郎并不是日军的高级军官。或许很多时候，人们都相信刺杀一两个人就可以让战争结束。全智贤在《暗杀》里说过这样一句话，“刺杀一两个日本人，能不能结束一场战争，我是不知道的，但我总要告诉人们，我们一直在战斗”。所以，即使李天然终于手刃仇人，卢沟桥的炮火依旧会在这个城市轰鸣。李天然凭借一腔热血，毫无来由地杀死了几个日本人，固然会让人激昂澎湃，可真的就是邪不压正吗？李天然的复仇，在我看来，是杀死懦弱的“自我”的过程，因为无父无母，李天然其实一直生活在“我是谁”、“我要去哪里”、“我要做什么”的自我怀疑之中，</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/2018725p2528751975.jpg" alt="许晴饰演的唐凤仪" title="">                </div>                <div class="image-caption">许晴饰演的唐凤仪</div>            </figure><p>&emsp;&emsp;唐凤仪，一个愿意陪着朱潜龙做皇帝梦的女人，习惯了被男人驱使和奴役，可被李天然恶作剧般在屁股上以后，她终于明白，自己在朱潜龙心中不过是一个玩物，尤其是六国饭店里的那场戏，看似不露痕迹地打朱潜龙耳光，实则这个敢爱敢恨的女人形象立了起来，回敬李天然的“凤仪之宝”，通过关巧红给李天然通风报信，日军进城时城墙上的一跃，都是这个角色留给人的深刻印象。所谓“商女不知亡国恨，隔江犹唱后庭花”，风尘女子的这种刻板印象，在姜文的电影里是不存在的，她们不单有性感的身姿，更有热血的灵魂。侵略者端坐在石狮子上准备拍照，被从城墙上一跃而下的唐凤仪撞倒在地上，当时电影院里发出一阵笑声，可这无非是一个女子的反抗而已。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/2018725p2527723815.jpg" alt="姜文对老婆是真爱" title="">                </div>                <div class="image-caption">姜文对老婆是真爱</div>            </figure><p>&emsp;&emsp;与之相对的关巧红，她美好得宛如江南恬静的女子，她同样是一种独特的美感，和唐凤仪这种艳丽的画风不同，她是像迷一样的女子，背后有太多故事没有说完，看似惊鸿一瞥地讲了放脚、开裁缝铺这些琐碎的事情，但永远给人一种“这个女人不简单”的感觉，她好像无论什么时候，都能找得到李天然；她好像对李天然有种莫名的情愫，可又清楚地知道自己想要做什么……喜欢上这样的女人，就像喜欢上一朵云，你看云时很近，而云看你时很远。即使到了故事的结尾，她依然像阵风飘然远去，留下原地惆怅的李天然，明明李天然爬屋顶比她要好，可要寻找她时，又要去哪里寻找呢？有时候，这像是朴树的《那些花儿》散落天涯，有时候，又像是泰戈尔的“生如夏花般灿烂，死如秋叶般静美”……</p><p>&emsp;&emsp;说实话，这一次彭于晏的角色设定让人很出戏，因为这个角色本身的真实感并不强，即使他可以飞檐走壁，即使他可以躲开子弹。究其本质，是因为李天然身上有着勇敢而又懦弱的矛盾性格，未回国时，他一心想杀根本一郎和朱潜龙报仇；等回国后，他突然像被定住一般不知所措。第一次莽撞间接造成老亨得利被杀害，第二次莽撞直接导致蓝青峰被软禁。彭于晏一直都是一个“孤儿”，无论是师父、老亨得利还是蓝青峰，其实都不见得有多爱他。一个心中带着复仇愿望的人，一旦真正地手刃了仇人，他存在的意义又会是什么呢？所以，他怕自己因为复仇而变得迷茫，李天然看似身负正义之名，可对于师门武学的传承并无实际意义，相反，是那个杀死师父的朱潜龙，为师父塑像扬名，让师父成为大家所称赞的武术名家，到底谁是正？谁是邪？当周围人都是在利用你，杀了朱潜龙，李天然将失去存在感；而杀了李天然，日本人可以随时除掉朱潜龙。跪在岳飞目前的秦桧夫妇，和被塑成一条狗跪在武术名家塑像前，是否具有异曲同工之妙？普通人会在乎真相到底是什么样子的吗？</p><p>&emsp;&emsp;一个再简单不过的寻找“爸爸”的故事，对于那时的中国，是否就像年轻而莽撞的李天然，在探索着“我是谁”、“我要去哪里”、“我要做什么”的终极哲学命题。亨得利父子出城遇见正在演习的日本军官，对方声称亨得利父子的驴子挡住了坦克，破坏了军方的演戏计划。亨得利父子以美国护照作为挡箭牌，日本军官不得不去找这两头驴子的晦气。多年以后，吴京在《战狼》系列里重复着美国护照和海军陆战队的老梗，只是此时的中国早已不再是那个家国积弱的中国。日本军官质问李天然为什么穿着日本和服，可彼时彼刻，根本一郎自作聪明地曲解论语中的含义，又是否是在告诉我们，从外表上模仿何其容易，可一旦要张嘴说话，就很容易被人识破。曾经日本在全面欧化的过程中，被西方人讥讽为穿着衣服的猴子，我们都曾经模仿过他人，一如今天“韩式审美”在中国流行。这是一个时代里的众生相，愿每个人都能找到“真我”，不再犹豫，不再怯懦，勇敢地面对自己，发现自己。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="生活感悟" scheme="http://qinyuanpei.github.io/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="影评" scheme="http://qinyuanpei.github.io/tags/%E5%BD%B1%E8%AF%84/"/>
    
      <category term="电影" scheme="http://qinyuanpei.github.io/tags/%E7%94%B5%E5%BD%B1/"/>
    
      <category term="邪不压正" scheme="http://qinyuanpei.github.io/tags/%E9%82%AA%E4%B8%8D%E5%8E%8B%E6%AD%A3/"/>
    
  </entry>
  
  <entry>
    <title>声明式RESTful客户端WebApiClient在项目中的应用</title>
    <link href="http://qinyuanpei.github.io/posts/380519286/"/>
    <id>http://qinyuanpei.github.io/posts/380519286/</id>
    <published>2018-07-16T09:02:35.000Z</published>
    <updated>2018-08-24T05:39:27.482Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>&emsp;&emsp;自从项目上采用敏捷开发的流程以后，我们的开发任务中出现了不少“联调”的任务，而所谓的“联调”任务，完全是拜前后端分离所赐。通常来讲，按照前后端分离的思想，我们的团队会被分成前端和后端两个组，前端负责页面内数据的展示，后端负责提供相关服务的接口。这样听起来非常合理，对吧？可问题在于，后端常常在等前端联调这些接口，因为后端不知道具体有哪些异常需要处理；同样，前端常常在等后端接口稳定，因为一旦出现问题，就会导致接口发生变更。虽然在此之前，我们早已花了一周左右的时间去讨论接口，接口文档早已伴随着API部署到线上，可我们依然需要大量的时间去沟通每个接口的细节。用一种什么样的语言来描述这种状态呢？大概就是人们并不是真的需要接口文档，因为真的不会有人去看这东西。</p><h1 id="从敏捷开发到产品架构"><a href="#从敏捷开发到产品架构" class="headerlink" title="从敏捷开发到产品架构"></a>从敏捷开发到产品架构</h1><p>&emsp;&emsp;为什么会出现这种情况呢？我想，可以从三个方面来考虑，即设计不当、进度不一、沟通不畅。有时候集思广益去讨论一个接口，可能并不是一件好事，因为考虑的因素越多，问题就会变得越复杂，相应地妥协的地方就会越多。我并非不懂得做人需要适当妥协，事实是从妥协的那一刻起，我们的麻烦越来越多。有人问怎么能消灭Bug，我说消灭需求就可以了。现代人被各种各样的社交网络包围着，以至于隐私都被赤裸裸地暴露在空气中，可你很难想象人与人之间的沟通会越来越困难，难道是因为社交网络加剧了人类本身的孤独？没有人是一座孤岛，可前后端分离好像加剧了这种界限。现在动辄讲究全栈，可当你把精力都耗费在这些联系上去，你如何去追求全栈？相反，我们像电话接线员一样，在不停地切换上下文，因为我们要“敏捷”起来，可作为工程师就会知道，切换上下文需要付出相应的代价。</p><p>&emsp;&emsp;我之所以提到这样一个场景，是出于对当前项目的一种整体回顾。我们的项目是一个客户端产品，但是它依然体现了前后端分离的思想。受业务背景限制，这个客户端采用了Native + Web的技术架构。如果你了解整个互联网产品形态的演变历程，就会对这种技术架构非常的了解，从曾经的Native和Web之争，到所谓的Hybrid App，再到如今的React Native及小程序，这种技术架构其实一直都存在，譬如Electron、Atom、Node-Webkit、Cordova、Ionic、VSCode等等，其实都是非常相近的技术。对应到我们的项目，我们提供了一个JSBridge来完成Native层和Web层之间的通信，而客户端的渲染实际上是由前端来完成的，所以你可以想到，我们通过一个WebView来加载页面，而平台相关的交互由C++/C#来完成，所以，理论上客户端是是一个和Electron类似的壳子(Shell)，它可以展示来自任何页面的内容。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/system%20architecture.png" alt="以JSBridge为核心的系统架构图" title="">                </div>                <div class="image-caption">以JSBridge为核心的系统架构图</div>            </figure><p>&emsp;&emsp;从客户端的角度来讲，它是Native层接口的提供者，连接着平台相关的API，并集成了第三方的硬件设备，所以，理论上它是和具体业务无关的。可实际上，因为Web层不能直接和文件系统交互，所以，像上传、下载这样本该由前端调用的接口，部分地转移到了客户端这边，所以，客户端无可避免地受到后端API变化的影响，因为业务上需求存在差异，上传接口前后共发生了三次变化，所以，客户端中存在三个版本的上传，当然，我相信这是一个设计上的问题，通过改进设计可以得到完美的解决。关于上传为什么会这么复杂，感兴趣的朋友可以通过留言来一起交流。这里我想说的是什么呢？因为客户端希望与具体业务无关，所以，客户端注定是以功能来划分服务，然后通过JSBridge暴露给Web层。可是对后端的微服务架构而言，它的服务是以业务为主导的，它的一个业务就是一个接口。由此导致一个问题，后端接口的数量不断增加，客户端面临频繁地改动。</p><h1 id="不做平庸的ApiCaller"><a href="#不做平庸的ApiCaller" class="headerlink" title="不做平庸的ApiCaller"></a>不做平庸的ApiCaller</h1><p>&emsp;&emsp;有很多人说，今天的编程工作变得越来越简单，对于这一点我非常认同。因为，无论是无论是语言、工具、生态、平台，都获得空前的繁荣，所以，我们大多数人的工作，可能就是调用现成的API，而少数人的工作，可能就是提供友好的API，甚至连代码你都可以在Google上找到，你唯一要做的就是Ctrl + C &amp; Ctrl + V。当初想要改变世界的你我，突然有一天就变成了ApiCaller，甚至大多数的框架，你连底层细节都无从得知。可你真的打算做一个平庸的ApiCaller吗？至少我是不愿意的，因为在我看来，调用后端提供的API，大多数情况下都是换个URL，或者换个参数，这样的代码你写一次以后，剩下的基本就是复制和粘贴了，你可能会非常鄙视我的这种行为，可事实就是这样的，不单单我在复制，连我身边的同事都在复制。可这能怎么办啊，只要后端提供了新接口，或者是对接口进行了调整，而这些接口必须由客户端封装，我们的工作就永远不会停止，可这不过调用后端的API 而已啊！</p><p>&emsp;&emsp;有时候，我们会说工作经验和工作时间未必是正相关的，因为如果我们十年都在做一件事情，那么其实和一年是没有区别的。为了避免成为一个平庸的ApiCaller，你必须思考那些真正重要的事情。怎么能降低后端API变化对客户端的影响呢？降低耦合度。怎么降低耦合度呢？依赖抽象而非依赖具体。想想WebService，它通过WSDL来对服务进行描述，而通过WSDL就可以在客户端创建代理类，一旦WebService发生变更，重新生成代理类就好。再回想一下，调用后端API会遇到那些问题？设置Header、设置Cookie 、拼接URL、拼接参数、URLEncode、SSL、JSON序列化、FormData、上传文件、编码/解码等等，是不是每一次都在处理这些问题？看到项目里用HttpWebRequest去构造Mulitpartfile结构，我忽然间觉得绝望。既然每次都是翻来覆去这些东西，为什么要用手来写？API文档构建工具可以帮助用户生成curl以及常见语言对应的代码，所以，我有理由相信，我们需要一个东西来帮助我们完成这个工作，就像WebService生成代理类一样。那么，有没有这样一个东西呢？这就是本文的主角——基于声明式的RESTful风格的客户端：<strong>WebApiClient</strong>。</p><h1 id="NET下的Retrofit：WebApiClient"><a href="#NET下的Retrofit：WebApiClient" class="headerlink" title=".NET下的Retrofit：WebApiClient"></a>.NET下的Retrofit：WebApiClient</h1><p>&emsp;&emsp;WebApiClient是.NET平台下的Retrofit。要理解这句话，首先要理解Retrofit。什么是Retrofit呢？Retrofit是一个Android/Java下的网络通信库，其本身基于okHttp，熟悉Android开发的朋友，对这个库应该不会感到陌生。Retrofit帮助我们解决了上文中提到的，在请求一个Web API时会遇到的问题，并通过注解这种技术，以一种声明式的方式来定义接口。简单来说，所有你想要调用Web API都是接口中的一个方法，你通过注解来告诉Retrofit，该方法会请求哪一个Web API，参数会以什么样的形式传递过去，结果会以什么样的形式返回回来，你完全不必去写那些底层HTTP通信相关的东西，因为Retrofit会帮你在运行时实现这个接口。所以，我们说Retrofit是一种声明式的HTTP客户端。声明式我们见过相当多啦，Java里的注解，C#里的Attribute、Python里的装饰器、JavaScript里的修饰器，以及如今各种各样的双向绑定框架。下面，我们来一起看看WebApiClient这个库。</p><p>&emsp;&emsp;现在，我假设你手里已经有可供调用的Web API，并且你真实地了解这些Web API是如何工作的。至此，我们需要完成的工作主要都集中在客户端，这里我们编写一个控制台应用来完成这一工作。首先，需要在项目中引入WebApiClient这个库，我们直接通过Nuget来完成安装即可(<strong>注：这里共有Laojiu.WebApiClient、WebApiClient.JIT和WebApiClient.AOT三个版本，博主使用的是Laojiu.WebApiClient</strong>)。使用WebApiClient的基本流程是：首先，定义一个继承自IHttpApiClient的接口并在接口中声明相关方法；其次，通过Attribute对接口中的方法和参数进行修饰以完成和Web API的绑定；最后，通过WebApiClient生成该接口的一个实例，而通过调用相应的实例方法就可以得到结果。这是不是和代理类的感觉非常像呢？像博主这样懒惰的人，或许连接口都不愿意亲自去写，因为我相信越是严谨的规则，就越是适合应用到自动化上面去。这样说可能无法让大家形成对WebApiClient的直观印象，那么让我们从一个简单的例子开始吧！</p><h2 id="Get请求接口"><a href="#Get请求接口" class="headerlink" title="Get请求接口"></a>Get请求接口</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">HttpHost(<span class="meta-string">"http://localhost:8000"</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IValuesApiCaller</span> : <span class="title">IHttpApiClient</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//GET http://localhost:8000/values1</span></span><br><span class="line">    [<span class="meta">HttpGet(<span class="meta-string">"/values1"</span>)</span>]</span><br><span class="line">    [<span class="meta">OAuth2Filter</span>]</span><br><span class="line">    <span class="function">ITask&lt;<span class="keyword">string</span>&gt; <span class="title">GetValues</span>(<span class="params"></span>)</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//GET http://localhost:8000/values1/&#123;id&#125;</span></span><br><span class="line">    [<span class="meta">HttpGet(<span class="meta-string">"/values1/&#123;id&#125;"</span>)</span>]</span><br><span class="line">    [<span class="meta">OAuth2Filter</span>]</span><br><span class="line">    <span class="function">ITask&lt;<span class="keyword">string</span>&gt; <span class="title">GetValue</span>(<span class="params"><span class="keyword">int</span> id</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这个示例中，我们展示了WebApiClient是如何处理带参数以及不带参数的Get请求的。通过HttpGet特性，我们分别为GetValues()和GetValue()两个方法指定了请求的URL。虽然在这里我们指定一个完整的URL，可是考虑到我们Web API通常都是分布在不同的域名下，所以我们可以通过HttpHost特性来配置一个BaseURL。接口的返回值为ITask<t>，我们可以通过我们的需要指定相应的类型，在这里我们以ITask<string>为例，特别说明的是，如果服务器返回的是标准的JSON格式，那么我们可以将其映射为相应的实体结构，这就需要使用JsonReturn标特性对方法进行修饰。我们知道Get请求可以通过QueryString形式来进行传参，那么这一点在WebApiClient中如何实现呢？这就用到所谓的<strong>“平铺参数”</strong>，即我们在方法中声明的参数会被WebApiClient自动地追加到URL上面去，再不需要去手动地拼接这些参数；同理，这些参数可以用一个包装类封装起来，具体大家参考<a href="https://github.com/dotnetcore/WebApiClient/wiki/WebApiClient%E5%9F%BA%E7%A1%80" target="_blank" rel="noopener">官方文档</a>。</string></t></p><p>&emsp;&emsp;OK，现在来看看如何调用IValuesApiCaller这个接口。我们在前面说过，WebApiClient会帮助我们生成一个IValuesApiCaller的实例，所以我们调用一个Web API的时候，关注点已然从之前的过程实现转变为接口实现，这正是我们渴望看到的局面。一个非常简洁的调用示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用Values Service</span></span><br><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> client = HttpApiClient.Create&lt;IValuesApiCaller&gt;())</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">"-----Invoke Values Service-----"</span>);</span><br><span class="line">    <span class="keyword">var</span> results = <span class="keyword">await</span> client.GetValues().InvokeAsync();</span><br><span class="line">    Console.WriteLine(<span class="string">$"results is <span class="subst">&#123;results&#125;</span>"</span>);</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">await</span> client.GetValue(<span class="number">10</span>).InvokeAsync();</span><br><span class="line">    Console.WriteLine(<span class="string">$"result is <span class="subst">&#123;result&#125;</span>"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Post请求接口"><a href="#Post请求接口" class="headerlink" title="Post请求接口"></a>Post请求接口</h2><p>&emsp;&emsp;接下来，我们再来说说Post请求接口。同样的，这里我们使用博主编写好的一个Service，我们称之为Student Service。它使用了EF Core来完成数据库的读写，它提供了一组和Student实体相关的API，这里我们使用它来作为Post请求接口的示例实现。因此，我们首先定义一个接口IStudentApiCaller：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">HttpHost(<span class="meta-string">"http://localhost:8000"</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IStudentApiCaller</span> : <span class="title">IHttpApiClient</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//GET http://localhost:8000/student</span></span><br><span class="line">    [<span class="meta">HttpGet(<span class="meta-string">"/student"</span>)</span>]</span><br><span class="line">    [<span class="meta">OAuth2Filter</span>]</span><br><span class="line">    [<span class="meta">JsonReturn</span>]</span><br><span class="line">    ITask&lt;List&lt;Student&gt;&gt; GetAllStudents();</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="comment">//POST http://localhost:8000/student</span></span><br><span class="line">    [<span class="meta">HttpPost(<span class="meta-string">"/student"</span>)</span>]</span><br><span class="line">    [<span class="meta">OAuth2Filter</span>]</span><br><span class="line">    <span class="function">ITask&lt;<span class="keyword">string</span>&gt; <span class="title">NewStudent</span>(<span class="params">[JsonContent] Student student</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里重点关注接口中的第二个方法。首先，它是一个Post请求；其次，它接受一个JSON格式的文本作为它的请求体，所以我们这里使用了JsonContent特性。前面我们提到过，接口返回类型ITask<t>，可以映射为对应的实体结构。注意到GetAllStudtents()这个方法中绑定的API，它负责从数据库中查询所有的Student信息并以JSON形式返回，所以这里我们将其映射为List<student>。与此同时，你会注意到JsonReturn特性，这是在告诉WebApiClient，你希望将返回的结果映射为强类型的模型；同理，你可以使用XmlReturn特性来处理返回值为Xml的情形。除此之外，你还可以使用FormContent特性来修饰方法参数，其作用是将模型参数以key1=value1&amp;key2=value2……的形式写入请求体中，对应于x-www-form-urlencode；更一般地，你可以使用FormField特性修饰方法参数，以form-data的形式写入请求体中。Mulitpart是博主最为讨厌的一种数据格式，请大家自己去看<a href="https://github.com/dotnetcore/WebApiClient/wiki/WebApiClient%E5%9F%BA%E7%A1%80" target="_blank" rel="noopener">官方文档</a>。</student></t></p><h2 id="过滤器与OAuth2"><a href="#过滤器与OAuth2" class="headerlink" title="过滤器与OAuth2"></a>过滤器与OAuth2</h2><p>&emsp;&emsp;无论如何，请允许我说，这是我最喜欢的一个特性。大家会注意到，在我的示例代码中，有一个东西一直没有去说，这就是OAuth2Filter，这其实是博主自己扩展的一个特性，这意味着在请求该API前，需要通过OAuth2授权以获得身份令牌。对于这一点，我想大家都是清楚的，因为在微服务架构中，Web API是作为一种受保护的资源而存在的，所以鉴权和授权是非常重要的点。以博主的项目组为例，我们做到第三个项目的时候，整个后端的OAuth2认证服务终于实现了统一，可即使如此，每一次这种基础设施都需要联调，都要考虑到底使用哪一种授权模式。譬如，客户端是考虑把token存放在全局静态类里，而前端是考虑把token存放在Cookie里，甚至在此之前，我们连refresh_token都没有，客户端在调用Web API时天天担心token过期，于是在调用Web API时主动去刷新一次token。你问我为什么不判断一下token有没有过期，因为后端没有提供这个接口呀。其实，我想说的只有一句话，基础设施请交给框架去处理。</p><p>&emsp;&emsp;WebApiClient提供了用于请求管道中的过滤器，可以让我们在请求前、请求后搞点事情。譬如，我们这里希望在请求前获取token，并将其追加到当前请求的Header里，或者是在请求前判断下token是否过期(假如后端愿意开发这个接口的话)，如果过期了就自动刷新下token，该怎么做呢？首先，我们定义一个IAuthApiCaller的接口，它负责从认证服务器上获取token，这里选择客户端模式：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">HttpHost(<span class="meta-string">"http://localhost:28203"</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IAuthApiCaller</span> : <span class="title">IHttpApiClient</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">HttpPost(<span class="meta-string">"/oauth2/token"</span>)</span>]</span><br><span class="line">    <span class="function">ITask&lt;<span class="keyword">string</span>&gt; <span class="title">GetToken</span>(<span class="params">[FormField] <span class="keyword">string</span> client_id,[FormField] <span class="keyword">string</span> client_secret,[FormField] <span class="keyword">string</span> grant_type = <span class="string">"client_credentials"</span></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接下来，我们继承ApiActionFilterAttribute来编写OAuth2FilterAttribute，显然，它会在请求前调用IAuthApiCaller接口实例，这里我们将client_id和client_secret硬编码到代码里，单单是为了演示如何去印证这个想法，实际项目中大家可以考虑通过配置或者是传参来实现：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">AttributeUsage(AttributeTargets.Method)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OAuth2FilterAttribute</span> : <span class="title">ApiActionFilterAttribute</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Task <span class="title">OnBeginRequestAsync</span>(<span class="params">ApiActionContext context</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">var</span> client = HttpApiClient.Create&lt;IAuthApiCaller&gt;())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> client_id = <span class="string">"578c06935d7f4c9897316ed50b00c19d"</span>;</span><br><span class="line">            <span class="keyword">var</span> client_secret = <span class="string">"d851c10e1897482eb6f476e359984b27"</span>;</span><br><span class="line">            <span class="keyword">var</span> result = client.GetToken(client_id, client_secret).InvokeAsync().Result;</span><br><span class="line">            <span class="keyword">var</span> json = JObject.Parse(result);</span><br><span class="line">            <span class="keyword">var</span> token = json[<span class="string">"access_token"</span>].Value&lt;<span class="keyword">string</span>&gt;();</span><br><span class="line">            context.RequestMessage.Headers.Authorization = <span class="keyword">new</span> AuthenticationHeaderValue(<span class="string">"Bearer"</span>,token);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">base</span>.OnBeginRequestAsync(context);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;至此，我们只需要给需要需要授权的API添加OAuth2Filter特性即可，全然不需要考虑这个token如何储存的问题。我对静态类和静态方法没有误解，仅仅是因为它是反模式的，任何全局内可以修改的成员，不管有没有人会去修改，它始终都是不安全的。在此我要表扬一下前端的同事，他们通过扩展ajax方法原型，实现了和这里类似的东西。所以说，你要多尝试去看看不同领域里的东西，抓住那些相同或者相似的本质，而不是被那些“旧酒换新瓶”的概念所迷惑，技术圈子的热闹有两种，一种是发明新的技术，一种是发明新的概念，我本人更喜欢第一种，你呢？</p><h2 id="上传与下载"><a href="#上传与下载" class="headerlink" title="上传与下载"></a>上传与下载</h2><p>&emsp;&emsp;其实，上传应该是Post请求的一种类型，可是考虑到下载的时候，接口的返回类型应该是数据流，所以我决定将这两个内容一起来讲。这里我们就考虑单纯的上传，不考虑由文件和键值对混合组成的MulitpartFormDataContent，因为这种结构让我觉得厌恶。这里，我们直接通过ASP.NET Core编写了一个文件上传/下载的Service，同样地，我们首先定义IFilesApiCaller接口：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">HttpHost(<span class="meta-string">"http://localhost:8000"</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IFilesApiCaller</span> : <span class="title">IHttpApiClient</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//Post http://localhost:8000/files/upload</span></span><br><span class="line">    [<span class="meta">HttpPost(<span class="meta-string">"/files/upload"</span>)</span>]</span><br><span class="line">    [<span class="meta">OAuth2Filter</span>]</span><br><span class="line">    [<span class="meta">JsonReturn</span>]</span><br><span class="line">    <span class="function">ITask&lt;<span class="keyword">string</span>&gt; <span class="title">Upload</span>(<span class="params">[HttpContent]List&lt;MulitpartFile&gt; files</span>)</span>;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="comment">//Get http://localhost:8000/files/download/&#123;fileId&#125;</span></span><br><span class="line">    [<span class="meta">HttpGet(<span class="meta-string">"/files/download/&#123;fileId&#125;"</span>)</span>]</span><br><span class="line">    [<span class="meta">OAuth2Filter</span>]</span><br><span class="line">    <span class="function">ITask&lt;HttpResponseMessage&gt; <span class="title">Download</span>(<span class="params"><span class="keyword">string</span> fileId</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;在这里，上传我使用了ASP.NET Core中的IFormFile接口，并且在Postman测试通过，可是在网页上用type为file的input标签进行测试时，发现页面一直无法正常响应，不知道具体是什么原因(<strong>后来发现它完全和Postman中的请求体一样，好吧😬</strong>)，我一直不太理解ajax上传和表单上传的区别，曾经项目上用HttpWebRequest去做文件的上传，里面需要大量的字符串拼接动作去构造MulitpartFormData，只要后端上传的API发生变更，这段代码几乎就会变成不可维护的代码，幸运的是，在经过几次迭代以后，他们终于意识到了这个问题，在我的建议下，他们使用HttpClient重构了代码。在这里你会看到Download()方法的返回值类型为ITask<httpresponsemessage>，这是HttpClient中使用的数据结构。为什么我推荐大家使用这套API，因为它和ASP.NET中的数据结构是一致的，而事实是上，WebApiClient正是在HttpClient的基础上完成的，所以这里你能够想到，我将通过HttpResponseMessage来获取返回的数据流，进而完成文件的下载。一起来看下面的示例：</httpresponsemessage></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用Files Service</span></span><br><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> client = HttpApiClient.Create&lt;IFilesApiCaller&gt;())</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">"-----Invoke File Service-----"</span>);</span><br><span class="line">    <span class="keyword">var</span> files = <span class="keyword">new</span> <span class="keyword">string</span>[]</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">@"C:\Users\PayneQin\Videos\Rec 0001.mp4"</span>,</span><br><span class="line">        <span class="string">@"C:\Users\PayneQin\Videos\Rec 0002.mp4"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    .Select(f=&gt;<span class="keyword">new</span> MulitpartFile(f))</span><br><span class="line">    .ToList();</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">await</span> client.Upload(files).InvokeAsync();</span><br><span class="line">    Console.WriteLine(result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> json = JArray.Parse(result);</span><br><span class="line">    <span class="keyword">var</span> fileId = ((JObject)json.First)[<span class="string">"fileId"</span>].Value&lt;<span class="keyword">string</span>&gt;();</span><br><span class="line">    <span class="keyword">var</span> fileName = Path.Combine(Environment.CurrentDirectory, <span class="string">"Output/Video001.mp4"</span>);</span><br><span class="line">    <span class="keyword">var</span> filePath = Path.GetDirectoryName(fileName);</span><br><span class="line">    <span class="keyword">if</span> (!Directory.Exists(filePath)) Directory.CreateDirectory(filePath);</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> fileStram = <span class="keyword">new</span> FileStream(fileName, FileMode.Create))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> stream = <span class="keyword">await</span> client.Download(fileId).InvokeAsync();</span><br><span class="line">        stream.Content.ReadAsStreamAsync().Result.CopyToAsync(fileStram);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里说明的是，非常遗憾，这里的上传接口并没有被成功调用，可能我还是被MulitpartFormDataContent这种东西所困惑着，尽管我使用了WebApiClient中提供的MulitpartFile类，并且使用HttpContent特性对参数进行了修饰。(<strong>后来发现是因为我使用JsonReturn特性，可我的Action的确是返回了JSON啊，所以，我不暂时理解不了这一点</strong>😬)。我了解到的一点信息是，Spring Cloud中的Feign，一个和Retrofit极其相似的HTTP客户端，其本身并没有实现文件上传的功能，需要借助插件来实现相关功能，所以，这是否说明HTTP协议中的上传实现本身就是一个错误，因为它和form-data搅和在一起，试图用键值对的形式去描述一个文件，我们的业务中需要给文件增加备注关联相关信息，坦白讲，这种数据结构令人非常痛苦，所以，上传这块会有三个不同的版本，我一直希望上传可以和具体的业务解耦，即使需要给文件增加备注或者是关联相关信息，应该交给新的Service去做这件事情啊，这简直教人头疼啊。</p><h2 id="可配置与动态化"><a href="#可配置与动态化" class="headerlink" title="可配置与动态化"></a>可配置与动态化</h2><p>&emsp;&emsp;我知道许多人对特性这种<strong>”配置“</strong>方式并不感冒，因为他们觉得通过配置文件就可以做到不修改代码。我曾经帮助组里写了一个非常简洁的配置方案，后来这个方案在Code Review的时候被拒绝，因为我和别人写得不一样。直到前几天我看到ASP.NET Core里全新的配置方式，我瞬间意识到这种配置方式和我之前的想法不谋而合，这个世界上聪明的人的想法总是如此一致。我相信人们看到这篇文章里出现的各种特性，都会认为像Host、URL等等这些东西都被硬编码了，说得好像你们的代码不需要随着配置文件变化而变化似的，说得好像你们的代码每次都不需要重新编译似的。我曾经考虑到这一点，在开发一个库的时候，充分考虑到了可配置化，事实是大家都不喜欢写配置文件，从那以后，我就变成了坚定的<strong>“约定大于配置“</strong>主义。</p><p>&emsp;&emsp;回到WebApiClient这个话题，如果你不喜欢这种基于特性的配置方式，那么你可以通过HttpApiConfig这个类，动态地对诸如Host、URL等参数进行配置，并在WebApiClient创建接口实例的时候传入这些配置。下面是一个简单的示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//手动创建配置</span></span><br><span class="line"><span class="keyword">var</span> config = <span class="keyword">new</span> HttpApiConfig()</span><br><span class="line">&#123;</span><br><span class="line">    HttpHost = <span class="keyword">new</span> Uri(<span class="string">"http://www.yourdomain.com"</span>),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用Values Service</span></span><br><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> client = HttpApiClient.Create&lt;IValuesApiCaller&gt;(config))</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">"-----Invoke Values Service-----"</span>);</span><br><span class="line">    <span class="keyword">var</span> results = <span class="keyword">await</span> client.GetValues().InvokeAsync();</span><br><span class="line">    Console.WriteLine(<span class="string">$"results is <span class="subst">&#123;results&#125;</span>"</span>);</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">await</span> client.GetValue(<span class="number">10</span>).InvokeAsync();</span><br><span class="line">    Console.WriteLine(<span class="string">$"result is <span class="subst">&#123;result&#125;</span>"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我知道杠精们绝对还有话要说，如果我连请求的URL都是动态地该怎么办呢？此时，你总不能让我再让我去配置URL了吧！对于这个问题，WebApiClient提供了Url特性，该特性可以修饰参数，表明这是一个URL，需要注意的是，该参数必须放在第一位，具体可以参考<a href="https://github.com/dotnetcore/WebApiClient/wiki/WebApiClient%E5%9F%BA%E7%A1%80" target="_blank" rel="noopener">官方文档</a>。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">HttpGet</span>]</span><br><span class="line"><span class="function">ITask&lt;<span class="keyword">string</span>&gt; <span class="title">Login</span>(<span class="params">[Url] <span class="keyword">string</span> url, <span class="keyword">string</span> username, <span class="keyword">string</span> password</span>)</span>;</span><br></pre></td></tr></table></figure></p><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>&emsp;&emsp;有时候，我会一直在想，前后端分离到底分离的是什么？在我看来，找出这种界限是最重要的，即前端与后端各自的职责是什么。我们想分离的其实是职责，可惜这种想法极其容易演变为前后端人员的分离。而这种人员上的分离，则让接口的设计和沟通充满了坎坷。前后端分离不在于项目是否由两个或者更多的人完成，而在于你是否可以意识到前后端代码里的界限。在这种前提下，博主通过项目上前后端分离的实践经验，配合产品本身的技术架构体系，引申出一个话题，即<strong>前端/客户端如何应对后端API快速扩增带来的影响</strong>，并由此提出，<strong>通过代理类来调用后端API的想法</strong>，这一想法借鉴了WebService。接下来，我们介绍了.NET平台下的Retrofit：WebApiClient，它可以让我们以一种“契约式”思想来声明接口，而不必关心这个接口该如何去实现，因为WebApiClient会帮助你实现具体功能。更改接口的代价永远比实现接口要小，所以，我相信这种声明式的HTTP客户端，可以让你更快速地应对来自后端的影响。在Java的世界里有Retrofit、有Feign，为了不被超越 太多，我们只能迎头赶上。谢谢大家，本篇到此结束，周末愉快！😬</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="编程语言" scheme="http://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="RESTful" scheme="http://qinyuanpei.github.io/tags/RESTful/"/>
    
      <category term="WebApi" scheme="http://qinyuanpei.github.io/tags/WebApi/"/>
    
      <category term="HttpClient" scheme="http://qinyuanpei.github.io/tags/HttpClient/"/>
    
  </entry>
  
  <entry>
    <title>米花之味：永远相信美好的事情</title>
    <link href="http://qinyuanpei.github.io/posts/2941880815/"/>
    <id>http://qinyuanpei.github.io/posts/2941880815/</id>
    <published>2018-07-02T09:50:17.000Z</published>
    <updated>2018-08-24T05:39:27.482Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>&emsp;&emsp;一如往常地坐公交回家，下过一场雨以后，天空被洗刷得干干净净，洗去了夏天的骄阳似火，洗去了归途的月明星稀。抬眼瞥见对面车窗，一个被夕阳裁剪得整齐的轮廓，就这样静静地映在玻璃上，一瞬间散发某种神圣的气息。突然间，我想到了被嘲笑不会撩妹的X君，想到了自嘲不会拒绝别人的Y君，想到了喜欢一个人而爱不得的Z君……大概这个模糊的轮廓，可以是这个世界上任何一个人。</p><p>&emsp;&emsp;我想说什么呢？你的生命也许从来都平淡无奇，可因为这一场秋雨的到来，在别人的眼睛里，就突然平添无数的神圣感。原来温暖从来都要自己去寻找，即使太阳的寿命意外的漫长，不至于像星辰一般昙花一现，你肉眼可以看到的星星，可能下一秒钟就消逝不见，就像这每天都见到的夕阳，有一天意外地点缀些金色或者黄色，你就会觉得它浑身都是温暖的力量。其实，那是极其平淡的一天，就像米花的味道一样，没有什么太特殊的含义，可你总愿意相信，当一个人的心足够虔诚的时候，神灵就可以听到你的心声，让那些奇迹发生。</p><p>&emsp;&emsp;米花之味，这部小清新得不像国产电影的电影，从一开始，就表现出了它不同于以往国产电影的气质，比如电影中卖鸡蛋的小女孩，在电影中前后共出现2次，第一次是女主辞掉城里工作回来的路上，第二次是女主独自驱车前往机场的路上。如果说第一次是女主出于善良而买小女孩的鸡蛋，那么第二次则是对家乡现状的一种无力感。这基本上奠定了这部电影整体的基调，现实与传统的始终形成鲜明的对比，甚至是作为矛盾冲突穿插在母女两人中间，可导演似乎并不想通过这些来表达什么观点，所以这就造成这部电影单看画面质感是非常美的，可整部电影的立意实在不算太高。</p><p>&emsp;&emsp;那么，我们在电影里看到了什么呢？跳广场舞大妈的一脸生无可恋、村里人夸夸其谈的致富梦想、表面奉承背地里说人长短、学校老师会接受学生“贿赂”、油腻感十足的新郎、“瓜分”募捐来的善款、搞封建迷信“请神”……这些非常真实的人物，像一张巨大的网将母女俩裹在其中，看起来两个人的矛盾，是留守儿童这样一个社会问题，可在我的理解中，这是现实与传统的一种碰撞，留守儿童不再是印象中内向闭塞的孩子，而或许是跟我们一样，知道什么是“吃鸡”，知道什么是“王者农药”，小镇村民不再是印象中善良淳朴的人们，而或许是知道生病了应该去医院，但“喊魂”这种事情同样需要，而对于募捐来的钱，无论是个人还是集体，都希望能分一点儿。</p><p>&emsp;&emsp;影片中喃杭的小伙伴喃湘露，是因为错过最佳治疗时机而死，而第一个送孩子去医院的人，恰恰是她们不大喜欢的老师，大人们说要等机场修好，就可以坐飞机去外面治病，接近尾声时，人们看到头顶呼啸而过的飞机，不知道会不会想起喃湘露这个孩子。母女俩完成和解是因为喃湘露的死亡，借喃杭的话说，“她不相信喃湘露已经死了，甚至都感觉不到悲伤”，可在一开始，女主就告诉女儿，以后不要和喃湘露一起玩儿。“请神”的时候，人们说已经有5年没有去祭拜过石佛啦。为什么要祭拜石佛呢？因为人们相信如果不这样做，以后会有更多的麻烦出现，可当一个地方被开发为旅游景点以后，我们以往所珍视的那些传统，究竟是否能在现代文明的洗礼下保存完整？</p><p>&emsp;&emsp;村民穿戴着传统的民族服饰，携带着供奉神灵的物品，一起到山里祭拜石佛，可门口悬挂着的“Closed”的木牌，连同将村民隔绝在外的那把铁锁，又仿佛将故事带入了后现代主义的胡同。如果石佛真的可以庇佑一方黎民，为何会被旅游开发者的一道铁门拦截？如果石佛真的可以感受到人们的虔诚，为何一定要到山林深处去朝圣祭拜？就像喃杭问她母亲，“我们给神跳舞，神就一定会知道吗？”，女主回答说，“只要你的心足够虔诚，神就可以感受得到”。这恰恰印证了老贺的举动，一行人被景区前的一道铁门给拦了下来，正暗自沮丧的时候，老贺说，“既然来都来了，无论在哪里跳舞，佛都会看见的”。</p><p>&emsp;&emsp;对于生活本身而言，鸡汤固然没有什么实际的用途，可人们往往又需要鸡汤，因为心里缺少了一样东西，就会很容易地被其它的东西填满，而这种东西我们都叫做它信仰。你总要试着去相信点什么，不管是唯物的还是唯心的。有时候我们之所以会焦虑，是因为我们想要索取的东西太多。其实生命里少了某些东西又能怎么样呢？你羡慕别人做什么事情都有人陪伴，可当你尝试去和别人一起做一件事情的时候，你就会发现，即使看电影这样一件小事，都会存在千差万别，比如你喜欢看好莱坞视觉大片，而我喜欢看日式田园小清新，真要找一部两个人都喜欢看的电影，难免会引发我的选择困难症。</p><p>&emsp;&emsp;有时候，你分不清喜欢一个人，到底是喜欢Ta还是喜欢Ta的习惯，分开以后的情侣，某一天意外地重逢，你说着对方那时这样或那样的习惯，而对方苦笑着说早就不喜欢那样子啦，那么，你开始怀疑，对方是不是真的喜欢这些，无论你是不是存在……喃杭打伤了大嘴，就在老师陪着大嘴在医院接受治疗的间隙，她对母亲撒谎说，“老师已经和大嘴回去了”……然后就是母女两人的冲突爆发，周围人的风言风语，母亲对女儿学习、生活上的种种不满，女儿对母亲的那种疏离感，相互纠缠在一起。喃湘露平时都见不到父母，甚至开玩笑地说，等到生一场大病看他们怎么办，可她依然相信，没有母亲会不爱自己的孩子。</p><p>&emsp;&emsp;最令我动容的是，喃杭说要给她变一个魔术，然后喃湘露就见到了自己的父母，三个人，六只眼睛，有惊异、有辛酸，霎时之间全部涌上心头。“神婆”说米花米酒都变味了不好吃，大概是因为我们缺少了那种简单和纯粹，母女俩一起炸米花的时候，中间女主被叫去一段时间，喃杭炸的米花在翻动的时候，从中间破碎成两半，或许人的心原本如此，当有了隔阂的时候，即便是再简单的事情，都会做不好。老人说山里不许女人进去，母女俩终于决定亲自走进洞里去，忽然发现，神圣无比的石佛，不过是在一个寻常无比的钟乳石洞里，听起来清脆无比的声音，不过是游客随手丢弃在地上的易拉罐……</p><p>&emsp;&emsp;心中去敬畏一样东西，不是永远被表象迷惑而且不敢有所怀疑，而是相信科学的解释，同样敬畏一切超越人力的力量，我怀疑云南的女孩子都会跳舞，比如曾经表演过千手观音的杨丽萍老师就来自云南，张大胡子甚至为了找一双好看的手，而让她出演了史上最美的梅超风，于是佛像前的一段舞蹈，成为了不亚于何小萍操场独舞的惊鸿一瞥，假如真的有来生，就祈祷喃湘露出生在一个富足的家庭里吧！你问神真的会灵验吗？不，不要去问神，而是去问你自己，所谓“心诚则灵”，相信一切美好的事情，All is well。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="生活感悟" scheme="http://qinyuanpei.github.io/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="影评" scheme="http://qinyuanpei.github.io/tags/%E5%BD%B1%E8%AF%84/"/>
    
      <category term="米花之味" scheme="http://qinyuanpei.github.io/tags/%E7%B1%B3%E8%8A%B1%E4%B9%8B%E5%91%B3/"/>
    
      <category term="电影" scheme="http://qinyuanpei.github.io/tags/%E7%94%B5%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title>基于Docker构建.NET持续集成环境</title>
    <link href="http://qinyuanpei.github.io/posts/3995512051/"/>
    <id>http://qinyuanpei.github.io/posts/3995512051/</id>
    <published>2018-06-12T17:53:59.000Z</published>
    <updated>2018-08-24T05:39:27.478Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>&emsp;&emsp;最近在考虑将整个项目组的产品，努力向着持续集成(CI)/持续部署(CD)的方向靠拢，因为目前我们仅仅实现了基于Docker的自动化部署，而部署包的构建依然依赖于人工打包，而每个版本的测试和部署，基本上都要给所有相关人员发一遍邮件，而写邮件无非是填写版本号和变更历史。身处在这样一个社会化分工逐渐加剧的『摩登时代』，我们唯一的希望就追求技能的多元化，你越是担心有一天会被AI所替代，就越是应该去追求灵动与美。这个世界何尝不是一个运行中的大型机器，可恰恰就是这种掺杂了情感的冰冷法则，让我们意识到需要更多的理解和宽容。管理者常常迷信敏捷开发的人月神话，希望人可以像零件一样按部就班，在这场噩梦到来以前，为何不去做一点更有用的事情，让云计算帮我们解放双手。</p><h1 id="背景说明"><a href="#背景说明" class="headerlink" title="背景说明"></a>背景说明</h1><p>&emsp;&emsp;我们的产品，从结构上来讲，分为后端、前端和客户端三个部分，其中，后端提供了从认证到上传、查询和下载等主要的AP接口；前端提供了基于后端API接口的页面，主要功能是监控和管理；客户端承担了主要的业务交互能力，主要功能是整合常用的硬件资源。从技术上来讲，后端是基于Spring Cloud的微服务架构，前端是基于node.js的典型前端工具链，而客户端是基于.NET/Win32的技术体系。所以，即使我们的客户端是运行在Window平台上，我们依然有大量的服务是运行在Linux环境下。负责部署的同事不愿意单独再构建一套持续集成(CI)环境，所以我们决定借助Docker完成整个持续集成(CI)环境的构建。</p><h1 id="构建过程"><a href="#构建过程" class="headerlink" title="构建过程"></a>构建过程</h1><p>&emsp;&emsp;完成整个项目的构建，需要覆盖到代码编译、单元测试、静态检查、版本发布这四个基本环节，我们整体上使用Jenkins 作为内部持续集成的平台，这意味着我们只需要在提交代码或者合并代码的时候，触发一个构建指令即可。这里我们考虑通过Docker来完成这些工作，一个整体上的设计思路如下图所示：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/Docker%20Flow.png" alt="构建思路" title="">                </div>                <div class="image-caption">构建思路</div>            </figure></p><h2 id="MSBuild"><a href="#MSBuild" class="headerlink" title="MSBuild"></a>MSBuild</h2><p>&emsp;&emsp;首先是MSBuild，它是我们整个构建流程中最重要的环节，我们平时通过Visual. Studio编译一个项目，背后其实就是由MSBuild这个构建工具来驱动，而通过MSBuild我们定义更多的构建流程，例如执行单元测试、实现Zip打包等等的流程。在Window平台下我们安装Visual Studio后就可以使用MSBuild，那么在Linux平台下呢？目前，MSBuild已经被微软开源并托管在Github上，大家可以通过这个地址：<a href="https://github.com/Microsoft/msbuild" target="_blank" rel="noopener">https://github.com/Microsoft/msbuild</a>来访问。通过阅读MSBuild的文档，我们了解到，目前MSBuild实际上有三个流向，分别是目前官方主推的<a href="https://github.com/Microsoft/msbuild/wiki/Building-Testing-and-Debugging-on-.Net-Core-MSBuild" target="_blank" rel="noopener">.Net Core</a>、传统<a href="https://github.com/Microsoft/msbuild/wiki/Building-Testing-and-Debugging-on-Full-Framework-MSBuild" target="_blank" rel="noopener">.Net Framework</a>以及由<a href="https://github.com/Microsoft/msbuild/wiki/Building-Testing-and-Debugging-on-Mono-MSBuild" target="_blank" rel="noopener">Mono</a>托管的部分。</p><p>&emsp;&emsp;.Net Core中MSBuild实际上被集成在<a href="https://docs.microsoft.com/zh-cn/dotnet/core/tools/?tabs=netcore2x" target="_blank" rel="noopener">.Net CLI</a>中，熟悉.NET Core的朋友一定都知道，.NET Core类型的项目，是可以直接通过dotnet命令来创建项目、还原Nuget包、运行项目、构建项目和发布项目的，可以想象的到这些功能是依赖MSBuild和Nuget的，可惜这种目前对我们来说不太适合。接下来，我们有两个选择，一个是Full Framework，一个是Mono，因为我们的服务器是一台Linux服务器，所以Full Framework对我们来说不适合，我们在无奈的情况下选择了Mono，按照官方文档，从源代码安装过程如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone -b xplat-master https://github.com/mono/msbuild/</span><br><span class="line">cd msbuild</span><br><span class="line">make</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;果不其然，这个无论是在Linux主机还是Docker中都失败了，官方的源代码我们编译不过去，那就只能考虑非源代码安装啦！按照官方的说法，我们需要Mono，所以兴奋地跑到Mono官方去安装，根据以前使用Mono的经验，飞快地在终端里输入下面两行代码：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install mono-runtime</span><br><span class="line">sudo apt-get install mono-xbuild</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;装完以后，发现可以使用Mono和XBuild，可无奈是XBuild版本实在太低，换句话说我们从Ubuntu官方源里安装完的Mono相当于.NET Framework 2.0的版本，这怎么可以呢？果断从Mono官方下载最新版本的Mono，这是一个经过反复试验的安装方法：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade -y</span><br><span class="line">sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys 3FA7E0328081BFF6A14DA29AA6A19B38D3D831EF</span><br><span class="line">sudo apt install apt-transport-https -y</span><br><span class="line">sudo apt-get install wget -y</span><br><span class="line">echo "deb https://download.mono-project.com/repo/ubuntu stable-trusty main" | sudo tee /etc/apt/sources.list.d/mono-official-stable.list</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install aptitude -y</span><br><span class="line">sudo apt-get install -f</span><br><span class="line">sudo apt-get install -y git</span><br><span class="line">sudo aptitude install -y mono-complete</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这里顺带安装了git和wget，因为下面我们会用到这两个软件。aptitude实在是修复Linux依赖问题的神器，我准备找时间用它修复下我的Linux环境。apt-transport-https这个是为了支持https协议，这个不用说太多，我们选择了最全的一个Mono版本mono-complete，它包含了我们在Linux下可以使用的所有程序集，换句话说，这些程序集以外的程序集，或者是和Windows联系紧密的COM组件、OCX等等，想都不要想啦，只有一件事情是对的，对平台的依赖越少，跨平台的可能性越高。</p><h2 id="Nuget"><a href="#Nuget" class="headerlink" title="Nuget"></a>Nuget</h2><p>&emsp;&emsp;<a href="https://www.nuget.org/" target="_blank" rel="noopener">Nuget</a>是.NET下使用最多的包管理器，虽然目前.NET Core里的依赖管理越来越像Maven，可我觉得作为整个构建工具里的一环，还是应该考虑进来，虽然我们的项目中的第三方库基本都靠拷。Nuget只有单独的命令行版本和Visual Studo扩展两个版本，这里我们使用wget下载命令行版本，然后再通过Mono来调用nuget.exe:<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo wget https:<span class="string">//dist.nuget.org/win-x86-commandline/v4.6.2/nuget.exe</span> <span class="string">/usr/local/bin/nuget.exe</span></span><br><span class="line"><span class="keyword">alias</span> nuget=<span class="string">"mono /usr/local/bin/nuget.exe"</span></span><br></pre></td></tr></table></figure></p><h2 id="Sonar"><a href="#Sonar" class="headerlink" title="Sonar"></a>Sonar</h2><p>&emsp;&emsp;对于Sonar的话，这里我推荐用SonarCloud，因为我们只需要通过wget下载SonarScanner，然后通过Mono调用并提供SonarCloud提供的token即可。曾经博主写过一篇关于使用SonarCloud为.NET/.NET Core项目提供静态检查的文章，在这篇文章中我们提到，SonarCloud支持.NET Framework 4.6+以上的版本以及.NET Core版本，所以，这里我们沿用当时的脚本即可，想了解SonarCloud的朋友，可以找到这篇文章进行深入了解。下面给出脚本：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo wget https://github.com/SonarSource/sonar-scanner-msbuild/releases/download/4.3.0.1333/sonar-scanner-msbuild-4.3.0.1333-net46.zip sonar-scanner.zip</span><br><span class="line">sudo unzip sonar-scanner.zip</span><br><span class="line">sudo alias sonar-scanner="mono ./sonar-scanner/SonarQube.Scanner.MSBuild.exe"</span><br><span class="line">sonar-scanner begin /k:"Sonar-HttpServer" /d:sonar.organization=&lt;Your-Org&gt; /d:sonar.host.url="https://sonarcloud.io" /d:sonar.login=&lt;Your-Token&gt;</span><br><span class="line">msbuild /t:Rebuild</span><br><span class="line">sonar-scanner end /d:sonar.login=&lt;Your-Token&gt;</span><br></pre></td></tr></table></figure></p><h2 id="NUnit"><a href="#NUnit" class="headerlink" title="NUnit"></a>NUnit</h2><p>&emsp;&emsp;既然我们有了Nuget，那么自然要用Nuget来做点事情。对于单元测试，微软提供的MSTest功能相对薄弱，关键是严重依赖Visual Studio，一旦我们想要移植到Linux平台下，就会发现阻力重重，所以在平时开发中，我更建议大家去使用NUnit或者XUnit，它们比MSTest功能强大，可以直接通过Nuget安装，同时自带TestRunner，这是一个控制台程序，我们直接通过Mono调用它，并把单元测试项目生成的动态链接库作为参数传递给它即可。<br>下面给出基本的脚本：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nuget install NUnit.Runners -Version 3.8.0 -OutputDirectory ./TestRunner</span><br><span class="line">alias nunit="mono ./TestRunner/NUnit.ConsoleRunner.3.8.0/tools/nunit3-console.exe"</span><br><span class="line">nunit &lt;Your-UnitTest-Project&gt;</span><br></pre></td></tr></table></figure></p><h1 id="牛刀小试"><a href="#牛刀小试" class="headerlink" title="牛刀小试"></a>牛刀小试</h1><p>&emsp;&emsp;下面我们来试试在Docker里完成镜像的构建，其实这里更推荐在Linux下安装Docker，博主在Window平台下安装了Docker for Windows，需要系统支持虚拟化技术。因为博主在构建镜像的时候，一直提示磁盘空间不足，所以，这里我们把Dockerfile放到DaoCloud上去跑，关于Docker的安装以后有机会在同大家分享。这里，DaoCloud你可以理解为一个帮我们装好了Docker的云主机，事实上用DaoCloud以后，感觉测试Dockerfile可以更省时间啦，效率上相差十倍啊！Dockerfile其实就是本文中这些脚本的集合，这里我们给出完整的Dockerfile，这个文件可以从<a href="https://github.com/qinyuanpei/HttpServer/blob/master/Dockerfile" target="_blank" rel="noopener">这里</a>获取：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:14.04</span><br><span class="line">LABEL vendor="qinyuanpei@163.com"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Install Mono &amp;&amp; XBuild</span></span><br><span class="line">RUN sudo apt-get update</span><br><span class="line">RUN sudo apt-get upgrade -y</span><br><span class="line">RUN sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys 3FA7E0328081BFF6A14DA29AA6A19B38D3D831EF</span><br><span class="line">RUN sudo apt install apt-transport-https -y</span><br><span class="line">RUN sudo apt-get install wget -y</span><br><span class="line">RUN echo "deb https://download.mono-project.com/repo/ubuntu stable-trusty main" | sudo tee /etc/apt/sources.list.d/mono-official-stable.list</span><br><span class="line">RUN sudo apt-get update</span><br><span class="line">RUN sudo apt-get install aptitude -y</span><br><span class="line">RUN sudo apt-get install -f</span><br><span class="line">RUN sudo apt-get install -y git</span><br><span class="line">RUN sudo apt-get install -y zip</span><br><span class="line">RUN sudo apt-get install -y unzip</span><br><span class="line">RUN sudo aptitude install -y mono-complete</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Intall Nuget</span></span><br><span class="line">RUN sudo wget -O nuget.exe https://dist.nuget.org/win-x86-commandline/v4.6.2/nuget.exe </span><br><span class="line"><span class="meta">#</span><span class="bash">RUN <span class="built_in">alias</span> nuget=<span class="string">"mono nuget.exe"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Install Sonar-Scanner</span></span><br><span class="line">RUN sudo wget -O sonar-scanner.zip https://github.com/SonarSource/sonar-scanner-msbuild/releases/download/4.3.0.1333/sonar-scanner-msbuild-4.3.0.1333-net46.zip</span><br><span class="line">RUN sudo unzip sonar-scanner.zip -d ./sonar-scanner</span><br><span class="line"><span class="meta">#</span><span class="bash">RUN <span class="built_in">alias</span> sonar-scanner=<span class="string">"mono .SonarQube.Scanner.MSBuild.exe"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Install NUnit</span></span><br><span class="line">RUN mono nuget.exe install NUnit.Runners -Version 3.8.0 -OutputDirectory ./TestRunner</span><br><span class="line"><span class="meta">#</span><span class="bash">RUN <span class="built_in">alias</span> nunit=<span class="string">"mono ./TestRunner/NUnit.ConsoleRunner.3.8.0/tools/nunit3-console.exe"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Build Project &amp;&amp; Sonar Analyse &amp;&amp; UnitTest</span></span><br><span class="line">RUN git clone https://github.com/qinyuanpei/HttpServer.git</span><br><span class="line">RUN sudo mono ./sonar-scanner/SonarQube.Scanner.MSBuild.exe begin /k:"Sonar-HttpServer" /d:sonar.organization="qinyuanpei-github" /d:sonar.host.url="https://sonarcloud.io" /d:sonar.login="db795a28468dc7c12805b330afed53d362fdd2d9"</span><br><span class="line">RUN msbuild /p:Configuration=Release ./HttpServer/HTTPServer/HTTPServer.sln</span><br><span class="line">RUN sudo mono ./sonar-scanner/SonarQube.Scanner.MSBuild.exe end /d:sonar.login="db795a28468dc7c12805b330afed53d362fdd2d9"</span><br><span class="line"><span class="meta">#</span><span class="bash"> RUN mono ./TestRunner/NUnit.ConsoleRunner.3.8.0/tools/nunit3-console.exe ./HttpServer/HTTPServer/HTTPServerLib.UnitTest/bin/Release/HttpServerLib.UnitTest.dll</span></span><br><span class="line">EXPOSE 2048</span><br></pre></td></tr></table></figure></p><p>好了，下面我们通过Dockerfile来构建镜像，这里不需要考虑部署，我们就是在Docker这个环境里跑跑结果(PS：不知道为什么alias在Docker里不起作用)：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t httpserver:v1 .</span><br></pre></td></tr></table></figure></p><p>可以看到，我们整个过程除了单元测试没有通过以外，其它的环节都非常顺利，这其中一个重要的原因是，博主这个项目对Window依赖较少，它是一个C#开发的简易Web服务器，主要是类库和控制台程序，可以完美地运行在Linux平台下，所以，跨平台最终考验的还是开发人员。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/Docker-02.png" alt="Docker中构建的结果" title="">                </div>                <div class="image-caption">Docker中构建的结果</div>            </figure></p><h1 id="One-More-Thing"><a href="#One-More-Thing" class="headerlink" title="One More Thing"></a>One More Thing</h1><p>&emsp;&emsp;这里我们主要针对的是.NET Framework，那么针对传统的ASP.NET以及最新的.NET Core又该如何做持续集成呢？这里简单说一下思路，具体的Dockerfile大家可以去DockerHub去找(抄)，这里我就不帮大家写了。对于传统的ASP.NET，在本文的基础上增加Jexus就可以做Linux下的部署，当然，前提是要避免和Window太过紧密的耦合，否则即便是大罗神仙亲临，这持续集成永远都是个梦。对于.NET Core，只要安装了它的SDK，编译、依赖管理、发布、部署都不再是问题，只要完善下单元测试和静态检查就可以，因为它是可以自部署的，并且天生就是为了跨平台而生，如果有可能，还是考虑用.NET Core吧，Windows最适合的还是吃鸡打游戏(逃……</p><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>&emsp;&emsp;读过我之前<a href="http://localhost:4000/posts/4891372/" target="_blank" rel="noopener">博客</a>的朋友，一定会发现，我今天这篇博客里所做的事情，同我曾经在.NET项目上使用TravisCI是完全一样的，所不同的是，TravisCI里的构建环境是别人提供好的，而这里的构建环境是我们自己搭建的。这并不是在做无用功，如果你需要搭建私有的Linux下的构建环境，我相信这篇文章会带给你一点启示。项目组最后还是放弃了这个方案，因为产品里集成了太多和Window关联的东西。而负责部署的同事最终如释重托，因为他们不必去踩这些无聊的坑，可对我来说，这像一道屈辱的烙印刻在我的心上，我甚至试过在Docker环境里搭建Window的环境，哪怕最终我发现我不能把Docker当一个虚拟机来用，我越来越害怕自己对那些变化一无所知，还庆幸自己可以在时光的影子里偷懒。</p><p>&emsp;&emsp;有时候，人们假装配合持续集成的流程，因为它听上去非常美好，可对环境的依赖不愿意削弱，对单元测试不是那么重视，对代码质量不是那么在意，这一切又永远都只是听上去美好而已。我听到有面试官在面试的时候，批评面试者所做的运维工作不是那么的高大上，毕竟我们只是写了点脚本而已，离面试官心中的DevOps相去甚远。可MSBuild是XML写成的脚本，make不过是个纯文本的脚本，到底哪一种更高大上？我在这篇文章里使用了Docker，能否让我的工作显得高大上？我们的工作到底有多少能适应DevOps？我觉得想清楚这个再谈高大上，不是不可以啊？对吧？好了，这就是这篇文章的全部内容啦，谢谢大家！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="开发工具" scheme="http://qinyuanpei.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term=".NET" scheme="http://qinyuanpei.github.io/tags/NET/"/>
    
      <category term="Docker" scheme="http://qinyuanpei.github.io/tags/Docker/"/>
    
      <category term="MSBuild" scheme="http://qinyuanpei.github.io/tags/MSBuild/"/>
    
  </entry>
  
  <entry>
    <title>一个由服务器时区引发的Bug</title>
    <link href="http://qinyuanpei.github.io/posts/172426938/"/>
    <id>http://qinyuanpei.github.io/posts/172426938/</id>
    <published>2018-06-05T11:03:57.000Z</published>
    <updated>2018-08-24T05:39:27.474Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>&emsp;&emsp;太阳照常升起，在每个需要挤公交车上班的日子里，即使窗外早已大雨如注。想来只有在周末，太阳会陪着我一起起床，所谓睡觉睡到自然醒，在雨天里保持晴天的心情，相当大的程度上，是因为今天不必上班。因此，一周里的心情晴雨表，简直就是活生生的天气预报，可惜我并不能预测我的心情，因为Bug会在某一瞬间发动突然袭击。一周前测试同事小J得到用户的反馈，我们某一笔订单突然无法从系统中查到，可就在数分钟前用户创建了这笔订单。前端同事小Q立刻追踪了这个问题，发现查询交易的接口调用正常，而后端同事小L确认数据库中是有这条交易记录的。于是，为了解决这样一个诡异的问题，几乎花费了大家大半天的时间。而最后的问题根源，居然充满了无厘头的意味，如本文主题所言，这是一个由服务器时区引发的Bug。在这篇文章中，我想和大家聊一聊，关于时区以及日期/时间格式化的相关问题，希望大家会喜欢这个话题，就如同我希望大家会喜欢我一样。<br>&emsp;&emsp;可能大家都不会意识到时区会成为一个问题，因为对大多数中国人而言，我们唯一的时间概念就是北京时间。我们不得不承认，互联网在弱化了空间地域性的同时，无形中疏远了人与人之间的距离，尤其当我们处在一个分布式架构的时代，云的存在让我们的Service分布在无数个服务器节点上去，我们甚至意识不到它们的存在。比如我们在阿里云上选购主机的时候，阿里云会让我们去选择主机所在的地域，因为选择离自己更近的地域，意味着可以更快的访问速度。再比如像亚马逊这样的云计算服务商，会在国内(<strong>宁夏·中卫</strong>)部署自己的资源，这显然是为了服务国内用户。那么，我们不得不去思考一个问题，假如我们要同时服务国内、外的用户，那么这些Service 可能会被同时部署到国内和国外的服务器上面。因此，我们就可能会遇到国内、外服务器时区不一致的问题，通常我们会以服务器时间为准并将其储到数据库中。此时，因为时区不一致，难免会产生本文中遇到的这个问题。</p><h1 id="时区为什么会不同？"><a href="#时区为什么会不同？" class="headerlink" title="时区为什么会不同？"></a>时区为什么会不同？</h1><p>&emsp;&emsp;既然时区是本文里的<strong>“罪魁祸首”</strong>，那么我们就会不由得思考这样一个问题，即为社么时区会不同。我们知道，地球是自西向东自转的，因此东边会比西边先看到太阳。相应地，东边的时间会比西边的早。这意味着时间并不是一个绝对的概念，即东边的时间与西边的事件存在时差。现实中的时差不单单要以小时计，而且还要以分和秒计，这给人们带来了不便和困扰。因此，1884年在华盛顿召开的国际子午线会议上，规定将全球划分为24个时区(东、西各十二个时区)，其中以英国格林尼治天文台旧址作为零时区，每个时区横跨经度15度，时间恰好为1小时，而东、西第12时区各跨经度7.5度，以东、西经180度为界。每个时区内时间，统一以该时区的中央经线的时间为主，相邻的两个时区间总是相差一个小时，这就是时区的由来，时区的出现解决了人们换算时间的问题。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/timezone_01.jpg" alt="世界时区分布" title="">                </div>                <div class="image-caption">世界时区分布</div>            </figure><br>&emsp;&emsp;事实上，时区的划分并不是一个严谨的事情，因为常常会出现一种情况，一个国家或者一个省份同时跨着2个或者更多的时区。以中国为例，中国幅员辽阔，差不多横跨5个时区，理论上在国内应该有5个时间，但为了使用起来方便，我们统一使用的是北京时间，即东八区时间。什么叫做东八区呢？即东半球第八个时区，其中央经度为东经120度。时区的计算非常简单，当你往西走时，每经过一个时区，时间会慢一个小时；当你往东走时，每经过一个时区，时间会快一个小时。例如，日本的东京位于东九区，因此，北京时间2018年6月9日8点整，对应的东京时间应该是2018年6月9日9点。这样，我们就会遇到一个非常有趣的问题，如果一个人到世界各地去旅行，它就需要不停地去将手表拨快或者拨慢，即使我们现在有了智能手机，它一样会提供不同时区的时间选择，假如我们偷懒选择了网络时间，那么它将永远和当地时间保持一致，因为我十分地确信，东京的运营商绝对不会选择使用北京时间。</p><h1 id="数据库里如何存储时间"><a href="#数据库里如何存储时间" class="headerlink" title="数据库里如何存储时间"></a>数据库里如何存储时间</h1><p>&emsp;&emsp;截至到目前为止，我们可以搞清楚的一件事情是，在不同的地域使用的时间是不同的，因为我们所使用的时间，本质上都是相对于格林尼治时间的相对时间，即使这些时间会因为地域存在差异，可从整个宇宙的角度来看，时间分明又是在绝对地流逝着，它对我们每一个人而言都是客观而公正的，当你发现时间越来越不够用的时候，你需要思考时间到底被浪费到什么地方去。我无意像霍金先生一样，去追溯时间的起源以及它的未来，在这篇文章里，我更关心的是，数据库里究竟是怎么样存储时间的，因为最根本的问题是，用户作为查询条件的时间，服务器上存储记录的时间，这两个时间的上下文发生了混乱。人类更喜欢在工作中不停地切换上下文，尤其是在面对无休止的会议、需求分析、Review等等诸如此类的中断的时候，你是否会想到频繁地切换上下文，本质上是需要付出代价的呢？<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/aron-visuals.jpg" alt="Time is All" title="">                </div>                <div class="image-caption">Time is All</div>            </figure><br>&emsp;&emsp;回到这个问题本身，我们现在来看看数据库中是如何存储时间的，这里我们选择三种最为常见的数据库来分析，它们分别是MySQL、Oracle 和 SQL Server。</p><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><p>&emsp;&emsp;对MySQL来说，它支持YEAR、DATE、TIME、DATETIME和TIMPSTAMP共5种数据类型。其中，</p><ul><li>YEAR类型占1个字节，取值范围为1901~2155，可以采用4位字符串或者4位数字赋值，不建议使用2位数字或者2为字符串赋值，因为容易混淆0和‘0’。</li><li>DATE类型占4个字节，取值范围为1000-01-01 ~ 9999-12-31，采用YYYY-MM-DD的格式赋值，不建议使用@或.这样的分隔符，不建议将年份表示为YY，理由同上。</li><li>TIME类型占3个字节，取值范围为-838:59:59 ~ 838:59:59，采用HH:MM:SS的格式赋值，不建议使用HH:MM或者SS的简写格式，以及混合使用D的格式。</li><li>DATETIME类型占8个字节，取值范围为1000-01-01 00:00:00 ~ 9999-12-31 23:59:59，标准格式为YYYY-MM-DD HH:MM:SS，规则同上</li><li>TIMESTAMP类型占4个字节，取值范围为19700101080001 ~ 20380119111407，系统可以使用CURRENT_TIMESTAMP或者自动输入当前的TIMESTAMP，需要注意的是，该数值与时区有关。</li></ul><h2 id="Oracle"><a href="#Oracle" class="headerlink" title="Oracle"></a>Oracle</h2><p>&emsp;&emsp;对Oracle来说，它支持DATE、TIMPSTAMP和INTERVAL共3种数据类型。其中，</p><ul><li>DATE类型占7个字节，是一种表示日期/时间的数据类型，本身包含世纪、世纪中的哪一天、月份、月份中的哪一天、小时、分钟和秒7个属性，例如2005-12-05 12:30:43对应的表示是120、105、12、5、12、31、44，我们注意到这里世纪和世纪中的年份，都被相应地增加了100，而分钟数和秒数分别增加了1，这里增加的100是为了区分公元前和公元后，一般在写入该类型的数据时，最好能显式地指定日期或者时间的格式。</li><li>TIMPSTAMP类型，同DATE类型类似，不同的是，TIMESTAMP类型可以支持秒分量的小数位数以及时区。秒分量的小数部分最多可以支持9位，当秒分量的小数部分为0时，它和DATE类型在功能上完全一致。</li><li>INTERVAL类型，顾名思义，这是一个表示时间间隔的数据类型，同.NET中的TimeSpan类型相似，它可以用来存储一个时间间隔，比如8个小时或者是30天，两个DATE或者TIMESTAMP相减可以得到INTERVAL，而DATE或者TIMESTAMP增加一个INTERVAL就可以得到相应的DATE或者TIMESTAMP。</li></ul><h2 id="SQL-Server"><a href="#SQL-Server" class="headerlink" title="SQL Server"></a>SQL Server</h2><p>&emsp;&emsp;对SQL Server来说，它支持Date、Time、DateTime和DateTime2共4种数据类型。其中，</p><ul><li>Date类型仅存储日期，不存储时间，需要3个字节的存储空间，默认格式为yyyy-MM-dd(PS:为什么没有一个标准来统一这些占位符的大小写)，取值范围为0001-01-01 ~ 9999-12-31，可以采用字符串、GetDate()、SysDateTime()三种方式赋值。</li><li>Time类型仅存储时间，不存储日期，需要7个字节的存储空间，默认格式为hh:mm:ss.nnnnnnn，可以注意到默认的秒分量小数部分为7位，建议使用字符串或者SysDateTime()这两种方式赋值，不建议使用GetDate()，因为该方法返回值为DateTime类型，其时间部分的精度没有Time类型的经度高。</li><li>DateTime/DateTime2，这个命名好COM+啊，其中DateTime类型存储日期和时间，需要8个字节的固定存储空间，相对应地，DateTime2的存储空间则是不固定的，因为它可以指定秒分量的小数位。DateTime的默认格式为yyyy-MM-dd hh:mm:ss.xxx，取值范围为1753-01-01 00:00:00.000 ~ 9999-1-3123:59:59.997，精确度为3.33毫秒，相应地，DateTime2的秒分量小数位默认可达到7位。通过GetDate()和GetUTCDate()两个函数，可以为DateTime类型赋值；通过SysDateTime()和SysUTCDateTime()函数，可以为DateTime2类型赋值。通常来说，DateTime2相比DateTime，具有更好的性能表现。<br>&emsp;&emsp;此时此刻，我们不得不面对这样一个现实，那就是：不同的数据库中对日期/时间的存储处理是不同的。看起来这像是一个显而易见的结论，因为这就像SQL这门语言一样，即使我们有着相同的标准，可最终我们面对的还是各种“方言”版本的SQL，甚至连这些难以统一的内置函数，都会成为某次面试中的题目。我们注意到，这些和日期/事件相关的数据类型，在对时区的支持上差异明显，MySQL中的DATESTAMP是标准的UNIX时间戳，存储的是自1970-01-01至今经过的秒数，这个数据的存取都是相对简单的，因为MySQL内部帮你做了大量的转换的工作，<br>&emsp;&emsp;可它的缺点是什么呢？由于4个字节长度的限制，它最多到2038年，可现在都2018年了啊！DATETIME类型的数据范围好像可以解决这个问题，遗憾的是它没有办法包含时区信息，这就尴尬了啊！或许有人会想到能不能用int类型来存储日期，这理论上是没有问题啊，可你愿意每次存取都要做一遍转换吗？这意味着我们需要一种同时支持日期、时间和时区的表示方法，所以，下面我们来说一说DateTime相关的格式化，这里特指UTC时间、GMT时间、本地时间和Unix时间。</li></ul><h1 id="繁杂的日期格式"><a href="#繁杂的日期格式" class="headerlink" title="繁杂的日期格式"></a>繁杂的日期格式</h1><p>&emsp;&emsp;我对日期/时间的格式化的厌恶，最早来自为Excel编写读写库，人们发明了各种各样的样式，虽然常用的无非那么多种，可对于一个编写Excel读写库的人来说，你不得不去在读写过程中面对各种各样的格式，或者是从字符串变为DateTime类型，或者是从DateTime变为字符串。我本人非常喜欢OADate这种方式，因为它真正地做到了样式与数据分离，我们大多数时候面对的时间，它到底是一种什么数据类型，为什么你在Excel里输入日期/时间字符串会被当作是日期/时间，而通过快捷键插入的系统时间同样会被当作是日期/时间，有没有一种统一的可以描述时间的方式呢？这里需要介绍UTC时间、GMT时间、本地时间和Unix时间4个概念。</p><h2 id="UTC时间"><a href="#UTC时间" class="headerlink" title="UTC时间"></a>UTC时间</h2><p>&emsp;&emsp;UTC时间，即Coordinate Universal Time。它是一种通用的时间表示方法，UTC是根据原子钟来计算时间，它是经过平均太阳时、地轴运动综合修正计算后的一个结果，使用秒作为计量单位，由于原子钟计量的时间精度非常高，因此，可以认为UTC一个世界标准时间。</p><h2 id="GMT时间"><a href="#GMT时间" class="headerlink" title="GMT时间"></a>GMT时间</h2><p>&emsp;&emsp;GMT时间，即Greenwhich Mean Time。如果大家对这个名词不熟悉，那么我相信，对于格林威治天文台，大家一定非常熟悉啦！ 十七世纪，为了满足英国海上霸权的扩张，格林威治皇家天文台开始对天文进行观测。历史上每一次霸权主义的扩张，其初衷必然是非正义的，可伴随着这个过程中而产生的文明，可谓是是泽被后世，前文中提到的时区划分，就是以格林尼治天文台旧址作为零时区，所以GMT时间和UTC时间等价，前者提出较早，基于天文观测；后者提出较晚，基于现代物理。</p><h2 id="本地时间"><a href="#本地时间" class="headerlink" title="本地时间"></a>本地时间</h2><p>&emsp;&emsp;本地时间，即LocalTime。从定以上来讲，本地时间=UTC时间+时差，其中东半球时区记为正，西半球时区记为负。以东八区为例，UTC+0800，即为本地时间，这就是我们所熟悉的北京时间。因为同时存在UTC和GMT两种标准，所以我们在某些场合下会看到GMT+0800，这两者表示的实际上是同一个时间，都以秒作为单位。</p><h2 id="Unix时间"><a href="#Unix时间" class="headerlink" title="Unix时间"></a>Unix时间</h2><p>&emsp;&emsp;Unix时间，又称Unix时间戳，顾名思义，这是一种在Unix及类Unix操作系统中表示时间的方法。Unix时间戳其实就是UTC 时间在计算机领域的一个应用，我们所看到的计算时间，其实都是从1970-01-01 00:00:00开始，截止到此时此刻的总秒数，这个方案被Unix及类Unix操作系统继承下来，甚至影响到了大量非Unix操作系统，这个方案后来被称为POSIX标准，因为该时间又被称为POSIX时间。或许有朋友会感到疑惑，计算机是会关机和断电的啊，那么这个时间不就会丢失吗？事实上计算机内部有一个称为RCT的硬件模块，该模块内部独立供电，所以可以准确记录下这个时间。一个有趣的事情是，计算机内部使用32位整型来表示时间，而32位整型最大能表示为2147483647秒，我们做个简单计算:2147483647/365/24/60/60，就可以知道这个数值为68.1年，这意味着计算机内部能表示最大年份为1970+68=2038。想想看今天已经是2018年啦，难道在我们有生之年会有幸见到这个Bug吗？这对整个数字时代来说算不算一次世界末日呢？哈哈，实际上我们有了64位以后这个问题就可以解决了，至于64位出现类似问题，这个只能交给时间来解决啦，因为那时你和我都早已不复存在。</p><h2 id="ISO8601"><a href="#ISO8601" class="headerlink" title="ISO8601"></a>ISO8601</h2><p>&emsp;&emsp;OK，现在我们来一起看一个实际的格式化问题，我们在调用后端提供的API接口时，前端同事使用日期格式是：2018-06-05T03:03:57.000Z，而后端同事使用的日期格式是：2018-03-16T19:14:22.077+0800。这两种不同的日期格式到底是什么呢？和我们这篇文章中提到的内容又有什么关联呢？因为博主曾经在写一个小工具的时候，遇到无法解析这种格式日期的问题，所以对这两种日期格式可谓是记忆犹新。这两种日期格式实际源于一个国际标准<a href="https://www.iso.org/iso-8601-date-and-time-format.html" target="_blank" rel="noopener">ISO8601</a>。<br>&emsp;&emsp;根据该格式的定义，当日期和时间组合使用时，需要在时间面前增加一个大写字母T，而Z表示时区，且默认表示0时区，因此字母Z可以省略，以我国为例，我国是东八区，所以正确的写法是+08:00，由此可以得知，第二种写法实际上就是一个表示东八区时间的表示方法，虽然这个写法是错误的。第一种写法有什么问题呢？它表示的是0时区的时间，因此对中国用户而言，他们需要在这个时间上增加8个小时的时差，可如果这个时间是经过时区修正后的时间会怎么办呢？时间对每一个人都很重要，可看到它的稀奇古怪的表示方法，难免会让人感到风中凌乱啊……<br>&emsp;&emsp;我们知道，<a href="https://bridge.net/go/newtonsoft/" target="_blank" rel="noopener">Json.Net</a>是.NET中一个非常流行的JSON解析和生成库，而我们在对一个实体进行序列化的时候，如果实体中属性的数据类型为DateTime，那么在序列化的时候就会出现一个非常有趣的现象。假如我们在数据库中有一个字段dateCreated，那么通过这个库转换出来的结果可能会是”\/Date(1269582661683+0800)\/“这样的结果，例如下面这段JSON：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="attr">"DateCreated"</span>:<span class="string">"\/Date(1528687303302)\/"</span>,</span><br><span class="line"> <span class="attr">"UserName"</span>:<span class="string">"Payne Qin"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>出现这个结果的原因，是因为我们使用微软提供的JavaScriptSerializer，而这个序列化器遵循的实际上是Unix时间标准，换句话说，这里展示的这个数值是1970-01-01 00:00:00至今的毫秒数， 这一点我们通过一个简单的计算就可以得到验证。Json.Net中默认使用ISO8601风格的序列化器，我们一起来看下面的例子，这里我们定义一个简单的数据结构，按照惯例，这个数据结构用Foo类表示：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">  [<span class="meta">JsonConverter(typeof(IsoDateTimeConverter))</span>]</span><br><span class="line">  <span class="keyword">public</span> DateTime IsoDateTime &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">  [<span class="meta">JsonConverter(typeof(JavaScriptDateTimeConverter))</span>]</span><br><span class="line">  <span class="keyword">public</span> DateTime JSDateTime &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">string</span> UserName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此时，我们可以注意到序列化后的结果如下：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"IsoDateTime"</span>:<span class="string">"2018-06-11T11:35:45.898768+08:00"</span>,</span><br><span class="line">  <span class="attr">"JSDateTime"</span>:new Date(<span class="number">1528688145898</span>),</span><br><span class="line">  <span class="attr">"UserName"</span>:<span class="string">"Payne Qin"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为了将这两种统一起来，建议通过JsonSerializerSettings，因为我们可以定制日期的样式：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> settings = <span class="keyword">new</span> JsonSerializerSettings();</span><br><span class="line">settings.DateFormatHandling = DateFormatHandling.IsoDateFormat;</span><br><span class="line">settings.DateFormatString = <span class="string">"yyyy-MM-ddTHH:mm:ss.fffzzz"</span>;</span><br><span class="line"><span class="keyword">var</span> json = JsonConvert.SerializeObject(entity,settings);</span><br></pre></td></tr></table></figure></p><p>此时，可以注意到结果为：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"IsoDateTime"</span>:<span class="string">"2018-06-11T11:45:46.981+08:00"</span>,</span><br><span class="line">  <span class="attr">"JSDateTime"</span>:<span class="string">"2018-06-11T11:45:46.981+08:00"</span>,</span><br><span class="line">  <span class="attr">"UserName"</span>:<span class="string">"Payne Qin"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>JavaScriptDateTimeConverter和IsoDateTimeConverter，均是DateTimeConverter的子类，因此我们可以定义更多的转换器，毕竟喜欢折腾的人类永远不会满足，除了本文中介绍到的时间表示方法以外，我们还有CST和DST等不同的表示方法，对了，关于格式化参数fff/zzz等请参考<a href="https://www.cnblogs.com/JiYF/p/7831547.html" target="_blank" rel="noopener">这里</a>，你就会知道人类是多么的无聊啊。</p><h1 id="不同语言中对时区的处理"><a href="#不同语言中对时区的处理" class="headerlink" title="不同语言中对时区的处理"></a>不同语言中对时区的处理</h1><p>&emsp;&emsp;好了，这篇文章基本上通篇都在讲时间，我们最初的问题是，服务器上的时区和当前时区不一致，导致在查询的时候时间无法对应起来。现在，我们应该可以达到一个共识，不管什么时候，我们都应该使用UTC时间或者GMT时间，而在拿到这样一个时间后，如果有必要请转换为本地时间，而当相关流程结束以后，最好将这个时间转换为UTC时间或者是GTM时间。现在，我们来看看不同的语言中是如何处理时区问题的，按照博主对语言的熟悉程度，博主选择了C#和Python两门语言来说明问题。</p><h2 id="CSharp"><a href="#CSharp" class="headerlink" title="CSharp"></a>CSharp</h2><p>&emsp;&emsp;C#中关于日期/时间的API都集中在DateTime类中，而关于时区的API则集中在TimeZone和TimeZoneInfo类中，我们一起来看下面的代码：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前时区：中国夏令时</span></span><br><span class="line"><span class="keyword">var</span> timezone = TimeZone.CurrentTimeZone;</span><br><span class="line"><span class="comment">//获取所有时区</span></span><br><span class="line"><span class="keyword">var</span> timezones = TimeZoneInfo.GetSystemTimeZones();</span><br><span class="line"><span class="comment">//获取时区ID：北京时间+08:00/China Standard Time</span></span><br><span class="line"><span class="keyword">var</span> timezoneId = TimeZoneInfo.GetSystemTimeZones()[<span class="number">102</span>].Id;</span><br><span class="line"><span class="comment">//当前系统时区：(UTC+08:00) 北京，重庆，香港特别行政区，乌鲁木齐</span></span><br><span class="line"><span class="keyword">var</span> currentTimeZone = TimeZoneInfo.Local;</span><br><span class="line"><span class="comment">//本地时间转换为UTC时间：2018/6/11 5:13:49</span></span><br><span class="line"><span class="keyword">var</span> dtUTC2 = TimeZoneInfo.ConvertTimeToUtc(DateTime.Now);</span><br><span class="line"><span class="comment">//将本地时间转换为指定时区的UTC时间：2018/6/11 5:13:49</span></span><br><span class="line"><span class="keyword">var</span> dt = DateTime.SpecifyKind(DateTime.Now, DateTimeKind.Local);</span><br><span class="line"><span class="keyword">var</span> dtUTC1 = TimeZoneInfo.ConvertTimeToUtc(dt, TimeZoneInfo.Local);</span><br><span class="line"><span class="comment">//将指定时间从指定时区转换至目标时区的时间：2018/6/11 1:13:49</span></span><br><span class="line"><span class="keyword">var</span> dtUTC3 = TimeZoneInfo.ConvertTime(dt, TimeZoneInfo.Local, TimeZoneInfo.GetSystemTimeZones()[<span class="number">30</span>]);</span><br><span class="line"><span class="comment">//当前UTC时间：2018/6/11 5:13:49</span></span><br><span class="line"><span class="keyword">var</span> dtUTC = DateTime.UtcNow;</span><br><span class="line"><span class="comment">//当前Unix时间：1528694152</span></span><br><span class="line"><span class="keyword">var</span> startTime = TimeZone.CurrentTimeZone.ToLocalTime(<span class="keyword">new</span> System.DateTime(<span class="number">1970</span>, <span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line"><span class="keyword">var</span> dtUnix = (<span class="keyword">int</span>)(DateTime.Now - startTime).TotalSeconds;</span><br></pre></td></tr></table></figure></p><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p>&emsp;&emsp;Python中针对时区的处理，发扬了Python一贯主张简单的传统，有多传统呢，大概只需要两行代码，是的，你没有听错，只需要两行代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tz = pytz.timezone(<span class="string">'Asia/Shanghai'</span>)</span><br><span class="line">dt = datetime.datetime.now(tz)</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;简单来说，在Python中我们只需要给定时区，即可将本地时间转化为指定时区对应的UTC时间，这里我们使用的是Python中的pytz这个库，如果你打开这个库的安装目录，就会发现其实它有大量时区相关的数据组成，如果我们直接调用pytz.timezone()就可以获得所有的时区信息。博主有一个Python<a href="https://github.com/qinyuanpei/BlogScripts/blob/master/HexoBlog.py" target="_blank" rel="noopener">脚本</a>运行在TravisCI的服务器上，而TravisCI来自一家法国的技术公司，因此在不指定时区的情况下，会默认使用TravisCI服务器上的时间，这并不是我想要的结果，所以，我们需要pytz来解决这个问题，至于这里为什么我们使用的是上海而不是北京，这是因为中国横跨5个时区，在国内大家习惯使用北京时间，而在国外这些时区数据没有做及时更新，所以这算是一个关于时区的历史遗留问题吧！</p><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>&emsp;&emsp;本文从实际生活中一个案例入手，首先，向大家解释了为什么我们需要时区，以及为什么地球上不同地域拥有不同的时间。接下来，我们以MySQL、Oracle和SQL Server三种数据库为例，了解了在数据库中是如何存储时间的，可以注意到大多数数据库都使用了时间戳来存储时间。由此，我们引出了UTC时间、GMT时间、本地时间以及Unix时间，并讲述了它们之间的区别。其中，UTC和GMT可以看作是等价的时间表示方法，两者仅仅是计量工具不同，在历史上提出的先后顺序不同，并且GMT时间是以UTC时间为基准的。而Unix时间是计算中表示时间的方法，其含义是自1970-01-01 00:00:00至今经过的总秒数，在此基础上我们引出了为什么32位计算机下能表示的最大年份是2037。在文章的最后，博主选择了最熟悉的C#和Python，向大家展示了和时区相关的操作。<br>&emsp;&emsp;我承认，这篇文章相当地细碎，可能因此牵扯了太多的概念，我一直在犹豫要不要发到博客上来。其实，有太多的时候，越来越发觉自己写不出来一篇好的文章，大概我需要去读更多的书，或者去解决更多的问题，可坚持写博客的一个重要原因，无非是我觉得我需要花点时间区整理这些东西，因为别人没有去关注的一个问题，而我去尝试关注或者解决了，这就是我的收获啊，总而言之，在这篇相当细碎的文章背后，我收获的可能并不比这篇文章里写出来的少，原谅我这些唠叨的碎碎念吧，这篇文章就是这样啦，谢谢大家！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="编程语言" scheme="http://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="时间" scheme="http://qinyuanpei.github.io/tags/%E6%97%B6%E9%97%B4/"/>
    
      <category term="时区" scheme="http://qinyuanpei.github.io/tags/%E6%97%B6%E5%8C%BA/"/>
    
      <category term="格式化" scheme="http://qinyuanpei.github.io/tags/%E6%A0%BC%E5%BC%8F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>关于电影《暗杀》背后的故事和想法</title>
    <link href="http://qinyuanpei.github.io/posts/2462008667/"/>
    <id>http://qinyuanpei.github.io/posts/2462008667/</id>
    <published>2018-06-01T09:33:25.000Z</published>
    <updated>2018-08-24T05:39:27.478Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script>    <div id="aplayer-AIiUsouk" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="569213279" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="false" data-listmaxheight="340px" data-preload="none" data-theme="#ad7a86"></div><p>&emsp;&emsp;最近看过了由全智贤主演的电影《暗杀》，虽然说这是一部我们早已熟稔的抗战题材电影，可是在全女神颜值和演技的诱惑下，我终于还是花了点时间来看这部电影。或许是因为我们见识过了太多的<strong>“抗日神剧”</strong>，所以在面对这样一部电影的时候，我们难免带着某种不屑的眼光去审视它。可是当你看完了这部电影，突然间兴奋到难以自制，不由地惊呼一声：想不到韩国拍这种主旋律电影都能这么好看。我想，这是一种由视角转换所引起的代入感，我曾经看过日本拍摄的甲午海战，日本在明治维新以后，积极地向西方学习先进技术，从天皇到官员，都能从俸禄中省出钱来发展海军事业，相比之下，以天朝上国自诩的大清帝国则是李鸿章一人在支撑着岌岌可危的朝廷。同样地，通过《浪客剑心》同名电影，你会意识到，在明治维新这场变革背后，可能会有无数个像志志雄这样的政治牺牲品。这些都是因为视角发生变化而引起的变化，同样地，在这部电影中，它讲述了韩、朝两国人记忆中的抗日战争，这场我们曾经经历过的抗日战争，在韩国人眼中到底是什么样子的，这或许对我们看待历史会有所启示。</p><h1 id="一明一灭，两条暗杀线"><a href="#一明一灭，两条暗杀线" class="headerlink" title="一明一灭，两条暗杀线"></a>一明一灭，两条暗杀线</h1><p>&emsp;&emsp;电影讲述了19世纪30年代，以安沃允(<strong>全智贤</strong>饰)为首的暗杀三人组，奉命刺杀日军驻朝鲜司令官及本国卖国贼的故事。故事发生在京城(即韩国首尔)和上海，时任韩国临时政府局务局局长的廉锡镇(<strong>李政宰</strong>饰)，在早年刺杀日军大将失败以后，暗地里早已投靠日本人，此时更将暗杀三人组的消息泄露给日方。一时间，暗杀三人组的刺杀行动和处决叛徒廉锡镇刺杀行动，构成了一明一暗两条线索，呼应了本片片名<strong>“暗杀”</strong>，而廉锡镇更是找来赏金猎人<strong>“夏威夷手枪”</strong>(<strong>河内宇</strong>饰)，意图阻挠暗杀三人组的刺杀行动，可以说，整个故事脉络就像这个刺杀行动一样简单直接，因此其故事悬念就落在了<strong>刺客的刺杀计划如何落实</strong>以及<strong>反派的阻挠方案将如何开展</strong>。所以，这个电影吸引人的地方就在于，即使你知道反派最终一定没有好下场，可不到全女神放下枪的那一刻，你总是不肯放下心来。因为即使是看双方斗智斗勇，在颜值与演技都在线的情况下，这一切依然显得赏心悦目。全女神在片中几乎承担了所有的动作戏份，可即便如此，李政宰在片中饰演的反派廉锡镇，风头一度不亚于全女神，这些我们后面再详细说。</p><p>&emsp;&emsp;电影中前期出现的场景都是在上海，可能有朋友会疑惑：为什么一部韩国拍的电影里会出现上海。这就要首先说说这段历史，当时韩国的临时政府是设在上海的，目的是方便金九、金元凤这样的革命志士开展救亡图存活动，因为当时的韩国(在南、北朝鲜没有分裂以前，指整个朝鲜半岛）早已笼罩在日军的军事统治阴影下。历史上，这段时期长达35年之久。日本是什么时候占领朝鲜的呢？没错，就是我们熟悉的中日甲午战争。当时北洋水师正是在运送陆军抵达朝鲜后的返航途中，与日本海军发生近代历史上第一次大规模铁甲舰海战。这场战争的结果我们都知道，北洋水师几乎全军覆没，清政府更是同日本签订了丧权辱国的马关条约。日本占领朝鲜半岛后，曾对当地人进行了惨无人道的屠杀，正是从那个时候起，朝鲜开始笼罩在日军的统治阴影之下，而流亡国外的临时政府，不得不寄居在上海的法租界，继续开展抗日活动。影片中的金九和金元凤，在历史上都可以找到记录。上海虹口爆炸事件，其实就是这部电影的历史原型，影片中二金的合作促成了三人暗杀组的成立，故事由此开始。</p><h1 id="这个反派有点帅哦"><a href="#这个反派有点帅哦" class="headerlink" title="这个反派有点帅哦"></a>这个反派有点帅哦</h1><p>&emsp;&emsp;李政宰饰演的廉锡镇，在电影一开始是以革命志士的形象出现的，他刺杀日军大将的任务失败，直接导致他在被捕后遭受严酷的刑罚。与此同时，间接导致了女主安沃允的母亲被亲日派父亲康寅国派人杀死，安沃允与双胞胎姐姐美津子分离，直至多年后，来自东北抗日武装的安沃允，和自幼在日占区长大的美津子，终于在一个屋檐下相认，可转眼间，姐姐就被卖国贼康寅国给杀死了，电影中全女神亲眼目睹姐姐死亡的那一幕真的是令人心碎。可偏偏是这样一个人，亲手挑选了这三名暗杀组的成员，亲手将刺杀行动的情报泄露给日方人员，尤其是他从衣兜里取出假信件投入火堆，伪造出信件被毁的假象这一幕。面对金九的怀疑，在明知手枪里没有子弹的情况下“以死明志”。对昔日的同志毫不手软，两个被金九派去刺杀他的同志，均被他重伤甚至杀死。面对曾经刺杀过的日军大将，他可以厚颜无耻地邀功请赏，并接受日军授予的爵位。可恰恰是这样一个人，在喝醉酒以后，诉说朝鲜各种武装力量各自为政的现实，忏悔把暗杀三人组送去送死。在严刑拷打面前，他做了叛徒，一如暗杀组成员干革命要给钱，这些或许没有那么伟光正，可它是那么的真实。</p><h1 id="演技与颜值同时在线的全女神"><a href="#演技与颜值同时在线的全女神" class="headerlink" title="演技与颜值同时在线的全女神"></a>演技与颜值同时在线的全女神</h1><p>&emsp;&emsp;全女神饰演的安沃允，是一个来自东北抗日武装的狙击手，一出场就瞬间狙杀四名敌人，身手当真是是不凡啊，更不必说端着汤姆生冲锋枪窜房顶跨屋脊，在负伤的情况下趴在疾驶的卡车引擎盖上。据说全女神电影中的动作戏都没有使用替身，一个明明可以靠颜值的人，尚且可以如此努力地去拼搏，那么身为普通人的你我，又有什么理由不努力呢？野蛮女友时期的全女神，或许看起来只是漂亮而已，而现在看来则是实力派。可她同样是一个憧憬着喝咖啡谈恋爱的少女，是一个看到姐姐洁白的嫁会衣泣不成声的妹妹，是一个面对亲生父亲无论如何都下不去手的狙击手。在假扮姐姐美津子参加婚礼以前，她做好了最坏的打算，就像她脑海中浮现过的画面一样，在敌人乱枪扫射下，献血染红了她洁白的婚纱……这或许是“夏威夷手枪”脑补的画面？这里有一个细节，“夏威夷手枪”将全女神送到医院以后，“夏威夷手枪”讨论起他对于暗杀行动的看法，全女神说了这样一段话，大意是“杀掉日军司令和汉奸康寅国，到底能不能让国家独立，这一点没有人会知道，但她必须要让人们知道，她们一直在战斗”……</p><p>&emsp;&emsp;这一刻，这个娇弱而坚强的女性形象就立起来了。全女神在本片中分饰两角，即姐姐美津子和妹妹安沃允，不过这种差异基本都是通过眼神表现出来的，姐姐身上有那种从小生活安逸的娇气，而妹妹身上有那种内敛冷静的帅气。战争从来都是残酷的，康寅国为了依附日本人，将美津子误认为安若允并杀死。在我看来，即便没有认错，以康寅国的为人，知道女儿和独立军有关联，他还是会这样做，因为女儿的幸福他完全不在乎，和日本人联姻无非是为了拉拢日本人。正如全女神所言，他用那双杀死了母亲的手，杀死了自己的女儿。人类的情感有时候就是这样诡异，一个对自己从来没有养育之恩的父亲，对方叛国投敌助纣为虐，即使两者间唯一的联系，是那可有可无的血缘关系，可最终还是需要“夏威夷手枪”，这个曾经是“杀父联盟”一员的人，替她开出这一枪。</p><h1 id="一个超有力量感的故事结尾"><a href="#一个超有力量感的故事结尾" class="headerlink" title="一个超有力量感的故事结尾"></a>一个超有力量感的故事结尾</h1><p>&emsp;&emsp;故事从挟持人质这里开始，就突然变得敷衍起来，可能这里就需要感情戏来作为某种过渡，假如两个人真的去了米拉波，这就真的变成了爱情电影，可这部电影不就是，一部打着主旋律幌子的动作电影吗？这种类型电影为了增加娱乐性，是需要幽默和爱情的。真正将影片推向高潮的是结尾出的审判，证人在开庭前就被廉锡镇派人杀死，于是没有可以再证明，廉锡镇曾经投敌叛国、出卖同志的罪行。这个世界上永远有大量的无知的人，他们选择用暴力来面对一名“韩奸”，可当廉锡镇脱下衣服，义正言辞地讲述自己“支持”独立运动的事迹时，这些人突然开始宣布这名“韩奸”无罪，这是否说明大众都是愚蠢的，可正是这些人的想法，在左右着我们每一个人，这和那些努力制造“焦虑”的人没有区别，我们不愿意相信真相，宁愿相信自己早已固化地思维，或者是人云亦云，没有自己独立的判断，这实在是件可怕的事情。法官失落地宣布证据不足、廉锡镇无罪释放的时候，大概内心会有某种无可奈何或者是不甘心。</p><p>&emsp;&emsp;这让我想起Unnatural里高濑这个案件，因为没有办法证明对方杀人，而关键的信息又被久部泄露出去，所以，这个案件一度到了要修改鉴定报告的程度，这和身为法医的三橙心中的使命感不相符合，关键时候，是神仓所长坚持递交了原始的鉴定报告。当我们想要制裁一个人的时候，能不能依然客观地去证明对方有罪，不冤枉任何一个人固然值得赞赏，可为了让对方伏法而采用非正义的手段是否是正确的呢？如果身为法医的三橙，用修改鉴定报告的方式，给高濑这个罪犯定刑的话，我相信，我们所有人都会失望，因为她不愿意输给非正常死亡，不愿意正常的人被乱入非正常的事件，采用非正常的方法去伤害别人或者是自己。相比中堂使用逼供的方式查找真相，她更希望中堂医生以一名法医学者的身份去战斗。自然，故事的结尾，所谓善恶有报，16年前的暗杀任务，终于在韩国光复以后，有安沃允和明宇重新执行，结尾处被乱枪打死的廉锡镇，在被问到为什么要出卖同志时，说了一句“我没想到会解放啊”，一句听起来像开玩笑的话，其实说出了战争年代人们的无奈，如果没有战争，或许这些事情就真的不会发生，可当战争机器被发动时，又有谁会想到这些呢？被卷入战争里人们没有选择，而发动战争的人从来不考虑以后。</p><h1 id="写在战争结束以后"><a href="#写在战争结束以后" class="headerlink" title="写在战争结束以后"></a>写在战争结束以后</h1><p>&emsp;&emsp;旷日持久的战争终于结束了，当画面定格到全女神那张近乎素颜的脸上时，她突然想起那些曾经最为亲切的面孔，想起“炸弹专家”黄德三，想起“速射炮”邱尚沃，想起酒馆老板娘……战争带给我们的是永远的伤痛，今天我们对于日本这个国家，可能有时候还会充满抵触情绪，但我想说的是，这场战争并没有结束，金九认为日本人已经投降，不再需要可依靠捐助维持，以光明正大地回到国内搞建设，可事实上像廉锡镇这样投日派，并没有完全得到清算，所以，金九在回国后不久就被韩国激进分子刺杀，廉锡镇所说的独立运动派系之争，在历史上是真实存在着的，金九就是被卷入到这场政治斗争中的牺牲品，所以，金元凤最终选择了朝鲜，而这种派系之争，更是加剧了整个朝鲜半岛的分裂，在这片土地上，曾经一起战斗过的兄弟、朋友，最终变成兵戎相向的敌人。</p><p>&emsp;&emsp;可这真的是和平吗？战争真的结束了吗？被38线分割开的这两个国家，一个通过韩剧、料理和科技为世界所知，一个更像是改革开放初期的中国，不知道还说神秘还是落后。何况，这条38线是停战线，并非某种和平的象征，而直至今天，这种刺杀的阴影一直笼罩在韩国政坛上，韩国现任总统朴槿惠的父亲和母亲先后都死于刺杀，所以，即使战争结束了，就能换回和平吗？就能抚平人们心中的伤痛吗？朝鲜与韩国，也许在我们有生之年里，都难以看到他们真正地握手言和，就像苏联解体以后不会再联合在一起，欧盟并非想象中的牢不可破，爱尔兰和北爱尔兰原本就是一家，印度和巴基斯坦是殖民战争的遗留问题……战争，带来的坏处，永远比好处要多。我们向往铸剑为犁的和平生活，可战争结束以后，是否真的能带来和平，人心中的伤痛需要多久可以愈合，人与人的相争逐利之心需要多久可以平息。</p><p>&emsp;&emsp;2018年的儿童节，同往年不同，因为许嵩为炮火中的叙利亚孩子们，创作了一首新歌《大千世界》，这首歌以2017年4月15日叙利亚炸弹袭击事件为背景，呼唤爱与和平，控诉那些肆意发动战争，而将无辜孩童卷入战火的人们。大千世界里的大人们，不要忘了你们曾经都是孩子，当人们都在通过晒娃这种方式度过儿童节时，你是否会想到在世界的某个地方，有人在穿着捐助的衣服和玩具的同时，更是被迫享受着温柔的暴力，我们从小给小孩子的玩具枪，是否有一天会真的变成荷枪实弹呢？我们在盛世之年，我们在贫富之间，我们在虚实交错路口，不断找寻，任何形式的相遇。愿大千世界，再无战争，再无暴力，愿每个深爱的人，都能被温柔对待。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="生活感悟" scheme="http://qinyuanpei.github.io/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="影评" scheme="http://qinyuanpei.github.io/tags/%E5%BD%B1%E8%AF%84/"/>
    
      <category term="和平" scheme="http://qinyuanpei.github.io/tags/%E5%92%8C%E5%B9%B3/"/>
    
      <category term="全智贤" scheme="http://qinyuanpei.github.io/tags/%E5%85%A8%E6%99%BA%E8%B4%A4/"/>
    
  </entry>
  
  <entry>
    <title>爱情像一场霍乱</title>
    <link href="http://qinyuanpei.github.io/posts/3782208845/"/>
    <id>http://qinyuanpei.github.io/posts/3782208845/</id>
    <published>2018-05-22T09:05:34.000Z</published>
    <updated>2018-08-24T05:39:27.482Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script>    <div id="aplayer-RUhEJdgK" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="536622304" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="false" data-listmaxheight="340px" data-preload="none" data-theme="#ad7a86"></div><p>&emsp;&emsp;距离读完马尔克斯的《霍乱时期的爱情》这本书，差不多已经有一个月左右的时间啦。相比小说中错综复杂的人物关系，更加让人印象深刻的或许是“百年孤独”式的开头。不论是多年后面对行刑队的布恩迪亚上校，还是拍打鹦鹉结果从梯子上摔下来的乌尔比诺医生。在这一刻，因为人物的过去与现在层叠出的这种时空感，或许就是马尔克斯想要去描绘的魔幻现实主义。最近看了由小说改编的同名电影，感觉对这部小说的印象更为具体化，小说的时间跨度将近半个世纪，是选择乌尔比诺和费尔米纳这样稳定的婚姻关系，还是选择阿里萨和费尔米纳这样偏执的爱情故事。我想，这是一个值得去思考的问题吧。</p><p>&emsp;&emsp;当乌尔比诺从梯子上摔下来即将离开人世的时候，他拼尽最后一口气对费尔米纳说：“只有上帝才知道我有多爱你”。单单从这句话来看，他们两个人或许是相爱的。可明明不久前，两个人还在为了一块肥皂的事情而争吵。现在大家对出轨这个问题看得特别重，重要到不要说是肉体出轨，连精神出轨都是不能被原谅的。从去年至今，网络上各种出轨的舆论消息层出不穷，好像爱情越来越不值得期待。可你看乌尔比诺和费尔米纳的婚姻是什么样的呢？乌尔比诺在妻子外出期间出轨了一名黑人女子，虽然他选择主动向妻子承认出轨，及时回归家庭，可在我们这些外人看来，这样的婚姻是含有杂质的婚姻。从妻子费尔米纳的角度，她结婚以前是不吃茄子的，而结婚以后则适应了茄子，你可以说两个人在一起，一定会有一方选择妥协。可在一个动辄讲三观、讲兴趣、讲地位的年代，你是否会觉得两个人合适呢？</p><p>&emsp;&emsp;合适，是一个特别巧妙的词汇，巧妙之处在于它真正可以做到“以不变应万变”。乌尔比诺夫妇的婚姻，或许是大多数人的真实写照。两个人第一次见面，源于费尔米纳的一场疾病。当时外面正流行着霍乱疫病，费尔米纳因为怀疑被感染了霍乱不得不寻找医生治疗，恰好乌尔比诺正从巴黎旅行回来。在医学技术不发达的年代，医生是没有听诊器的，所以乌尔比诺必须贴着费尔米纳裸露的胸部听心跳。书作和电影中都详细地描绘了这个过程，两个青年男女在这种情况下发生了身体上的接触，费尔米纳更是被对方身上的男性气概所吸引。可这算是爱情吗？我更愿意相信，这是一种原始的欲望冲动，可你说这两个人间没有爱情，估计所有人都会反对，谁让我们都喜欢用海枯石烂表示爱情的忠贞，这两个人在一起生活50年，甚至作者都表示：一对恩爱的夫妻最重要的不是幸福，而是稳定的关系。</p><p>&emsp;&emsp;所以，不管你愿不愿意承认，爱情最终都会部分地转化为亲情，爱情本身是有瑕疵的、有缺陷的，争吵不可避免，犯错不可避免。诚然，我们都希望对方忠诚的对待自己，可人归根到底是一种对自我忠诚的动物，你说你不能接受对方变心，可人、时间和空间无时无刻不在发生着变化，喜欢或者不喜欢，不过是某一瞬间的状态，你必须相信，爱情本来就不完美、充满瑕疵，可这就是真实的爱情的样子啊，人们会记得你婚礼上的海誓山盟，唯独不会记得你每天柴米油盐的平平淡淡；人们会给他们愿意看到的表面现象去点赞，唯独不会关注你是不是真正的快乐。爱情里有人不厌其烦地寻找真爱，有人沉溺在回忆里不敢再触碰爱情，对我来说，这两种选择我都表示尊重，因为爱情本来就有它真实的样子。</p><p>&emsp;&emsp;我不知道，还会不会有人为了别人而苦等51年9个月零4天，一个人究竟有多大的勇气和执念，才能从一个朝气蓬勃的青年变成一个白发苍苍的老人。金庸先生的名篇《射雕英雄传》里，神算子瑛姑因为失去爱子而一夜白头，我想，这其中有对段皇爷见死不救的怨恨，有对周伯通求而不得的执念。可对阿里萨而言，从他遇见费尔米纳那天开始，他的生命就仿佛注定是属于她的，他坚持给她写信，在楼下为她拉小提琴，在长椅上刻下她的名字，甚至是喝花露水、吃玫瑰花。如果说爱情像一场霍乱，应该会没有怀疑，因为阿里萨的确像是生了一场霍乱，不然怎么会疯狂地爱直至偏执甚至有些荒唐。我完全可以理解阿里萨的举动，因为年轻时的我们都曾做出过类似的举动。我并不反对这样的爱情，可当你回头来看这两个人的爱情的时候，费尔米纳对阿里萨这个人几乎一无所知，除了知道对方的职业是报务员。</p><p>&emsp;&emsp;电影中费尔米纳甚至给阿里萨回了信，可就如同费尔米纳所言，“他们两个人之间只有虚幻，爱情蒙蔽了彼此的双眼”，大概所有一见钟情的人都没能考虑一个问题，那就是你真的了解对方这个人吗？非常不幸的是，即使亲近如父母、妻子和丈夫这样的关系，一个人也永远不可能了解另外一个人。一个人究竟要爱得多卑微，才会心心念念地等着对方的丈夫死掉，甚至怕对方比丈夫先死掉。假如阿里萨只是这样痴痴等待50年的话，我们最多只是替他感到惋惜而已，可偏偏阿里萨为了“报复”费尔米纳，缓解被她伤害的心，开始一次又一次地疯狂纵欲，在肉体的狂欢中不断强化精神层面上对费尔米纳的爱，据他自己记载，他和寡妇、少妇甚至少女都发生过关系，可当他终于等来费尔米纳的时候，他声称自己是一个处男。</p><p>&emsp;&emsp;人常常复杂到让你我怀疑人生，而阿里萨则是一个复杂到，让你觉得他还有点可怜的人。他视其它女性的肉体如无物，唯独将费尔米纳推上女神的圣坛。更微妙的是，费尔米纳居然是喜欢过阿里萨这个人的。她不过是在乌尔比诺和阿里萨间选择了更好的一个而已，可阿里萨这种病态的爱在我看来是极为自私的，因为无论两个人多么地爱彼此，一旦出现这种肉体的出轨，就意味着永远无法挽回。虽然费尔米纳选择嫁给了乌尔比诺，可假如有一个人在别人的身体上出轨无数次，在你的丈夫逝世以后告诉你，他等这一天已经等了51年9个月零4天，我不知道你会作何感想。我没有任何的封建思想残留，我尊重女性在丈夫死后改嫁的自由，可选择这样一个充满“缺点”的人，我觉得还是需要去认真想一想的。</p><p>&emsp;&emsp;两个人如果真心相爱，即便是满头白发的蹒跚老者，我认为结婚都是没有问题的，可当两个70多岁的老人坦诚相见时，当阿里萨看到费尔米纳干瘪下垂的胸部时，当各自看到对方充满皱纹和赘肉的身体时，我真的想知道，这50多年的等待真的值吗？或许是值的的，就像这两个人喜欢的都是有点幻想成分的对方一样，我向往永远靠精神慰藉彼此的帕拉图之恋，也不排斥男欢女爱的肉体之欢，可无论哪一种都必须建立在真实的现实中，一个虚幻的爱慕者，一个你并不真正了解的人，当幻想被打破的一瞬间，或许就是爱情破碎的时候，所以，我希望我们对待感情更慎重些，即使没有人爱你，学会自爱未尝不可。我们的生命原本就短暂，何苦要将这生命浪费在别人身上，况且我们有时候我们就像费尔米纳一样，分不清到底是爱还是孤独，人在经历枯燥和乏味以后是会变的，会变得对事物充满新鲜感，即使是曾经不喜欢的东西。</p><p>&emsp;&emsp;从某种角度而言，阿里萨是成功的，因为他用一生的时间得到了喜欢的女人。可我时常觉得人生有比这更重要的事情，就像你小时候看到喜欢的东西，却发现自己买不起的时候，你会怎么样做呢？我想大多数人都会选择不要了或者是等以后有机会再买。可人就是这样奇怪的动物，明明以前非常非常喜欢，可突然有一天发现咋再喜欢不起来。为什么我们对这件事情可以坦然接受，唯独在面对感情的时候常常无法自拔呢？你当初有没有得到这样一件喜欢的东西，或许会影响你在未来的人生轨迹，可在大多数情况下，我们的生命实在泛不起多少涟漪。有人说，人生下来的时候，结局就早已注定，我们唯一能做的事情，就是努力去填补和丰富这五六十年的时间。这样说来，人生实在是没有什么事情非做不可的，如果有，那只有一件事情，那就是努力地活下去。</p><p>&emsp;&emsp;《Unnatural》里中堂系一直对恋人的死无法释怀，整整八年时间一直都在调查恋人的死亡原因，直到真相被查明，得到恋人父亲的原谅。我不是说，人生不可以有执念，我只是希望大家明白，执念只会让你太关注结果而忽略过程，而我们的生命是需要一天天去度过的。就像阿里萨终于得到了费尔米纳，可两个70多岁的老人，在这个世界上还有多少时间可以挥霍呢？我倒情愿日子过得稍微慢一些，用一辈子的时间去了解对方，我们一直所希望看到的，不就是被人理解和认同吗？如果永远一个可以同你交流灵魂的人，那么就努力学习一个人去生活，人生没有那么多必须做的事情，只有你愿不愿意去做的事情。起风了，就当努力生存。活着不好吗？我实在不愿意再看到罗密欧与朱丽叶这样的悲剧，虽然我们都曾歌颂过这样的故事，可只要活着就会有新的机会啊。</p><p>&emsp;&emsp;有时候想想我们父母这一代人，几乎在毫无准备的情况下，被动地步入了婚姻的殿堂。时隔多年以后，或消融在柴米油盐的平淡里，或交织在子女亲情的羁绊中，或穿行在流水光阴的得失间……直至爱情彻底消亡最终变成亲情，像一滴松胶油慢慢变成一颗精美的琥珀。有人说，婚姻是爱情的坟墓，甚至结过婚的人会觉得婚姻非常无趣。那么，罗曼蒂克是否一定会消亡？如果是，是不是婚姻里有没有爱情都可以，因为总有一天它会枯竭，人生里充满太多无可奈何的事情，单单是爱情这一件事情就可以写满整个历史，爱情里有像童话一般美好的故事，同样有像悲剧一般哀伤的故事。</p><p>&emsp;&emsp;或许是我们这一代独生子女们，在接触到更广阔的网络世界后，极大地影响了我们对这个世界的认知，以至于我们觉得自己就是活得太明白了。可如果要这样稀里糊涂地度过余生中的五六十年，每个人突然间又不甘心接受这残酷的命运。当我发现，我要远离父母生活，甚至完全能力能力和精力照顾他们的时候，我很容易地想到我的未来，是不是会和他们一样。有人说，婚姻是为了找到一个人陪你一起往前走，可我们这些独生子女们，早就习惯了一个人去生活，生命里总是充满着无尽的变故，或许她曾经特别特别喜欢你，可突然有一天她就不再喜欢你了；或许你们曾经是特别特别友好的朋友，可突然有一天对方就突然离你远去；或许你们朝夕相处亲密无间，可到最后突然发现根本不了解彼此……</p><p>&emsp;&emsp;人明明都是会变的，可偏偏总爱把希望寄托在变化的事物上面。在一个周围一切都在变化的世界里，追求一成不变毫无疑问是贪心的，我们能追求的只有稳定，可难免会问一个不理智的问题：稳定可以理解为爱吗？这正是乌尔比诺和费尔米纳两个人的感情生活留给我们的谜题。年少时或许会憧憬阿里萨这样因爱成痴的故事，可正如村上春树所说，“哪里会有人喜欢孤独，不过是不喜欢失望罢了”。如果爱情是一场霍乱，我希望每个生病的人，都能尽早地从这场疾病中治愈。“起风了，当努力生存”，就像石原里美饰演的三橙说过的，“有时间绝望还不如去吃点好吃的呢”，比起找到心爱的人，学会如何爱自己不是更重要吗？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="读书笔记" scheme="http://qinyuanpei.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="影评" scheme="http://qinyuanpei.github.io/tags/%E5%BD%B1%E8%AF%84/"/>
    
      <category term="阅读" scheme="http://qinyuanpei.github.io/tags/%E9%98%85%E8%AF%BB/"/>
    
      <category term="马尔克斯" scheme="http://qinyuanpei.github.io/tags/%E9%A9%AC%E5%B0%94%E5%85%8B%E6%96%AF/"/>
    
  </entry>
  
  <entry>
    <title>使用Jexus实现ASP.NET在Linux平台下的部署</title>
    <link href="http://qinyuanpei.github.io/posts/815861661/"/>
    <id>http://qinyuanpei.github.io/posts/815861661/</id>
    <published>2018-05-20T14:00:03.000Z</published>
    <updated>2018-08-24T05:39:27.478Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>&emsp;&emsp;Hello，大家好，我是Payne，欢迎大家关注我的博客，我的博客地址是<a href="https://qinyuanpei.github.io">https://qinyuanpei.github.io</a>。今天想写一点关于Linux部署ASP.NET相关的话题，为什么突然想写这个话题呢？因为就在几天前，我被我所认识的一位前辈深深地鄙视了一番，原因是我依然在使用一个落后的IoC框架——Unity，在如今已然是公元2018年的今天。我突然想到，距离.NET Core 2.0发布已经有一段时间，而.NET Core 3.0的roadmap已经开始提上日程，可我好像还没来得及认真地去对待这个现状。我一直在关注跨平台和跨语言的技术，就像我在大学里的时候就开始接触Linux一样，未来我们要面对的是种类繁多的终端平台，从PC时代到移动互联网，再到VR、AR、IoT和AI，有太多太多的事情在悄然发生着变化。偶尔我的内心会泛起焦虑和迷茫，可在时光蹉跎直至褪色以前，我或许只是变回了曾经的自己。既然要如同涅槃一般重新开始，为什么不首先重新拾起曾经关注的领域呢？所以，在这今天这篇文章里，你将看到：<strong>如何使用Jexus实现ASP.NET在Linux平台下的部署</strong>。</p><h1 id="故事背景"><a href="#故事背景" class="headerlink" title="故事背景"></a>故事背景</h1><p>&emsp;&emsp;我们项目组在开发这样一种服务，它可以通过收集招聘网站的简历来提取相关信息，而这些信息将作为训练集供AI算法使用。考虑到Python在AI领域的优势，我们决定采用Python来开发自然语言处理相关的业务，而简历的收集则是通过.NET中的Web Service暴露给前端。整个开发相对顺利，可是在部署环节出现了问题。因为项目组以往的的项目都是部署在Linux Server上，所以在部署Web Service的问题上产生了分歧，负责运维的同事不愿意为这一个项目而单独配置一台Windows Server。这里需要说明的是，采用.NET来开发Web Service的一个重要原因是，这些简历中存在大量Word文档(.doc/.docx)，因此不得不采用Office提供的COM组件来支持文档的解析，虽然后来证明的确是这些COM组件拖了跨平台的后腿。所以，在这个时候，我们面临着两种选择，第一种方案是采用Windows Server来部署，我们的运维同事表示不开心；第二种方案是采用Linux Server来部署。我们知道.NET跨平台的一个关键技术是Mono，可Mono的问题是它的基础类库不大健全，相信微软收购Mono以后这个问题能够得到解决。目前官方主推的跨平台技术是.NET Core，考虑到迁移到.NET Core版本的成本，我们最终没有选择这个方案。事实上，即使采用.NET Core进行开发，最终我们的部署依然需要依赖<a href="https://www.jexus.org/" target="_blank" rel="noopener">Jexus</a>。综合考虑这些因素，我们决定采用<a href="https://www.jexus.org/" target="_blank" rel="noopener">Jexus</a>来将ASP.NET项目部署到Linux平台。</p><h1 id="关于Jexus"><a href="#关于Jexus" class="headerlink" title="关于Jexus"></a>关于Jexus</h1><p>&emsp;&emsp;Jexus是由<a href="http://www.cnblogs.com/yunei" target="_blank" rel="noopener">宇内流云</a>开发的一款Linux平台上的高性能Web服务器，它是一个可以免费使用、不开源的项目，最大的特色是可以支持ASP.NET、ASP.NET Core、PHP。通俗地来讲，我们可以认为它是Linux平台上的IIS，这并不为过，因为你可以注意到<a href="https://www.jexusmanager.com/en/latest/" target="_blank" rel="noopener">Jexus Manager</a>这个项目，它可以同时支持Jexus，IIS 和 IIS Express三种服务器的管理，并提供了各个平台下一致的使用体验，而Linux平台则主要是针对Jexus。Jexus提供了不亚于商用服务器的众多特性，比如多站点支持、使用应用程序池来调度管理工作进程、具有良好的稳定性和容错能力、支持 HTTPS 和 WebSockets、支持 FastCGI 协议和 OWIN 标准。除此以外，它同时支持 URL 重写、反向代理、压缩传输、入侵检测等重要功能。Jexus底层采用Linux中的epoll机制来处理网站请求，所以会比通常使用libuv实现的技术拥有更高的性能。作为一款跨平台软件，Jexus支持主流的Linux发行版本。目前，国内外已经有大量的网站采用Jexus作为它的服务器，我们可以在Jexus的官网上找到这些<a href="https://www.jexus.org/Examples.htm" target="_blank" rel="noopener">案例</a>。虽然微软官方正在全力推广.NET Core，但对于那些需要维护的旧项目而言，迁移到全新的.NET Core平台着实是个不小的挑战，而且目前支持.NET Core版本的类库并不丰富，虽然最终的趋势一定是.NET Core替代Mono，但对于Mono而言，在.NET宣布开源以后，从.NET Framework中吸收的基础类库，极大的改善了Mono基础类库不完善的状况，而Mono针对CLR的实现、C#编译器的实现、AOT环境等等特性，或许可以为.NET跨平台提供借鉴，这是一个相互促进的过程。在新时代到来以前，我们暂时需要使用Jexus来过渡。</p><h1 id="Hello-Linux"><a href="#Hello-Linux" class="headerlink" title="Hello Linux"></a>Hello Linux</h1><p>&emsp;&emsp;OK，下面我们来体验一下Jexus在Linux平台上的效果，这里我们以ASP.NET MVC4为例，我们直接通过Visual Studio创建一个项目即可，这里我们需要的是这个项目发布以后的所有文件。总之，这些文件需要通过某种方式放到Linux平台上，大家自己去想办法就好啦，这个不再说多余的话。</p><h2 id="安装Jexus"><a href="#安装Jexus" class="headerlink" title="安装Jexus"></a>安装Jexus</h2><p>&emsp;&emsp;Jexus安装起来是非常简单的，这里博主使用的是Elementary OS，基于Ubuntu14.0的衍生版本。在终端下执行如下命令：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http<span class="variable">s:</span>//jexus.org/release/x64/install.<span class="keyword">sh</span>|sudo <span class="keyword">sh</span></span><br></pre></td></tr></table></figure></p><p>你没有看错，真的只需要一行命令。事实上，Jexus分为两个版本，即通用版和独立版。其差别是通用版不含Mono运行时，独立版含有Mono运行时。官方建议使用独立版，如果有朋友想尝试安装通用版，请在终端下执行如下命令：<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https:<span class="regexp">//</span>jexus.org<span class="regexp">/release/i</span>nstall|sudo sh</span><br></pre></td></tr></table></figure></p><p>无论采用哪一种方式安装，当你看到终端中显示：Jexus已经被成功安装到系统，就表示Jexus安装成功了。</p><h2 id="配置Jexus"><a href="#配置Jexus" class="headerlink" title="配置Jexus"></a>配置Jexus</h2><p>&emsp;&emsp;Jexus部署到网站，需要两个东西，一个是网站内容(废话)，一个是网站配置。假定我们这里将这两个东西打包在一起，压缩包的名字为app.tar。为什么这里选择了.tar格式的压缩文件呢？因为在Linux平台下这个格式更好用些，我们熟悉的.zip格式，可能会需要我们安装相应的扩展。此时，我们可以使用如下脚本来部署网站：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -xf app.tar</span><br><span class="line">sudo mv  -f <span class="selector-class">.aspnetconf</span> usr/jexus/siteconf/aspnetconf</span><br><span class="line">sudo mv ./aspnet /var/www</span><br></pre></td></tr></table></figure></p><p>OK，现在来解释下这个脚本，这里我们需要部署一个名为“aspnet”的网站，所以，网站的内容被放置在“aspnet”这个目录里。该网站对应一个作用于Jexus的配置文件，配置文件的名字为aspnetconf。首先，我们将“aspnetconf”这个配置文件移动到了“usr/jexus/siteconf/”目录下，这是Jexus指定的配置路径，即<strong>每一个站点都有一个配置文件，且该配置文件被放置在“usr/jexus/siteconf/”目录下</strong>。然后，我们将“aspnet”这个文件夹移动到了“/var/www”目录下，这是Jexus指定的网站目录，即<strong>每一个站点都有一个文件夹，文件夹的名字可以理解为网站的名字</strong>。默认情况下，Jexus会在www目录里创建一个名为default的文件夹，即默认有一个名为default的站点，不过经过博主核实，最新版(v5.8.3)中是没有default站点。同理，Jexus会siteconf目录里创建一个名为default的配置文件。我们通常以这个配置文件为参照来编写我们自己的配置文件，例如下面是aspnetconf中的内容：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">port</span>=<span class="number">4000</span>                  </span><br><span class="line"><span class="attr">root</span>=/ /var/www/aspnet          </span><br><span class="line"><span class="attr">hosts</span>=  </span><br><span class="line"><span class="attr">indexs</span>= </span><br><span class="line"><span class="attr">aspnet_exts</span>=</span><br></pre></td></tr></table></figure></p><p>其中，</p><ul><li>port表示Jexus Web服务器监听的端口(必填）</li><li>root表示网站虚拟目录与其对应的物理目录，中间使用空格分开(必填）</li><li>hosts表示网站域名(建议填写)，可以使用泛域名如<em>.yourdomain.com或者填写</em>表示默认网站，一个端口有且只有一个默认网站，选填</li><li>indexs表示网站首页文件名，如index.html、index.aspx等，多个文件名使用英文逗号分开，选填</li><li>aspnet_exts表示ASP.NET扩展名，不建议填写。如要填写，多个扩展名(不含.)使用英文逗号分开。</li></ul><p>最简单的配置只需要port和root即可，更多的配置项可以参考官方文档。</p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>&emsp;&emsp;Jexus的常用命令简单到只有3个，start、restart、stop。命令的基本格式为：<br><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo /usr/jexus/jws start <span class="string">[站点名(可选，不指定时表示所有)]</span></span><br><span class="line">sudo /usr/jexus/jws restart <span class="string">[站点名(可选，不指定时表示所有)]</span></span><br><span class="line">sudo /usr/jexus/jws stop <span class="string">[站点名(可选，不指定时表示所有)]</span></span><br></pre></td></tr></table></figure></p><p>在这个例子里，我们执行如下命令来启动aspnet这个站点：<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="regexp">/usr/</span>jexus<span class="regexp">/jws start aspnet</span></span><br></pre></td></tr></table></figure></p><p>当终端中返回OK时，就表示启动成功啦，此时，我们打开浏览器，输入<a href="http://localhost:4000就可以看到如下画面(这里的端口号为4000)：" target="_blank" rel="noopener">http://localhost:4000就可以看到如下画面(这里的端口号为4000)：</a><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/Blog_Jexus_01.jpg" alt="运行在Linux上的ASP.NET" title="">                </div>                <div class="image-caption">运行在Linux上的ASP.NET</div>            </figure><br>你就说，这算不算惊喜。我们还可以输入<a href="http://localhost:4000/info来验证Jexus是否配置正确，当Jexus被正确配置以后，你就会看到一个显示着“Welcome" target="_blank" rel="noopener">http://localhost:4000/info来验证Jexus是否配置正确，当Jexus被正确配置以后，你就会看到一个显示着“Welcome</a> to Jexus”的页面。嗯嗯，好像是和Nginx挺像的哈！</p><h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker+"></a>Docker+</h1><p>&emsp;&emsp;接下来，让我们考虑将这些Linux上的工作转移到Docker中来做，因为借助Docker的容器技术，它可以为我们提供一个足以自给自足的环境。通过这个环境编译测试通过的镜像可以批量地部署到生产环境中。如果你不想在每一台Linux Server上都覆盖本文的流程，那么Docker将是提高你部署效率的不二选择，而且从认知完整性的角度来看待Docker，你就会发现它和Jekins、TravisCI、VSTS工具一样，都可以非常完美地被接入到持续集成(CI)的流程里去，譬如我们项目组采用的是Jekins + Gitlib + Docker的方案，所以，如果你想要选择一个最适合你的持续集成(CI)方案，无论如何，Docker都是需要去了解的一个知识。关于Docker的背景知识大家可以自己去了解，这里我们通过编写Dockerfile来完成网站镜像的构建：<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">14.04</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> vendor=<span class="string">"qinyuanpei@163.com"</span></span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># Prepare Environment</span></span></span><br><span class="line"><span class="bash">RUN sudo apt-get update </span></span><br><span class="line"><span class="bash">RUN sudo apt-get install -y</span></span><br><span class="line"><span class="bash">RUN sudo apt-get install -y curl</span></span><br><span class="line"><span class="bash">RUN sudo apt-get install -y wget</span></span><br><span class="line"><span class="bash">RUN sudo curl -sSL https://jexus.org/release/x64/install.sh|sudo sh</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># Deploy Website</span></span></span><br><span class="line"><span class="bash">ADD dest/ /</span></span><br><span class="line"><span class="bash">RUN sudo mv -f aspnetconf /usr/jexus/siteconf/aspnetconf</span></span><br><span class="line"><span class="bash">RUN sudo mkdir -p /var/www</span></span><br><span class="line"><span class="bash">RUN sudo mv ./aspnet /var/www</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># Start Jexus</span></span></span><br><span class="line"><span class="bash">EXPOSE 4000</span></span><br><span class="line"><span class="bash">WORKDIR /usr/jexus</span></span><br><span class="line"><span class="bash">CMD sudo ./jws start aspnet</span></span><br></pre></td></tr></table></figure></p><p>如果你熟悉Linux下的命令的话，你就会知道apt-get、curl、wget这些命令的含义，真正需要的解释的是ADD，它表示的是，将Dockerfile同级目录下的dest目录添加到Docker环境中，接下来的命令我们同样非常熟悉，因为这和Linux下操作是完全一样的。不过，这里的确有些坑需要踩，在博主构建镜像的过程中，发现容器环境和虚拟机环境还是有本质不同的，这里的mv命令在Docker下有时候会引发“hard link”的问题，从Stackoverflow上好像并没有找到太有价值的答案，总之，这个问题非常的玄学。接下来，我们会将Docker容器的4000端口暴露出来，为什么是4000端口呢？因为这个网站的配置中指向了4000端口，这一点在上文中我们已经提及。而入口处的命令，显然是启动Jexus服务，这个不再解释。</p><p>这里，我们通过如下命令来构建一个镜像版本：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">docker</span> <span class="keyword">build </span>-t jexus-aspnet:<span class="built_in">v1</span>.<span class="number">0</span> .</span><br></pre></td></tr></table></figure></p><p>假如这个镜像被成功构建出来，我们就可以使用这个镜像来启动网站啦。如下图所示：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/Blog_Jexus_02.jpg" alt="使用Docker创建网站镜像" title="">                </div>                <div class="image-caption">使用Docker创建网站镜像</div>            </figure><br>具体地，我们可以使用docke image命令来管理所有的docker镜像。这里我们启动网站：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">docker</span> <span class="selector-tag">run</span> <span class="selector-tag">-p</span> 4050<span class="selector-pseudo">:4000</span> <span class="selector-tag">-t</span> <span class="selector-tag">jexus-aspnet</span><span class="selector-pseudo">:v1.0</span></span><br></pre></td></tr></table></figure></p><p>这里，我们将Docker容器的4000端口映射到主机的4050端口，当我们在浏览器中输入：<a href="http://localhost:4050，就可以得到和Linux下一样的结果。不过，在写作这篇博客时，博主使用的是Windows下的Docker，如果大家遇到相关问题，欢迎在博客评论区留言。" target="_blank" rel="noopener">http://localhost:4050，就可以得到和Linux下一样的结果。不过，在写作这篇博客时，博主使用的是Windows下的Docker，如果大家遇到相关问题，欢迎在博客评论区留言。</a></p><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>&emsp;&emsp;本文从一个实际工作的场景切入，分析和阐述了如何使用Jexus实现ASP.NET项目在Linux下的部署。为了简化这篇文章的写作，我们使用了一个ASP.NET MVC4的示例项目，真实的项目通常会有数据库，所以情况会比本文所介绍的流程更为复杂，可这让我们看到了一种可能性不是吗？通过查阅相关资料，博主发现ASP.NET Core的部署不需要Jexus，它只需要一个dotnet run命令即可。然后，作为一次体验Docker的过程，我们通过编写Dockerfile的方式让Jexus和Docker发生了某种奇妙的关联。作为本文的一个延伸，我们需要考虑网站服务停止后可以自动重启，这就是所谓的守护进程机制啦，感兴趣的朋友可以继续深入研究，Jexus提供了大量的优秀特性，这篇文章中所看到的不过是冰山一角。最终，我们的项目还是没有使用Jexus，这其中有对Jexus性能的不信任，有因为COM组件而做出的妥协，有对Mono非官方方案的鄙夷……可以说，技术选型是一个受到多种因素制约的问题，谁拥有了话语权，就可以左右技术选型的走向，这是否又印证了，人类并非如自己所标榜的那般理性和正义？好了，以上就是这篇文章的全部内容啦，今天是5月20日，如果没有人对你说“我爱你”，请记得对自己说“我爱你”，谢谢大家！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="开发工具" scheme="http://qinyuanpei.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Jexus" scheme="http://qinyuanpei.github.io/tags/Jexus/"/>
    
      <category term="Docker" scheme="http://qinyuanpei.github.io/tags/Docker/"/>
    
      <category term="Linux" scheme="http://qinyuanpei.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>使用SonarCloud为.NET/.NET Core项目集成静态检查</title>
    <link href="http://qinyuanpei.github.io/posts/4891372/"/>
    <id>http://qinyuanpei.github.io/posts/4891372/</id>
    <published>2018-05-12T01:16:52.000Z</published>
    <updated>2018-08-24T05:39:27.478Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>&emsp;&emsp;Hi，朋友们，大家好，欢迎大家关注我的博客，我是Payne，我的博客地址是<a href="http://qinyuanpei.github.io">http://qinyuanpei.github.io</a>。在不知不觉间，5月份已然度过大半，最近无论是读书还是写作均停滞不前，被拖延症支配的我深感有虚度时光之嫌。今天这篇文章，我将为大家介绍如何使用<a href="https://about.sonarcloud.io/" target="_blank" rel="noopener">SonarCloud</a>，来为.NET/.NET Core项目集成静态检查。如果大家使用过<a href="https://www.sonarqube.org/" target="_blank" rel="noopener">SonarCube</a>的话，对接下来我要讲的内容一定不会感到陌生，因为<a href="https://about.sonarcloud.io/" target="_blank" rel="noopener">SonarCloud</a>实际上就是<a href="https://www.sonarqube.org/" target="_blank" rel="noopener">SonarCube</a>的“云”版本。在云计算概念深入人心的今天，我们可以通过互联网来访问各种各样的服务。譬如，我曾经为大家介绍过的TravisCI就是一个在线的持续集成(CI)服务。这些云服务可以让我们不再关心基础设施如何去搭建，进而集中精力去解决最核心、最关键的问题。和持续集成关注“持续”不同，静态检查关注的是代码质量。目前，SonarCloud支持<strong>.NET Framework 4.6</strong>以上及<strong>.NET Core</strong>版本。通过这篇文章，你将了解到<strong>SonarCloud的基本使用</strong>、<strong>SonarCloud与TravisCI的服务集成</strong>这两方面的内容。</p><h1 id="SonarCloud"><a href="#SonarCloud" class="headerlink" title="SonarCloud"></a>SonarCloud</h1><p>&emsp;&emsp;静态检查，顾名思义就是通过扫描源代码来发现代码中隐藏的缺陷，譬如潜在的Bug、重复/复杂的代码等等，这些通常被称为代码中的“坏味道”，静态检查就是通过工具去扫描这些“坏味道”。Sonar是一个基于Java的代码质量管理工具，由Sonar和SonarScanner两个主要部分组成，前者是一个Web系统用以展示代码扫描结果，而后者是真正用以扫描代码的工具。Sonar具备良好的扩展性，众多的插件使得它可以和Jenkins等集成工具结合使用，同时可支持不同语言项目的扫描分析。在.NET中我们可以使用<a href="https://github.com/StyleCop" target="_blank" rel="noopener">Stylecop</a>来进行静态检查，无独有偶，<a href="http://www.jetbrains.com/resharper/" target="_blank" rel="noopener">ReShaper</a>中同样提供了静态检查的特性。在这篇文章中我们主要使用Sonar来作为.NET项目的静态检查工具。</p><p>&emsp;&emsp;通常使用Sonar来构建静态检查工具时，需要我们在本地搭建一套运行环境，而SonarCloud是针对Sonar推出的一个“云”版本。我们只需要执行脚本就可以完成代码分析，而分析的结果则可以直接在SonarCloud网站中看到。这就是“云计算”的魅力所在，我们无需关心Sonar是如何安装以及配置的，当我们需要使用这种服务的时候直接使用就好了。目前，SonarCloud对开源项目是免费提供的。因此，如果你不想亲自去搭建一个静态分析的环境，那么你可以选择使用SonarCloud来对代码进行静态分析。SonarCloud支持17种语言的扫描分析，支持和Travis、VSTS、AppVeyor等CI工具集成，甚至你可以在SonarCloud上找到大量实际的项目。</p><p>&emsp;&emsp;我对SonarCloud感兴趣的一个重要原因是，它可以和TravisCI完美地集成在一起，而且在此之前，我曾经使用过一段时间的Sonar。在使用SonarCloud前，我们需要注册一个账号，这里建议使用Github账号授权登录，因为我们需要授权给SonarCloud来拉取代码，尤其当你使用TravisCI来集成SonarCloud的时候。除此之外，我们需要准备好以下工具：</p><ul><li><a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">JDK</a>，即Java SE Development Kit，运行SonarScanner时依赖Java环境。</li><li><a href="https://git-scm.com/" target="_blank" rel="noopener">Git</a>，版本控制工具，如果身为一名程序员而没有安装Git，请面壁思过并自我检讨。</li><li><a href="https://msdn.microsoft.com/en-us/library/dd393574.aspx" target="_blank" rel="noopener">MSBuild</a>，.NET平台项目构建工具，推荐一个无脑安装的方法，安装全宇宙无敌的IDE：Visual Studio。</li><li><a href="https://docs.sonarqube.org/display/SCAN/Analyzing+with+SonarQube+Scanner+for+MSBuild" target="_blank" rel="noopener">SonarScanner</a>，即Sonar的代码扫描器，注意这里有两个版本：<a href="https://github.com/SonarSource/sonar-scanner-msbuild/releases/download/4.2.0.1214/sonar-scanner-msbuild-4.2.0.1214-net46.zip" target="_blank" rel="noopener">.NET Framework 4.6 +</a> 和 <a href="https://github.com/SonarSource/sonar-scanner-msbuild/releases/download/4.2.0.1214/sonar-scanner-msbuild-4.2.0.1214-netcoreapp2.0.zip" target="_blank" rel="noopener">.NET Core</a>，本文以.NET Framework 4.6 +为例。</li></ul><h1 id="第一个-NET项目"><a href="#第一个-NET项目" class="headerlink" title="第一个.NET项目"></a>第一个.NET项目</h1><p>&emsp;&emsp;好了，下面我们来使用SonarCloud对博主的一个项目<a href="https://github.com/qinyuanpei/HttpServer" target="_blank" rel="noopener">HttpServer</a>进行分析。首先，我们需要在SonarCloud中创建一个项目。如下图所示，我们首先选择Organization，默认情况下，通过Github授权登录以后，会生成一个格式为：${UserName}-github的组织名称，例如我这里是：qinyuanpei-github。这里我们选择默认组织，然后点击：Continue。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/Wechat_20180511174948.png" alt="设置组织名称" title="">                </div>                <div class="image-caption">设置组织名称</div>            </figure><br>&emsp;&emsp;接下来，我们需要设置一个Token，其目的是通过这个Token登录SonarCloud，然后把SonarScanner在本地扫描的结果发送到SonarCloud。这里我们可以选择生成一个新的Token或者是使用一个已经存在的Token。建议使用一个Token来管理所有的项目，因为这个Token显示一次后就不再显示，同时维护多个Token实在是太痛苦啦，当然，如果你能管理好所有Token的Key的话。设置完Token点击下一步：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/SonarCloud02.png" alt="设置Token" title="">                </div>                <div class="image-caption">设置Token</div>            </figure><br>&emsp;&emsp;设置完Token以后需要选择项目类型以及设置项目名称，在这个例子中，博主的项目名称是HttpServer，建议使用Sonar-${Project Name}的形式来为项目命名，而项目类型显然应该选择“C# or VB.NET”。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/SonarCloud03.png" alt="设置项目名称" title="">                </div>                <div class="image-caption">设置项目名称</div>            </figure><br>&emsp;&emsp;接下来我们就得到最关键的信息，如图所示，这里有三条命令，我们将其复制下来，然后将其写到批处理(.bat)或者PowerShll脚本里。以后运行这三条命令，就可以对当前项目进行静态检查，是不是很简单啊？简单分析下，这三条命令，第一条命令根据我们设置的Token、项目名称、组织等信息“开始”对项目进行分析，注意到这里有一个“begin”；第二条命令是一个MSBuild命令，其目的是对整个项目重新构建；第三条命令是将静态分析的提交到SonarCloud，注意到这里有一个“end”。具体文档可以参考 <a href="https://docs.sonarqube.org/display/SCAN/Analyzing+with+SonarQube+Scanner+for+MSBuild" target="_blank" rel="noopener">这里</a>  哦！<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/SonarCloud04.png" alt="复制3条命令" title="">                </div>                <div class="image-caption">复制3条命令</div>            </figure><br>&emsp;&emsp;好了，现在我们在SonarCloud中就可以看到扫描结果啦，开心！如果执行命令出现问题，请确保正确安装了相关工具，并检查这些工具是否被添加到系统变量中，特别是Java需要设置JAVA_HOME。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/Wechat_20180511183203.png" alt="扫描结果" title="">                </div>                <div class="image-caption">扫描结果</div>            </figure></p><h1 id="TravisCI与SonarCloud的集成"><a href="#TravisCI与SonarCloud的集成" class="headerlink" title="TravisCI与SonarCloud的集成"></a>TravisCI与SonarCloud的集成</h1><p>&emsp;&emsp;现在我们来回顾下整个过程，我们需要在本地安装SonarScanner，这是一个Java编写的应用程序，因此我们需要一个Java运行环境。每次都需要通过SonarCloud来创建项目，获得项目相关的信息以后，在命令中携带这些参数并执行命令，就可以在SonarCloud中获得本地的扫描结果。在整个过程中，我们依然需要一个本地的环境，这一点都不灵活。现实世界的复杂性，就在于我们无法为还原出完全一致的处境。<br>&emsp;&emsp;所以，托尔斯泰开宗明义地说道：“幸福的家庭都是相似的，不幸的家庭各有各的不幸”，况且作为一个执着于让重复的事情自动化的人，如果让我做这件事情，我保证第一次会意外地觉得好奇，而等到第二次、第三次的时候我就会感到厌烦，这就是人们所说的三分钟热度。诚然，我的确是一个花心的双子座。我们提到，SonarCloud支持TravisCI，所以，接下来我们来考虑如何让TravisCI帮助我们运行Sonar。<br>&emsp;&emsp;常规的思路是，下载SonarScanner并执行脚本。这种思路的问题在于TravisCI运行在Linux下，我们确定SonnarScanner是否可以支持Linux平台，尽管SonarScanner使用Java开发。通过阅读TravisCI的<a href="https://docs.travis-ci.com/user/sonarcloud/" target="_blank" rel="noopener">文档</a>，我们发现TravisCI本身是支持SonarCloud的插件的，由此我们就可以着手将这一切交给TravisCI来做啦！<br>&emsp;&emsp;关于如何使用TravisCI，这里不再赘述啦！大家可以参考我的这两篇博客，这两篇博客分别是：<a href="https://qinyuanpei.github.io/posts/3521618732/">持续集成在Hexo自动化部署上的实践</a>、<a href="https://qinyuanpei.github.io/posts/1113828794/">基于Travis CI实现 Hexo 在 Github 和 Coding 的同步部署</a>。当然第一手的资料必然是官方文档，我是不好意思随便对别人说RTFM的。按照文档说明，我们首先需要一个名为sonar-project.properties的配置文件，在该配置文件中配置了诸如项目名称、组织名称等关键信息，Sonar会自动读取这个配置文件里的信息并携带到命令中去，这个配置文件是在是太熟悉啦，假如你认真地读了这篇文章，并注意到了SonarCloud生成的三条命令。这个配置文件内容如下：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># must be unique in a given SonarQube instance</span></span><br><span class="line">sonar.<span class="attribute">projectKey</span>=Sonar-HttpServer</span><br><span class="line"><span class="comment"># this is the name and version displayed in the SonarQube UI. Was mandatory prior to SonarQube 6.1.</span></span><br><span class="line">sonar.<span class="attribute">projectName</span>=HttpServer</span><br><span class="line">sonar.<span class="attribute">projectVersion</span>=1.0</span><br><span class="line"><span class="comment"># Path is relative to the sonar-project.properties file. Replace "\" by "/" on Windows.</span></span><br><span class="line"><span class="comment"># This property is optional if sonar.modules is set.</span></span><br><span class="line">sonar.<span class="attribute">sources</span>=.</span><br><span class="line"><span class="comment"># Encoding of the source code. Default is default system encoding</span></span><br><span class="line"><span class="comment">#sonar.sourceEncoding=UTF-8</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;配置文件中有来自官方的注释，我就不再狗尾续貂的去做相应的解释了。我们发现，这个里面是没有token的，按照官方<a href="https://docs.travis-ci.com/user/sonarcloud/" target="_blank" rel="noopener">文档</a>中的说明，token应该配置在.travis.yml这个文件中，熟悉TravisCI的朋友就会知道，这个文件通常用来配置持续集成的流程。按照约定，SonarCloud属于TravisCI的一个插件，应该配置在addons节点下，我们注意到，在这里可以配置组织名称和token两个节点的信息。组织信息这个简单，直接按照前面的流程填写即可，需要注意的是这里的token。<br>&emsp;&emsp;因为token采用明文配置的话，难免会存在安全风险，所以官方的建议是：使用TravisCI的终端工具进行加密。这是一个基于Ruby的命令行工具，直接在命令行中对token进行加密即可。不过想起很多年前，第一次接触Jekyll时被Ruby支配的恐惧感，我决定寻找新的出路。官方文档说可以在TravisCI中配置<a href="https://docs.travis-ci.com/user/environment-variables/#Defining-Variables-in-Repository-Settings" target="_blank" rel="noopener">全局变量</a>，这种方式我们接入Coding Page 时曾使用过，不过经过博主尝试，这种方式一直无法获得权限，所以，我不得不在配置文件中写明文，大家不要学我啊：<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">addons:</span></span><br><span class="line"><span class="symbol">  sonarcloud:</span></span><br><span class="line"><span class="symbol">    organization:</span> <span class="string">"在这里输入你的组织名称"</span> </span><br><span class="line"><span class="symbol">    token:</span> <span class="string">"在这里输入你的token"</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;原本走到这一步时，我就该和大家对本文进行小结啦！可偏偏我注意到了SonarCloud生成命令中有MSBuild的身影，于是我开始尝试在TravisCI脚本中编写.NET相关的命令，因为我从未在TravisCI中对.NET项目进行持续集成，所以我很好奇它如果跑起来会是什么样子的。同样参照官方<a href="https://docs.travis-ci.com/user/languages/csharp/" target="_blank" rel="noopener">文档</a>，发现目前TravisCI支持Mono和.NET Core的两个版本的构建工具，Mono我可以理解，因为TravisCI运行在Linux环境下，这和我们以前运行在Windows环境下是不一样的。而.NET Core原本就支持跨平台，目前官方释放出了2.0预览版，同时3.0的计划开始提上日程。无论或早或晚，我们面对的都将是一个多平台化的未来，永远不要固执地封闭在一个生态系统里，技术是如此，人生何尝不是如此呢？<br>&emsp;&emsp;好啦，言归正传，了解到这种可能性以后，我开始尝试编写TravisCI脚本，官方默认的构建系统是XBuild，实际使用中遇到些问题，开始考虑能不能替换成MSBuild，事实上MSBuild目前已经是跨平台的，Nuget同样跨平台。微软收购Mono以后，Visual Studio基本上算是跨平台了，况且我们还有一个编辑器中的黑马Visual Studio Code。IIS目前可以考虑用Jexus替换，而有了OWIN这个服务器接口以后，我们有更多的Host可以去选择，现在剩下的只有SQL Server啦，可想而知，除了WinForm/WPF/COM等这种系统依赖性强的东西，大多数的服务其实都可以跑在Linux上。经过反复尝试，最终我们实现了：<strong>在TravisCI下使用MSBuild构建项目</strong>、<strong>使用Nuget在线安装NUnit并运行单元测试</strong>、<strong>使用SonarCloud对代码进行静态检查</strong>。一起来看脚本怎么写：<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">jdk:</span><br><span class="line">  -<span class="ruby"> oraclejdk8</span></span><br><span class="line"><span class="ruby"><span class="symbol">mono:</span> </span></span><br><span class="line"><span class="ruby">  - latest</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby"><span class="symbol">language:</span> csharp</span></span><br><span class="line"><span class="ruby"><span class="symbol">solution:</span> ./HTTPServer/HTTPServer.sln</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby"><span class="symbol">notifications:</span></span></span><br><span class="line"><span class="ruby">  <span class="symbol">email:</span></span></span><br><span class="line"><span class="ruby">    <span class="symbol">recipients:</span></span></span><br><span class="line"><span class="ruby">      - <span class="number">875974254</span>@qq.com <span class="comment">#请替换成你的邮箱，谢谢</span></span></span><br><span class="line"><span class="ruby">      - qinyuanpei@163.com <span class="comment">#请替换成你的邮箱，谢谢</span></span></span><br><span class="line"><span class="ruby">    <span class="symbol">on_success:</span> change <span class="comment"># default: change</span></span></span><br><span class="line"><span class="ruby">    <span class="symbol">on_failure:</span> always <span class="comment"># default: always</span></span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby"><span class="symbol">install:</span></span></span><br><span class="line"><span class="ruby">  - cd ./HTTPServer</span></span><br><span class="line"><span class="ruby">  - nuget restore ./HTTPServer.sln <span class="comment"># restore nuget</span></span></span><br><span class="line"><span class="ruby">  - nuget install NUnit.Runners -Version <span class="number">3.8</span>.<span class="number">0</span> -OutputDirectory ./TestRunner <span class="comment"># install nunit</span></span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby"><span class="symbol">script:</span></span></span><br><span class="line"><span class="ruby">  - msbuild /<span class="symbol">p:</span>Configuration=Release HTTPServer.sln</span></span><br><span class="line"><span class="ruby">  - mono ./TestRunner/NUnit.ConsoleRunner.<span class="number">3.8</span>.<span class="number">0</span>/tools/nunit3-console.exe ./HTTPServerLib.UnitTest/bin/Release/HttpServerLib.UnitTest.dll</span></span><br><span class="line"><span class="ruby">  - sonar-scanner -Dsonar.verbose=<span class="literal">true</span> -X</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby"><span class="symbol">branches:</span></span></span><br><span class="line"><span class="ruby">  <span class="symbol">only:</span></span></span><br><span class="line"><span class="ruby">    - master</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby"><span class="symbol">addons:</span></span></span><br><span class="line"><span class="ruby">  <span class="symbol">sonarcloud:</span></span></span><br><span class="line"><span class="ruby">    <span class="symbol">organization:</span> <span class="string">"在这里输入你的组织名称"</span> </span></span><br><span class="line"><span class="ruby">    <span class="symbol">token:</span> <span class="string">"在这里输入你的token"</span></span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">    </span></span><br><span class="line"><span class="ruby"><span class="symbol">cache:</span></span></span><br><span class="line"><span class="ruby">  <span class="symbol">directories:</span></span></span><br><span class="line"><span class="ruby">    - <span class="string">'$HOME/.sonar/cache'</span></span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;好啦，感受技术的魅力吧！可以注意到，我这里有4个单元测试，其中2个通过、2个失败。虽然单元测试没有通过，可我代码没有Bug呀！<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/Wechat_20180512003928.png" alt="NUnit运行结果" title="">                </div>                <div class="image-caption">NUnit运行结果</div>            </figure></p><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>&emsp;&emsp;本文介绍了一个“云”服务：SonarCloud。SonarCloud是一个基于SonarCube的静态分析工具，通过SonarCloud我们无需搭建Sonar环境就可以对项目进行静态分析。为了验证和实现这个诉求，我们首先提供了通过SonarScanner来扫描代码的示例，其原理是在命令行参数中携带相关信息，通过token来验证和登录SonarCloud，在完成对代码的扫描以后，就可以在SonarCloud中查看整个项目的分析结果。<br>&emsp;&emsp;接下来，为了验证SonarCloud和TravisCI进行集成的可行性，我们尝试通过travisCI脚本的方式来调用SonarCloud，其原理是通过配置文件获得相关信息由TravisCI完成所有的分析工作，这里需要注意的是要对token进行加密。在编写TravisCI脚本的过程中，我们一同验证了MSBuild、Nuget、NUnit等.NET常规工具或者类库在Linux平台下使用的可能性，最终在TravisCI的帮助下完成了从项目构建、单元测试再到代码的分析的整个流程。<br>&emsp;&emsp;虽然静态分析并不能完全保证代码没有问题，可人类总是不情愿承认自己仅仅是一种高等动物而已，这个世界上有好多东西人们不一定会喜欢，因为它们要么是正确的要么是有益的。本文这个方案需要把代码暴露在Github，对于一般的服务集成，我们更推荐Jenkins + Sonar这样的组合，前者可以替换TravisCI提供持续集成服务，同Github、Gitlib等代码托管服务进行集成、同Stylecop、Sonar等静态检查工具进行集成，这方面的资料非常丰富，我们这里就不再多说啦，总而言之，让一切更好就是我们的目的，晚安！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="开发工具" scheme="http://qinyuanpei.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Mono" scheme="http://qinyuanpei.github.io/tags/Mono/"/>
    
      <category term="Travis" scheme="http://qinyuanpei.github.io/tags/Travis/"/>
    
      <category term="Sonar" scheme="http://qinyuanpei.github.io/tags/Sonar/"/>
    
  </entry>
  
  <entry>
    <title>罗马数字与阿拉伯数字的相互转换</title>
    <link href="http://qinyuanpei.github.io/posts/4158690468/"/>
    <id>http://qinyuanpei.github.io/posts/4158690468/</id>
    <published>2018-04-30T10:59:46.000Z</published>
    <updated>2018-08-24T05:39:27.482Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>&emsp;&emsp;最近遇到一道非常有趣的题目，题目大意如下：有一个富翁在银河系里做生意，而银河系使用的是罗马数字，所以他需要一个精明能干的助手，帮助他完成罗马数字与阿拉伯数字的相互转换，题目在这个背景下衍生出交易场景，我们需要帮助他计算出相关商品的价格。对于这道题目，如果剥离开这个题目本身的交易场景，这道题目本质上就是一个纯粹的算法问题。说来惭愧，博主当时并未能快速地解决这个问题，事后通过研读别人的文章始能有所领悟。所以，今天想在这篇文章里，同大家一起来讨论下这个问题。今天，全世界都在使用0到9这10个阿拉伯数字，比阿拉伯数字早2000年的罗马数字。为什么没有流传下来为后世所用呢？我觉得这是一个非常有意思的问题，数学同计算机学科间那种千丝万缕的联系、技术演进过程中若有若无的某种必然性……这些都是令我觉得非常有意思的地方。那么，一起来看看这个问题可好？</p><h1 id="罗马数字起源"><a href="#罗马数字起源" class="headerlink" title="罗马数字起源"></a>罗马数字起源</h1><p>&emsp;&emsp;罗马数字，顾名思义，就是古罗马人使用的数字系统。在罗马数字中，共有7个基本数字，即I、V、X、L、C、D、M，它们分别表示1、5、10、50、100、500、1000。可以注意到，在这套数字系统中，0不被视作是一个整数。据说，曾经有一位罗马学者不顾教皇的反对，执意将与0相关的知识以及0在运算中的作用向民众传播，因此被教皇囚禁并投入监狱，理由是0是一个邪物，破坏了神圣的数。同样罗马数字无法表示小数(<strong>注：罗马数字有分数的表示方法，可仅仅能表示1/12的整数倍</strong>)，因此罗马数字常常用来表示纪年，在欧洲国家的古书籍、建筑和钟表中，我们都可以见到罗马数字的身影。我们熟悉的元素周期表，同样采用了罗马数字来表示元素所在的”族”。需要说明的是，罗马数字是一种计数规则，而非计算规则，这意味者罗马数字是没有进位和权重的概念的，所以一般罗马数字只用以计数而不用以演算。</p><p>&emsp;&emsp;既然罗马数字是一种计数规则，那么我们就不得不说一说它的组合规则，因为4000以内的数字，都可以用这7个基本数字组合表示。具体来讲，罗马数字的基本规则有以下4条：</p><ul><li>重复次数：<strong>一个数字重复多少次，所表示的数字就是这个罗马数字的多少倍；一个罗马数字最多重复三次。</strong>这条规则该怎么理解呢？第一点，I、II、III分别表示1、2、3；第二点，4必须被表示为IV，而不是IIII。关于4的表示方法，在历史上一直存在争议，一种观点认为IIII这种写法占用书写空间，IV可以达到简化书写的作用；而一种观点则认为IV有亵渎神灵朱庇特、含不敬侮辱之意。</li><li>左减原则：<strong>当一个较小的数字被放在一个较大数字的左边时，所表示的数字等于这个大数减去这个小数，且左边最多只能放一个较小的数字</strong>。联系第一条原则，IV表示的实际上是V-I，所以这个数值表示4；同理，9为了满足第一条原则，必须被表示成IX。</li><li>右加原则：<strong>当一个较小的数字被放在一个较大数字的右边时，所表示的数字等于这个大数加上这个小数，且右边最多只能放一个较小的数字</strong>。这一条原则和第二条原则相对应，例如11会被表示成XI、21会被表示为XXI，以此类推。</li><li>搭配原则：<strong>I只能被放在V和X的左边；X只能被放在L和C的左边；C只能被放在D和M的左边；V、L、D不能被放在左边</strong>。这一条可以看作对是第二条的总结，所以没有什么可说的。</li></ul><p>&emsp;&emsp;好了，通过这个这些规则我们就可以组合出不同的数字，我们可以注意到这些数字呈现出1、4、5、9的规律。什么是1、4、5、9的规律呢？我们可以注意到4和9是两个特殊的数字，4必须通过5左减来得到，9必须通过10左减来得到，这是因为罗马数字要满足最多重复三次的原则，而4和9相对1和5的偏移量恰好是4，所以它们的表示方法和其他数字不同。因为罗马数字没有进位和权重的概念，所以除了左减和右增这两种特殊情况以外，它的基本数字应该从左至右依次递减，即使在左减的情况下，左边的数字应该和右边的数字处在同一序列。这句话怎么理解呢？例如，90必须用100-10来表示；而99必须拆解为90和9，然后分别用100-10和10-1来表示，唯独不能通过100-1来表示，因为100和1分属两个不同的序列。</p><h1 id="数字转换实现"><a href="#数字转换实现" class="headerlink" title="数字转换实现"></a>数字转换实现</h1><p>&emsp;&emsp;了解完罗马数字的历史渊源，我们就对罗马数字有了一定的了解。现在来考虑一个问题，即罗马数字和阿拉伯数字间的相互转换。罗马数字的确是古罗马人发明的，可阿拉伯数字实际上却是古印度人发明的。今天全世界人都在使用阿拉伯数字，因此这两者间需要一个转换器，这正是我们一开始所讨论的问题：假如银河系里的人们都使用罗马数字来计数，当一个地球上的富翁来到银河系以后，他要如何去和这里的人们进行交易。显然，这种转换应该是双向的，我们下面分别来看如何实现相应的转换。</p><h2 id="阿拉伯转罗马"><a href="#阿拉伯转罗马" class="headerlink" title="阿拉伯转罗马"></a>阿拉伯转罗马</h2><p>&emsp;&emsp;首先来考虑阿拉伯数字转罗马数字，因为一个罗马数字必然是从左到右依次递减，所以我们只需要将这7个基本数字从大到小排列，找到第一个不小于指定数字的数位即可。例如1024显然超过了1000，而罗马数字中的1000对应M，因此1024的第一位应该是M。接下来24，显然超过10，因此1024的第二位数字应该是X。接下来14，显然超过10，因此1024的第三位数字同样是X。接下来4，这是一个特殊的数字，需要被表示为IV，这是1024的第四位数字。我们将整个过程串联起来，就可以得到1024的罗马数字形式MXXIV。我们注意的一点是，这里需要4和9这两个数字作为辅助数字，因为1到3、6到8的数字，我们总可以通过不断地重复1来得到，就像辗转相除法一样。如果没有这两个辅助数字会怎样呢？4会变成IIII，而9会变成VIIII，显然这是不符合我们预期的。整理下我们的思路，这段代码实现如下：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> ConvertToRoman(int <span class="built_in">number</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> output = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">var</span> digitMap = <span class="keyword">new</span> Dictionary&lt;int,<span class="built_in">string</span>&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">      &#123;<span class="number">1</span>,<span class="string">"I"</span>&#125;,&#123;<span class="number">4</span>,<span class="string">"IV"</span>&#125;,&#123;<span class="number">5</span>,<span class="string">"V"</span>&#125;,&#123;<span class="number">9</span>,<span class="string">"IX"</span>&#125;,</span><br><span class="line">      &#123;<span class="number">10</span>,<span class="string">"X"</span>&#125;,&#123;<span class="number">40</span>,<span class="string">"XL"</span>&#125;,&#123;<span class="number">50</span>,<span class="string">"L"</span>&#125;,&#123;<span class="number">90</span>,<span class="string">"XC"</span>&#125;,</span><br><span class="line">      &#123;<span class="number">100</span>,<span class="string">"C"</span>&#125;,&#123;<span class="number">400</span>,<span class="string">"CD"</span>&#125;,&#123;<span class="number">500</span>,<span class="string">"D"</span>&#125;,&#123;<span class="number">900</span>,<span class="string">"CM"</span>&#125;,</span><br><span class="line">      &#123;<span class="number">1000</span>,<span class="string">"M"</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">var</span> digits = digitMap.OrderByDescending(<span class="function"><span class="params">e</span> =&gt;</span> e.Key).ToList();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; digits.Count &amp;&amp; <span class="built_in">number</span> &gt; <span class="number">0</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">number</span> &lt; digits[i].Key) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">number</span> &gt;= digits[i].Key)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">number</span> -= digits[i].Key;</span><br><span class="line">            output.Append(digits[i].Value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> output.ToString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="罗马转阿拉伯"><a href="#罗马转阿拉伯" class="headerlink" title="罗马转阿拉伯"></a>罗马转阿拉伯</h2><p>&emsp;&emsp;接下来考虑罗马数字如何转换为阿拉伯数字，我们可以明确的一点是，罗马数字基本上是从左到右依次递减排列的，每一个数字的左侧和右侧出现的数字一定处于当前数字的同一序列。比如，I只能被放在V和X的左边；X只能被放在L和C的左边；C只能被放在D和M的左边。因此，我们从左到右依次遍历整个字符串，将每个字符转化为对应的阿拉伯数字然后累加即可，需要注意的是，当当前元素小于下一元素时，表示当前元素为负数；当当前元素大于下一元素时，表示当前元素为正数。显然，这里最后一位应该是正数，因为它没有下一个元素可以比较。至此，我们梳理出整个思路：从第一位到第n-1位依次循环，判断当前元素的正负然后累加，再加上最后一位元素的值即可。下面是代码实现：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ConvertToNumber</span>(<span class="params"><span class="keyword">string</span> romanNumber</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> number = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> length = romanNumber.Length;</span><br><span class="line">    <span class="keyword">var</span> digits = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">string</span>,<span class="keyword">int</span>&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">      &#123;<span class="string">"I"</span>,<span class="number">1</span>&#125;,&#123;<span class="string">"V"</span>,<span class="number">5</span>&#125;,&#123;<span class="string">"X"</span>,<span class="number">10</span>&#125;,&#123;<span class="string">"L"</span>,<span class="number">50</span>&#125;,&#123;<span class="string">"C"</span>,<span class="number">100</span>&#125;,&#123;<span class="string">"D"</span>,<span class="number">500</span>&#125;,&#123;<span class="string">"M"</span>,<span class="number">1000</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//前面 n-1 位数字通过左右比较决定正负 &amp; 第 n 位数字必然为正</span></span><br><span class="line">        <span class="keyword">if</span> ((digits[romanNumber[i].ToString()] &gt;= digits[romanNumber[i + <span class="number">1</span>].ToString()]) || i + <span class="number">1</span> &gt;= length)</span><br><span class="line">        &#123;</span><br><span class="line">            number += digits[romanNumber[i].ToString()];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            number -= digits[romanNumber[i].ToString()];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="为什么会溢出"><a href="#为什么会溢出" class="headerlink" title="为什么会溢出"></a>为什么会溢出</h1><p>&emsp;&emsp;相信上面这两段代码，大家都已然把玩过了。可我们仔细想想，就会觉得这事儿不靠谱。前段时间网络上一直流传着，我们这些佛系青年正在被同龄人抛弃。这个题目里我们所面对的，可是一个来自地球的的富翁啊！富翁的钱不都是按亿来计数的吗？我们没有一个亿这样的小目标，我们的目标是月入5万啊，这是一个社会上流行的说法。好了，回到这个题目中来，如果我们输入50000这个阿拉伯数字，它会输出什么呢？答案是50个M，这很罗马数字啊，当然更神奇的事情是什么呢？当我们尝试把这由50个M组成的罗马数字转换为阿拉伯数字时，会发现它不能像我们期望地输出50000，而会变成是一个负数。为什么这里是负数呢？答案是溢出啦！</p><p>&emsp;&emsp;过去，我们常常听到”溢出“这个词儿，最常见的是数据溢出。为什么会发生数据溢出呢？因为我们定义的数据超过了计算机所使用的数据的表示范围。这一点我们可能无法理解，一个相对粗浅的认识是，现代计算机的内存已经大到非常客观，甚至我们的硬盘都已经使用TB这样的容量单位，为什么还是会发生数据溢出呢？回到罗马数字这个问题，我们发现一个残酷的事实是，古罗马人并没有定义1000以上的数字表示，这或许和古罗马人发明数字的过程有关。古人最早都是使用手指、绳结、竹筹这样的工具来计数，在人们没有接触到相当大的数字以前，人们认为这些数的表示是足够的。同样的，我们的计算机经历了从8位、16位、32位到64位的发展。所以，这个世界上没有任何东西是一成不变的，一个技术方案势必要随着业务演化而扩展。</p><p>&emsp;&emsp;我们前面曾提到，这7个基本数字可以表示4000以内的数字，为什么是4000以内呢？因为根据罗马数字最多重复三次的规则，我们应该用5000-1000来表示4000，可问题是这7个基本数字中并没有5000的定义，这和计算机中的数据溢出是非常相似的，因为我们都无法通过现有的构造去描述一个新的东西。这和数学上的那些”扩充“有着极其相似的地方，当我们意识到所有的数不都是整数的时候，我们引入了分数/小数；当我们意识到所有的数不都是有理数的时候，我们引入了无理数； 当我们意识到所有的数不都是实数的时候，我们引入了虚数。在数学上，这叫做数的扩充；在计算机里，这叫做数据溢出。数学作为一本学科，可以通过完善理论来自圆其说；而编程语言里数据结构，是在一开始就定义好的一套规范，它无法更不应该经常去修改，关于如何去解决程序中数据溢出的问题，这已然是一个新的问题了，不过我们可以看看古罗马人是怎么做的。</p><p>&emsp;&emsp;聪明的罗马人自然想到了这个问题，他们提出的解决方案是这样的：在一个数字的上面加一条横线，表示这个数增值1000倍。所以，按照这个定义，4000应该由IV变化而来，9000应该由10000变化而来，而10000则可以看作是10的1000倍，即10000应该由X变化而来。我们在最初的规则中为什么没有说这一条呢？因为在数字上面增加一条横线，这更接近一个书写的行为，它增加了我们程序解析的难度，当一个数字的上面出现横线以后，我们就不能再按照原来的方式去转换。所以，考虑这个因素，实际上还是为了简化问题本身，这道题目中同样回避了这个问题。罗马人这个想法的确很好，可以解决眼下我们所面临的问题，可时间久了以后，罗马人发现这套计数规则书写了繁琐复杂，因而这套规则渐渐地就被人们放弃了。在2015年意大利官方宣布，国内街道编码、文件编码等全部废弃原有的罗马数字，改为使用阿拉伯数字。</p><h1 id="选择阿拉伯数字"><a href="#选择阿拉伯数字" class="headerlink" title="选择阿拉伯数字"></a>选择阿拉伯数字</h1><p>&emsp;&emsp;历史最终选择了阿拉伯数字，而不是罗马数字，这并不是一个巧合，尽管罗马数字要比阿拉伯数字早2000年。罗马数字的缺陷不仅仅在于其书写的繁杂，一个更重要的原因是，它不能更好地推动数学学科的发展。罗马人发明罗马数字的目的是为了计数，可一旦产生了数，就势必会产生计算。可我们发现罗马数字并不适合计算，因为它对数字的构造并不是正交的。一个最为直观的例子是，数字可能会用一个字母、两个字母或者三个字母来表示，如果两个数字要进行加减法，我们会发现它的数字是无法”对齐“的，你必须非常小心地分清楚不同的数位，而罗马数字恰好是没有数位的概念的。同样，当数字加减时会产生进位或者借位，罗马数字的构造会导致牵一发而动全身，因为任何一个中间步骤，我们都必须将其记录下来，记录的代价是将整个结果重写。反观阿拉伯数字，0到9共10个数字可以表示一切，形式上的统一让计算更加便捷，书写更为简洁，这套定义可以扩展到无限大的数上面去，可以扩展到小数、分数甚至无理数、虚数。这是否意味着，一个统一化的定义或者构造，更适合去做相关的运算流程或者逻辑流程呢？</p><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>&emsp;&emsp;本文从一道有趣的题目作为引子，引出这篇文章的主题：罗马数字。我们首先为大家回顾了罗马数字的历史渊源。罗马数字是一种由古罗马人创造的数字系统，这套数字系统主要的用途是进行计数。罗马数字由I、V、X、L、C、D、M共7个基本数字组成，其基本规则是最多重复三次、左减右增。接下来，我们分析了罗马数字与阿拉伯数字相互转换的规律，并提供相关代码实现。在当前方案的基础上，我们引出了罗马数字中的”4000“问题，联系计算机中的数据溢出的相关概念，我们分析了为什么当罗马数字超过4000时会发生”溢出“，以及罗马人是如何解决这个问题的。虽然罗马数字比阿拉伯数字早2000年，可历史最终选择了阿拉伯数字，这里我们简要地分析了原因，因为罗马数字并不适合计算，而数字作为数学的基本要素，一个不能被运用到计算出的数字系统，最终免除不了被人们抛弃的命运。好了，这篇五一节前的文章 就是这样啦，4月再见！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="编程语言" scheme="http://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="数学" scheme="http://qinyuanpei.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="算法" scheme="http://qinyuanpei.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数字" scheme="http://qinyuanpei.github.io/tags/%E6%95%B0%E5%AD%97/"/>
    
  </entry>
  
  <entry>
    <title>邂逅AOP：说说JavaScript中的修饰器</title>
    <link href="http://qinyuanpei.github.io/posts/3668933172/"/>
    <id>http://qinyuanpei.github.io/posts/3668933172/</id>
    <published>2018-04-15T21:20:03.000Z</published>
    <updated>2018-08-24T05:39:27.482Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>&emsp;&emsp;Hi，各位朋友，大家好，欢迎大家关注我的博客，我是Payne，我的博客地址是<a href="https://qinyuanpei.github.io">https://qinyuanpei.github.io</a>。这个月基本上没怎么更新博客和公众号，所以今天想写一篇科普性质的文章，主题是JavaScript中的修饰器。 为什么使用了”邂逅”这样一个词汇呢？因为当你知道无法再邂逅爱情的时候，你只能去期待邂逅爱情以外的事物；当你意识到爱情不过是生命里的小插曲，你只能去努力弥补生命的完整性。在过往的博客中，我曾向大家介绍过譬如Spring.NET、Unity、AspectCore等AOP相关的框架，亦曾向大家介绍过譬如Python中的装饰器、.NET中的Attribute、Java中的注解等等。再我看来，这些都是非常相近的概念，所以今天这篇文章我们又双叒叕要说AOP啦！什么？你说JavaScript里居然AOP！这简直比任何特性都要开心好吗？而这就要从本文的主角——JavaScript中的修饰器说起。</p><h1 id="什么是修饰器？"><a href="#什么是修饰器？" class="headerlink" title="什么是修饰器？"></a>什么是修饰器？</h1><p>&emsp;&emsp;JavaScript中的修饰器(<strong>Decorator</strong>)，是ES7的一个提案。目前的浏览器版本均不支持这一特性，所以主流的技术方案是采用Babel进行转译，事实上前端的工具链有相当多的工具都是这样，当然这些都是我们以后的话题啦！修饰器的出现，主要解决了下面这两个问题：</p><ul><li>不同类间共享方法</li><li>在<strong>编译时</strong>期间对类及其方法进行修改</li></ul><p>&emsp;&emsp;这里第一点看起来意义并不显著啊，因为JavaScript里有了模块化以后，在不同间共享方法只需要将其按模块导出即可。当然，在模块化这个问题上，JavaScript社区发扬了一贯的混乱传统，CommonJS、AMD、CMD等等不同的规范层出不穷，幸运的是ES6中使用了import和export实现了模块功能，这是目前事实上的模块化标准。这里需要关注的第二点，在<strong>编译时</strong>期间对类及其方法进行修改，这可以对类及其方法进行修改，这就非常有趣了呀！再注意到这里的修饰器即<strong>Decorator</strong>，我们立刻想Python中的装饰器，想到装饰器模式，想到代理模式，所以相信到这里大家不难理解我所说的，我们又双叒叕要说AOP啦！</p><p>&emsp;&emsp;那么说了这么多，JavaScript中的修饰器到底长什么样子呢？其实，它没有什么好神秘的，我们在Python和Java中都曾见过它，前者称为<strong>装饰器</strong>，后者称为<strong>注解</strong>，即在类或者方法的上面增加一个@符号，联想一下Spring中的Controller，我们大概知道它长下面这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 修饰类 */</span></span><br><span class="line">@bar</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">foo</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 修饰方法 */</span></span><br><span class="line">@bar</span><br><span class="line">foo()&#123;&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;OK，现在大家一定觉得，这TM简直就是抄袭了Python好吗？为了避免大家变成一个肤浅的人，我们一起来看看下面具体的例子：</p><h2 id="修饰类"><a href="#修饰类" class="headerlink" title="修饰类"></a>修饰类</h2><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@setProp</span><br><span class="line"><span class="keyword">class</span> User &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span></span> setProp(<span class="keyword">target</span>) &#123;</span><br><span class="line">    <span class="keyword">target</span>.age = <span class="number">30</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(User.age)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个例子展示的是，我们如何通过修饰器函数setProp()来为User对象赋值，为什么叫做修饰器函数呢？因为这就是个函数啊，而且JavaScript和Python一样都是支持函数式编程的编程语言，所以大家看到这个大可不必感到吃惊，因为大道至简殊途同归。好了，注意到SetProp()方法有一个参数target，因为该方法修饰User类，所以它的参数就是User类，显然它为User类扩展了一个属性age，并给它赋值为30。相信有朋友一定会奇怪这个age是哪里定义的，我只能说JavaScript是个神奇的语言，一切都是对象，一切都是函数。现在，当我们执行到最后一句时，会输出30，这是因为修饰器对类进行修改。</p><p>&emsp;&emsp;现在我们尝试修改下这个方法，我们希望可以通过修饰器修改age属性的值，而不是让它成为一个固定数值30，这样就涉及到带参数的修饰器函数。修饰器函数本身会接收三个参数，第一个参数是被修饰的对象，因此为了增加一个新的参数，我们需要对原来的函数进行一层包装，你知道吗？此时我感到非常兴奋，因为这TM真的和Python一模一样啊。好了，遵从这个策略，我们修改原来的代码，并将其调整如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@setProp(<span class="number">20</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setProp</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">        target.age = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(User.age)</span><br></pre></td></tr></table></figure></p><p>此种差别，大家可以非常明显地看出来，我们在使用修饰器函数setProp()的时候，现在允许传入一个参数20，此时的结果是非常地显而易见的，这段代码将如你所愿地输出20。</p><h2 id="修饰方法"><a href="#修饰方法" class="headerlink" title="修饰方法"></a>修饰方法</h2><p>&emsp;&emsp;既然修饰器可以修饰类，那么可不可以修饰方法呢？答案自然是可以的。因为当修饰器修饰类的时候，修饰器函数的参数是一个对象，即target，而当修饰器修饰方法的时候，修饰器函数的参数是一个函数。可函数难道就不是对象吗？.NET里的委托最终不是同样会生成一个类吗？Python中不是有函数对象这一概念吗？那么，我们继续看一个例子 ：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    @readonly</span><br><span class="line">    getName() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Hello World'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// readonly修饰函数，对方法进行只读操作</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readonly</span>(<span class="params">target, name, descriptor</span>) </span>&#123;</span><br><span class="line">    descriptor.writable = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">return</span> descriptor</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> u = <span class="keyword">new</span> User()</span><br><span class="line"><span class="comment">// 尝试修改函数，在控制台会报错</span></span><br><span class="line">u.getName = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'I will override'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这个例子中，我们通过修饰器函数readonly()对getName()方法进行修饰，使其变成一个readonly的方法。我们提到修饰器函数有三个参数，target指被修饰的对象，name指被修饰器对象的名称，descriptor指被修饰对象的defineProperty。因为设置descriptor的writable属性为false以后，这个函数就无法被覆盖重写，所以代码中尝试重写该方法时就会报错；同理，如果我们对descriptor的value属性进行修改，则可以对该函数进行重写。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;相信熟悉Python中的朋友，应该会知道在Python中内置了大量的装饰器，譬如@property可以让一个方法像属性一样被调用、@staticmethod可以让一个方法变成静态方法、@classmethod可以让一个方法变成类方法等。那么，作为Python的追随者，JavaSript中是否存在相类似的概念呢？答案还是肯定的啊！哈哈。具体大家可以参考这里：<a href="http://es6.ruanyifeng.com/#docs/decorator" target="_blank" rel="noopener">ES6  Decorator</a></p><h1 id="AOP与修饰器"><a href="#AOP与修饰器" class="headerlink" title="AOP与修饰器"></a>AOP与修饰器</h1><p>&emsp;&emsp;熟悉我写作风格的朋友，应该可以猜到我接下来要做什么了。的确，作为一个在某些方面有强迫症的人，我一直在不遗余力地向大家推广AOP，因为我相信AOP真的可以帮大家去做很多事情。比如最简单的记录日志，或许在前端项目中大家更习惯用console.log()来记录日志，甚至是使用alert()，毕竟这些东西不会在界面上展示出来，所以写一写这些东西好像无可厚非。可当你有了AOP以后，为什么还要做如此出力不讨好的事情呢？我写这篇文章的一个重要原因，正是我看到在前端同事的代码中，使用修饰器做了一个简单的AOP，这非常符合我的品味。具体怎么样去做呢？我们一起来看这段代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bussiness</span> </span>&#123;</span><br><span class="line">    @log</span><br><span class="line">    step1() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    @log</span><br><span class="line">    step2() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">target,name,decriptor</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> origin = descriptor.value;</span><br><span class="line">    descriptor.value = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Calling function "$&#123;name&#125;" with '</span>, argumants);</span><br><span class="line">      <span class="keyword">return</span> origin.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> descriptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;我们刚刚提到通过修改descriptor的value属性可以达到重写方法的目的，那么这里就是利用这种方式对原来的方法进行了修改，在调用原来的方法前调用console.log()写了一行日志。的确，就是这样一行平淡无奇的代码，将我们从泥潭中解救出来。试想看到一段日志记录和业务流程掺杂的代码，谁会有心情去解读代码背后真实的含义，更不必说将来有一天要去删除这些日志有多么艰难啦。AOP的基本思想是在代码执行前后插入代码片段，因为根据JavaScript中的原型继承，我们可以非常容易地为Function类型扩展出before和after两个函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.before = <span class="function"><span class="keyword">function</span>(<span class="params">beforefunc</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">var</span> outerArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>,<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> innerArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    beforefunc.apply(<span class="keyword">this</span>,innerArgs);</span><br><span class="line">    self.apply(<span class="keyword">this</span>,outerArgs)</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.after = <span class="function"><span class="keyword">function</span>(<span class="params">afterfunc</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">var</span> outerArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>,<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> innerArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    self.apply(<span class="keyword">this</span>,outerArgs)</span><br><span class="line">    afterfunc.apply(<span class="keyword">this</span>,innerArgs);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;想象一下，现在我们在重写descriptor的value属性的时候，可以同时指定它的before()方法和after()方法，所以最初的这段代码可以继续被改写为：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Calling function "$&#123;name&#125;" with '</span>, argumants);</span><br><span class="line">    <span class="keyword">return</span> origin.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">func.before(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Start calling function $&#123;name&#125;'</span>);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">func.after(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'End calling function $&#123;name&#125;'</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;所以，所有让你觉得会增加风险的东西，都是源于你内心的恐惧，因为你不愿意去尝试改变，这是真正的复用，如果Ctrl + C和Ctrl + V可以被称为复用的话，我觉得每一个人都可以说自己是网红啦！这并不是一个笑话，还有什么比写一个@log更简单的吗？同样，我们可以使用修饰器去统计代码运行的时间，而不是在所有地方用两个Date()对象去相减。遵从简洁，从心开始：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">time</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">target,name,decriptor</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> origin = descriptor.value;</span><br><span class="line">    descriptor.value = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">let</span> beginTime = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">      <span class="keyword">let</span> result = origin.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>);</span><br><span class="line">      <span class="keyword">let</span> endTime = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">      <span class="keyword">let</span> time = endTime.getTime() - beginTime.getTime();</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"Calling function '$&#123;name&#125;' used '$&#123;time&#125;' ms"</span>); </span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> descriptor;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@time</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;再比如，我们的业务中要求：用户在访问相关资源或者是执行相关操作时，需要确保用户的状态是登录着的，因此，我们不可避免地在代码中，使用if语句去判断用户是否登录，试想如果所有的业务代码都这样写，两个模块间就存在了直接耦合，当然我们可以说这是最简单的做法，因为它照顾了大部分人的思维和情绪，可你看Angular/Redux/TypeScript等项目中无一不遍布着修饰器的身影，当一种框架逐渐流行并成为一种趋势的时候，好像大家立刻就忘记了一件事情：原本我们都是非常排斥这些奇技淫巧的，可因为框架的流行你就默认接受了这种设定。那么，这个逻辑如何使用修饰器来编写会怎么样呢？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    @checkLogin</span><br><span class="line">    getUserInfo() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'获取已登录用户的用户信息'</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @checkLogin</span><br><span class="line">    sendMsg() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'发送消息'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查用户是否登录，如果没有登录，就跳转到登录页面</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkLogin</span>(<span class="params">target, name, descriptor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> method = descriptor.value</span><br><span class="line">    descriptor.value = <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//假想的校验方法，假设这里可以获取到用户名/密码</span></span><br><span class="line">        <span class="keyword">if</span> (validate(args)) &#123;</span><br><span class="line">            method.apply(<span class="keyword">this</span>, args)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'没有登录，即将跳转到登录页面...'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> u = <span class="keyword">new</span> User()</span><br><span class="line">u.getUserInfo()</span><br><span class="line">u.sendMsg()</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;显然，现在我们可以避免模块间的直接耦合，无需在每个业务方法中重复去写if语句，更重要的是通过JavaScript中的模块化规范，我们可以把checkLogin这个方法，扩展到更多的业务类及其方法中去，而唯一的代价就是在方法上增加@checkLogin修饰，你说，有这样优雅的策略，你为什么就不愿意去使用呢？在ASP.NET中我们通过Authorize特性就可以为API和页面授权，现在看来这是不是有点异曲同工之妙呢？你现在还觉得这样麻烦吗？</p><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>&emsp;&emsp;这篇文章从一个前端项目中的日志拦截器(InterceptLog)为引子，引出了ES7提案中的一个特性：修饰器。修饰器的出现，解决了两个问题：第一、不同类间共享方法；第二、在<strong>编译时</strong>期间对类及其方法进行修改。虽然目前修饰器不能直接在浏览器中使用，可是通过Babel这样的转译工具，我们已经可以在项目中提前感受这一特性，这里表扬下前端组的同事们。JavaScript中的修饰器同Python中的修饰器类似，可以修饰类及其方法。JavaScript中的修饰器不建议修饰函数，因为存在一个函数提升的问题，如果一定要修饰函数，按照高阶函数的概念直接包装函数即可。通过修饰器可以简化我们的代码，在本文中我们例举了日志记录、运行时间记录、登录检查三个AOP相关的实例，希望大家可以从这篇文章中有所收获。</p><p>&emsp;&emsp;最后，请允许博主爆一个料，因为要写一个简单的修饰器，需要安装若干Babel甚至是Webpack插件，我这篇文章中的代码，截止到写这篇文章时都没能在实际环境中运行，这不能怪我啊，因为前端的工具链实在是太长太多啦，这当然不能和直接内置装饰器的Python相比啊，这真的不是吐槽诶，我需要一个开箱即用的特性就这么难吗？人生苦短，我用Python！(逃</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li><a href="https://segmentfault.com/a/1190000011479378" target="_blank" rel="noopener">读懂ES7中JavaScript修饰器 </a></li><li><a href="https://segmentfault.com/a/1190000010019412" target="_blank" rel="noopener">ES7 Decorator 入门解析</a></li><li><a href="http://web.jobbole.com/84247/" target="_blank" rel="noopener">ES7 Decorator 装饰者模式</a></li><li><a href="http://es6.ruanyifeng.com/#docs/decorator" target="_blank" rel="noopener">ECMAScript 6 入门</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="编程语言" scheme="http://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="AOP" scheme="http://qinyuanpei.github.io/tags/AOP/"/>
    
      <category term="ES6" scheme="http://qinyuanpei.github.io/tags/ES6/"/>
    
      <category term="JS" scheme="http://qinyuanpei.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>一念执着，千山无阻</title>
    <link href="http://qinyuanpei.github.io/posts/2613006280/"/>
    <id>http://qinyuanpei.github.io/posts/2613006280/</id>
    <published>2018-04-03T09:08:04.000Z</published>
    <updated>2018-08-24T05:39:27.474Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>&emsp;&emsp;上周看了部印度电影《小萝莉的猴神大叔》，以一言敝之，这是一部被名字耽误的好电影，就像我们所熟知的《三傻大闹宝莱坞》、《偶滴个神呐》、《外星醉汉PK地球神》等等电影一样。不过作为一部由“印度三汗”之一萨尔曼·汗主演的电影，可能因为其在国内的知名度不及阿米尔·汗，所以早在这部2015年就上映的电影，并未在国内产生太显著的影响力。相反，同档电影《环太平洋2》票房热度居高不下，大概是因为景甜姐姐终于不负国人期望去拯救全人类啦。即使当时电影院里看这部电影的人寥寥无几，可我觉得还是有必要给大家说一说这部电影，一个即使你能猜对所有情节依然会喜欢的电影。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/p2311758198.jpg" alt="小萝莉与猴神大叔" title="">                </div>                <div class="image-caption">小萝莉与猴神大叔</div>            </figure><p>&emsp;&emsp;影片一开始，讲述的是来自巴基斯坦穆斯林家庭的小女孩沙希达的故事。沙希达到6岁还不会说话，她的父母对此感到焦虑不已。祖父建议带她到神庙里去向神祈祷，可这座神庙在印度境内，并且两国间互相仇视达半个世纪之久。因为沙希达的父亲曾在巴基斯坦军方服过5年兵役，因此他没有办法申请前往印度的签证。无奈之下，沙希达的母亲独自带领女儿前往印度，不想在返回巴基斯坦的途中，沙希达在列车停靠期间，为下车救一只小羊羔而和母亲走散，并被一节载满粮食的火车带到印度。沙希达在那里遇到了“猴神”帕万，面对印度警方的无动于衷，大使馆因为印巴冲突而关门，黑中介拐卖幼童等等一系列的变故，帕万不得不走上亲自送沙希达回家的旅程……</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/p2322605677.jpg" alt="沙希达与小羊羔" title="">                </div>                <div class="image-caption">沙希达与小羊羔</div>            </figure><p>&emsp;&emsp;电影的主线是非常清晰的，不同的是，整个电影被放在一个充斥着宗教矛盾、种姓歧视、印巴冲突的大背景里，所以导演试图去表达的内涵，就不再单纯地是为了讲这样一个故事，一如“三傻”抨击印度教育制度、OMG/偶滴个神/PK探讨宗教和神一样，这部电影里有许多值得去探讨的东西。电影两条相互交叉的线索构成，男主帕夫是一个虔诚的宗教信徒，他信奉的是印度猴神哈奴曼，并努力将宗教的教义落实到言行中去，甚至在生活中显得憨厚而木讷，导演在刻画这个人物时明显夸大了这一点，印象最深的是男主考高中就考了10次，最终父亲居然因为这个“惊喜”而去世。男主寄身在父亲身前的好友家中，并邂逅了一份“坎坷”的爱情。男主的确是一个普世价值中的失败者，没有稳定的工作，岳父要求他在六个月内买一套婚房，甚至从被黑中介欺骗这里可以看出，他并不是一个社会经验丰富的人。善良的男主在猴神节上给沙希达买了薄饼和饮料，沙希达就认定他是一个值得信赖的人，两个人的故事就此展开。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/p2319317555.jpg" alt="小孩子都懂得说谎" title="">                </div>                <div class="image-caption">小孩子都懂得说谎</div>            </figure><p>&emsp;&emsp;帕夫最初希望向印度警方寻求帮助，可警方认为警察局并不是孤儿院，拒绝为沙希达提供相关帮助。无奈之下，帕夫将小女孩带回岳父家中，起初人们见到这个可爱的小女孩，一度认为这是这个小女孩来自印度的某个高贵种姓。种姓制度是一种以血统论为基础的等级制度，广泛存在于印度社会运作与生活中，虽然印度早在1947年就脱离了英国殖民者的统治，可这种在殖民时期被固定和僵化的制度，在今天依旧影响深远。无独有偶，印巴冲突正是英国殖民统治者将印度划分为两个地区统治的结果，电影中印度的印地语和巴基斯坦的乌尔都语，其实是非常相似的两门语言。曾经有两个自命不凡的民族，一个是德意志雅丽安族，一个是扶桑国大和民族，一起发动第二次世界大战，为了所谓的种族优越性，大肆迫害犹太人和中国人，一个6岁的孩子因为可爱就被迫贴上这种种族的标签，人类繁衍至今，这种病态的虚荣心不觉得可悲吗？</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/p2311757793.jpg" alt="有什么区别？" title="">                </div>                <div class="image-caption">有什么区别？</div>            </figure><p>&emsp;&emsp;如果说这种自带歧视的贴标签行为，仅仅是人类的一厢情愿的话，那么接下来沙希达所到的一切事情更像是一种本能。男主的岳父家是一个典型的印度佛教徒家庭，沙希达因为受到肉食的诱惑而到领居家吃鸡肉，当她遇到清真寺就会像母亲一样裹上头巾上前参拜……男主起初不愿意或者说不敢去清真寺内，或许是因为两种截然不同的宗教信仰，让他习惯性地去排斥一种新的文化。这何尝不是我们呢？一旦长大三观就特别难更改，面对三观不合这样的问题，大家都出奇地相信分手就能解决问题。可人类不曾见过一颗恒星的诞生和消亡，可我们就固执地相信这短短几十年里的所见所闻。其实我们大可不必去接受什么，就像这世间有千万种书千万句话，渐渐地丰富了我们原本枯竭的生命。男主纠结于该不该到清真寺里招人，他的女朋友则告诉他，沙希达只是一个6岁的孩子，宗教对她来说有什么意义呢？是啊，我们简简单单地来到这个世界上，等离开时突然发现平添了无数个毫无意义的身份，我承认，沙希达从背后抱住男主的时候，我一个大男人心里像是被温暖到了。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/p2273740173.jpg" alt="沙希达像母亲一样参拜" title="">                </div>                <div class="image-caption">沙希达像母亲一样参拜</div>            </figure><p>&emsp;&emsp;真正揭开小女孩身份的是一场球赛，一场特殊的球赛，一场发生在印度和巴基斯坦间的球赛。这里有一个细节，小女孩的母亲怀孕期间就是在看一场板球比赛。在这场比赛中，印度输掉了比赛，当所有人都一脸失落时，唯独沙希达高兴地手舞足蹈，甚至冲到电视机面前，亲吻巴基斯坦国旗。男主小心翼翼地问小女孩，“巴基斯坦？”。小女孩的确认让男主悲喜交加，喜的是终于知道小女孩的身世，悲的是两国积怨久矣为岳父所不容。事实上两国曾因为流民而引发流血事件，电影中男主岳父仇视巴基斯坦人的原因恰在于此。这让我想到，阿米尔·汗主演的电影PK中，女主嘉谷爱上了一个穆斯林男孩，父母对穆斯林的偏见以及宗教对这段感情的干涉，差点让两个真心相爱的人分开。男主再次遭遇无奈，他前往领事馆希望寻求领事馆的帮助，领事馆以沙希达没有护照为由，拒绝为男主提供帮助，这里导演让我们了解了两国间的冲突到底有多严重，一场动乱导致领事馆暂停营业一个月。男主通过岳父介绍，找到一家旅游中介公司，对方声称需要12万卢比(约合人民币10000多元)，男主的女朋友甚至拿出了准备买房子的钱，可黑心中介转手就把沙希达卖到了妓院，一个6岁的小女孩啊，妓院是什么地方？</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/p2284899606.png" alt="安全感十足的大叔" title="">                </div>                <div class="image-caption">安全感十足的大叔</div>            </figure><p>&emsp;&emsp;电影开始介绍男主时说他学习不好，更不擅长体育运动(摔跤)。妓院里男主一个房间一个房间的找小女孩，当找到小女孩的时候，这个电影突然燃了起来，虽然按照角色设定，男主不应该有这样的身手，可事实上这名印度演员萨尔曼·汗，就是以健身达人的称号闻名于世的，据说他参与演出的电影都会安排裸露上身的戏份，这一次我们就当做主角光环好啦，甚至当看到黑中介在电线上荡秋千时，小女孩那纯真的笑脸，我能想到的只有一句话，“愿你被世界温柔对待”，这样一个可爱的小女孩，我愿意她一直都长不大，因为这个世界并没有那么好，幸运的是，她遇到了善良的猴神大叔。我很想知道，为什么人长大以后，反而更加不惮于勇险恶的用心去猜度别人，这到底是一种成熟，还是一种倒退。你大概不会想到，一个印度人，为了帮助一个萍水相逢的巴基斯坦人，在没有签证的情况下，冒着被当做间谍的风险，偷偷穿过两国边界的防线，只为了送这个小女孩回家，你说他不为博眼球出名，不为做好事谋利，他到底是为了什么？原谅我说句俗气的话，这就是爱啊！</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/p2513104611.jpg" alt="公交车司机的神助攻" title="">                </div>                <div class="image-caption">公交车司机的神助攻</div>            </figure><p>&emsp;&emsp;在穿越巴基斯坦边防线的时候，男主坚持要得到边防战士的批准后再入境，虽然这是一个讲述诚实和信念的励志故事，可我还是想说，遵从某种信念，并不是教条地照本宣科，而是在道德和法律允许的条件下适当变通。为什么要强调道德和法律呢？因为万物皆虚，万事皆座啊，《刺客信条》里刺客的信仰是每一代刺客都在追求的东西，以阿泰尔为例，他年轻时因为所罗门神殿任务的失败，而被降级为新手刺客，在完成刺杀9个圣殿骑士的任务中，他开始变得冷静而沉着，“万物皆虚，万事皆允”的理念开始变得越来越清晰。帕夫常常说他向哈奴曼神保证永远不偷偷摸摸，可他先后躲在清真寺里、车顶逃避警察搜捕，反而是那位伊斯兰教阿訇令人印象深刻，男主说自己不能进清真寺，阿訇说清真寺从来不锁门，所以任何人都可以进去。阿訇送男主一行三人离开后，以伊斯兰教礼仪祝福男主，并询问在印度教中如何表达祝福，随后以印度教礼仪向男主行礼，并煞有介事地问，“哈奴曼神在这里还管用？”。是啊，两个信仰不同的国家，素来相互仇视，可到了人家的地方，居然还要祈求本国的神灵护佑，这是不是有点讽刺呢？其实，宗教并不是要教会我们去排斥什么，而是要学会拥有一颗包容的心，只要一件事情的出发点是善良的，我相信这不会违背任何宗教的教义，佛家讲因果，道家讲无为，儒家讲修身，本质上都是劝人向善，大概爱是人类共同的语言，同样是神共同的语言。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/p2513104142.jpg" alt="阿訇以印度教礼仪祝福众人" title="">                </div>                <div class="image-caption">阿訇以印度教礼仪祝福众人</div>            </figure><p>&emsp;&emsp;一旦明白了这一点，你就会理解男主接下来所做的事情，比如在电话里向警察撒谎以躲避警察追捕、身为一个印度教徒参拜伊斯兰教神殿、在身上蒙上黑色衣袍伪装成伊斯兰教女子、以伊斯兰教礼仪向帮助他的人表示感谢……所谓“大道至简“，我希望我们相互去借鉴和学习不同领域里的东西，而不是相互对立和排斥彼此。《笑傲江湖》里的五岳剑派，一心想成为能和少林武当抗衡的江湖势力，其实像左冷禅这样的“宗师”级人物，如果可以以华山石壁上魔教长老破除各派剑法的图形为基础，集结各派所长，创造一门新的武功并不是不可能，奈何江湖人物一样逃不过权势的诱惑，想要扫除魔教势力，先破武当，再灭少林，再加上狭隘的门户之见，五岳剑派的辉煌不过是转眼云烟。想想《碧血剑》里大反派玉真子，一人一剑就敢上华山挑战，华山派的衰落可见一斑。如今全世界都被互联网连接在一起，文化间的相互影响越来越深，宗教如是，文化如是，不要以狭隘的民族观去审视我们不懂的文化，就如同不要觉得朋友圈里你不懂的东西Low一样，心态要开放，眼光要长远。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/p2504182255.jpg" alt="突然觉得生活美好起来" title="">                </div>                <div class="image-caption">突然觉得生活美好起来</div>            </figure><p>&emsp;&emsp;这部电影有太多的意料之中，同样有太多的意料之外。我知道小女孩会和母亲重逢，可我不知道真正打动我的是那一声叔叔；我知道男主会被警方逮捕，可我不知道巴方会想到屈打成招，理由仅仅是因为对方是一个印度人；我知道小女孩并不是哑巴，可我不知道原来说出一句话需要莫大的勇气……这里感谢那个电视台记者，这是一个媒体人的自我修养；感谢那个正直的警官，他没有给他的国家丢脸；感谢那些冲开边防线的巴基斯坦人民，有一种力量叫做民心所向。我希望两个国家可以像电影一样美好，不再有冲突，不再有流血，即使我知道现实中的困难远比电影中的多……可这的确是一群成年人的童话，就像电影最终定格在沙希达和她的猴神大叔拥抱在一起一样，有些美好值得我们去期待，有些东西值得我们去追寻，它们或许是爱，或许是正义，或许是善良，或许是信念，或许是和平，或许是勇敢……我猜中了故事的结尾，依然为这个故事而热泪盈眶，这一切并非是因为我矫情，而是因为我简单，简单到有些东西不必理解得那么深刻，就像我单纯地喜欢着你却不知道为什么一样。好了，这篇影评终于写完啦，晚安！<em>^_^</em></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/p2272195568.jpg" alt="永恒的瞬间" title="">                </div>                <div class="image-caption">永恒的瞬间</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="生活感悟" scheme="http://qinyuanpei.github.io/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="影评" scheme="http://qinyuanpei.github.io/tags/%E5%BD%B1%E8%AF%84/"/>
    
      <category term="电影" scheme="http://qinyuanpei.github.io/tags/%E7%94%B5%E5%BD%B1/"/>
    
      <category term="印度" scheme="http://qinyuanpei.github.io/tags/%E5%8D%B0%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>漫谈应用程序重试策略及其实现</title>
    <link href="http://qinyuanpei.github.io/posts/115524443/"/>
    <id>http://qinyuanpei.github.io/posts/115524443/</id>
    <published>2018-03-31T19:20:54.000Z</published>
    <updated>2018-08-24T05:39:27.482Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>&emsp;&emsp;最近随项目组对整个项目进行联调，在联调过程中暴露出各种问题，让我不得不开始反思，怎么样更好地去做好一件事情，譬如说在开发过程中如何保证Web服务的稳定性，在敏捷开发中如何降低文档维护的成本，以及如何提高多环境服务部署的效率等等。我为什么会考虑这些问题呢？通常我们都是在约定好接口后并行开发的，因此在全部接口完成以前，所有的服务都是以渐进的形式进行集成的，那么如何保证服务在集成过程中的稳定性呢？尤其当我们面对开发/测试/生产三套环境时，如何提高服务部署的效率呢？当接口发生变更的时候，如何让每一个人都知悉变化的细节，同时降低人员维护文档的成本呢？这些问题或许和你我无关，甚至这不是一个技术问题，可恰恰这是我们时常忽视的问题，我是我想要写这篇文章的一个重要原因。</p><h1 id="代码越来越复杂"><a href="#代码越来越复杂" class="headerlink" title="代码越来越复杂"></a>代码越来越复杂</h1><p>&emsp;&emsp;面对这种问题，尤其是当你发现，它并不是一个纯粹的技术问题的时候。选择一件你喜欢的事情的去做，固然可以令你开心；而选择一件你不喜欢的事情去做，则可以令你成长。我们每一个人都不是人类学家，可生命中80%的时间都在研究人类。当你接收到一条别人的讯息时，不管这个讯息本身或对或错，在生而为人的角色预设中，你都必须去提供一个响应，甚至是比对方期望更高的一个响应。可是服务器会返回403、404或者500甚至更多的状态码，人生有时候并没有机会去选择Plan B或者Plan C。所以，即使所面临境地再艰难，能不能勇敢地再去尝试一次，说服对方或者选择妥协，就像一段代码被修改得面目全非，可人类本来就是喜欢皆大欢喜的动物，总希望别人都认认真真，而自己则马马虎虎，因为“认真你就输了”，有谁喜欢输呢？</p><p>&emsp;&emsp;好了，现在假设我们有这样一个业务场景，我们需要调用一个WebAPI来获取数据，然后对这些数据做相关处理。这个API接口被设计为返回JSON数据，因此，这个“简单”的业务场景通过以下代码来实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract</span><span class="params">(url)</span>:</span></span><br><span class="line">    text = requests.get(url).content.decode(<span class="string">'utf-8'</span>)</span><br><span class="line">    json_data = json.loads(text)</span><br><span class="line">    data = json_data[<span class="string">'raw_data'</span>]</span><br><span class="line">    <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这个代码非常简单吧！可是过了十天半个月，每次解析JSON数据的时候随机出现异常，经验丰富的同事建议增加try…except，并在捕获到异常以后返回None。于是，extract()方法被修改为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract</span><span class="params">(url)</span>:</span></span><br><span class="line">    text = requests.get(url).content.decode(<span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        json_data = json.loads(text)</span><br><span class="line">        data = json_data[<span class="string">'raw_data'</span>]</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        print(<span class="string">"JSON数据无效，重试！"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;修改后的代码，果然比修改前稳定啦，可是负责后续流程的同事开始抱怨，现在代码中出现大量判断返回值是否为None的代码片段，甚至在Web API返回正确结果的情况下，依然会返回None，为此，机智的同事再次修改代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract</span><span class="params">(url)</span>:</span></span><br><span class="line">text = requests.get(url).content.decode(<span class="string">'utf-8'</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">        json_data = json.loads(text)</span><br><span class="line">        data = json_data[<span class="string">'raw_data'</span>]</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        print(<span class="string">"JSON数据无效，重试！"</span>)</span><br><span class="line">        <span class="keyword">return</span> extract(url)</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;可以预见的是，使用递归可能会导致递归的深度问题，假如调用者传入一个错误的URL，将导致这里无限递归下去，于是考虑限制重试的次数；增加重试次数的限制以后，发现每次重试需要有一个时间间隔……更不必说要在这里增加日志记录，以及在特定场景下需要将异常抛出，由此可见这段简单的代码会变得越来越复杂，如下所示：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract</span><span class="params">(url)</span>:</span></span><br><span class="line">    text = requests.get(url).content.decode(<span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        json_data = json.loads(text)</span><br><span class="line">        data = json_data[<span class="string">'raw_data'</span>]</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">            print(<span class="string">'正在进行第&#123;0&#125;次重试'</span>.format(str(i))</span><br><span class="line">            result = extract(url)</span><br><span class="line">            <span class="keyword">if</span>(result!=<span class="keyword">None</span>):</span><br><span class="line">                <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;可以注意到，这是一个非常合理的代码演进过程。在这个演进过程中，一段非常简单的代码变得越来越复杂。在我写下这篇文章前，我亲眼目睹了这种复杂的代码，是如何难以复用以及集成的，日志记录、异常处理等流程和正常流程“混合”在一起，甚至你不得不通过函数的返回值来判断是否异常，我一直在想怎么样去解决这些“corner”问题，就像人们一致认为：王垠博士擅长解决的是理想状态下的纯问题。而现实世界中存在着各种各样的“corner”问题，这或许就是学术界与工业界的区别，那么怎么样去更好地解决这一切问题呢？</p><h1 id="应用程序重试策略"><a href="#应用程序重试策略" class="headerlink" title="应用程序重试策略"></a>应用程序重试策略</h1><p>&emsp;&emsp;既然我们可以预见到这些问题的存在，那么，现在让我们正式切入今天这篇博客的主题，即应用程序重试策略。我们在这里以一种渐进式的方式，向大家展示了一个简单的应用程序，是如何因为异常处理变得越来越复杂的，这里我们选择重试，是因为现实世界本身存在不稳定性，即使我们现在有各种自动化工具来替代传统运维。就像有时候你怀疑是代码出现Bug，实际上则是服务器在某一段时间内宕机，当这种事情就发生在你身边的时候，你不得不去着手解决这些“corner”问题，而这恰好是人生的无奈之处。</p><h2 id="Try-Catch-Redo策略"><a href="#Try-Catch-Redo策略" class="headerlink" title="Try-Catch-Redo策略"></a>Try-Catch-Redo策略</h2><p>&emsp;&emsp;这应该是我们最容易想到的一种重试策略了，其思路是对函数的返回值和异常进行处理，其缺点是无法解决重试无效的问题。这里我们将问题简化为对异常进行处理，其基本的代码实现如下：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Retry</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">var</span> result = DoWork();</span><br><span class="line">    <span class="keyword">if</span>(!result)&#123;</span><br><span class="line">      <span class="comment">//重试一次</span></span><br><span class="line">      Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">      DoWork();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span>(Exception e)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//重试一次</span></span><br><span class="line">    Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">    DoWork();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;可以注意到，这种策略最多可以重试一次，因此如果重试后无效，这个策略就变得毫无意义起来，我们需要寻找一种更好的方式。</p><h2 id="Try-Catch-Redo-Retry策略"><a href="#Try-Catch-Redo-Retry策略" class="headerlink" title="Try-Catch-Redo-Retry策略"></a>Try-Catch-Redo-Retry策略</h2><p>&emsp;&emsp;考虑到第一种策略无法解决重试无效的问题，我们在此基础上增加对重试次数以及重试间隔的控制，这就是Try-Catch-Redo-Retry策略，其基本实现如下：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Retry</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//最大重试次数为5次</span></span><br><span class="line">    <span class="keyword">int</span> times = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">//重试间隔为10秒</span></span><br><span class="line">    <span class="keyword">int</span> interval = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//存储异常的列表</span></span><br><span class="line">    <span class="keyword">var</span> exceptions = <span class="keyword">new</span> List&lt;Exception&gt;();</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> result = DoWrok();</span><br><span class="line">            <span class="keyword">if</span>(result) <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(Exception ex)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(--times&lt;=<span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> AggregateException(exceptions);</span><br><span class="line">            exceptions.Add(ex);</span><br><span class="line">            Thread.Sleep(TimeSpan.FromSeconds(interval));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;可以注意到，通过while(true)结构的确可以增加重试的次数。问题在于：如果不设置合理的循环跳出条件，就有可能造成逻辑上的死循环。尤其当循环体内的逻辑执行时间较长时，会增加用户的等待时间，这看起来亦非良策啊！</p><h2 id="Retry-Builder策略"><a href="#Retry-Builder策略" class="headerlink" title="Retry-Builder策略"></a>Retry-Builder策略</h2><p>&emsp;&emsp;Try-Catch-Redo和Try-Catch-Redo-Retry这两种策略理解起来非常容易，可这两种策略都有一个致命的缺陷，即正常逻辑和重试逻辑重度耦合。我们希望采用一种更优雅的方法，以一种非侵入式的方式给正常逻辑增加重试重试逻辑。需要考虑的是，在确保重试次数和重试间隔可配置的前提下，支持自定义重试源，即可以捕捉一个或多个异常以及对返回值进行处理。在这里推荐三个框架，分别是Java中的<a href="https://docs.spring.io/spring-batch/trunk/reference/html/retry.html" target="_blank" rel="noopener">Spring-Retry</a>和<a href="https://github.com/rholder/guava-retrying" target="_blank" rel="noopener">Guava-Retrying</a>、.NET中的<a href="https://github.com/App-vNext/Polly" target="_blank" rel="noopener">Polly</a>。其中Spring-Retry是基于Throwable类型的重试机制，即针对可捕获异常执行重试策略，并提供相应的回滚策略；而Guava-Retrying提供了更为丰富的重试源定义，譬如多个异常或者多个返回值；而Polly则提供了除重试以外的断路器、超时、隔板隔离、缓存、回退等多种策略。这三者的相似之处在于，通过一个Factory来创建满足不同重试策略的Retryer，然后由Retryer来通过回调来执行重试逻辑，我不喜欢Java中回调函数写法，所以这里以Polly为例：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> retryTwoTimesPolicy = Policy</span><br><span class="line">        .Handle&lt;DivideByZeroException&gt;()</span><br><span class="line">        .Retry(<span class="number">3</span>, (ex, count) =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"执行失败! 重试次数 &#123;0&#125;"</span>, count);</span><br><span class="line">            Console.WriteLine(<span class="string">"异常来自 &#123;0&#125;"</span>, ex.GetType().Name);</span><br><span class="line">        &#125;);</span><br><span class="line">    retryTwoTimesPolicy.Execute(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">var</span> b = <span class="number">1</span>/a;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (DivideByZeroException e)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">$"Excuted Failed,Message: (<span class="subst">&#123;e.Message&#125;</span>)"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;可以看到，写出一段语义化的代码是多么的重要，因为我相信大家都看懂了。这里的Policy承担了RetryBuilder的角色，它定义了这样一种策略：当程序引发DivideByZeroException时进行重试，重试次数为3次，并且以匿名函数的方式指定了重试时的回调函数；而创建的retryTowTimesPolicy承担了Retryer的角色，它通过Execute()方法来定义要执行的重试逻辑。当3次都重试失败时就会引发DivideByZeroException并在最外层函数中被捕捉到。我经常听到有人说设计模式没有用，我想说因为你从来都不知道什么叫做大道至简，引入无数个中间层是无法让你直接看到代码定义，可计算机领域里有一句名言，“任何一个问题都可以通过引入一个中间层来得到解决”。</p><h2 id="装饰器-AOP策略"><a href="#装饰器-AOP策略" class="headerlink" title="装饰器/AOP策略"></a>装饰器/AOP策略</h2><p>&emsp;&emsp;我从来不惮于将各种重复的工作自动化，这并不是我喜欢在别人面前炫技，而是因为在现实生活中我是一个懒惰的人，甚至是每天早上10点开站会这样的事情，我都愿意让计算机程序去提前通知我做好准备。我并不是一个不懂得自律的人，仅仅是因为我觉得我们可以用这个时间去做些别的事情。AOP是一种可以在运行时期间动态修改代码的技术，我们自然可以想到给所有的函数都加上异常处理和重试的特性，幸运的是Python中的有这样一个第三方库：<a href="http://tenacity.readthedocs.io/en/latest/" target="_blank" rel="noopener">Tenacity</a>，它可以帮助我们优雅地实现重试：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tenacity <span class="keyword">import</span> retry</span><br><span class="line"><span class="keyword">from</span> json.decoder <span class="keyword">import</span> JSONDecodeError</span><br><span class="line"></span><br><span class="line"><span class="meta">@retry(retry=retry_if_exception_type(JSONDecodeError), wait=wait_fixed(5), stop=stop_after_attempt(3))</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract</span><span class="params">(url)</span>:</span></span><br><span class="line">    text = requests.get(url).content.decode(<span class="string">'utf-8'</span>)</span><br><span class="line">    json_data = json.loads(text)</span><br><span class="line">    data = json_data[<span class="string">'raw_data'</span>]</span><br><span class="line">    <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;通过@retry这个装饰器函数，我们就可以知道，这里设计的重试策略是：当引发JSONDecodeError这个异常时，每隔5秒中重试一次，最大重试次数为3次。Python中的装饰器，本质上就是高阶函数的概念，修饰器函数对被修饰函数进行“操作”后返回一个新的函数，这个特性在.NET中可以通过委托/匿名方法/lambda来实现，结合Unity、AspectCore等AOP框架，相信大家完全可以将这个特性移植到.NET中来，当语言的差别变得微乎其微的时候，原理的重要性不言而喻。</p><h2 id="重试策略核心理念"><a href="#重试策略核心理念" class="headerlink" title="重试策略核心理念"></a>重试策略核心理念</h2><p>&emsp;&emsp;好了，截止到目前，我们分析了四种不同的重试策略，并且这四种重试策略是随着我们认知的加深而逐渐递进的。那么，通过这四种不同的重试策略，我们能否梳理出一个相对完整的应用程序重试策略呢？换言之，当为应用程序增加重试相关的功能时，我们都需要考虑哪些因素，因为使用这些框架会是非常简单的过程，而更重要的则是我们逐步演进的思考过程。当我们所依赖的是一个不稳定的场景，譬如远程调用、数据加载、数据上传等场景时，或者是在异常场景中需要重试以满足业务稳定性的要求等等，就可以考虑使用重试策略。这里简单地做一下梳理：</p><ul><li>重试逻辑与正常逻辑解耦，整个设计是非侵入式的。</li><li>支持自定义策略，譬如重试次数、重试间隔、重试源、重试超时时间等。</li><li>支持自定义断言，即可以使用Predict<t>或者类似表达式来定义返回值满足的条件。</t></li><li>支持多种异常，即可以针对特定的Exception或者自定义的Exception进行拦截。</li><li>断言实例和异常实例，作为正常逻辑和重试逻辑两者间的媒介进行交互。</li><li>通过命令模式，由Retryer对象完成对正常逻辑的调用，同时在内部封装重试逻辑。</li></ul><h1 id="一个简单的Retry实现"><a href="#一个简单的Retry实现" class="headerlink" title="一个简单的Retry实现"></a>一个简单的Retry实现</h1><p>&emsp;&emsp;好了，熟悉我写作风格的朋友，一定知道我不喜欢空泛地讲一套理论，我更喜欢通过“造轮子”的这种方式，以加深对一个事物或者原理的认识。对于今天这篇文章，我的初衷是想告诉大家如何优雅地去实现Retry，因为在现实中我们总会遇到各种各样的枷锁，这些枷锁约束着你写出糟糕的代码，我们比别人用心甚至更努力，反而常常被认为是有代码洁癖或者是炫技，可不管怎么样，人生是我们自己的，如果没有办法说服别人在项目中使用这些技术，那我们就在项目以外的地方去使用，或者是告诉别人我们有一种相对优雅的设计，如果这个设计恰好对别人有用，对我们来说就是一种莫大的幸福。参考Polly的API风格，这个Retry被我设计成了下面的样子：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> result = Retry.Default</span><br><span class="line">    .Times(<span class="number">3</span>)</span><br><span class="line">    .Interval(<span class="number">2</span>)</span><br><span class="line">    .Catch&lt;DivideByZeroException&gt;()</span><br><span class="line">    .Reject((count,ex)=&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> message = <span class="keyword">string</span>.format(<span class="string">"第&#123;0&#125;次重试，异常来自:&#123;1&#125;"</span>, count, ex.Message);</span><br><span class="line">        Trace.WriteLine(message);</span><br><span class="line">    &#125;)</span><br><span class="line">    .Execute&lt;<span class="keyword">int</span>&gt;(()=&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span> / m;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(Exeption ex)</span><br><span class="line">&#123;</span><br><span class="line">    Trace.WriteLine(ex.Message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;我承认它和Polly非常地像，不过我并没有去看Polly是如何实现的，目前它的实现完全来自这篇文章中我们提到的这些策略。我在为它增加了针对返回值的断言支持，通过Return方法来实现，而对异常的支持则是通过Catch方法来实现，除此以外，它支持异步方法调用，我们熟悉的Task/async/await这些API都可以使用。目前它还是一个玩具儿，因为我发现最难的部分，其实是断言或者说自定义表达式的设计，对于线程安全相关的问题，我会在慢慢地去完善它，如果你对它感兴趣的话，可以通过这里访问：<a href="https://github.com/qinyuanpei/RetryIt" target="_blank" rel="noopener">RetryIt</a>。好了，感谢大家关注我的博客，今天这篇先写到这里啦，欢迎大家在博客中留言！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="编程语言" scheme="http://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="异常" scheme="http://qinyuanpei.github.io/tags/%E5%BC%82%E5%B8%B8/"/>
    
      <category term="重试" scheme="http://qinyuanpei.github.io/tags/%E9%87%8D%E8%AF%95/"/>
    
      <category term="想法" scheme="http://qinyuanpei.github.io/tags/%E6%83%B3%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>使用Unity框架简化应用程序异常处理及日志记录流程</title>
    <link href="http://qinyuanpei.github.io/posts/3291578070/"/>
    <id>http://qinyuanpei.github.io/posts/3291578070/</id>
    <published>2018-03-21T19:35:40.000Z</published>
    <updated>2018-08-24T05:39:27.478Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>&emsp;&emsp;最近公司安排学习项目代码，前后花了一周左右的时间，基本熟悉了项目中的各个模块，感觉项目难度上整体偏中等。这是一个具备完整前端和后端流程的项目，在学习这个项目的过程中，我逐渐发现某些非常有趣的东西，比如在Web API的设计中采用严谨而完善的错误码、使用OAuth和JWT对API资源进行访问控制，在JavaScript中使用修饰器特性来实现日志记录等等，这些东西我会在后续的博客逐步去整理，今天想说的是如何通过Unity框架来简化应用程序异常处理和日志记录流程，而之所以关注这个问题，是因为我发现项目中接近滥用的异常处理，以及我不能忍受的大量重复代码。</p><h1 id="背景描述"><a href="#背景描述" class="headerlink" title="背景描述"></a>背景描述</h1><p>&emsp;&emsp;由于业务场景上的需要，我们在产品中集成了大量第三方硬件厂商的SDK，这些SDK主要都是由C/C++编写的动态链接库，因此在使用这些SDK的过程中，通常频繁地使用返回值来判断一个方法是否成功被调用，虽然项目上制定了严格的错误码规范，可当我看到大量的Log()方法和业务逻辑混合在一起时，我内心依然是表示拒绝的，甚至我看到在捕获异常以后记录日志然后继续throw异常，这都是些什么鬼操作啊，考虑到我的语言描述得可能不太准确，大家可以从下面两段代码来感受下整体画风：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">short</span> <span class="title">LoginTerminal</span>(<span class="params"><span class="keyword">string</span> uid,<span class="keyword">string</span> pwd</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">    Log.BeginLog()</span><br><span class="line">    <span class="keyword">return</span> SDK.Login(uid,pwd)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">catch</span>(Exception ex)</span><br><span class="line">&#123;</span><br><span class="line">    log.LogError(ErrorCode.E2301,ex)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> TerminalException(ex.Message);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">    Log.EndLog()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这是一段相对完整的业务逻辑代码，当然这里都是伪代码实现，这里我比较反感的两个地方是：第一，从头出现到尾的BeginLog()/EndLog()这对方法；第二，在Catch块中记录完日志然后将异常再次抛出。经过我对项目的一番了解，BeginLog()/EndLog()这对方法会在日志中记录某个方法开始执行和结束执行的位置。在方法执行前后插入代码片段，这不就是面向切面编程(AOP)的思想吗？这里记录完日志然后再抛出异常的做法，我个人是不大认同的，因为我觉得拦截异常应该有一个统一的入口，因为异常会继续向上传递，既然如此，为什么我们不能统一地去处理异常和记录日志呢？难道就一定要让Log这个静态类无处不在吗？同样地，我们注意到项目还会有下面这样的代码：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ProcessTerminal</span>(<span class="params"><span class="keyword">object</span> sender,ProcessEventArgs args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        Log.BeginLog();</span><br><span class="line">        <span class="keyword">var</span> terminal = (Termainal)sender;</span><br><span class="line">        <span class="keyword">var</span> result = terminal.Process(args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span></span><br><span class="line">    &#123;</span><br><span class="line">        Log.EndLog();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这种代码看起来不再关注异常，可和第一段一样，从头出现到尾的BeginLog()/EndLog()简直不能忍，而且这里的try…finally结构难免让人想起using的语法糖，那么这样是不是可以考虑让这个Log拥有类似的结构，换言之，我们总不能一直都在每一个方法里，重复写BeginLog()/EndLog()这两个方法吧，既然EndLog()方法总是在finally块里被执行，那为什么不考虑把它放到Dispose()方法里(前提是有一个结构实现IDispose接口)。你问我是不是有代码洁癖啊？我真的没有，我就是懒，不喜欢重复做一件事情。所谓”管中窥豹，可见一斑”，大家可以想象整个项目会是什么样子。</p><p>&emsp;&emsp;好了，为了避免让自己写这种糟糕的代码，我决心使用Unity框架来简化下这里的异常处理和日志记录流程，一个有追求的程序，如果可以交给自动化工具去做的事情，为什么要一次又一次地重复去写呢？我们可以吐槽一段代码写得有多糟糕，可我们所做的任何努力，都是为了让自己不变成这个样子。Unity框架提供的AOP，即面向切面编程，不就可以做这样的事情吗？所以，能动手的就直接动手，君子有所为有所不为，不要重复自己，</p><h1 id="Unity框架与AOP"><a href="#Unity框架与AOP" class="headerlink" title="Unity框架与AOP"></a>Unity框架与AOP</h1><p>&emsp;&emsp;好啦，交待完故事背景，今天的主角终于可以登场啦！经常关注我博客的朋友，一定知道我个人比较喜欢IoC/AOP这类所谓的”奇技淫巧”，就在今天我还在和一位同事在讨论Ioc，这位同事认为Ioc增加了代码的复杂性，不认为Ioc会为项目带来明显的便利性。其实我相信大道至简，任何框架对我们而言都是高度抽象的，可正是因为有了这些抽象的层次，我们渐渐学会了关注核心的东西。这里提到了Ioc，即控制反转，或者我们可以称之为依赖注入，那么Unity框架就是.NET下众多依赖注入框架之一，这里称之为Unity框架，主要是避免和跨平台游戏引擎Unity产生混淆，以下全部称之为Unity框架。Unity框架中提供了核心的依赖注入相关的接口，而微软的企业最佳实践库中为Unity扩展出了AOP相关的功能。除此以外，Spring.NET、Aspect.Core、AspectF等都是.NET下的AOP方案。那么在今天的故事中，我们遇到了的一个场景是在指定方法执行前、后插入代码片段，这是面向切面编程(AOP)的基本思想，为此，我们考虑使用Unity框架来简化应用程序中异常处理及日志记录流程。</p><h2 id="Unity中的三种拦截器"><a href="#Unity中的三种拦截器" class="headerlink" title="Unity中的三种拦截器"></a>Unity中的三种拦截器</h2><p>&emsp;&emsp;Unity中提供了三种典型的拦截器，为了选择一种合适的拦截器来实现我们的功能，我们首先来了解下这三种不同的拦截器各自的应用场景：</p><ul><li>TransparentProxyInterceptor：即透明代理拦截器，基于.NET Remoting 技术实现代理，它可以拦截对象的所有函数，缺点是被拦截对象必须继承自MarshalByRefObject。</li><li>InterfaceInterceptor：顾名思义，即接口拦截器，仅拦截指定接口，显然只要目标类型实现了指定接口就可以拦截。C#不支持多继承，选择这种方式对代码的影响最小。</li><li>VirtualMethodInterceptor：顾名思义，即虚方法拦截器，仅拦截虚方法，这个对目标类型的要求就非常高啦，一般我们不会考虑这种方式。</li></ul><p>对Unity框架而言，不管我们使用哪一种拦截器，我们都需要通过UnityContainer这个容器来为目标类型注入拦截器，这样Unity框架会帮助我们生成代理对象，我们只要在使用代理对象的时候，这些拦截器才会真正工作。博主曾经以为定义好下面这些Handler就可以了，简直是图样图森破。好了，一个基本的代码流程如下，请不要问我配置文件怎么配，我真的不喜欢配置文件，搞得跟某配置狂魔语言似的，反正这些配置文件这次记住了下次还是会忘的，可下面这几行代码是不会轻易忘记的啊：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> container = <span class="keyword">new</span> UnityContainer().AddNewExtension&lt;Interception&gt;().RegisterType&lt;IBussiness, Bussiness&gt;();</span><br><span class="line">container.Configure&lt;Interception&gt;().SetInterceptorFor&lt;IBussiness&gt;(<span class="keyword">new</span> InterfaceInterceptor());</span><br><span class="line"><span class="keyword">var</span> bussiness = container.Resolve&lt;IBussiness&gt;();</span><br></pre></td></tr></table></figure></p><p>注意，这里不要直接从Github或者Nuget上下载Unity框架，因为最新版的Unity我实在是不会用啊！:joy: 我喜欢开箱即用的产品，我愿意钻研啊，可DeadLine永远会有终点！<br>我们需要从微软企业最佳实践库中<a href="https://www.microsoft.com/en-us/download/details.aspx?id=38789" target="_blank" rel="noopener">下载</a>以下动态链接库：</p><ul><li>CommonServiceLocator.dll</li><li>Microsoft.Practices.Unity.Configuration.dll</li><li>Microsoft.Practices.Unity.dll</li><li>Microsoft.Practices.Unity.Interception.Configuration.dll</li><li>Microsoft.Practices.Unity.Interception.dll<br>考虑到我们这里需要实现两种功能，针对异常的异常处理流程，以及正常的日志记录流程，为此我们将实现ExceptionHandler和LogHandler两个组件。下面我们来一起了解这两个组件的实现过程，这里博主选择了最简单的ICallHandler接口，而非更一般的IInterceptionBehavior接口，主要希望让这个过程更简单些，同时实现在方法粒度上的可控，即我们可以选择性的去拦截某一个方法，而非全部的方法，因为在实际业务中并非所有的方法都需要拦截。</li></ul><h2 id="LogHandler的实现"><a href="#LogHandler的实现" class="headerlink" title="LogHandler的实现"></a>LogHandler的实现</h2><p>&emsp;&emsp;LogHandler主要用于记录日志，所以我们需要记录方法的名字，方法的参数以及方法执行的结果，甚至是是否引发异常，这些功能在AOP中是相对基础的功能，Unity框架为我们提供了这些基础设施，我们只要就可以获取到这些信息，然后将其记录到日志中即可。这里的代码如下：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LogHandler</span> : <span class="title">ICallHandler</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> ICallHandler.Order &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    IMethodReturn ICallHandler.Invoke(IMethodInvocation input, GetNextHandlerDelegate getNext)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> methodInfo = input.MethodBase;</span><br><span class="line">        <span class="keyword">var</span> methodName = methodInfo.Name;</span><br><span class="line">        Logger.Log(<span class="keyword">string</span>.Format(<span class="string">"----------开始调用&#123;0&#125;----------"</span>, methodName));</span><br><span class="line">        <span class="keyword">var</span> parameters = methodInfo.GetParameters();</span><br><span class="line">        <span class="keyword">var</span> arguments = input.Arguments;</span><br><span class="line">        <span class="keyword">var</span> logInfo = parameters.Select(e =&gt; <span class="keyword">string</span>.Format(<span class="string">"&#123;0&#125;:&#123;1&#125;"</span>, e.Name, arguments[e.Position]));</span><br><span class="line">        Logger.Log(<span class="string">"传入的参数为:"</span> + <span class="keyword">string</span>.Join(<span class="string">","</span>, logInfo.ToArray()));</span><br><span class="line">        <span class="keyword">var</span> result = getNext()(input, getNext);</span><br><span class="line">        <span class="keyword">if</span> (result.Exception != <span class="literal">null</span>)</span><br><span class="line">            Logger.Log(<span class="keyword">string</span>.Format(<span class="string">"调用异常:&#123;0&#125;-&#123;1&#125;"</span>, result.Exception.Message, result.Exception.StackTrace));</span><br><span class="line">        Logger.Log(<span class="keyword">string</span>.Format(<span class="string">"调用&#123;0&#125;的结果为：&#123;1&#125;"</span>, methodName, result.ReturnValue));</span><br><span class="line">        Logger.Log(<span class="keyword">string</span>.Format(<span class="string">"----------结束调用&#123;0&#125;----------"</span>, methodName));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为了让这个Handler更好用一些，我们希望它可以以Attribute的方式出现在方法上面，这样被标记过的方法就会被Unity框架拦截，所以我们需要一个继承自Attribute类的东西，知道我为什么不喜欢配置文件吗？因为我有Attribute啊！幸运的是Unity框架为我们提供了这样一个基类：HandlerAttribute，由此下面的代码可以这样写：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">AttributeUsage(AttributeTargets.Method,AllowMultiple = true)</span>]</span><br><span class="line"><span class="keyword">class</span> <span class="title">LogHandlerAttribute</span> : <span class="title">HandlerAttribute</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> ICallHandler <span class="title">CreateHandler</span>(<span class="params">IUnityContainer container</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LogHandler();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="ExceptionHandler的实现"><a href="#ExceptionHandler的实现" class="headerlink" title="ExceptionHandler的实现"></a>ExceptionHandler的实现</h2><p>&emsp;&emsp;对于ExceptionHandler来说，它相比LogHandler增加的功能在于，它需要处理异常，按照目前项目的异常处理习惯，这种和硬件相关的方法都会被定义为一个ErrorCode，为此我们的ExceptionHandler类中需要增加一个ErrorCode类型的成员，这是一个枚举类型。这里的代码实现如下：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ExceptionHandler</span> : <span class="title">ICallHandler</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> ICallHandler.Order &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> ErrorCode &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    IMethodReturn ICallHandler.Invoke(IMethodInvocation input, GetNextHandlerDelegate getNext)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> methodInfo = input.MethodBase;</span><br><span class="line">        <span class="keyword">var</span> methodName = methodInfo.Name;</span><br><span class="line">        Logger.Log(<span class="keyword">string</span>.Format(<span class="string">"--------------方法&#123;0&#125;执行开始--------------"</span>, methodName));</span><br><span class="line">        <span class="keyword">var</span> parameters = methodInfo.GetParameters();</span><br><span class="line">        <span class="keyword">var</span> arguments = input.Arguments;</span><br><span class="line">        <span class="keyword">var</span> logInfo = parameters.Select(e =&gt; <span class="keyword">string</span>.Format(<span class="string">"&#123;0&#125;:&#123;1&#125;"</span>, e.Name, arguments[e.Position]));</span><br><span class="line">        Logger.Log(<span class="string">"传入的参数为:"</span> + <span class="keyword">string</span>.Join(<span class="string">","</span>, logInfo.ToArray()));</span><br><span class="line">        <span class="keyword">var</span> result = getNext()(input, getNext);</span><br><span class="line">        <span class="keyword">if</span> (result.Exception != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Logger.Log(<span class="keyword">string</span>.Format(<span class="string">"Error Code is &#123;0&#125;"</span>, ErrorCode));</span><br><span class="line">            result.Exception = <span class="literal">null</span>;</span><br><span class="line">            Logger.Log(<span class="keyword">string</span>.Format(<span class="string">"--------------方法&#123;0&#125;执行结束--------------"</span>, methodName));</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(ErrorCode);</span><br><span class="line">        &#125;</span><br><span class="line">        Logger.Log(<span class="keyword">string</span>.Format(<span class="string">"--------------方法&#123;0&#125;执行结束--------------"</span>, methodName));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以注意到ExceptionHandler相比LogHandler的变化，主要发生在异常处理这部分，如你所愿，我在拦截到异常以后抛出了一个对应ErrorCode的异常，虽然我不赞同这种做法，但为了尊重现有项目的编程风格，我只能写有这样一行看起来非常拙劣的代码，我真的没有代码洁癖，我仅仅是觉得它还不够好，就像我觉得自己还不够好一样，同样，它需要定义一个对应的Attribute类，这样我们可以更加自由地使用这些特性：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">AttributeUsage(AttributeTargets.Method,AllowMultiple = true)</span>]</span><br><span class="line"><span class="keyword">class</span> <span class="title">LogHandlerAttribute</span> : <span class="title">HandlerAttribute</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> ICallHandler <span class="title">CreateHandler</span>(<span class="params">IUnityContainer container</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LogHandler();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>&emsp;&emsp;好了，现在我们可以来看，如何使用这篇文章中定义的两个组件：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> container = <span class="keyword">new</span> UnityContainer().AddNewExtension&lt;Interception&gt;().RegisterType&lt;IBussiness, Bussiness&gt;();</span><br><span class="line">container.Configure&lt;Interception&gt;().SetInterceptorFor&lt;IBussiness&gt;(<span class="keyword">new</span> InterfaceInterceptor());</span><br><span class="line"><span class="keyword">var</span> bussiness = container.Resolve&lt;IBussiness&gt;();</span><br><span class="line"><span class="keyword">var</span> sum = bussiness.Add(<span class="number">12</span>,<span class="number">23</span>);</span><br><span class="line">Console.WriteLine(sum);</span><br><span class="line"><span class="keyword">var</span> div = bussiness.Divide(<span class="number">1</span>,<span class="number">0</span>)</span><br><span class="line">Console.WriteLine(div)</span><br></pre></td></tr></table></figure></p><p>IBussiness接口及其实现类Bussiness定义如下：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IBussiness</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Add</span>(<span class="params"><span class="keyword">int</span> a, <span class="keyword">int</span> b</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Divide</span>(<span class="params"><span class="keyword">int</span> a, <span class="keyword">int</span> b</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Bussiness : MarshalByRefObject, IBussiness</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">LogHandler</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Add</span>(<span class="params"><span class="keyword">int</span> a, <span class="keyword">int</span> b</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">ExceptionHandler(ErrorCode = <span class="meta-string">"E2303"</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Divide</span>(<span class="params"><span class="keyword">int</span> a, <span class="keyword">int</span> b</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a / b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>好了，现在我们来看一下结果：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img-blog.csdn.net/20180320235018714" alt="使用AOP简化后的异常处理和日志记录流程" title="">                </div>                <div class="image-caption">使用AOP简化后的异常处理和日志记录流程</div>            </figure></p><p>&emsp;&emsp;我们为此付出的代价是什么？第一，要有一个接口，写接口难道还有疑问吗？第二，要添加Attribute到指定方法上面，我保证这点时间足够你写好几遍重复代码了。第三，需要依赖注入机制，这个可能是到目前为止最大的影响，因为有了依赖注入以后，对象的实例化都交给了Unity框架，看起来我们好像被束缚了手脚，不能再任性地new一个对象实例出来，可这不正是依赖注入的精髓所在吗？我们就是需要Unity框架，来帮助我们管理这些模块间的依赖关系及其生命周期，如果你觉得这点代码不能接受，抱歉，任何依赖注入框架拯救不了你！</p><p>&emsp;&emsp;今天这篇文章，我们从一个实际项目的背景出发，引出使用Unity框架来简化异常处理和日志记录流程这一想法，在正式实践这一想法前，我们首先了解了Unity框架中提供的三种拦截器及其各自优劣，在此基础上我们实现了LogHandler和ExceptionHandler两个组件，并展示了如何使用这两个组件，探讨使用整个AOP机制对现有项目的影响有多大，以及为什么我们需要Unity框架等问题，框架固然重要，了解为什么使用框架则更重要！好啦，这就是今天这篇文章的内容啦，再次谢谢大家关注我的博客，各位晚安！:smile:</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="编程语言" scheme="http://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="AOP" scheme="http://qinyuanpei.github.io/tags/AOP/"/>
    
      <category term="异常" scheme="http://qinyuanpei.github.io/tags/%E5%BC%82%E5%B8%B8/"/>
    
      <category term="日志" scheme="http://qinyuanpei.github.io/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>基于新浪微博的男女性择偶观数据分析(下)</title>
    <link href="http://qinyuanpei.github.io/posts/3083474169/"/>
    <id>http://qinyuanpei.github.io/posts/3083474169/</id>
    <published>2018-03-17T15:28:40.000Z</published>
    <updated>2018-08-24T05:39:27.478Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>&emsp;&emsp;各位朋友，大家好，我是Payne，欢迎大家关注我的博客。我的博客地址是：<a href="https://qinyuanpei.github.io">https://qinyuanpei.github.io</a>。对于今天这篇文章的主题，相信经常关注我博客的朋友一定不会陌生。因为在2017年年底的时候，我曾以此为题写作了一篇文章：<a href="https://qinyuanpei.github.io/posts/1386017461/">基于新浪微博的男女择偶观数据分析(上)</a>。这篇文章记录了我当时脑海中闪烁着的细微想法，即当你发现一件事物背后是由哲学或者心理学这类玄奥的科学在驱动的时候，不妨考虑使用数学的思维来让一切因素数量化，我想这是最初数据分析让我感兴趣的一个原因。因为当时对文本的处理了解得非常粗浅，所以在第一次写作这篇文章的时候，实际的工作不过是在分词后绘制词云而已。等到我完成对微信好友信息的数据分析以后，我意识到微博这里其实可以继续发掘。关于微信好友信息的数据分析，可以参考这篇文章：<a href="https://qinyuanpei.github.io/posts/2805694118/">基于Python实现的微信好友数据分析</a>。在这样的想法促使下，便有了今天这篇文章，因为工作关系一直没有时间及时整理出来，希望这篇文章可以带给大家一点启示，尤其是在短文本分类方面，这样我就会非常开心啦！:slightly_smiling_face:</p><h1 id="故事背景"><a href="#故事背景" class="headerlink" title="故事背景"></a>故事背景</h1><p>&emsp;&emsp;关于故事背景，我在 <a href="https://qinyuanpei.github.io/posts/1386017461/">基于新浪微博的男女择偶观数据分析(上)</a> 这篇文章中说得非常清楚啦。起因就是我想知道，男性和女性在选择伴侣的时候，到底更为关注哪些因素？在对微信好友信息进行数据分析的时候，我们可以非常直接地确定，譬如性别、签名、头像、位置这四个不同的维度，这是因为我们处理的是结构化的数据。什么是结构化的数据呢？一个非常直观的认识是，这些数据可以按照二维表的方式组织起来。可对于微博这样一个无结构的文本数据类型，我们除了对词频、词性等因素做常规统计分析以外，好像完全找不到一个合理有效的方案，因为我们很容易就明白一件事情，即：<strong>在短短的140个字符中，人类语言的多样性被放大到淋漓尽致</strong> 。为了将种种离散的信息收敛在一个统一的结构里，我们必须为这些文本构建一种模型，并努力使这种模型可以量化和计算。我们通过词云对微博进行可视化分析，更多是针对词频的一种分析方法，这种方法虽然可以帮助我们找出关键字，可是因为最初写作这篇文章时，对数据分析领域相关知识知之甚少，而且在分析的过程中没有考虑停用词，所以我认为在文本分类或者是主题提取层面上，我们都需要一种更好的方法。</p><h1 id="常见的技术方法"><a href="#常见的技术方法" class="headerlink" title="常见的技术方法"></a>常见的技术方法</h1><p>&emsp;&emsp;这篇文章涉及的领域称为<strong>文本分类</strong>或者<strong>主题提取</strong>，而针对微博、短信、评论等这类短文本的分类，则被称为<strong>短文本分类</strong>。为什么要进行文本分类呢？第一，<strong>提取出潜在主题以后可以帮助我们做进一步的分析</strong>。譬如博主这里想要从相亲类微博中分析男性和女性的择偶观，首先要解决的就是主题建模问题，因为在择偶过程中要考虑的因素会非常多，我们到底要选取哪些因素来分析呢？这些因素在特定领域中被称为特征，所以文本分类的过程伴随着特征提取。第二，<strong>短文本数据通常只有一个主题，看起来这是在简化我们的分析过程，实则传统的基于文档的主题模型算法在这里难以适用。</strong>因为这类主题模型算法都假定一篇文档中含有多个主题，而我们分析的是群体现象，这种个体上的差异必须设法将其统一于一体，比如美元和$属于同一个主题，我们需要一种策略来对其进行整合。</p><p>&emsp;&emsp;传统主题提取模型通常由<strong>文本预处理</strong>、<strong>文本向量化</strong>、<strong>主题挖掘</strong>和<strong>主题表示</strong>等多个流程组成，每个流程都会有多种处理方法，不同的组合方法会产生不同的建模结果。目前，人们在传统主题提取模型的基础上，发展起了以<strong>CNN</strong>和<strong>RNN</strong>为代表的深度学习方法，在这里我们依然关注传统主题提取模型，因为这个领域对博主而言是个陌生的领域，这里我们更多的是关注传统主题提取模型。按照传统主题提取模型，文本分类问题被拆分为<strong>特征工程</strong>和<strong>分类器</strong>两个部分，其中，<strong>特征工程的作用是将文本转化为计算机可以理解的格式，并提供强特征表达能力，即特征信息可以用以分类，而分类器基本上是统计学相关的内容，其作用是根据特征对数据进行分类</strong>。下面来简单介绍下常见的技术方法。</p><h2 id="特征工程"><a href="#特征工程" class="headerlink" title="特征工程"></a>特征工程</h2><p>&emsp;&emsp;特征工程覆盖了<strong>文本预处理</strong>、<strong>特征提取</strong>和<strong>文本表示</strong>三个流程。文本预处理通常指<strong>分词</strong>和<strong>去除停用词</strong>这两个过程，可以说分词是自然语言处理的基本前提。特征提取实际上囊括两个部分，即特征项的选择和特征项权重的计算。选择特征项的基本思路是：根据某个评价指标对原始数据进行排序，然后从中选择分数最高的评价指标，同时过滤掉其余的评价指标。通常可以选择的评价指标有<strong>文档频率</strong>、<strong>互信息</strong>、<strong>信息增益</strong>等，而特征权重的计算主要是经典的<strong>TF-IDF</strong>算法及其扩展算法。文本表示是指将文本预处理后转化为计算机可以理解的格式，是决定分类效果最重要的部分。传统做法是使用<strong>词袋模型(BOW)</strong>或者<strong>向量空间模型(VSM)</strong>，比如<strong>Word2Vec</strong>就是一个将词语转化为向量的相关项目。因为向量模型完全忽视文本的上下文，所以为了弥补这种技术上的不足，业界同时使用基于语义的文本表示方法，比如常见的<strong>LDA</strong>语义模型。</p><h2 id="分类器"><a href="#分类器" class="headerlink" title="分类器"></a>分类器</h2><p>&emsp;&emsp;分类器主要是统计学里的分类方法，基本上大部分的机器学习方法都在文本分类领域有所应用，比如最常见的<strong>朴素贝叶斯算法(Naive Bayes)</strong>、<strong>KNN</strong>、<strong>支持向量机(SVM)</strong>、<strong>最大熵(MaxEnt)</strong>、<strong>决策树</strong>和<strong>神经网络</strong>等等。简单来说，假设我们所有的数据样本可以划分为训练集和测试集。首先，分类器可以在训练集上执行分类算法以生成分类模型；其次，分类器可以通过分类模型对测试集进行预测以生成预测结果；最后，分类器可以计算出相关的评价指标以评估分类的效果。这里最常用的两个评价指标是<strong>准确率</strong>和<strong>召回率</strong>，前者关注的是数据的准确性，后者关注的是数据的全面性。</p><h1 id="TF-IDF与朴素贝叶斯"><a href="#TF-IDF与朴素贝叶斯" class="headerlink" title="TF-IDF与朴素贝叶斯"></a>TF-IDF与朴素贝叶斯</h1><p>&emsp;&emsp;<strong>TF-IDF</strong>(term frequency–inverse document frequency)是一种被用于信息检索与数据挖掘的统计学方法，常常被用来评估某个字词对于一个文件集或者是一个语料库中的一份文档的重要程度。在特征工程这里我们提到，特征工程中主要通过特征权重来对数据进行排序和分类，因此<strong>TF-IDF</strong>本质上是一种加权技术。<strong>TF-IDF</strong>的主要思想是：字词的重要性与它在文件中出现的次数成正比上升，与此同时与它在语料库中出现的频率成反比下降。这句话是什么意思呢？如果某个词或者短语在一篇文章中出现的频率(即<strong>TF</strong>)较高，并且在其它文章中出现的频率(即<strong>IDF</strong>)较低，那么就可以人为这个词或者短语可以作为一个特征，具备较好的类别区分能力，因此适合用来作为分类的标准。<strong>TF-IDF</strong>实际上是TF * IDF，即TF(term frequency，词频)与IDF(inverse document frequency，逆文档频率)的乘积，具体我们通过下面的公式来理解：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/20180321003843372-tf.png" alt="term frequency，词频" title="">                </div>                <div class="image-caption">term frequency，词频</div>            </figure><br>&emsp;&emsp;显然，这里的TF表示某一词条在文档中出现的频率。再看IDF:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/2018032100393444-idf.png" alt="inverse document frequency，逆文档频率" title="">                </div>                <div class="image-caption">inverse document frequency，逆文档频率</div>            </figure><br>&emsp;&emsp;这里的D表示语料库中文档的数目，而分母表示的是含有指定词的文档的数目，这里两者求商后取对数即可得到IDF。需要注意的是，当该词语不在语料库中时，理论上分母会变成0，这将导致计算无法继续下去，因此为了修正这一错误，我们在分母上加1，这样就可以得到IDF更为一般的计算公式。按照这样的思路，我们将两段文本分完词以后，分别计算每一个词的tf-idf并按照tf-idf对其进行排序，然后选取前N个元素作为其关键字，这样我们就获得了两个N维向量，按照向量理论的相关知识，两个向量间的夹角越小，其相关性越显著，这就是文本相似度判断的常规做法，在这个过程中，我们覆盖到了<strong>文本预处理</strong>、<strong>特征提取</strong>和<strong>文本表示</strong>三个过程，相信大家会对这个过程有更好的理解。</p><p>&emsp;&emsp;好了，那么什么是特征呢？这里计算出来的tf-idf实际上就是一组特征，这个特征是上下文无关、完全基于频率分析的结果，现在这些结果都是计算机可以处理的数值类型，所以特征工程要做的事情，就是从这些数值中分析出某一种规律出来。譬如，我们通过分析大量的气象资料，认为明天有80%的概率会下雨，那么此时下雨的概率0.8就可以作为一个特征值，在排除干扰因素的影响以后，我们可以做一个简单的分类，如果下雨的概率超过0.8即认为明天会下雨，反之则不会下雨。这是一个接近理想的二值化模型，在数学中我们有一种概率分布模型称为0-1分布，即一件事情只有两个可能，如果该事件会发生的概率为p，则该事件不会发生的概率为1-p。如果所有的问题都可以简化到这种程度，我相信我们会觉得这个世界枯燥无比，因为一切非黑即白、非此即彼，这会是我们所希望的世界的样子吗？<br>&emsp;&emsp;为什么在这里我要提到概率呢？因为这和我们下面要提到的朴素贝叶斯有关。事实上，朴素贝叶斯的理论基础，正是我们所熟悉的条件概率。根据概率的相关知识，我们有以下公式，即全概率公式：P(A|B) = P(AB)/P(B)。我们对A和B进行交换，同理可得：P(B|A) = P(A/B)/P(A)。由此我们即得到了贝叶斯公式：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/20180323235155564.png" alt="贝叶斯公式" title="">                </div>                <div class="image-caption">贝叶斯公式</div>            </figure><br>&emsp;&emsp;所以，朴素贝叶斯本质上是一种基于概率理论的分类算法。我们知道条件概率成立的前提是各个事件都是独立的，因此在朴素贝叶斯算法中假设所有特征间都是独立的，可当我们逐渐地了解这个世界，就会明白这个世界并不是非黑即白、非此即彼的，甚至一件事情会受到来自方方面面的因素影响，就像我们从前学习物理的时候喜欢用控制变量法一样，总有一天你会明白当时的想法太天真。朴素贝叶斯算法中的“朴素”，通常被翻译为Naive，而这个词就是表示天真的意思，这正是朴素贝叶斯的名称由来，它简单粗暴地认为各个特征间是相互独立的，有人认为这种假设是相当不严谨的，所以相当排斥这种分类的理论，所幸朴素贝叶斯在实际应用中分类效果良好，尤其是在解决垃圾邮件过滤这类问题上，所以到今天为止，朴素贝叶斯依然是一个相当经典的分类算法，它是一个根据给定特性/属性，基于条件概率为样本赋予某个类别标签的模型。</p><h1 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h1><p>&emsp;&emsp;好了，讲述这些理论知识实在是一件苦差事，因为让读者了解一套新的知识，远远比让自己了解一套新的知识容易，所以在描述这些理论的时候，我努力地避免给大家留下晦涩深奥地印象，可这样难免会让读者觉得我不太专业。可是，谁让我们生活在一个被无数前辈开垦过地世界里呢？作为一个资深的“调包侠”，这些理论我们能理解多少算多少，最终我们需要的只是一个库而已，所以在正式进入下面的内容时，我们首先来梳理侠整体数据分析的思路，这样我们就能对整个过程有一个相对感性的认识了。关于如何从新浪微博抓取数据，这个我们在<a href="https://qinyuanpei.github.io/posts/1386017461/">上篇</a>有详细的介绍，这里不再重复阐述，所有数据我们都存储在数据库里，下面的图示不再展示关于数据库的细节：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/20180324005637219.png" alt="特征分析流程图" title="">                </div>                <div class="image-caption">特征分析流程图</div>            </figure><br>&emsp;&emsp;简单来讲，这是一个有监督的、使用二元分类的特征提取过程。这里的语料库是由人工进行编制的文本资料，语料库的好坏将直接影响到分类的效果。比如说，我们希望提取的特征是陕西省的地理信息，那么我们就需要准备一个，由陕西省所辖的所有地级市组成的文本文件，这里为了方便后续处理，我们建议每行存放一个短文本信息。</p><p>&emsp;&emsp;接下来，我们会从数据库中读取所有的数据，然后进行预处理操作，这里的预处理是指分词和去除停用词，停用词表是从网络上下载的，然后根据我们自己的需要再在基础上进行添加，我们会选取前20个词语作为关键词，这里使用了结巴分词的相关接口，其算法原理正是tf-idf。我们会使用这20个关键词，和语料库中每一个主题下的内容进行比较，这里的相似度由SnowNLP提供支持，其计算结果是一个20维的向量，我们对向量进行归一化后，如果其向量中所有维度的值的最大值&gt;=0.95，则认为该文本和这一主题相关，因此该主题的权重会增加1，否则会继续计算下一个文本的相似度。</p><p>&emsp;&emsp;我们汇总所有主题的权重，即可统计出各个主题出现的频率。比如我们这里关注A、B、C三个主题，而经过计算这三个主题各自出现的频率为0.1、0.8和0.1，所以我们这里可以理解为：这里有80%的把握认为文本和B主题有关，由此我们选取出了分类的特征，这里我们使用一个元组来表示特征，其表示为([0.1,0.8,0.1],”B”)。依次类推，我们就获得了全部的特征信息。接下来，我们使用nltk中提供的朴素贝叶斯分类器对内容进行分类，训练集和测试集合各占50%，最终通过准确度来评估整个分类的效果。</p><h2 id="特征分析"><a href="#特征分析" class="headerlink" title="特征分析"></a>特征分析</h2><p>&emsp;&emsp;特征分析的难点主要在特征的提取，在这里我们通过不同主题的频率来选取特征：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buildFeatures</span><span class="params">(sentence,document)</span>:</span></span><br><span class="line">    tokens = jieba.analyse.extract_tags(sentence)</span><br><span class="line">    tokens = list(filter(<span class="keyword">lambda</span> x:x.strip() <span class="keyword">not</span> <span class="keyword">in</span> stopwords, tokens))</span><br><span class="line">    features = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (subject,contents) <span class="keyword">in</span> document.items():</span><br><span class="line">        <span class="keyword">for</span> content <span class="keyword">in</span> contents:</span><br><span class="line">            <span class="keyword">if</span>(similarText(tokens,content)):</span><br><span class="line">                <span class="keyword">if</span>(subject <span class="keyword">in</span> features):</span><br><span class="line">                    features[subject]+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    features[subject]=<span class="number">1</span></span><br><span class="line">    total = sum(features.values())</span><br><span class="line">    <span class="keyword">for</span> subject <span class="keyword">in</span> features.keys():</span><br><span class="line">        features[subject] = features[subject] / total</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 特征归一化</span></span><br><span class="line">    <span class="keyword">for</span> subject <span class="keyword">in</span> subjects:</span><br><span class="line">        <span class="keyword">if</span>(subject <span class="keyword">not</span> <span class="keyword">in</span> features.keys()):</span><br><span class="line">            features[subject] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 预测结果</span></span><br><span class="line">    max_value = max(features.values())</span><br><span class="line">    suggest_subject = <span class="string">' '</span></span><br><span class="line">    <span class="keyword">for</span> (key,value) <span class="keyword">in</span> features.items():</span><br><span class="line">        <span class="keyword">if</span>(value == max_value):</span><br><span class="line">            suggest_subject = key</span><br><span class="line">    <span class="keyword">return</span> features, suggest_subject</span><br></pre></td></tr></table></figure></p><p>其中，stopwords我们从一个指定文件中读取：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stopwords = open(<span class="string">'stopwords.txt'</span>,<span class="string">'rt'</span>,encoding=<span class="string">'utf-8'</span>).readlines()</span><br></pre></td></tr></table></figure></p><p>这里有一个计算句子和主题相似度的方法similarText()，其定义如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文本相似度</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">similarText</span><span class="params">(tokens,content)</span>:</span></span><br><span class="line">    snow = SnowNLP(tokens)</span><br><span class="line">    similar = snow.sim(content)</span><br><span class="line">    norm = math.sqrt(sum(map(<span class="keyword">lambda</span> x:x*x,similar)))</span><br><span class="line">    <span class="keyword">if</span>(norm == <span class="number">0</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    similar = map(<span class="keyword">lambda</span> x:x/norm,similar)</span><br><span class="line">    <span class="keyword">return</span> max(similar)&gt;=<span class="number">0.95</span></span><br></pre></td></tr></table></figure></p><p>我们通过下面的代码来构建特征，以及使用朴素贝叶斯分类器进行分类，核心代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">analyseFeatures</span><span class="params">()</span>:</span></span><br><span class="line">    rows = loadData()</span><br><span class="line">    document = loadDocument(subjects)</span><br><span class="line">    features = [buildFeatures(row[<span class="number">0</span>],document) <span class="keyword">for</span> row <span class="keyword">in</span> rows]</span><br><span class="line">    length = len(features)</span><br><span class="line">    print(<span class="string">'数据集: '</span> + str(length))</span><br><span class="line">    cut_length = int(length * <span class="number">0.5</span>)</span><br><span class="line">    print(<span class="string">'训练集: '</span> + str(cut_length))</span><br><span class="line">    train_set = features[<span class="number">0</span>:cut_length]</span><br><span class="line">    print(<span class="string">'测试集: '</span> + str(length - cut_length))</span><br><span class="line">    test_set = features[cut_length:]</span><br><span class="line">    classifier = nltk.NaiveBayesClassifier.train(train_set)</span><br><span class="line">    train_accuracy = nltk.classify.accuracy(classifier,train_set)</span><br><span class="line">    print(<span class="string">'准确度: '</span> + str(train_accuracy))</span><br><span class="line"></span><br><span class="line">    counts = Counter(map(<span class="keyword">lambda</span> x: x[<span class="number">1</span>],test_set))</span><br><span class="line">    <span class="keyword">for</span> key, count <span class="keyword">in</span> counts.items():</span><br><span class="line">        freq = count/len(test_set)</span><br><span class="line">        print(<span class="string">"主题&lt;&#123;0&#125;&gt;: &#123;1&#125;"</span>.format(key,freq))</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;下面是特征提取相关的结果，因为最近对语料库进行了调整，所以准确度只有92%，用一位前辈的话说，数据分析就像炼丹，在结果没有出来以前，没有人知道答案会是什么。这里使用的是nltk内置的朴素贝叶斯分类器，而nltk是一个自然语言处理相关的库，感兴趣的朋友可以自行了解，这里推荐一本书：<a href="https://book.douban.com/subject/27057666/" target="_blank" rel="noopener">《NLTK基础教程(用NLTK和Python库构建机器学习应用)》</a>。下图中展示了各个主题在整个微博文本中所占的比重：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/20180324205251158.jpg" alt="特征提取及其分类效果" title="">                </div>                <div class="image-caption">特征提取及其分类效果</div>            </figure><h2 id="年龄分布"><a href="#年龄分布" class="headerlink" title="年龄分布"></a>年龄分布</h2><p>&emsp;&emsp;对于男女性的年龄分布，我们通过正则来提取微博中年龄相关的数值，然后统计不同年龄出现的频数，并将其绘制为柱形统计图，相关代码实现如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">analyseAge</span><span class="params">()</span>:</span> </span><br><span class="line">    ages = []</span><br><span class="line">    rows = loadData()</span><br><span class="line">    pattern = re.compile(<span class="string">r'\d&#123;2&#125;\年|\d&#123;2&#125;\岁'</span>)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> rows:</span><br><span class="line">        text = row[<span class="number">0</span>].decode(<span class="string">'utf-8'</span>)</span><br><span class="line">        matches = pattern.findall(text)</span><br><span class="line">        <span class="keyword">if</span>(len(matches)&gt;<span class="number">0</span>):</span><br><span class="line">            match = matches[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">u'年'</span> <span class="keyword">in</span> match):</span><br><span class="line">                now = datetime.datetime.now().year</span><br><span class="line">                birth = int(<span class="string">''</span>.join(re.findall(<span class="string">r'\d'</span>,match)))</span><br><span class="line">                ages.append(now - <span class="number">1900</span> - birth)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ages.append(int(<span class="string">''</span>.join(re.findall(<span class="string">r'\d'</span>,match))))</span><br><span class="line">    ages = list(filter(<span class="keyword">lambda</span> x: x&gt;<span class="number">10</span> <span class="keyword">and</span> x&lt;<span class="number">40</span>, ages))</span><br><span class="line">    freqs = Counter(ages).items()</span><br><span class="line">    freqs = sorted(freqs,key=<span class="keyword">lambda</span> x:x[<span class="number">0</span>],reverse=<span class="keyword">False</span>)</span><br><span class="line">    freqs = dict(freqs)</span><br><span class="line">    drawing.bar(<span class="string">'男女性择偶观数据分析:年龄分布'</span>,freqs,<span class="string">'年龄'</span>,<span class="string">'人数'</span>,<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;通过图表，我们可以发现：择偶年龄重点集中在24~28岁之间，并且整个年龄区间符合正态分布。每年过年的时候，我们都会听到年轻人被催婚的声音，甚至作为一个单身的人，每一个节日都像是我们的忌日，因为无论在哪里，你都可以被秀恩爱或者被撒狗粮。“哪有人会喜欢孤独呢？不过是不喜欢失望”，当这句话出现在我的Kindle屏幕上，出现在村上春树的《挪威的森林》里，我突然有种扎心的感觉。有一天，当我不在视爱情为必需品时，我突然意识到生命里有太多比感情重要的事情。我不希望我们因为一句年龄到了就去结婚，如果人生的一切都有期限都要按部就班，那么为什么我们不能平静地面对衰老和死亡呢？人天生起点就是不一样的，所以你不必努力去迎合别人定制的标准，就像学生时代大家面对的是同一张考卷，有的人交卷交得早，有的人交卷交得晚，有的人考试成绩好，有的人考试成绩差，可这不过是一场考试而已，不是吗？如果我的时间不能浪费在我喜欢的人身上，我宁愿永远将时间浪费在自己的身上，除了生与死以外，结婚和繁衍并不是必答题，我可以不结婚啊，一如我可以交白卷啊！<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/Figure_1-1.png" alt="男女性择偶观数据分析:年龄分布" title="">                </div>                <div class="image-caption">男女性择偶观数据分析:年龄分布</div>            </figure></p><h2 id="性别组成"><a href="#性别组成" class="headerlink" title="性别组成"></a>性别组成</h2><p>&emsp;&emsp;性别组成，我们主要从微博中的关键字入手，因为这些微博明确了择偶的是男嘉宾还是女嘉宾，我们通过这些特征就可以分析出男女性别比例。相关代码实现如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">analyseSex</span><span class="params">()</span>:</span></span><br><span class="line">    rows = loadData()</span><br><span class="line">    sexs = &#123;<span class="string">'male'</span>:<span class="number">0</span>, <span class="string">"female"</span>:<span class="number">0</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> rows:</span><br><span class="line">        text = row[<span class="number">0</span>].decode(<span class="string">'utf-8'</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">u'男嘉宾[向右]'</span> <span class="keyword">in</span> text:</span><br><span class="line">            sexs[<span class="string">'male'</span>]+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="string">u'女嘉宾[向右]'</span> <span class="keyword">in</span> text:</span><br><span class="line">            sexs[<span class="string">'female'</span>]+=<span class="number">1</span></span><br><span class="line">    drawing.pie(<span class="string">'男女性择偶观数据分析:男女性别比例'</span>,sexs,<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;通过下面的图表，我们可以非常直观地看到，男性数量是超过女性数量的，两者比例接近1.38:1。这和目前中国的实际基本相符，考虑到人们有更多的相亲渠道可以选择，我认为实际的比例应该会更大，媒体称适婚男性比女性多出3000万，性别比例的失衡难免会让男生找不到对象。可找不着对象有什么关系呢？人生短短一世，活着时候能见到最多不过四世同堂，血缘关系并不能让后辈替你完成未竟之事，当一个离开了这个世界，它与世界的关联就变得微乎其微，时间会让记忆逐渐模糊直至遗忘，你无法将这点微弱的安全感寄托在某一个人身上，人生而有涯，而知无涯，能在这个世界里流传下去的只有思想，我不想和任何人去攀比，因为生而为人，我很抱歉。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/Figure_1-2.png" alt="男女性择偶观数据分析:男女性别比例" title="">                </div>                <div class="image-caption">男女性择偶观数据分析:男女性别比例</div>            </figure></p><h2 id="身高分布"><a href="#身高分布" class="headerlink" title="身高分布"></a>身高分布</h2><p>&emsp;&emsp;身高分布，同样采用关键字匹配的方式实现，不同的是，择偶者通常会在微博中给出自己的身高以及对伴侣期望的身高，由此我们对微博中的身高进行了提取，分别获得了男性、女性身高分布及其身高差分布。这是我最开始研究这个问题的初衷，现在的结果印证了当时的想法，我内心其实是特别开心的，这正是为什么要花时间和精力写这篇文章的原因所在。这里，相关的代码实现如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 身高分布</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">analyseHeight</span><span class="params">()</span>:</span></span><br><span class="line">    heights = []</span><br><span class="line">    rows = loadData()</span><br><span class="line">    pattern = re.compile(<span class="string">r'1\d&#123;2&#125;|\d&#123;1&#125;\.\d&#123;1,2&#125;|\d&#123;1&#125;\米\d&#123;2&#125;'</span>)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> rows:</span><br><span class="line">        text = row[<span class="number">0</span>].decode(<span class="string">'utf-8'</span>)</span><br><span class="line">        matches = pattern.findall(text)</span><br><span class="line">        <span class="keyword">if</span>(len(matches)&gt;<span class="number">1</span>):</span><br><span class="line">            matches = map(<span class="keyword">lambda</span> x:int(<span class="string">''</span>.join(re.findall(<span class="string">r'\d'</span>,x))),matches)</span><br><span class="line">            matches = list(filter(<span class="keyword">lambda</span> x: x&lt;<span class="number">190</span> <span class="keyword">and</span> x&gt;<span class="number">150</span>, matches))</span><br><span class="line">            <span class="keyword">if</span>(len(matches)&gt;<span class="number">1</span>):</span><br><span class="line">                height = &#123;&#125; </span><br><span class="line">                height[<span class="string">'male'</span>] = max(matches)</span><br><span class="line">                height[<span class="string">'female'</span>] = min(matches)</span><br><span class="line">                heights.append(height)</span><br><span class="line">    <span class="comment"># 男性身高分布</span></span><br><span class="line">    male_heights = list(map(<span class="keyword">lambda</span> x:x[<span class="string">'male'</span>],heights))</span><br><span class="line">    male_heights = Counter(male_heights).items()</span><br><span class="line">    male_heights = dict(sorted(male_heights,key=<span class="keyword">lambda</span> x:x[<span class="number">0</span>],reverse = <span class="keyword">False</span>))</span><br><span class="line">    drawing.bar(<span class="string">'男女性择偶观数据分析:男性身高分布'</span>,male_heights,<span class="string">'身高'</span>,<span class="string">'人数'</span>,<span class="keyword">None</span>)</span><br><span class="line">    <span class="comment"># 女性身高分布</span></span><br><span class="line">    female_heights = list(map(<span class="keyword">lambda</span> x:x[<span class="string">'female'</span>],heights))</span><br><span class="line">    female_heights = Counter(female_heights).items()</span><br><span class="line">    female_heights = dict(sorted(female_heights,key=<span class="keyword">lambda</span> x:x[<span class="number">0</span>],reverse = <span class="keyword">False</span>))</span><br><span class="line">    drawing.bar(<span class="string">'男女性择偶观数据分析:女性身高分布'</span>,female_heights,<span class="string">'身高'</span>,<span class="string">'人数'</span>,<span class="keyword">None</span>)</span><br><span class="line">    <span class="comment"># 男女身高差分布</span></span><br><span class="line">    substract_heights = list(map(<span class="keyword">lambda</span> x:x[<span class="string">'male'</span>]-x[<span class="string">'female'</span>],heights))</span><br><span class="line">    substract_heights = Counter(substract_heights).items()</span><br><span class="line">    substract_heights = dict(sorted(substract_heights,key=<span class="keyword">lambda</span> x:x[<span class="number">0</span>],reverse = <span class="keyword">False</span>))</span><br><span class="line">    drawing.bar(<span class="string">'男女性择偶观数据分析:男女身高差分布'</span>,substract_heights,<span class="string">'身高差'</span>,<span class="string">'人数'</span>,<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;虽然女生都希望男生180以上，据说这样可以举高高、有安全感，可是作为一个成年人，我们必须勇敢地打破这种不切实际的幻想，因为身高和外貌都是父母给我们的，那些基因里决定的东西，往往是我们无法通过后天努力来弥补的。如果可以的话，我希望自己再长高5厘米，可如果我再无法长高，我希望你能接受现在的我，接受一个人身高上的缺陷，和接受一个人人性中的缺点，在我看来是一模一样的。可人类最大的问题， 就在于愿意相信自己眼睛看到的，耳朵听到的，并且这是两个人建立联系的前提，人家愿意了解你有趣的灵魂，前提是你有一副好看的皮囊，人类啊，说到底是一种比较高级的动物而已，就像动物用皮毛、肤色去吸引同类一样，如你所见，男生平均身高其实只有175而已！<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/Figure_1-4.png" alt="男女性择偶观数据分析:男性身高分布" title="">                </div>                <div class="image-caption">男女性择偶观数据分析:男性身高分布</div>            </figure></p><p>&emsp;&emsp;女性的身高通常不会被作为筛选条件，正如社会群体通常都是对男性提出各种要求一样，两个同等条件下的男、女性，人们理所当然地对男性提出了更高的要求，可其实大家都是母亲十月怀胎而来，同样地都在这个世界里生活了20多年。所以这个世界上有太多地问题，其实都是人们自己造成的。比如女性一定要找一个穿高跟鞋后还要比她高的男性，而男性一定要找一个身高上和他相差不大的女性，男性的身高不足175，同女性的身高不足165一样，都是人们眼中比较尴尬的身高，可你看这图表中女性的平均身高是160，那么，就让大家一起尴尬吧，不知道当年小平爷爷和拿破仑将军的夫人心里是怎么想的啦！<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/Figure_1-5.png" alt="男女性择偶观数据分析:女性身高分布" title="">                </div>                <div class="image-caption">男女性择偶观数据分析:女性身高分布</div>            </figure></p><p>&emsp;&emsp;最初我研究这个问题的时候，我发现微博上有好多身高不足160的女性，要求伴侣期望身高都是175以上，作为一个身高只有170的男生，我感到绝望和悲伤啊，后来和一位朋友聊天，他说他觉得我连170都没有，我想说人类为什么要这般奇怪，譬如体重一定要说得比实际轻、身高一定要说得比实际高、年龄一定要说得比实际小……难道这样不感觉累吗？那么到底有多少人希望两个人的身高差超过20厘米呢？网络上流传的所谓最萌身高差到底萌不萌呢？你看孟德尔通过豌豆杂交试验来研究遗传问题，两个身高差超过20厘米的人的后代，平均下来难道不是只有170吗？图表表明，男女性之间最佳的身高差是15厘米。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/Figure_1-6.png" alt="男女性择偶观数据分析:男女身高差分布" title="">                </div>                <div class="image-caption">男女性择偶观数据分析:男女身高差分布</div>            </figure></p><h2 id="地理分布"><a href="#地理分布" class="headerlink" title="地理分布"></a>地理分布</h2><p>&emsp;&emsp;因为在这些微博中会出现相亲者的地理信息，所以我们整理了陕西省各县市的名称作为关键字，试图分析出这些相亲者的地理分布，这里我们简单绘制了一个柱形图，相关代码实现如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 地区分析</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">anslyseLocation</span><span class="params">()</span>:</span></span><br><span class="line">    freqs = &#123; &#125;</span><br><span class="line">    citys = [<span class="string">u'西安'</span>,<span class="string">u'铜川'</span>,<span class="string">u'宝鸡'</span>,<span class="string">u'咸阳'</span>,<span class="string">u'渭南'</span>,<span class="string">u'延安'</span>,<span class="string">u'汉中'</span>,<span class="string">u'榆林'</span>,<span class="string">u'安康'</span>,<span class="string">u'商洛'</span>]</span><br><span class="line">    rows = loadData()</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> rows:</span><br><span class="line">        text = row[<span class="number">0</span>].decode(<span class="string">'utf-8'</span>)</span><br><span class="line">        <span class="keyword">for</span> city <span class="keyword">in</span> citys:</span><br><span class="line">            <span class="keyword">if</span>(city <span class="keyword">in</span> text):</span><br><span class="line">                <span class="keyword">if</span>(city <span class="keyword">in</span> freqs.keys()):</span><br><span class="line">                    freqs[city]+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    freqs[city]=<span class="number">1</span></span><br><span class="line">    drawing.bar(<span class="string">'地区分布图'</span>,freqs,<span class="string">'地区'</span>,<span class="string">'人数'</span>,<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这里的结果令人出戏，因为西安作为陕西省的省会城市，在所有地区中一骑绝尘。考虑到在这些微博中”西安”存在干扰，所以这个结果并不是非常严谨，不能作为一个有效的分析指标，而且这里存在同义词，比如”本地”和”土著”其实都表示西安，而我们统计的时候并没有考虑这种情况，所以这里绘制的地区分布图表，大家看看就好啦！<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/Figure_1-7.png" alt="男女性择偶观数据分析:地区分布图" title="">                </div>                <div class="image-caption">男女性择偶观数据分析:地区分布图</div>            </figure></p><h2 id="星座分布"><a href="#星座分布" class="headerlink" title="星座分布"></a>星座分布</h2><p>&emsp;&emsp;这里为什么要分析星座呢？理论上来讲，我是不大相信这些东西的，可当你经历的事情多了以后，你就会下意识地认为这些东西说得很对，我想古代的占卜算卦基本上是同样的东西，其实世间好多事情之间应该是没有直接的联系的，无非是在千百年的历史积淀中，逐渐地形成了一套建立在经验上的理论体系，这就像我们今天所追捧的机器学习，我们有千百年的历史长河去收集数据，每一个相信这些理论的人都是一个数据样本，这些理论体系通过不断地训练和模拟，逐渐可以正确地预测某些事情，让我们相信万事万物间存在某种联系。可即便如此，人类依旧免不了对各种事物存在偏见，比如星座中经常无辜躺枪的处女座、双子座和天蝎座，人类最擅长的认知方式，就是用一个群体现象来预测个人现象，可讽刺的是朴素贝叶斯就是这样的思想，所以这里我们简单地统计了下各种星座的频数分布：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 星座分析</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">analyseStar</span><span class="params">()</span>:</span></span><br><span class="line">    stars = [<span class="string">'白羊'</span>,<span class="string">'金牛'</span>,<span class="string">'双子'</span>,<span class="string">'巨蟹'</span>,<span class="string">'狮子'</span>,<span class="string">'处女'</span>,<span class="string">'天秤'</span>,<span class="string">'天蝎'</span>,<span class="string">'射手'</span>,<span class="string">'摩羯'</span>,<span class="string">'水瓶'</span>,<span class="string">'双鱼'</span>]</span><br><span class="line">    freqs = &#123;&#125;</span><br><span class="line">    rows = loadData()</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> rows:</span><br><span class="line">        text = row[<span class="number">0</span>].decode(<span class="string">'utf-8'</span>)</span><br><span class="line">        <span class="keyword">for</span> star <span class="keyword">in</span> stars:</span><br><span class="line">            <span class="keyword">if</span>(star <span class="keyword">in</span> text):</span><br><span class="line">                <span class="keyword">if</span>(star <span class="keyword">in</span> freqs.keys()):</span><br><span class="line">                    freqs[star]+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    freqs[star]=<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> star <span class="keyword">in</span> stars:</span><br><span class="line">        <span class="keyword">if</span>(star <span class="keyword">not</span> <span class="keyword">in</span> freqs.keys()):</span><br><span class="line">            freqs[star] = <span class="number">0</span></span><br><span class="line">    freqs = Counter(freqs).items()</span><br><span class="line">    freqs = dict(freqs)</span><br><span class="line">    drawing.pie(<span class="string">'男女性择偶观数据分析:星座分布'</span>,freqs,<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这个结果相对客观些，因为12个星座基本上平分秋色啦，并不存在某种星座独领风骚的情况，简直是人与自然的大和谐了呢？<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/Figure_1-3.png" alt="男女性择偶观数据分析:星座分布" title="">                </div>                <div class="image-caption">男女性择偶观数据分析:星座分布</div>            </figure></p><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>&emsp;&emsp;这篇文章写到这里，我其实已经非常疲惫啦，因为这篇文章的<a href="https://qinyuanpei.github.io/posts/1386017461/">上篇</a>与下篇中间相隔了差不多三个月，而且我写作上篇的时候，并没有打算写这一篇文章出来，再者两篇文章写作时的心境完全不同，所以现在写完这篇文章，终于有种如释重负的感觉，一来没有因拖延症而放弃这篇文章，二来为了了解相关的理论以及训练数据花费大量精力，我必须对自己的过去有一个总结，这是我今年年初给自己制定的目标，不管有没有喜欢我，我总要去做这些事情，不是因为我想要证明什么或者做给谁看，而是我认为这件事情比某些事情有趣而且重要。这篇文章首先承接上文，交待故事的背景，即为什么要做这样的数据分析；然后我们简单介绍了文本分类的常用的技术方法，主要以特征工程和分类器为主；接下来我们介绍了两个经典的理论：tf-idf和朴素贝叶斯，这是本文文本分类的理论基础；在数据分析这部分，我们对特征、年龄、性别、身高、地区和星座等进行了分析，并借助Python中的图表模块完成了数据的可视化工作。好啦，以上就是这篇文章的全部内容啦，欢迎大家积极留言和评论，晚安！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="数据分析" scheme="http://qinyuanpei.github.io/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
      <category term="微博" scheme="http://qinyuanpei.github.io/tags/%E5%BE%AE%E5%8D%9A/"/>
    
      <category term="朴素贝叶斯" scheme="http://qinyuanpei.github.io/tags/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/"/>
    
      <category term="文本分类" scheme="http://qinyuanpei.github.io/tags/%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>行走在消逝中</title>
    <link href="http://qinyuanpei.github.io/posts/2809571715/"/>
    <id>http://qinyuanpei.github.io/posts/2809571715/</id>
    <published>2018-03-15T21:29:47.000Z</published>
    <updated>2018-08-24T05:39:27.482Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script>    <div id="aplayer-zMKkEaJR" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="523845740" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="false" data-listmaxheight="340px" data-preload="none" data-theme="#ad7a86"></div><p>&emsp;&emsp;从昨天到今天，关于霍金逝世的消息，一直在朋友圈里刷屏。昨天同事告诉我这个消息的时候，我心底先是一片恍惚，而后习惯性地打开微信，发现朋友圈和公众号里都在讨论这件事情。而等到我吃饭的时候，居然听到临桌的一名男生，在向同伴讲述霍金辐射的理论，堪称我在这一天所见过的一股清流。不知道从什么时候开始，一个人物的突然离去，总是会让人们在短时间内亢奋起来，仿佛一场集体缅怀的狂欢。回顾最近这些年来已故的名人，例如杨绛先生、杨洁导演、词作家闫肃、作家黄易等等，每每提及不禁令人一阵唏嘘，正所谓“逝者已矣，生者如斯”。可我想说的是，不要总是等到离开的时候，才会想起一个人的存在。</p><p>&emsp;&emsp;印象中第一次有这种感觉是在2011年，那时我刚刚考上大学，我只记得那时站在太阳底下的我，突然大声地向周围人宣布乔布斯逝世的消息。我清晰地记着父母惊愕的表情，因为在他们的人生字典里，全然不知道乔布斯是谁，可在19岁的我看来，那就像是某种重大的事情发生，至少从今天的角度来看，在我出生的1992年里，苏联正式解体，我们的生命总是不可避免地和某种历史进程关联起来。因为从中学时候就开始住校，印象中每次回家都既陌生而熟悉，偶尔会听到妈妈讲，家族里某一位长辈突然过世。这种事情听得多了，居然不会再觉得惊讶。可是想起这些人里，有人曾经出过数学题考问过我，有人你曾经帮过他们做过什么事情……刹那间觉察到时光的残忍——所谓的物是人非，大概就是你还在此处，而别人早已暗自走远。</p><p>&emsp;&emsp;坦白地讲，我对霍金的认知永远都停留在《时间简史》这本书上，记得16年买了Kindle以后，的确买了这本书来读，大概读了十来页便读不下去。霍金和海伦·凯勒一样，是被我划定到身残志坚这类写作素材的范畴里。当时，语文老师让我们关注每年的感动中国人物评选，其初衷便是为了丰富我们的写作素材。回想那些年里，遭受无数次宫刑而忍辱负重的司马迁、实验了3000多种材料终于制造出灯泡的爱迪生、披发行吟泪洒汨罗而心系家国的屈原……这些在学生时代频频被消费的历史人物，在今天看来是否有些相似呢？据说知乎上一天内产生了700多个霍金相关的问题，一个曾经活在我们作文里的人物，在他离开这个世界以后，再次成为我们热议的话题，好像他从来没有在这个世界上存在过一样，这是一件可怕的事情。</p><p>&emsp;&emsp;我认为尊重一名物理学家的基本要求是相信科学。伴随着霍金变成人们关注的热点，网络上开始流传伽利略、爱因斯坦和霍金三个人之间巧合的时间线问题，仿佛我们面对的不是一名为宇宙物理学做出巨大贡献的科学家，而是一个被神化的“活佛”转世。有人说，人类都是一群戏精。集体缅怀一个伟人吧，立马有人跳出来说，伟人的著作都没读过一本，蹭什么热度；大家都不关注这件事情吧，立马有人跳出说，“将军坟前无人问，戏子家事天下知”，根本没有人关心科技工作者。可你看关注的时候，大家都在关注什么，譬如定要给物理学领域内的专家学者们排出个优劣来，定要将一个人的私事深挖出来品判人品。杨绛先生说，“我们曾如此渴望命运的波澜，到最后才发现：人生最曼妙的风景，竟是内心的淡定与从容。我们曾如此期盼外界的认可，到最后才知道：世界是自己的，与他人毫无关系。“，这是最浅显不过的道理，可惜想要做到实在太难。</p><p>&emsp;&emsp;我一直相信“人生而孤独”，除了亲情血缘以外，人与人间的联系，有时脆弱得像一只挂在风筝上的线，随时都会有断开的危险。有些人不知不觉就渐渐走远了，我们一路踟蹰而雁行，在相遇中失散，在失散中相遇，可当两个人再次相遇时，已然不是当初的彼此。我是一个不太会维护亲密关系的人，不知道是我自己走得太快，还是别人走得太快，无数的人在我这里出现然后离开，仿佛是在追逐风中的花瓣，等到风停了的时候，花瓣已不见，花香已飘远。有时候会突然问自己，想把别人留在我的生命里，是不是一件自私的事情。游戏制作人陈星汉有一款游戏叫做《风之旅人》，在广阔无垠的沙漠场景中，最多只有两个玩家出现，出现的时间和地点随机，对方可能来自任何一个国家，你对他/她的的身份信息一无所知，两个人唯一的互动方式是“共鸣”。两个靠在一起的人，可以通过“共鸣”来为对方的围巾补充能量，最重要的一点是，一旦两个人走失，就永远不会再相遇，这是这款游戏超现实意义的一个体现。</p><p>&emsp;&emsp;我不知道，两个人从无话不说到无话可说需要多久；我只知道，真正想要离开的人，从来都是不动声色的。自那以后，我不知道对方会在哪里，会变成什么样子，每天都会做哪些事情。我承认，别人的世界和你毫无关联，可你终究不愿意让自己成为孤岛，所以你会感到痛苦和挣扎，会想要找一个能永远陪伴你的人。可生老病死是人生里无可避免的结果，我们终其一生所寻找的灵魂伴侣，是否真的可以陪伴彼此到生命尽头。如果一切注定都要失去，我宁愿一直这样下去，我从来没有把生育看做是我生命的一种延续，因为每一个人的生命都注定独一无二，你不能想当然地认为，血缘关系会替你继承什么东西。从你死亡的那一刻起，一切都变成新的东西。</p><p>&emsp;&emsp;人的一生会死亡三次，第一次是医生宣布你的死亡，这是肉体上的死亡；第二次是人们来参加你的葬礼，这是社会学意义上的死亡；第三次是这个世界没有人再记得你，这是哲学意义上的死亡。或许这个世界再无霍金，可他的思想和著作一直就在那里，时间会记录着人类的过去和未来，而他是搭乘时光列车满世界旅行的自由灵魂。一个人可以不结婚，可以不生孩子，因为这是你生而为人的选择，世俗的力量是如此的强大，以至于我们都以为，人生就是一个跳一跳游戏，每一个年龄就应该跳到相应的位置。我的人生目标里没有结婚生子，如果我注定留不下任何人，如果我注定永远要被这个世界所遗忘，我宁愿在我还活着的时候，努力去写字去发出声音，即使在这空荡荡的宇宙里听不到回声，可声音不是一直都在传播着吗？</p><p>&emsp;&emsp;有时候，想想人生难免会觉得失望。我们明明知道世界是自己，和他人毫无关联，可我们还在努力地和这个世界发生着关联；我们明明不愿意让别人了解自己的生活，可我们对这个世界的表达欲从来没有衰减过。从镌刻在龟壳上甲骨文到以丝帛作为书写材料，再到造纸术的产生，再到今天的各种芯片，甚至内容的形式从文本演变为图片再演变为视频……可我们怎么就变成了一堆“亡灵”，从前QQ好友列表一片隐身，如今朋友圈剩下一条横线。如果一定要别人不再想起你，等你真正离开这个世界的时候，才会突然间被想起，我会很心疼一条鱼的记忆，因为一条鱼的记忆只有8秒。</p><p>&emsp;&emsp;如果下一刻失去记忆的，是你和我这般普通人，我们没有机会像霍金一样，被大家集体缅怀，你希望被那一个人记着，记多长时间呢？就像我总和朋友们说，回家以后找时间相聚，可在家时会觉得家人最为重要，在某一瞬间发现自己并没有那么多时间；就像我总计划着找机会去看望语文老师，可和朋友约不到一起时便无从谈起……我突然间想到，高中的第一堂语文课上，老师安排大家写一篇作文，题目好像叫做《回首向来》亦或者是《行走在消逝中》，那时我的作文没有写完，反而被老师叫起来当众朗读，我说“回首向来萧瑟处，也无风雨也无晴”，记忆明明是有的，可我突然叫不出来有些人的名字，甚至在某一个清晨惊醒，梦到过往的某一天考试迟到，或者是快要交卷发现作文没有写……我稍稍一定神，考试那好像是很多年前的事情了吧……</p><p>&emsp;&emsp;我其实很想留下来陪你或者陪Ta呀，可时光列车从来不会留给我思考的时间，有时候我走得快，有时候你走得快，像无法逃离黑洞的光一样，拼命地往前走往前走。在广阔无垠的宇宙中，我们生活在彼此平行的世界里，有时看得见彼此，有时看不见彼此，靠着彼此间微弱的万有引力，不至于失散得太远，在成为一颗孤独的白矮星之前，请记住我。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="生活感悟" scheme="http://qinyuanpei.github.io/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="霍金" scheme="http://qinyuanpei.github.io/tags/%E9%9C%8D%E9%87%91/"/>
    
      <category term="时间" scheme="http://qinyuanpei.github.io/tags/%E6%97%B6%E9%97%B4/"/>
    
      <category term="请记住我" scheme="http://qinyuanpei.github.io/tags/%E8%AF%B7%E8%AE%B0%E4%BD%8F%E6%88%91/"/>
    
  </entry>
  
</feed>
