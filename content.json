[{"title":"漫谈应用程序重试策略及其实现","date":"2018-03-31T19:20:54.000Z","path":"posts/115524443/","text":"&emsp;&emsp;最近随项目组对整个项目进行联调，在联调过程中暴露出各种问题，让我不得不开始反思，怎么样更好地去做好一件事情，譬如说在开发过程中如何保证Web服务的稳定性，在敏捷开发中如何降低文档维护的成本，以及如何提高多环境服务部署的效率等等。我为什么会考虑这些问题呢？通常我们都是在约定好接口后并行开发的，因此在全部接口完成以前，所有的服务都是以渐进的形式进行集成的，那么如何保证服务在集成过程中的稳定性呢？尤其当我们面对开发/测试/生产三套环境时，如何提高服务部署的效率呢？当接口发生变更的时候，如何让每一个人都知悉变化的细节，同时降低人员维护文档的成本呢？这些问题或许和你我无关，甚至这不是一个技术问题，可恰恰这是我们时常忽视的问题，我是我想要写这篇文章的一个重要原因。 代码越来越复杂&emsp;&emsp;面对这种问题，尤其是当你发现，它并不是一个纯粹的技术问题的时候。选择一件你喜欢的事情的去做，固然可以令你开心；而选择一件你不喜欢的事情去做，则可以令你成长。我们每一个人都不是人类学家，可生命中80%的时间都在研究人类。当你接收到一条别人的讯息时，不管这个讯息本身或对或错，在生而为人的角色预设中，你都必须去提供一个响应，甚至是比对方期望更高的一个响应。可是服务器会返回403、404或者500甚至更多的状态码，人生有时候并没有机会去选择Plan B或者Plan C。所以，即使所面临境地再艰难，能不能勇敢地再去尝试一次，说服对方或者选择妥协，就像一段代码被修改得面目全非，可人类本来就是喜欢皆大欢喜的动物，总希望别人都认认真真，而自己则马马虎虎，因为“认真你就输了”，有谁喜欢输呢？ &emsp;&emsp;好了，现在假设我们有这样一个业务场景，我们需要调用一个WebAPI来获取数据，然后对这些数据做相关处理。这个API接口被设计为返回JSON数据，因此，这个“简单”的业务场景通过以下代码来实现：12345def extract(url): text = requests.get(url).content.decode('utf-8') json_data = json.loads(text) data = json_data['raw_data'] return data &emsp;&emsp;这个代码非常简单吧！可是过了十天半个月，每次解析JSON数据的时候随机出现异常，经验丰富的同事建议增加try…except，并在捕获到异常以后返回None。于是，extract()方法被修改为：123456789def extract(url): text = requests.get(url).content.decode('utf-8') try: json_data = json.loads(text) data = json_data['raw_data'] return data except Exception: print(\"JSON数据无效，重试！\") return None &emsp;&emsp;修改后的代码，果然比修改前稳定啦，可是负责后续流程的同事开始抱怨，现在代码中出现大量判断返回值是否为None的代码片段，甚至在Web API返回正确结果的情况下，依然会返回None，为此，机智的同事再次修改代码如下：123456789def extract(url): text = requests.get(url).content.decode('utf-8') try: json_data = json.loads(text) data = json_data['raw_data'] return data except Exception: print(\"JSON数据无效，重试！\") return extract(url) &emsp;&emsp;可以预见的是，使用递归可能会导致递归的深度问题，假如调用者传入一个错误的URL，将导致这里无限递归下去，于是考虑限制重试的次数；增加重试次数的限制以后，发现每次重试需要有一个时间间隔……更不必说要在这里增加日志记录，以及在特定场景下需要将异常抛出，由此可见这段简单的代码会变得越来越复杂，如下所示：123456789101112def extract(url): text = requests.get(url).content.decode('utf-8') try: json_data = json.loads(text) data = json_data['raw_data'] return data except Exception: for i in range(3): print('正在进行第&#123;0&#125;次重试'.format(str(i)) result = extract(url) if(result!=None): return result &emsp;&emsp;可以注意到，这是一个非常合理的代码演进过程。在这个演进过程中，一段非常简单的代码变得越来越复杂。在我写下这篇文章前，我亲眼目睹了这种复杂的代码，是如何难以复用以及集成的，日志记录、异常处理等流程和正常流程“混合”在一起，甚至你不得不通过函数的返回值来判断是否异常，我一直在想怎么样去解决这些“corner”问题，就像人们一致认为：王垠博士擅长解决的是理想状态下的纯问题。而现实世界中存在着各种各样的“corner”问题，这或许就是学术界与工业界的区别，那么怎么样去更好地解决这一切问题呢？ 应用程序重试策略&emsp;&emsp;既然我们可以预见到这些问题的存在，那么，现在让我们正式切入今天这篇博客的主题，即应用程序重试策略。我们在这里以一种渐进式的方式，向大家展示了一个简单的应用程序，是如何因为异常处理变得越来越复杂的，这里我们选择重试，是因为现实世界本身存在不稳定性，即使我们现在有各种自动化工具来替代传统运维。就像有时候你怀疑是代码出现Bug，实际上则是服务器在某一段时间内宕机，当这种事情就发生在你身边的时候，你不得不去着手解决这些“corner”问题，而这恰好是人生的无奈之处。 Try-Catch-Redo策略&emsp;&emsp;这应该是我们最容易想到的一种重试策略了，其思路是对函数的返回值和异常进行处理，其缺点是无法解决重试无效的问题。这里我们将问题简化为对异常进行处理，其基本的代码实现如下：123456789101112131415161718private void Retry()&#123; try &#123; var result = DoWork(); if(!result)&#123; //重试一次 Thread.Sleep(1000); DoWork(); &#125; &#125; catch(Exception e) &#123; //重试一次 Thread.Sleep(1000); DoWork(); &#125;&#125; &emsp;&emsp;可以注意到，这种策略最多可以重试一次，因此如果重试后无效，这个策略就变得毫无意义起来，我们需要寻找一种更好的方式。 Try-Catch-Redo-Retry策略&emsp;&emsp;考虑到第一种策略无法解决重试无效的问题，我们在此基础上增加对重试次数以及重试间隔的控制，这就是Try-Catch-Redo-Retry策略，其基本实现如下：123456789101112131415161718192021222324private void Retry()&#123; //最大重试次数为5次 int times = 5; //重试间隔为10秒 int interval = 10; //存储异常的列表 var exceptions = new List&lt;Exception&gt;(); while(true) &#123; try &#123; var result = DoWrok(); if(result) return result; &#125; catch(Exception ex) &#123; if(--times&lt;=0) throw new AggregateException(exceptions); exceptions.Add(ex); Thread.Sleep(TimeSpan.FromSeconds(interval)); &#125; &#125;&#125; &emsp;&emsp;可以注意到，通过while(true)结构的确可以增加重试的次数。问题在于：如果不设置合理的循环跳出条件，就有可能造成逻辑上的死循环。尤其当循环体内的逻辑执行时间较长时，会增加用户的等待时间，这看起来亦非良策啊！ Retry-Builder策略&emsp;&emsp;Try-Catch-Redo和Try-Catch-Redo-Retry这两种策略理解起来非常容易，可这两种策略都有一个致命的缺陷，即正常逻辑和重试逻辑重度耦合。我们希望采用一种更优雅的方法，以一种非侵入式的方式给正常逻辑增加重试重试逻辑。需要考虑的是，在确保重试次数和重试间隔可配置的前提下，支持自定义重试源，即可以捕捉一个或多个异常以及对返回值进行处理。在这里推荐三个框架，分别是Java中的Spring-Retry和Guava-Retrying、.NET中的Polly。其中Spring-Retry是基于Throwable类型的重试机制，即针对可捕获异常执行重试策略，并提供相应的回滚策略；而Guava-Retrying提供了更为丰富的重试源定义，譬如多个异常或者多个返回值；而Polly则提供了除重试以外的断路器、超时、隔板隔离、缓存、回退等多种策略。这三者的相似之处在于，通过一个Factory来创建满足不同重试策略的Retryer，然后由Retryer来通过回调来执行重试逻辑，我不喜欢Java中回调函数写法，所以这里以Polly为例：12345678910111213141516171819try&#123; var retryTwoTimesPolicy = Policy .Handle&lt;DivideByZeroException&gt;() .Retry(3, (ex, count) =&gt; &#123; Console.WriteLine(\"执行失败! 重试次数 &#123;0&#125;\", count); Console.WriteLine(\"异常来自 &#123;0&#125;\", ex.GetType().Name); &#125;); retryTwoTimesPolicy.Execute(() =&gt; &#123; var a = 0; var b = 1/a; &#125;);&#125;catch (DivideByZeroException e)&#123; Console.WriteLine($\"Excuted Failed,Message: (&#123;e.Message&#125;)\");&#125; &emsp;&emsp;可以看到，写出一段语义化的代码是多么的重要，因为我相信大家都看懂了。这里的Policy承担了RetryBuilder的角色，它定义了这样一种策略：当程序引发DivideByZeroException时进行重试，重试次数为3次，并且以匿名函数的方式指定了重试时的回调函数；而创建的retryTowTimesPolicy承担了Retryer的角色，它通过Execute()方法来定义要执行的重试逻辑。当3次都重试失败时就会引发DivideByZeroException并在最外层函数中被捕捉到。我经常听到有人说设计模式没有用，我想说因为你从来都不知道什么叫做大道至简，引入无数个中间层是无法让你直接看到代码定义，可计算机领域里有一句名言，“任何一个问题都可以通过引入一个中间层来得到解决”。 装饰器/AOP策略&emsp;&emsp;我从来不惮于将各种重复的工作自动化，这并不是我喜欢在别人面前炫技，而是因为在现实生活中我是一个懒惰的人，甚至是每天早上10点开站会这样的事情，我都愿意让计算机程序去提前通知我做好准备。我并不是一个不懂得自律的人，仅仅是因为我觉得我们可以用这个时间去做些别的事情。AOP是一种可以在运行时期间动态修改代码的技术，我们自然可以想到给所有的函数都加上异常处理和重试的特性，幸运的是Python中的有这样一个第三方库：Tenacity，它可以帮助我们优雅地实现重试：123456789from tenacity import retryfrom json.decoder import JSONDecodeError@retry(retry=retry_if_exception_type(JSONDecodeError), wait=wait_fixed(5), stop=stop_after_attempt(3))def extract(url): text = requests.get(url).content.decode('utf-8') json_data = json.loads(text) data = json_data['raw_data'] return data &emsp;&emsp;通过@retry这个装饰器函数，我们就可以知道，这里设计的重试策略是：当引发JSONDecodeError这个异常时，每隔5秒中重试一次，最大重试次数为3次。Python中的装饰器，本质上就是高阶函数的概念，修饰器函数对被修饰函数进行“操作”后返回一个新的函数，这个特性在.NET中可以通过委托/匿名方法/lambda来实现，结合Unity、AspectCore等AOP框架，相信大家完全可以将这个特性移植到.NET中来，当语言的差别变得微乎其微的时候，原理的重要性不言而喻。 重试策略核心理念&emsp;&emsp;好了，截止到目前，我们分析了四种不同的重试策略，并且这四种重试策略是随着我们认知的加深而逐渐递进的。那么，通过这四种不同的重试策略，我们能否梳理出一个相对完整的应用程序重试策略呢？换言之，当为应用程序增加重试相关的功能时，我们都需要考虑哪些因素，因为使用这些框架会是非常简单的过程，而更重要的则是我们逐步演进的思考过程。当我们所依赖的是一个不稳定的场景，譬如远程调用、数据加载、数据上传等场景时，或者是在异常场景中需要重试以满足业务稳定性的要求等等，就可以考虑使用重试策略。这里简单地做一下梳理： 重试逻辑与正常逻辑解耦，整个设计是非侵入式的。 支持自定义策略，譬如重试次数、重试间隔、重试源、重试超时时间等。 支持自定义断言，即可以使用Predict或者类似表达式来定义返回值满足的条件。 支持多种异常，即可以针对特定的Exception或者自定义的Exception进行拦截。 断言实例和异常实例，作为正常逻辑和重试逻辑两者间的媒介进行交互。 通过命令模式，由Retryer对象完成对正常逻辑的调用，同时在内部封装重试逻辑。 一个简单的Retry实现&emsp;&emsp;好了，熟悉我写作风格的朋友，一定知道我不喜欢空泛地讲一套理论，我更喜欢通过“造轮子”的这种方式，以加深对一个事物或者原理的认识。对于今天这篇文章，我的初衷是想告诉大家如何优雅地去实现Retry，因为在现实中我们总会遇到各种各样的枷锁，这些枷锁约束着你写出糟糕的代码，我们比别人用心甚至更努力，反而常常被认为是有代码洁癖或者是炫技，可不管怎么样，人生是我们自己的，如果没有办法说服别人在项目中使用这些技术，那我们就在项目以外的地方去使用，或者是告诉别人我们有一种相对优雅的设计，如果这个设计恰好对别人有用，对我们来说就是一种莫大的幸福。参考Polly的API风格，这个Retry被我设计成了下面的样子：123456789101112131415161718192021try&#123; var result = Retry.Default .Times(3) .Interval(2) .Catch&lt;DivideByZeroException&gt;() .Reject((count,ex)=&gt; &#123; var message = string.format(\"第&#123;0&#125;次重试，异常来自:&#123;1&#125;\", count, ex.Message); Trace.WriteLine(message); &#125;) .Execute&lt;int&gt;(()=&gt; &#123; var m = 0; return 3 / m; &#125;);&#125;catch(Exeption ex)&#123; Trace.WriteLine(ex.Message);&#125; &emsp;&emsp;我承认它和Polly非常地像，不过我并没有去看Polly是如何实现的，目前它的实现完全来自这篇文章中我们提到的这些策略。我在为它增加了针对返回值的断言支持，通过Return方法来实现，而对异常的支持则是通过Catch方法来实现，除此以外，它支持异步方法调用，我们熟悉的Task/async/await这些API都可以使用。目前它还是一个玩具儿，因为我发现最难的部分，其实是断言或者说自定义表达式的设计，对于线程安全相关的问题，我会在慢慢地去完善它，如果你对它感兴趣的话，可以通过这里访问：RetryIt。好了，感谢大家关注我的博客，今天这篇先写到这里啦，欢迎大家在博客中留言！","tags":[{"name":"异常","slug":"异常","permalink":"http://qinyuanpei.github.io/tags/异常/"},{"name":"重试","slug":"重试","permalink":"http://qinyuanpei.github.io/tags/重试/"},{"name":"想法","slug":"想法","permalink":"http://qinyuanpei.github.io/tags/想法/"}]},{"title":"使用Unity框架简化应用程序异常处理及日志记录流程","date":"2018-03-21T19:35:40.000Z","path":"posts/3291578070/","text":"&emsp;&emsp;最近公司安排学习项目代码，前后花了一周左右的时间，基本熟悉了项目中的各个模块，感觉项目难度上整体偏中等。这是一个具备完整前端和后端流程的项目，在学习这个项目的过程中，我逐渐发现某些非常有趣的东西，比如在Web API的设计中采用严谨而完善的错误码、使用OAuth和JWT对API资源进行访问控制，在JavaScript中使用修饰器特性来实现日志记录等等，这些东西我会在后续的博客逐步去整理，今天想说的是如何通过Unity框架来简化应用程序异常处理和日志记录流程，而之所以关注这个问题，是因为我发现项目中接近滥用的异常处理，以及我不能忍受的大量重复代码。 背景描述&emsp;&emsp;由于业务场景上的需要，我们在产品中集成了大量第三方硬件厂商的SDK，这些SDK主要都是由C/C++编写的动态链接库，因此在使用这些SDK的过程中，通常频繁地使用返回值来判断一个方法是否成功被调用，虽然项目上制定了严格的错误码规范，可当我看到大量的Log()方法和业务逻辑混合在一起时，我内心依然是表示拒绝的，甚至我看到在捕获异常以后记录日志然后继续throw异常，这都是些什么鬼操作啊，考虑到我的语言描述得可能不太准确，大家可以从下面两段代码来感受下整体画风：1234567891011121314151617public short LoginTerminal(string uid,string pwd)&#123; try &#123; Log.BeginLog() return SDK.Login(uid,pwd) &#125; catch(Exception ex) &#123; log.LogError(ErrorCode.E2301,ex) throw new TerminalException(ex.Message); &#125; finally &#123; Log.EndLog() &#125;&#125; &emsp;&emsp;这是一段相对完整的业务逻辑代码，当然这里都是伪代码实现，这里我比较反感的两个地方是：第一，从头出现到尾的BeginLog()/EndLog()这对方法；第二，在Catch块中记录完日志然后将异常再次抛出。经过我对项目的一番了解，BeginLog()/EndLog()这对方法会在日志中记录某个方法开始执行和结束执行的位置。在方法执行前后插入代码片段，这不就是面向切面编程(AOP)的思想吗？这里记录完日志然后再抛出异常的做法，我个人是不大认同的，因为我觉得拦截异常应该有一个统一的入口，因为异常会继续向上传递，既然如此，为什么我们不能统一地去处理异常和记录日志呢？难道就一定要让Log这个静态类无处不在吗？同样地，我们注意到项目还会有下面这样的代码：1234567891011121314public void ProcessTerminal(object sender,ProcessEventArgs args)&#123; try &#123; Log.BeginLog(); var terminal = (Termainal)sender; var result = terminal.Process(args); &#125; finally &#123; Log.EndLog(); &#125;&#125; &emsp;&emsp;这种代码看起来不再关注异常，可和第一段一样，从头出现到尾的BeginLog()/EndLog()简直不能忍，而且这里的try…finally结构难免让人想起using的语法糖，那么这样是不是可以考虑让这个Log拥有类似的结构，换言之，我们总不能一直都在每一个方法里，重复写BeginLog()/EndLog()这两个方法吧，既然EndLog()方法总是在finally块里被执行，那为什么不考虑把它放到Dispose()方法里(前提是有一个结构实现IDispose接口)。你问我是不是有代码洁癖啊？我真的没有，我就是懒，不喜欢重复做一件事情。所谓”管中窥豹，可见一斑”，大家可以想象整个项目会是什么样子。 &emsp;&emsp;好了，为了避免让自己写这种糟糕的代码，我决心使用Unity框架来简化下这里的异常处理和日志记录流程，一个有追求的程序，如果可以交给自动化工具去做的事情，为什么要一次又一次地重复去写呢？我们可以吐槽一段代码写得有多糟糕，可我们所做的任何努力，都是为了让自己不变成这个样子。Unity框架提供的AOP，即面向切面编程，不就可以做这样的事情吗？所以，能动手的就直接动手，君子有所为有所不为，不要重复自己， Unity框架与AOP&emsp;&emsp;好啦，交待完故事背景，今天的主角终于可以登场啦！经常关注我博客的朋友，一定知道我个人比较喜欢IoC/AOP这类所谓的”奇技淫巧”，就在今天我还在和一位同事在讨论Ioc，这位同事认为Ioc增加了代码的复杂性，不认为Ioc会为项目带来明显的便利性。其实我相信大道至简，任何框架对我们而言都是高度抽象的，可正是因为有了这些抽象的层次，我们渐渐学会了关注核心的东西。这里提到了Ioc，即控制反转，或者我们可以称之为依赖注入，那么Unity框架就是.NET下众多依赖注入框架之一，这里称之为Unity框架，主要是避免和跨平台游戏引擎Unity产生混淆，以下全部称之为Unity框架。Unity框架中提供了核心的依赖注入相关的接口，而微软的企业最佳实践库中为Unity扩展出了AOP相关的功能。除此以外，Spring.NET、Aspect.Core、AspectF等都是.NET下的AOP方案。那么在今天的故事中，我们遇到了的一个场景是在指定方法执行前、后插入代码片段，这是面向切面编程(AOP)的基本思想，为此，我们考虑使用Unity框架来简化应用程序中异常处理及日志记录流程。 Unity中的三种拦截器&emsp;&emsp;Unity中提供了三种典型的拦截器，为了选择一种合适的拦截器来实现我们的功能，我们首先来了解下这三种不同的拦截器各自的应用场景： TransparentProxyInterceptor：即透明代理拦截器，基于.NET Remoting 技术实现代理，它可以拦截对象的所有函数，缺点是被拦截对象必须继承自MarshalByRefObject。 InterfaceInterceptor：顾名思义，即接口拦截器，仅拦截指定接口，显然只要目标类型实现了指定接口就可以拦截。C#不支持多继承，选择这种方式对代码的影响最小。 VirtualMethodInterceptor：顾名思义，即虚方法拦截器，仅拦截虚方法，这个对目标类型的要求就非常高啦，一般我们不会考虑这种方式。 对Unity框架而言，不管我们使用哪一种拦截器，我们都需要通过UnityContainer这个容器来为目标类型注入拦截器，这样Unity框架会帮助我们生成代理对象，我们只要在使用代理对象的时候，这些拦截器才会真正工作。博主曾经以为定义好下面这些Handler就可以了，简直是图样图森破。好了，一个基本的代码流程如下，请不要问我配置文件怎么配，我真的不喜欢配置文件，搞得跟某配置狂魔语言似的，反正这些配置文件这次记住了下次还是会忘的，可下面这几行代码是不会轻易忘记的啊：123var container = new UnityContainer().AddNewExtension&lt;Interception&gt;().RegisterType&lt;IBussiness, Bussiness&gt;();container.Configure&lt;Interception&gt;().SetInterceptorFor&lt;IBussiness&gt;(new InterfaceInterceptor());var bussiness = container.Resolve&lt;IBussiness&gt;(); 注意，这里不要直接从Github或者Nuget上下载Unity框架，因为最新版的Unity我实在是不会用啊！:joy: 我喜欢开箱即用的产品，我愿意钻研啊，可DeadLine永远会有终点！我们需要从微软企业最佳实践库中下载以下动态链接库： CommonServiceLocator.dll Microsoft.Practices.Unity.Configuration.dll Microsoft.Practices.Unity.dll Microsoft.Practices.Unity.Interception.Configuration.dll Microsoft.Practices.Unity.Interception.dll考虑到我们这里需要实现两种功能，针对异常的异常处理流程，以及正常的日志记录流程，为此我们将实现ExceptionHandler和LogHandler两个组件。下面我们来一起了解这两个组件的实现过程，这里博主选择了最简单的ICallHandler接口，而非更一般的IInterceptionBehavior接口，主要希望让这个过程更简单些，同时实现在方法粒度上的可控，即我们可以选择性的去拦截某一个方法，而非全部的方法，因为在实际业务中并非所有的方法都需要拦截。 LogHandler的实现&emsp;&emsp;LogHandler主要用于记录日志，所以我们需要记录方法的名字，方法的参数以及方法执行的结果，甚至是是否引发异常，这些功能在AOP中是相对基础的功能，Unity框架为我们提供了这些基础设施，我们只要就可以获取到这些信息，然后将其记录到日志中即可。这里的代码如下：123456789101112131415161718192021public class LogHandler : ICallHandler&#123; int ICallHandler.Order &#123; get; set; &#125; IMethodReturn ICallHandler.Invoke(IMethodInvocation input, GetNextHandlerDelegate getNext) &#123; var methodInfo = input.MethodBase; var methodName = methodInfo.Name; Logger.Log(string.Format(\"----------开始调用&#123;0&#125;----------\", methodName)); var parameters = methodInfo.GetParameters(); var arguments = input.Arguments; var logInfo = parameters.Select(e =&gt; string.Format(\"&#123;0&#125;:&#123;1&#125;\", e.Name, arguments[e.Position])); Logger.Log(\"传入的参数为:\" + string.Join(\",\", logInfo.ToArray())); var result = getNext()(input, getNext); if (result.Exception != null) Logger.Log(string.Format(\"调用异常:&#123;0&#125;-&#123;1&#125;\", result.Exception.Message, result.Exception.StackTrace)); Logger.Log(string.Format(\"调用&#123;0&#125;的结果为：&#123;1&#125;\", methodName, result.ReturnValue)); Logger.Log(string.Format(\"----------结束调用&#123;0&#125;----------\", methodName)); return result; &#125;&#125; 为了让这个Handler更好用一些，我们希望它可以以Attribute的方式出现在方法上面，这样被标记过的方法就会被Unity框架拦截，所以我们需要一个继承自Attribute类的东西，知道我为什么不喜欢配置文件吗？因为我有Attribute啊！幸运的是Unity框架为我们提供了这样一个基类：HandlerAttribute，由此下面的代码可以这样写：12345678[AttributeUsage(AttributeTargets.Method,AllowMultiple = true)]class LogHandlerAttribute : HandlerAttribute&#123; public override ICallHandler CreateHandler(IUnityContainer container) &#123; return new LogHandler(); &#125;&#125; ExceptionHandler的实现&emsp;&emsp;对于ExceptionHandler来说，它相比LogHandler增加的功能在于，它需要处理异常，按照目前项目的异常处理习惯，这种和硬件相关的方法都会被定义为一个ErrorCode，为此我们的ExceptionHandler类中需要增加一个ErrorCode类型的成员，这是一个枚举类型。这里的代码实现如下：123456789101112131415161718192021222324252627public class ExceptionHandler : ICallHandler&#123; int ICallHandler.Order &#123; get; set; &#125; public string ErrorCode &#123; get; set; &#125; IMethodReturn ICallHandler.Invoke(IMethodInvocation input, GetNextHandlerDelegate getNext) &#123; var methodInfo = input.MethodBase; var methodName = methodInfo.Name; Logger.Log(string.Format(\"--------------方法&#123;0&#125;执行开始--------------\", methodName)); var parameters = methodInfo.GetParameters(); var arguments = input.Arguments; var logInfo = parameters.Select(e =&gt; string.Format(\"&#123;0&#125;:&#123;1&#125;\", e.Name, arguments[e.Position])); Logger.Log(\"传入的参数为:\" + string.Join(\",\", logInfo.ToArray())); var result = getNext()(input, getNext); if (result.Exception != null) &#123; Logger.Log(string.Format(\"Error Code is &#123;0&#125;\", ErrorCode)); result.Exception = null; Logger.Log(string.Format(\"--------------方法&#123;0&#125;执行结束--------------\", methodName)); throw new Exception(ErrorCode); &#125; Logger.Log(string.Format(\"--------------方法&#123;0&#125;执行结束--------------\", methodName)); return result; &#125;&#125; 可以注意到ExceptionHandler相比LogHandler的变化，主要发生在异常处理这部分，如你所愿，我在拦截到异常以后抛出了一个对应ErrorCode的异常，虽然我不赞同这种做法，但为了尊重现有项目的编程风格，我只能写有这样一行看起来非常拙劣的代码，我真的没有代码洁癖，我仅仅是觉得它还不够好，就像我觉得自己还不够好一样，同样，它需要定义一个对应的Attribute类，这样我们可以更加自由地使用这些特性：12345678[AttributeUsage(AttributeTargets.Method,AllowMultiple = true)]class LogHandlerAttribute : HandlerAttribute&#123; public override ICallHandler CreateHandler(IUnityContainer container) &#123; return new LogHandler(); &#125;&#125; 本文小结&emsp;&emsp;好了，现在我们可以来看，如何使用这篇文章中定义的两个组件：1234567var container = new UnityContainer().AddNewExtension&lt;Interception&gt;().RegisterType&lt;IBussiness, Bussiness&gt;();container.Configure&lt;Interception&gt;().SetInterceptorFor&lt;IBussiness&gt;(new InterfaceInterceptor());var bussiness = container.Resolve&lt;IBussiness&gt;();var sum = bussiness.Add(12,23);Console.WriteLine(sum);var div = bussiness.Divide(1,0)Console.WriteLine(div) IBussiness接口及其实现类Bussiness定义如下：123456789101112131415161718192021public interface IBussiness&#123; int Add(int a, int b); int Divide(int a, int b);&#125;public class Bussiness : MarshalByRefObject, IBussiness&#123; [LogHandler] public int Add(int a, int b) &#123; return a + b; &#125; [ExceptionHandler(ErrorCode = \"E2303\")] public int Divide(int a, int b) &#123; return a / b; &#125;&#125; 好了，现在我们来看一下结果： 使用AOP简化后的异常处理和日志记录流程 &emsp;&emsp;我们为此付出的代价是什么？第一，要有一个接口，写接口难道还有疑问吗？第二，要添加Attribute到指定方法上面，我保证这点时间足够你写好几遍重复代码了。第三，需要依赖注入机制，这个可能是到目前为止最大的影响，因为有了依赖注入以后，对象的实例化都交给了Unity框架，看起来我们好像被束缚了手脚，不能再任性地new一个对象实例出来，可这不正是依赖注入的精髓所在吗？我们就是需要Unity框架，来帮助我们管理这些模块间的依赖关系及其生命周期，如果你觉得这点代码不能接受，抱歉，任何依赖注入框架拯救不了你！ &emsp;&emsp;今天这篇文章，我们从一个实际项目的背景出发，引出使用Unity框架来简化异常处理和日志记录流程这一想法，在正式实践这一想法前，我们首先了解了Unity框架中提供的三种拦截器及其各自优劣，在此基础上我们实现了LogHandler和ExceptionHandler两个组件，并展示了如何使用这两个组件，探讨使用整个AOP机制对现有项目的影响有多大，以及为什么我们需要Unity框架等问题，框架固然重要，了解为什么使用框架则更重要！好啦，这就是今天这篇文章的内容啦，再次谢谢大家关注我的博客，各位晚安！:smile:","tags":[{"name":"AOP","slug":"AOP","permalink":"http://qinyuanpei.github.io/tags/AOP/"},{"name":"异常","slug":"异常","permalink":"http://qinyuanpei.github.io/tags/异常/"},{"name":"日志","slug":"日志","permalink":"http://qinyuanpei.github.io/tags/日志/"}]},{"title":"基于新浪微博的男女性择偶观数据分析(下)","date":"2018-03-17T15:28:40.000Z","path":"posts/3083474169/","text":"&emsp;&emsp;各位朋友，大家好，我是Payne，欢迎大家关注我的博客。我的博客地址是：https://qinyuanpei.github.io。对于今天这篇文章的主题，相信经常关注我博客的朋友一定不会陌生。因为在2017年年底的时候，我曾以此为题写作了一篇文章：基于新浪微博的男女择偶观数据分析(上)。这篇文章记录了我当时脑海中闪烁着的细微想法，即当你发现一件事物背后是由哲学或者心理学这类玄奥的科学在驱动的时候，不妨考虑使用数学的思维来让一切因素数量化，我想这是最初数据分析让我感兴趣的一个原因。因为当时对文本的处理了解得非常粗浅，所以在第一次写作这篇文章的时候，实际的工作不过是在分词后绘制词云而已。等到我完成对微信好友信息的数据分析以后，我意识到微博这里其实可以继续发掘。关于微信好友信息的数据分析，可以参考这篇文章：基于Python实现的微信好友数据分析。在这样的想法促使下，便有了今天这篇文章，因为工作关系一直没有时间及时整理出来，希望这篇文章可以带给大家一点启示，尤其是在短文本分类方面，这样我就会非常开心啦！:slightly_smiling_face: 故事背景&emsp;&emsp;关于故事背景，我在 基于新浪微博的男女择偶观数据分析(上) 这篇文章中说得非常清楚啦。起因就是我想知道，男性和女性在选择伴侣的时候，到底更为关注哪些因素？在对微信好友信息进行数据分析的时候，我们可以非常直接地确定，譬如性别、签名、头像、位置这四个不同的维度，这是因为我们处理的是结构化的数据。什么是结构化的数据呢？一个非常直观的认识是，这些数据可以按照二维表的方式组织起来。可对于微博这样一个无结构的文本数据类型，我们除了对词频、词性等因素做常规统计分析以外，好像完全找不到一个合理有效的方案，因为我们很容易就明白一件事情，即：在短短的140个字符中，人类语言的多样性被放大到淋漓尽致 。为了将种种离散的信息收敛在一个统一的结构里，我们必须为这些文本构建一种模型，并努力使这种模型可以量化和计算。我们通过词云对微博进行可视化分析，更多是针对词频的一种分析方法，这种方法虽然可以帮助我们找出关键字，可是因为最初写作这篇文章时，对数据分析领域相关知识知之甚少，而且在分析的过程中没有考虑停用词，所以我认为在文本分类或者是主题提取层面上，我们都需要一种更好的方法。 常见的技术方法&emsp;&emsp;这篇文章涉及的领域称为文本分类或者主题提取，而针对微博、短信、评论等这类短文本的分类，则被称为短文本分类。为什么要进行文本分类呢？第一，提取出潜在主题以后可以帮助我们做进一步的分析。譬如博主这里想要从相亲类微博中分析男性和女性的择偶观，首先要解决的就是主题建模问题，因为在择偶过程中要考虑的因素会非常多，我们到底要选取哪些因素来分析呢？这些因素在特定领域中被称为特征，所以文本分类的过程伴随着特征提取。第二，短文本数据通常只有一个主题，看起来这是在简化我们的分析过程，实则传统的基于文档的主题模型算法在这里难以适用。因为这类主题模型算法都假定一篇文档中含有多个主题，而我们分析的是群体现象，这种个体上的差异必须设法将其统一于一体，比如美元和$属于同一个主题，我们需要一种策略来对其进行整合。 &emsp;&emsp;传统主题提取模型通常由文本预处理、文本向量化、主题挖掘和主题表示等多个流程组成，每个流程都会有多种处理方法，不同的组合方法会产生不同的建模结果。目前，人们在传统主题提取模型的基础上，发展起了以CNN和RNN为代表的深度学习方法，在这里我们依然关注传统主题提取模型，因为这个领域对博主而言是个陌生的领域，这里我们更多的是关注传统主题提取模型。按照传统主题提取模型，文本分类问题被拆分为特征工程和分类器两个部分，其中，特征工程的作用是将文本转化为计算机可以理解的格式，并提供强特征表达能力，即特征信息可以用以分类，而分类器基本上是统计学相关的内容，其作用是根据特征对数据进行分类。下面来简单介绍下常见的技术方法。 特征工程&emsp;&emsp;特征工程覆盖了文本预处理、特征提取和文本表示三个流程。文本预处理通常指分词和去除停用词这两个过程，可以说分词是自然语言处理的基本前提。特征提取实际上囊括两个部分，即特征项的选择和特征项权重的计算。选择特征项的基本思路是：根据某个评价指标对原始数据进行排序，然后从中选择分数最高的评价指标，同时过滤掉其余的评价指标。通常可以选择的评价指标有文档频率、互信息、信息增益等，而特征权重的计算主要是经典的TF-IDF算法及其扩展算法。文本表示是指将文本预处理后转化为计算机可以理解的格式，是决定分类效果最重要的部分。传统做法是使用词袋模型(BOW)或者向量空间模型(VSM)，比如Word2Vec就是一个将词语转化为向量的相关项目。因为向量模型完全忽视文本的上下文，所以为了弥补这种技术上的不足，业界同时使用基于语义的文本表示方法，比如常见的LDA语义模型。 分类器&emsp;&emsp;分类器主要是统计学里的分类方法，基本上大部分的机器学习方法都在文本分类领域有所应用，比如最常见的朴素贝叶斯算法(Naive Bayes)、KNN、支持向量机(SVM)、最大熵(MaxEnt)、决策树和神经网络等等。简单来说，假设我们所有的数据样本可以划分为训练集和测试集。首先，分类器可以在训练集上执行分类算法以生成分类模型；其次，分类器可以通过分类模型对测试集进行预测以生成预测结果；最后，分类器可以计算出相关的评价指标以评估分类的效果。这里最常用的两个评价指标是准确率和召回率，前者关注的是数据的准确性，后者关注的是数据的全面性。 TF-IDF与朴素贝叶斯&emsp;&emsp;TF-IDF(term frequency–inverse document frequency)是一种被用于信息检索与数据挖掘的统计学方法，常常被用来评估某个字词对于一个文件集或者是一个语料库中的一份文档的重要程度。在特征工程这里我们提到，特征工程中主要通过特征权重来对数据进行排序和分类，因此TF-IDF本质上是一种加权技术。TF-IDF的主要思想是：字词的重要性与它在文件中出现的次数成正比上升，与此同时与它在语料库中出现的频率成反比下降。这句话是什么意思呢？如果某个词或者短语在一篇文章中出现的频率(即TF)较高，并且在其它文章中出现的频率(即IDF)较低，那么就可以人为这个词或者短语可以作为一个特征，具备较好的类别区分能力，因此适合用来作为分类的标准。TF-IDF实际上是TF * IDF，即TF(term frequency，词频)与IDF(inverse document frequency，逆文档频率)的乘积，具体我们通过下面的公式来理解： term frequency，词频 &emsp;&emsp;显然，这里的TF表示某一词条在文档中出现的频率。再看IDF: inverse document frequency，逆文档频率 &emsp;&emsp;这里的D表示语料库中文档的数目，而分母表示的是含有指定词的文档的数目，这里两者求商后取对数即可得到IDF。需要注意的是，当该词语不在语料库中时，理论上分母会变成0，这将导致计算无法继续下去，因此为了修正这一错误，我们在分母上加1，这样就可以得到IDF更为一般的计算公式。按照这样的思路，我们将两段文本分完词以后，分别计算每一个词的tf-idf并按照tf-idf对其进行排序，然后选取前N个元素作为其关键字，这样我们就获得了两个N维向量，按照向量理论的相关知识，两个向量间的夹角越小，其相关性越显著，这就是文本相似度判断的常规做法，在这个过程中，我们覆盖到了文本预处理、特征提取和文本表示三个过程，相信大家会对这个过程有更好的理解。 &emsp;&emsp;好了，那么什么是特征呢？这里计算出来的tf-idf实际上就是一组特征，这个特征是上下文无关、完全基于频率分析的结果，现在这些结果都是计算机可以处理的数值类型，所以特征工程要做的事情，就是从这些数值中分析出某一种规律出来。譬如，我们通过分析大量的气象资料，认为明天有80%的概率会下雨，那么此时下雨的概率0.8就可以作为一个特征值，在排除干扰因素的影响以后，我们可以做一个简单的分类，如果下雨的概率超过0.8即认为明天会下雨，反之则不会下雨。这是一个接近理想的二值化模型，在数学中我们有一种概率分布模型称为0-1分布，即一件事情只有两个可能，如果该事件会发生的概率为p，则该事件不会发生的概率为1-p。如果所有的问题都可以简化到这种程度，我相信我们会觉得这个世界枯燥无比，因为一切非黑即白、非此即彼，这会是我们所希望的世界的样子吗？&emsp;&emsp;为什么在这里我要提到概率呢？因为这和我们下面要提到的朴素贝叶斯有关。事实上，朴素贝叶斯的理论基础，正是我们所熟悉的条件概率。根据概率的相关知识，我们有以下公式，即全概率公式：P(A|B) = P(AB)/P(B)。我们对A和B进行交换，同理可得：P(B|A) = P(A/B)/P(A)。由此我们即得到了贝叶斯公式： 贝叶斯公式 &emsp;&emsp;所以，朴素贝叶斯本质上是一种基于概率理论的分类算法。我们知道条件概率成立的前提是各个事件都是独立的，因此在朴素贝叶斯算法中假设所有特征间都是独立的，可当我们逐渐地了解这个世界，就会明白这个世界并不是非黑即白、非此即彼的，甚至一件事情会受到来自方方面面的因素影响，就像我们从前学习物理的时候喜欢用控制变量法一样，总有一天你会明白当时的想法太天真。朴素贝叶斯算法中的“朴素”，通常被翻译为Naive，而这个词就是表示天真的意思，这正是朴素贝叶斯的名称由来，它简单粗暴地认为各个特征间是相互独立的，有人认为这种假设是相当不严谨的，所以相当排斥这种分类的理论，所幸朴素贝叶斯在实际应用中分类效果良好，尤其是在解决垃圾邮件过滤这类问题上，所以到今天为止，朴素贝叶斯依然是一个相当经典的分类算法，它是一个根据给定特性/属性，基于条件概率为样本赋予某个类别标签的模型。 数据分析&emsp;&emsp;好了，讲述这些理论知识实在是一件苦差事，因为让读者了解一套新的知识，远远比让自己了解一套新的知识容易，所以在描述这些理论的时候，我努力地避免给大家留下晦涩深奥地印象，可这样难免会让读者觉得我不太专业。可是，谁让我们生活在一个被无数前辈开垦过地世界里呢？作为一个资深的“调包侠”，这些理论我们能理解多少算多少，最终我们需要的只是一个库而已，所以在正式进入下面的内容时，我们首先来梳理侠整体数据分析的思路，这样我们就能对整个过程有一个相对感性的认识了。关于如何从新浪微博抓取数据，这个我们在上篇有详细的介绍，这里不再重复阐述，所有数据我们都存储在数据库里，下面的图示不再展示关于数据库的细节： 特征分析流程图 &emsp;&emsp;简单来讲，这是一个有监督的、使用二元分类的特征提取过程。这里的语料库是由人工进行编制的文本资料，语料库的好坏将直接影响到分类的效果。比如说，我们希望提取的特征是陕西省的地理信息，那么我们就需要准备一个，由陕西省所辖的所有地级市组成的文本文件，这里为了方便后续处理，我们建议每行存放一个短文本信息。 &emsp;&emsp;接下来，我们会从数据库中读取所有的数据，然后进行预处理操作，这里的预处理是指分词和去除停用词，停用词表是从网络上下载的，然后根据我们自己的需要再在基础上进行添加，我们会选取前20个词语作为关键词，这里使用了结巴分词的相关接口，其算法原理正是tf-idf。我们会使用这20个关键词，和语料库中每一个主题下的内容进行比较，这里的相似度由SnowNLP提供支持，其计算结果是一个20维的向量，我们对向量进行归一化后，如果其向量中所有维度的值的最大值&gt;=0.95，则认为该文本和这一主题相关，因此该主题的权重会增加1，否则会继续计算下一个文本的相似度。 &emsp;&emsp;我们汇总所有主题的权重，即可统计出各个主题出现的频率。比如我们这里关注A、B、C三个主题，而经过计算这三个主题各自出现的频率为0.1、0.8和0.1，所以我们这里可以理解为：这里有80%的把握认为文本和B主题有关，由此我们选取出了分类的特征，这里我们使用一个元组来表示特征，其表示为([0.1,0.8,0.1],”B”)。依次类推，我们就获得了全部的特征信息。接下来，我们使用nltk中提供的朴素贝叶斯分类器对内容进行分类，训练集和测试集合各占50%，最终通过准确度来评估整个分类的效果。 特征分析&emsp;&emsp;特征分析的难点主要在特征的提取，在这里我们通过不同主题的频率来选取特征：123456789101112131415161718192021222324252627def buildFeatures(sentence,document): tokens = jieba.analyse.extract_tags(sentence) tokens = list(filter(lambda x:x.strip() not in stopwords, tokens)) features = &#123;&#125; for (subject,contents) in document.items(): for content in contents: if(similarText(tokens,content)): if(subject in features): features[subject]+=1 else: features[subject]=1 total = sum(features.values()) for subject in features.keys(): features[subject] = features[subject] / total # 特征归一化 for subject in subjects: if(subject not in features.keys()): features[subject] = 0 # 预测结果 max_value = max(features.values()) suggest_subject = ' ' for (key,value) in features.items(): if(value == max_value): suggest_subject = key return features, suggest_subject 其中，stopwords我们从一个指定文件中读取：1stopwords = open('stopwords.txt','rt',encoding='utf-8').readlines() 这里有一个计算句子和主题相似度的方法similarText()，其定义如下：123456789# 文本相似度def similarText(tokens,content): snow = SnowNLP(tokens) similar = snow.sim(content) norm = math.sqrt(sum(map(lambda x:x*x,similar))) if(norm == 0): return False similar = map(lambda x:x/norm,similar) return max(similar)&gt;=0.95 我们通过下面的代码来构建特征，以及使用朴素贝叶斯分类器进行分类，核心代码如下：12345678910111213141516171819def analyseFeatures(): rows = loadData() document = loadDocument(subjects) features = [buildFeatures(row[0],document) for row in rows] length = len(features) print('数据集: ' + str(length)) cut_length = int(length * 0.5) print('训练集: ' + str(cut_length)) train_set = features[0:cut_length] print('测试集: ' + str(length - cut_length)) test_set = features[cut_length:] classifier = nltk.NaiveBayesClassifier.train(train_set) train_accuracy = nltk.classify.accuracy(classifier,train_set) print('准确度: ' + str(train_accuracy)) counts = Counter(map(lambda x: x[1],test_set)) for key, count in counts.items(): freq = count/len(test_set) print(\"主题&lt;&#123;0&#125;&gt;: &#123;1&#125;\".format(key,freq)) &emsp;&emsp;下面是特征提取相关的结果，因为最近对语料库进行了调整，所以准确度只有92%，用一位前辈的话说，数据分析就像炼丹，在结果没有出来以前，没有人知道答案会是什么。这里使用的是nltk内置的朴素贝叶斯分类器，而nltk是一个自然语言处理相关的库，感兴趣的朋友可以自行了解，这里推荐一本书：《NLTK基础教程(用NLTK和Python库构建机器学习应用)》。下图中展示了各个主题在整个微博文本中所占的比重： 特征提取及其分类效果 年龄分布&emsp;&emsp;对于男女性的年龄分布，我们通过正则来提取微博中年龄相关的数值，然后统计不同年龄出现的频数，并将其绘制为柱形统计图，相关代码实现如下：1234567891011121314151617181920def analyseAge(): ages = [] rows = loadData() pattern = re.compile(r'\\d&#123;2&#125;\\年|\\d&#123;2&#125;\\岁') for row in rows: text = row[0].decode('utf-8') matches = pattern.findall(text) if(len(matches)&gt;0): match = matches[0] if(u'年' in match): now = datetime.datetime.now().year birth = int(''.join(re.findall(r'\\d',match))) ages.append(now - 1900 - birth) else: ages.append(int(''.join(re.findall(r'\\d',match)))) ages = list(filter(lambda x: x&gt;10 and x&lt;40, ages)) freqs = Counter(ages).items() freqs = sorted(freqs,key=lambda x:x[0],reverse=False) freqs = dict(freqs) drawing.bar('男女性择偶观数据分析:年龄分布',freqs,'年龄','人数',None) &emsp;&emsp;通过图表，我们可以发现：择偶年龄重点集中在24~28岁之间，并且整个年龄区间符合正态分布。每年过年的时候，我们都会听到年轻人被催婚的声音，甚至作为一个单身的人，每一个节日都像是我们的忌日，因为无论在哪里，你都可以被秀恩爱或者被撒狗粮。“哪有人会喜欢孤独呢？不过是不喜欢失望”，当这句话出现在我的Kindle屏幕上，出现在村上春树的《挪威的森林》里，我突然有种扎心的感觉。有一天，当我不在视爱情为必需品时，我突然意识到生命里有太多比感情重要的事情。我不希望我们因为一句年龄到了就去结婚，如果人生的一切都有期限都要按部就班，那么为什么我们不能平静地面对衰老和死亡呢？人天生起点就是不一样的，所以你不必努力去迎合别人定制的标准，就像学生时代大家面对的是同一张考卷，有的人交卷交得早，有的人交卷交得晚，有的人考试成绩好，有的人考试成绩差，可这不过是一场考试而已，不是吗？如果我的时间不能浪费在我喜欢的人身上，我宁愿永远将时间浪费在自己的身上，除了生与死以外，结婚和繁衍并不是必答题，我可以不结婚啊，一如我可以交白卷啊！ 男女性择偶观数据分析:年龄分布 性别组成&emsp;&emsp;性别组成，我们主要从微博中的关键字入手，因为这些微博明确了择偶的是男嘉宾还是女嘉宾，我们通过这些特征就可以分析出男女性别比例。相关代码实现如下：12345678910def analyseSex(): rows = loadData() sexs = &#123;'male':0, \"female\":0&#125; for row in rows: text = row[0].decode('utf-8') if u'男嘉宾[向右]' in text: sexs['male']+=1 elif u'女嘉宾[向右]' in text: sexs['female']+=1 drawing.pie('男女性择偶观数据分析:男女性别比例',sexs,None) &emsp;&emsp;通过下面的图表，我们可以非常直观地看到，男性数量是超过女性数量的，两者比例接近1.38:1。这和目前中国的实际基本相符，考虑到人们有更多的相亲渠道可以选择，我认为实际的比例应该会更大，媒体称适婚男性比女性多出3000万，性别比例的失衡难免会让男生找不到对象。可找不着对象有什么关系呢？人生短短一世，活着时候能见到最多不过四世同堂，血缘关系并不能让后辈替你完成未竟之事，当一个离开了这个世界，它与世界的关联就变得微乎其微，时间会让记忆逐渐模糊直至遗忘，你无法将这点微弱的安全感寄托在某一个人身上，人生而有涯，而知无涯，能在这个世界里流传下去的只有思想，我不想和任何人去攀比，因为生而为人，我很抱歉。 男女性择偶观数据分析:男女性别比例 身高分布&emsp;&emsp;身高分布，同样采用关键字匹配的方式实现，不同的是，择偶者通常会在微博中给出自己的身高以及对伴侣期望的身高，由此我们对微博中的身高进行了提取，分别获得了男性、女性身高分布及其身高差分布。这是我最开始研究这个问题的初衷，现在的结果印证了当时的想法，我内心其实是特别开心的，这正是为什么要花时间和精力写这篇文章的原因所在。这里，相关的代码实现如下：12345678910111213141516171819202122232425262728293031# 身高分布def analyseHeight(): heights = [] rows = loadData() pattern = re.compile(r'1\\d&#123;2&#125;|\\d&#123;1&#125;\\.\\d&#123;1,2&#125;|\\d&#123;1&#125;\\米\\d&#123;2&#125;') for row in rows: text = row[0].decode('utf-8') matches = pattern.findall(text) if(len(matches)&gt;1): matches = map(lambda x:int(''.join(re.findall(r'\\d',x))),matches) matches = list(filter(lambda x: x&lt;190 and x&gt;150, matches)) if(len(matches)&gt;1): height = &#123;&#125; height['male'] = max(matches) height['female'] = min(matches) heights.append(height) # 男性身高分布 male_heights = list(map(lambda x:x['male'],heights)) male_heights = Counter(male_heights).items() male_heights = dict(sorted(male_heights,key=lambda x:x[0],reverse = False)) drawing.bar('男女性择偶观数据分析:男性身高分布',male_heights,'身高','人数',None) # 女性身高分布 female_heights = list(map(lambda x:x['female'],heights)) female_heights = Counter(female_heights).items() female_heights = dict(sorted(female_heights,key=lambda x:x[0],reverse = False)) drawing.bar('男女性择偶观数据分析:女性身高分布',female_heights,'身高','人数',None) # 男女身高差分布 substract_heights = list(map(lambda x:x['male']-x['female'],heights)) substract_heights = Counter(substract_heights).items() substract_heights = dict(sorted(substract_heights,key=lambda x:x[0],reverse = False)) drawing.bar('男女性择偶观数据分析:男女身高差分布',substract_heights,'身高差','人数',None) &emsp;&emsp;虽然女生都希望男生180以上，据说这样可以举高高、有安全感，可是作为一个成年人，我们必须勇敢地打破这种不切实际的幻想，因为身高和外貌都是父母给我们的，那些基因里决定的东西，往往是我们无法通过后天努力来弥补的。如果可以的话，我希望自己再长高5厘米，可如果我再无法长高，我希望你能接受现在的我，接受一个人身高上的缺陷，和接受一个人人性中的缺点，在我看来是一模一样的。可人类最大的问题， 就在于愿意相信自己眼睛看到的，耳朵听到的，并且这是两个人建立联系的前提，人家愿意了解你有趣的灵魂，前提是你有一副好看的皮囊，人类啊，说到底是一种比较高级的动物而已，就像动物用皮毛、肤色去吸引同类一样，如你所见，男生平均身高其实只有175而已！ 男女性择偶观数据分析:男性身高分布 &emsp;&emsp;女性的身高通常不会被作为筛选条件，正如社会群体通常都是对男性提出各种要求一样，两个同等条件下的男、女性，人们理所当然地对男性提出了更高的要求，可其实大家都是母亲十月怀胎而来，同样地都在这个世界里生活了20多年。所以这个世界上有太多地问题，其实都是人们自己造成的。比如女性一定要找一个穿高跟鞋后还要比她高的男性，而男性一定要找一个身高上和他相差不大的女性，男性的身高不足175，同女性的身高不足165一样，都是人们眼中比较尴尬的身高，可你看这图表中女性的平均身高是160，那么，就让大家一起尴尬吧，不知道当年小平爷爷和拿破仑将军的夫人心里是怎么想的啦！ 男女性择偶观数据分析:女性身高分布 &emsp;&emsp;最初我研究这个问题的时候，我发现微博上有好多身高不足160的女性，要求伴侣期望身高都是175以上，作为一个身高只有170的男生，我感到绝望和悲伤啊，后来和一位朋友聊天，他说他觉得我连170都没有，我想说人类为什么要这般奇怪，譬如体重一定要说得比实际轻、身高一定要说得比实际高、年龄一定要说得比实际小……难道这样不感觉累吗？那么到底有多少人希望两个人的身高差超过20厘米呢？网络上流传的所谓最萌身高差到底萌不萌呢？你看孟德尔通过豌豆杂交试验来研究遗传问题，两个身高差超过20厘米的人的后代，平均下来难道不是只有170吗？图表表明，男女性之间最佳的身高差是15厘米。 男女性择偶观数据分析:男女身高差分布 地理分布&emsp;&emsp;因为在这些微博中会出现相亲者的地理信息，所以我们整理了陕西省各县市的名称作为关键字，试图分析出这些相亲者的地理分布，这里我们简单绘制了一个柱形图，相关代码实现如下：1234567891011121314# 地区分析def anslyseLocation(): freqs = &#123; &#125; citys = [u'西安',u'铜川',u'宝鸡',u'咸阳',u'渭南',u'延安',u'汉中',u'榆林',u'安康',u'商洛'] rows = loadData() for row in rows: text = row[0].decode('utf-8') for city in citys: if(city in text): if(city in freqs.keys()): freqs[city]+=1 else: freqs[city]=1 drawing.bar('地区分布图',freqs,'地区','人数',None) &emsp;&emsp;这里的结果令人出戏，因为西安作为陕西省的省会城市，在所有地区中一骑绝尘。考虑到在这些微博中”西安”存在干扰，所以这个结果并不是非常严谨，不能作为一个有效的分析指标，而且这里存在同义词，比如”本地”和”土著”其实都表示西安，而我们统计的时候并没有考虑这种情况，所以这里绘制的地区分布图表，大家看看就好啦！ 男女性择偶观数据分析:地区分布图 星座分布&emsp;&emsp;这里为什么要分析星座呢？理论上来讲，我是不大相信这些东西的，可当你经历的事情多了以后，你就会下意识地认为这些东西说得很对，我想古代的占卜算卦基本上是同样的东西，其实世间好多事情之间应该是没有直接的联系的，无非是在千百年的历史积淀中，逐渐地形成了一套建立在经验上的理论体系，这就像我们今天所追捧的机器学习，我们有千百年的历史长河去收集数据，每一个相信这些理论的人都是一个数据样本，这些理论体系通过不断地训练和模拟，逐渐可以正确地预测某些事情，让我们相信万事万物间存在某种联系。可即便如此，人类依旧免不了对各种事物存在偏见，比如星座中经常无辜躺枪的处女座、双子座和天蝎座，人类最擅长的认知方式，就是用一个群体现象来预测个人现象，可讽刺的是朴素贝叶斯就是这样的思想，所以这里我们简单地统计了下各种星座的频数分布：12345678910111213141516171819# 星座分析def analyseStar(): stars = ['白羊','金牛','双子','巨蟹','狮子','处女','天秤','天蝎','射手','摩羯','水瓶','双鱼'] freqs = &#123;&#125; rows = loadData() for row in rows: text = row[0].decode('utf-8') for star in stars: if(star in text): if(star in freqs.keys()): freqs[star]+=1 else: freqs[star]=1 for star in stars: if(star not in freqs.keys()): freqs[star] = 0 freqs = Counter(freqs).items() freqs = dict(freqs) drawing.pie('男女性择偶观数据分析:星座分布',freqs,None) &emsp;&emsp;这个结果相对客观些，因为12个星座基本上平分秋色啦，并不存在某种星座独领风骚的情况，简直是人与自然的大和谐了呢？ 男女性择偶观数据分析:星座分布 本文小结&emsp;&emsp;这篇文章写到这里，我其实已经非常疲惫啦，因为这篇文章的上篇与下篇中间相隔了差不多三个月，而且我写作上篇的时候，并没有打算写这一篇文章出来，再者两篇文章写作时的心境完全不同，所以现在写完这篇文章，终于有种如释重负的感觉，一来没有因拖延症而放弃这篇文章，二来为了了解相关的理论以及训练数据花费大量精力，我必须对自己的过去有一个总结，这是我今年年初给自己制定的目标，不管有没有喜欢我，我总要去做这些事情，不是因为我想要证明什么或者做给谁看，而是我认为这件事情比某些事情有趣而且重要。这篇文章首先承接上文，交待故事的背景，即为什么要做这样的数据分析；然后我们简单介绍了文本分类的常用的技术方法，主要以特征工程和分类器为主；接下来我们介绍了两个经典的理论：tf-idf和朴素贝叶斯，这是本文文本分类的理论基础；在数据分析这部分，我们对特征、年龄、性别、身高、地区和星座等进行了分析，并借助Python中的图表模块完成了数据的可视化工作。好啦，以上就是这篇文章的全部内容啦，欢迎大家积极留言和评论，晚安！","tags":[{"name":"微博","slug":"微博","permalink":"http://qinyuanpei.github.io/tags/微博/"},{"name":"朴素贝叶斯","slug":"朴素贝叶斯","permalink":"http://qinyuanpei.github.io/tags/朴素贝叶斯/"},{"name":"文本分类","slug":"文本分类","permalink":"http://qinyuanpei.github.io/tags/文本分类/"}]},{"title":"行走在消逝中","date":"2018-03-15T21:29:47.000Z","path":"posts/2809571715/","text":"&emsp;&emsp;从昨天到今天，关于霍金逝世的消息，一直在朋友圈里刷屏。昨天同事告诉我这个消息的时候，我心底先是一片恍惚，而后习惯性地打开微信，发现朋友圈和公众号里都在讨论这件事情。而等到我吃饭的时候，居然听到临桌的一名男生，在向同伴讲述霍金辐射的理论，堪称我在这一天所见过的一股清流。不知道从什么时候开始，一个人物的突然离去，总是会让人们在短时间内亢奋起来，仿佛一场集体缅怀的狂欢。回顾最近这些年来已故的名人，例如杨绛先生、杨洁导演、词作家闫肃、作家黄易等等，每每提及不禁令人一阵唏嘘，正所谓“逝者已矣，生者如斯”。可我想说的是，不要总是等到离开的时候，才会想起一个人的存在。 &emsp;&emsp;印象中第一次有这种感觉是在2011年，那时我刚刚考上大学，我只记得那时站在太阳底下的我，突然大声地向周围人宣布乔布斯逝世的消息。我清晰地记着父母惊愕的表情，因为在他们的人生字典里，全然不知道乔布斯是谁，可在19岁的我看来，那就像是某种重大的事情发生，至少从今天的角度来看，在我出生的1992年里，苏联正式解体，我们的生命总是不可避免地和某种历史进程关联起来。因为从中学时候就开始住校，印象中每次回家都既陌生而熟悉，偶尔会听到妈妈讲，家族里某一位长辈突然过世。这种事情听得多了，居然不会再觉得惊讶。可是想起这些人里，有人曾经出过数学题考问过我，有人你曾经帮过他们做过什么事情……刹那间觉察到时光的残忍——所谓的物是人非，大概就是你还在此处，而别人早已暗自走远。 &emsp;&emsp;坦白地讲，我对霍金的认知永远都停留在《时间简史》这本书上，记得16年买了Kindle以后，的确买了这本书来读，大概读了十来页便读不下去。霍金和海伦·凯勒一样，是被我划定到身残志坚这类写作素材的范畴里。当时，语文老师让我们关注每年的感动中国人物评选，其初衷便是为了丰富我们的写作素材。回想那些年里，遭受无数次宫刑而忍辱负重的司马迁、实验了3000多种材料终于制造出灯泡的爱迪生、披发行吟泪洒汨罗而心系家国的屈原……这些在学生时代频频被消费的历史人物，在今天看来是否有些相似呢？据说知乎上一天内产生了700多个霍金相关的问题，一个曾经活在我们作文里的人物，在他离开这个世界以后，再次成为我们热议的话题，好像他从来没有在这个世界上存在过一样，这是一件可怕的事情。 &emsp;&emsp;我认为尊重一名物理学家的基本要求是相信科学。伴随着霍金变成人们关注的热点，网络上开始流传伽利略、爱因斯坦和霍金三个人之间巧合的时间线问题，仿佛我们面对的不是一名为宇宙物理学做出巨大贡献的科学家，而是一个被神化的“活佛”转世。有人说，人类都是一群戏精。集体缅怀一个伟人吧，立马有人跳出来说，伟人的著作都没读过一本，蹭什么热度；大家都不关注这件事情吧，立马有人跳出说，“将军坟前无人问，戏子家事天下知”，根本没有人关心科技工作者。可你看关注的时候，大家都在关注什么，譬如定要给物理学领域内的专家学者们排出个优劣来，定要将一个人的私事深挖出来品判人品。杨绛先生说，“我们曾如此渴望命运的波澜，到最后才发现：人生最曼妙的风景，竟是内心的淡定与从容。我们曾如此期盼外界的认可，到最后才知道：世界是自己的，与他人毫无关系。“，这是最浅显不过的道理，可惜想要做到实在太难。 &emsp;&emsp;我一直相信“人生而孤独”，除了亲情血缘以外，人与人间的联系，有时脆弱得像一只挂在风筝上的线，随时都会有断开的危险。有些人不知不觉就渐渐走远了，我们一路踟蹰而雁行，在相遇中失散，在失散中相遇，可当两个人再次相遇时，已然不是当初的彼此。我是一个不太会维护亲密关系的人，不知道是我自己走得太快，还是别人走得太快，无数的人在我这里出现然后离开，仿佛是在追逐风中的花瓣，等到风停了的时候，花瓣已不见，花香已飘远。有时候会突然问自己，想把别人留在我的生命里，是不是一件自私的事情。游戏制作人陈星汉有一款游戏叫做《风之旅人》，在广阔无垠的沙漠场景中，最多只有两个玩家出现，出现的时间和地点随机，对方可能来自任何一个国家，你对他/她的的身份信息一无所知，两个人唯一的互动方式是“共鸣”。两个靠在一起的人，可以通过“共鸣”来为对方的围巾补充能量，最重要的一点是，一旦两个人走失，就永远不会再相遇，这是这款游戏超现实意义的一个体现。 &emsp;&emsp;我不知道，两个人从无话不说到无话可说需要多久；我只知道，真正想要离开的人，从来都是不动声色的。自那以后，我不知道对方会在哪里，会变成什么样子，每天都会做哪些事情。我承认，别人的世界和你毫无关联，可你终究不愿意让自己成为孤岛，所以你会感到痛苦和挣扎，会想要找一个能永远陪伴你的人。可生老病死是人生里无可避免的结果，我们终其一生所寻找的灵魂伴侣，是否真的可以陪伴彼此到生命尽头。如果一切注定都要失去，我宁愿一直这样下去，我从来没有把生育看做是我生命的一种延续，因为每一个人的生命都注定独一无二，你不能想当然地认为，血缘关系会替你继承什么东西。从你死亡的那一刻起，一切都变成新的东西。 &emsp;&emsp;人的一生会死亡三次，第一次是医生宣布你的死亡，这是肉体上的死亡；第二次是人们来参加你的葬礼，这是社会学意义上的死亡；第三次是这个世界没有人再记得你，这是哲学意义上的死亡。或许这个世界再无霍金，可他的思想和著作一直就在那里，时间会记录着人类的过去和未来，而他是搭乘时光列车满世界旅行的自由灵魂。一个人可以不结婚，可以不生孩子，因为这是你生而为人的选择，世俗的力量是如此的强大，以至于我们都以为，人生就是一个跳一跳游戏，每一个年龄就应该跳到相应的位置。我的人生目标里没有结婚生子，如果我注定留不下任何人，如果我注定永远要被这个世界所遗忘，我宁愿在我还活着的时候，努力去写字去发出声音，即使在这空荡荡的宇宙里听不到回声，可声音不是一直都在传播着吗？ &emsp;&emsp;有时候，想想人生难免会觉得失望。我们明明知道世界是自己，和他人毫无关联，可我们还在努力地和这个世界发生着关联；我们明明不愿意让别人了解自己的生活，可我们对这个世界的表达欲从来没有衰减过。从镌刻在龟壳上甲骨文到以丝帛作为书写材料，再到造纸术的产生，再到今天的各种芯片，甚至内容的形式从文本演变为图片再演变为视频……可我们怎么就变成了一堆“亡灵”，从前QQ好友列表一片隐身，如今朋友圈剩下一条横线。如果一定要别人不再想起你，等你真正离开这个世界的时候，才会突然间被想起，我会很心疼一条鱼的记忆，因为一条鱼的记忆只有8秒。 &emsp;&emsp;如果下一刻失去记忆的，是你和我这般普通人，我们没有机会像霍金一样，被大家集体缅怀，你希望被那一个人记着，记多长时间呢？就像我总和朋友们说，回家以后找时间相聚，可在家时会觉得家人最为重要，在某一瞬间发现自己并没有那么多时间；就像我总计划着找机会去看望语文老师，可和朋友约不到一起时便无从谈起……我突然间想到，高中的第一堂语文课上，老师安排大家写一篇作文，题目好像叫做《回首向来》亦或者是《行走在消逝中》，那时我的作文没有写完，反而被老师叫起来当众朗读，我说“回首向来萧瑟处，也无风雨也无晴”，记忆明明是有的，可我突然叫不出来有些人的名字，甚至在某一个清晨惊醒，梦到过往的某一天考试迟到，或者是快要交卷发现作文没有写……我稍稍一定神，考试那好像是很多年前的事情了吧…… &emsp;&emsp;我其实很想留下来陪你或者陪Ta呀，可时光列车从来不会留给我思考的时间，有时候我走得快，有时候你走得快，像无法逃离黑洞的光一样，拼命地往前走往前走。在广阔无垠的宇宙中，我们生活在彼此平行的世界里，有时看得见彼此，有时看不见彼此，靠着彼此间微弱的万有引力，不至于失散得太远，在成为一颗孤独的白矮星之前，请记住我。","tags":[{"name":"霍金","slug":"霍金","permalink":"http://qinyuanpei.github.io/tags/霍金/"},{"name":"时间","slug":"时间","permalink":"http://qinyuanpei.github.io/tags/时间/"},{"name":"请记住我","slug":"请记住我","permalink":"http://qinyuanpei.github.io/tags/请记住我/"}]},{"title":"我是猫，一只特立独行的猫","date":"2018-03-06T08:57:48.000Z","path":"posts/352037321/","text":"&emsp;&emsp;终于在除夕夜到来前，在Kindle上读完了2017年的最后一本书，来自夏目漱石先生的《我是猫》。起初买这本书的动机说起来非常滑稽，一来以为这会是一本诙谐幽默的书，二来对夏目这个名字莫名地充满好感。我读的是曹曼翻译的中文译本，读时觉得这位作者的文字清新素雅，即使全书行文节奏堪称缓慢到极点，想来应该是我们这个时代的人物。及至翻阅作者生平，始知这位被誉为“国民大作家”的日本作家，早在100年前就在日本文学史上享有盛名。这种感觉如何去形容呢？大概就是杨过从剑冢石刻的寥寥数语中，遥想独孤求败”生平求一敌手而不可得”的寂寥难堪。这位老先生的文字可以说非常”摩登“了，因为在100年后的今天再次读来，竟完全读不出违和感来，所谓”嬉笑怒骂皆成文章“，讽刺与幽默杂然相陈，这是我喜欢这本书的理由。 &emsp;&emsp;对于《我是猫》这本书，按照作者的话说，它是一部没有什么情节的小说，因为它完全是以一只猫的视角来行文，这只生活在一个教师家庭里的猫，每天都会接触到形形色色的文人，譬如：不食人间烟火，空有一番理论而不去实践的独仙；整天磨玻璃球，做事一丝不苟甚至古板木呐的寒月；表面上每天都很乐观，实则唯恐天下不乱的米亭；做事三分钟热情，自命清高的苦沙弥……等等。在猫的眼睛这里，这些人整天聚在一起讨论没有意义的事情，对现实世界心怀不满，不思进取就会怨天尤人，甚至金田及其夫人的”拜金主义“，为金钱而陷害苦沙弥的邻居，唯利是图、虚伪圆滑的铃木，这些人在猫的眼睛里都是丑陋而黑暗的。这只猫平静地叙述着它的见闻，仿佛它早已经整个人类和社会看穿看透，或许带着些嘲讽，或许带着些同情。 &emsp;&emsp;每年的2月22日是日本的猫节，这是我在读完这本书以后知道的。而猫在日本的文化形象中是非常神圣的，据说这是因为猫最早由遣唐使带来日本，首先作为宫廷宠物出现，直至江户时代进入”寻常百姓家“。除此之外，日本作为重度渔业国度，对稻米的珍惜使其在捕鼠护粮方面极为重视，猫作为老鼠的天敌自然而然地受到喜爱。相传招财猫起源于东京世田谷的豪德寺，因此猫在日本被人们当作神明供奉。再比如日本动漫中的机器猫、龙猫和Hello Kitty都是猫在日本文化中的经典形象，日本的文学作品比如《草枕子》、《源氏物语》等里面都有关于猫的故事。时至今日，依然有大量德川家族与猫的故事流传。因此，猫在日本人眼中有一种浓厚的贵族气息。陈凯歌导演的《妖猫传》，改编自日本作家梦枕貘的小说《沙门空海》，猫在其中的重要性不言自明。 &emsp;&emsp;这是一本“猫眼看世界”的书，这是一个怎样的世界呢？1871年，日本历史上最为大刀阔斧的一次改革——明治维新，开始在全国范围内推行。改革带来经济飞速发展的同时，带来了各种矛盾日益突出的社会问题。36年的1905年，时年38岁的夏目漱石，以猫的视角，如初入人类社会一般，探讨当时知识分子的心理状态和对社会变迁的感慨，并因此一举成名，获得社会广泛关注，被认为是日本批判现实主义文学的丰碑。每一个时代都有它的无奈，或许我们今天难以想象老先生当时的心境，不过从这些猫的口吻里，从这些辛辣的讽刺和戏谑中，我们总能读出作者当时内心的苦闷。猫眼里那些荒诞不经的行为，恰恰就是你我每天的生活，我们总说人类和猫是好朋友，可那仅仅是我们以为的，在猫的眼睛里，我们就像一群神经病。 &emsp;&emsp;猫是如何看待人类的呢？猫说：世间的奢侈往往是无能的表现。猫一年到头都穿着同一件衣服，而人类好像不把尽可能多的东西往身上照顾就难受，人类给羊添麻烦，受蚕照顾，承蒙棉花的恩泽，你看吧，我们的所作所为连只猫都看不下去。人类羡慕猫的悠闲，故而感慨道：什么时候能像猫一样轻松就好了。可明明是人类自己制造出一堆乱七八糟的事情给自己，到头来还抱怨真痛苦真痛苦，就像自己生起一堆火，到头来嚷着热死了热死了。这一切在猫看来都是庸庸碌碌的。猫甚至断言道：人类不可能永远繁荣昌盛下去。嗯，我愿静候属于猫族时代的到来。从前是“人类一思考，上帝就发笑”，而现在是“人类一思考，猫君就发笑”。猫觉得人类模仿它们的声音时是愚蠢的，尤其是在抚摸它们的时候，因为根本不存在撒娇声，只有被撒娇声，因为我们期待的是，猫向我们撒娇，可难道不是我们在向猫撒娇？ &emsp;&emsp;个体的荒谬，在人类的个性面前根本不值一提，就如同人类的个性得到完全解放以后，永远像一锅众口难调的羹汤。小说中苦沙弥、迷亭、寒月、东风和独仙时常在一起聊天，话题涉及哲学、艺术，爱情、生活等多个方面，这只“毒舌”的猫，就在无意识地引导和放大这些观点，“我认为这个世界上，没有比爱和美更受人尊重的了”，所以这本书里的观点，其实并不是完全的消极的，就像这只猫平静地看着这个世界，它对人类有过嘲讽，有过同情，它甚至没有自己的名字，当它失足淹死在水缸里的时候，对这个世界更多的是种悲天悯人吧！我们这个世界上有五种毒药，佛家所谓的“贪嗔痴慢疑”，作者提到“可没有任何一个人，能够全然抛开自己去研究外界，如果人类能够把自己疏离出来，那么疏离的瞬间，也就没有了自己”，人类常常不愿放过自己，更不愿放过别人，因为所有无解的问题，都可以制造一个意义出来，而我们早已习惯这一切。 &emsp;&emsp;曾经有朋友问我，为什么喜欢猫这种动物，我回答说，因为我就像一只猫，一只特立独行的猫，对所有人都很友善和蔼，却喜欢独来独往。因为维护这种若即若离的关系，对我来说比任何事情都要困难。人类以为猫都是傲娇的动物，其实这是人类的一厢情愿，因为从智力上来说，猫的智力是不及狗的。猫自然对人是有感情的，不过在人类驯养动物的历程中，狗更聪明、更懂得如何向人类索取，我们所认定的感情，在狗的世界里或许并不是。人类难以理解的事物，所谓阳春白雪，所谓曲高和寡，不自然地背负上高冷的名声，对一只猫而已，到底是我们不了解猫，还是不了解我们自己。人总在试图驯化猫这种动物，可猫无非是人类的一种折射而已，它就像那些独立潇洒的人一样，不藉由粘人和撒娇来获取安全感，在这个世上没有谁会离不开谁。你走，我不必送你；你来，不管多大风多大雨，我都去接你。这是我——一只猫的自白。 &emsp;&emsp;有时候，难免会觉得人类自作聪明，喜欢给世间的事物贴上不同的标签，譬如二哈、喵星人、汪星人、猫主子……可你知道猫如何评价人类的吗？作者说，“这些人虽然看起来快活，但是如果叩问他们的心底，却可以听见悲凉的回响”。为什么会听见悲凉的回响呢？大概是人类丰富而有趣的个性，不断地尝试挑战世俗的眼光，结果被世俗打败而变得世俗，这听起来简直就像是，英雄杀死魔王又变成魔王的故事的翻版。“每个人地位都提高，等同于每个人的地位都下降。人类不再做让自己委屈的事情，正是个人力量变强的证明；几乎不再插手别人的事情，反而是群体力量变弱的证明”。一点亏都不愿意吃，一点小便宜就要占，无一不是为了证明个人意志的强化，可人与人间的空间越来越狭窄，日益窘迫，为了扩充自己膨胀到近乎爆炸。人与人之间那点空间，是一切痛苦的根源，你说这还不算作悲凉吗？没有谁可以完全了解一个人，不完全认知是人类关系的反应剂，痛苦、误会、偏见……等等纷至沓来，你以为你模仿猫叫，猫就真的听懂了吗？ &emsp;&emsp;夏目先生在后记里写道，“世事变迁就像猫的眼珠一样变幻莫测，短短几个月世间，就可以去那极乐世界，或者可以把薪水花光光。年底过去了，正月过去了，花朵凋谢，新叶又生。以后世界将如何变化，我不了解，只不过水缸中猫的瞳孔，应该可以凝成永恒”。我想，世界会一如既往地这样无奈下去，时间会一如既往地这样消逝下去，而你和我会一如既往地平庸且烦恼下去。假如有这样一只猫，通过瞳孔记下了我的生平，不知道它会如何评价我呢？就像在某一个下雨天，突然想到某一个人，单单是因为怕这世界里，从此再没了对方的音讯。可单单是想到又有什么意义呢？《笑傲江湖》里令狐冲率领江湖群雄，前往少林寺解救被困的圣姑，这个将来会成为他妻子的人，而眼下更是生死未知、前途未明，可在一片寂静中听到雪花簌簌落下时，他想到的却是：小师妹不知这时候不知在干甚么。及至岳林珊为林平之所杀，临死托付令狐冲替她照顾小林子，内心却又不知做何感想了吧……","tags":[{"name":"夏目漱石","slug":"夏目漱石","permalink":"http://qinyuanpei.github.io/tags/夏目漱石/"},{"name":"日本文学","slug":"日本文学","permalink":"http://qinyuanpei.github.io/tags/日本文学/"},{"name":"我是猫","slug":"我是猫","permalink":"http://qinyuanpei.github.io/tags/我是猫/"}]},{"title":"基于Travis CI实现 Hexo 在 Github 和 Coding 的同步部署","date":"2018-02-27T10:45:04.000Z","path":"posts/1113828794/","text":"&emsp;&emsp;各位朋友，大家好，我是Payne，欢迎大家关注我的博客，我的博客地址是 https://qinyuanpei.github.io .在曾经的一篇博客：《持续集成在Hexo自动化部署上的实践》中，我为大家分享了在线持续集成服务 Travis CI 的相关内容，在这篇文章中我们通过 Travis CI 为 Hexo 提供了自动部署的支持。其原理是Github为 Travis CI 分配一个token，当我们向 Github 推送新的代码以后，Travis 就会从代码仓库中拉取代码，并通过 npm 安装依赖生成静态页面，我们将这些静态页面推送到 master 分支，即可完成对Hexo的部署操作。这个流程从去年10月份建立以来，一直运行得非常稳定，对我个人而言，随着博客里得内容越来越多，在本地生成静态页面需要20多秒得时间，而有了持续集成服务以后，我可以用这个时间去做更多的事情，当持续集成流程发生异常的时候，微信上会收到 Travis 发送的邮件，整个过程简直令人心情愉悦。 &emsp;&emsp;今天想继续写点这个话题相关的内容，即如何通过 Travis CI 实现 Hexo 在 Github 和 Coding 的同步部署。显然，部署 Hexo 到 Github Pages 我们已经实现，今天我们着重来说 Coding Pages。为什么我们需要 Coding Pages 呢？主要从两个方面考虑，首先，因为 Github Pages 屏蔽了百度的爬虫，所以我们托管在 Github 上的博客，无法被搜索引擎正常收录；其次，由于 Github Pages 的服务器在国外，所以在国内博客的速度会受到影响，而且“防火墙”的国情决定了 Github 是一个不稳定的网站。曾经经历过短时间内无法使用 Github 的情形，故而，为了保证博客可以更加稳定地运行，我们必须为博客提供一个备份镜像，这就是我们今天要提到的 Coding Pages 服务啦。在正式使用这个服务前，我们首先简单介绍下这个服务。 &emsp;&emsp;我们知道 Github Pages 是 Github 提供的静态页面托管服务，其初衷是为个人项目或者组织项目创建演示或者文档站点，而 Coding Pages 则是国内的代码托管平台 Coding 提供的类似服务，国内类似的代码托管平台还有码云、Gitlab 等。Coding Pages 支持自定义域名、SSL 等基本特性，随着官方不断对这一服务进行升级，目前该服务除支持静态页面部署以外，同时支持 PHP 和 MySQL这类动态页面部署的特性。对 Hexo 来说，静态页面部署的特性完全可以支撑我们这个想法。我的想法是以 Github 作为代码的主仓库，其上面的 blog 分支存放博客的源代码， master 分支存放博客的静态页面，在此基础上，我们同时推送静态页面到 Github 和 Coding 的代码仓库，这样就可以实现两个平台的同步部署，这里的部署自然是指由 Travis 完成的自动化部署。整体的流程设想如下图所示： 博客同步部署流程图 &emsp;&emsp;通过这个流程图，我们可以注意到，新增加的工作量，主要体现在 Travis 向 Coding 的代码仓库推送静态页面，因此我们首先要有一个 Coding 的代码仓库。关于如何注册 Coding 及在 Coding 上创建代码仓库，这里不再详细赘述啦，大家可以自行百度、Google 或者阅读官方文档。Travis CI 的行为主要由 .travis.yml 这个文件来决定，要推送静态页面到 Coding 的代码仓库，Travis CI 需要有代码仓库的读写权限。顺着这个思路，尝试让 Coding 授权 给 Travis CI，结果从文档中发现Travis CI 并不支持 Coding，而 Coding 官方支持的持续集成 flow.ci 需要使用者从 Docker 创建镜像，所以看起来这条路无法走通。从搜索引擎中检索相关问题，从 Git 工作机制的角度入手，可以想到三种常见思路，即 SSH Key、Hexo 的 deploy 插件和 HTTPS协议。 &emsp;&emsp;第一种思路是考虑让 Travis CI 的远程服务器共享本机的SSH Key，通过 ssh-copy-id 命令即可实现，可问题是 Travis CI 每次创建虚拟机环境是变化的，因此我们无法确定目标主机的 IP 或者计算机名称等信息，这种思路不适合 Travis CI。而 Travis CI 官方同样提供了命令行工具来完成这个工作，因为 Travis CI 是基于 Ruby 开发而来，所以需要 Ruby 的环境支持，作为一个为逃避 Jekyll 而选择 Hexo 的人，我是不会让自己再受到 Ruby 的摧残的，所以这种思路基本放弃。第二种思路是使用 Hexo 提供的 deploy 插件，例如 hexo-deploy-git 这个插件支持通过 git 部署，而 Coding 和 Github 都支持 Git 相关的协议，所以可以考虑使用这个插件来完成这个操作，目前网络上可以检索到的资料，都是使用这个插件来完成同步部署。可是经过我一位使用过这个插件的朋友确定，该插件需要再执行 git 命令行期间输入用户名和密码，Travis CI 是不会给你机会输入用户名和密码的，所以这种思路再次放弃。第三种 HTTPS 协议，这个想都不用想是需要输入密码的，所以果断直接放弃。 &emsp;&emsp;正所谓”行至水穷处，坐看云起时”，山重水复之间，柳暗花明之际，我意外发现 Coding 提供了和 Github 类似的”访问令牌”，我们在使用 Travis CI 的时候，实际上做了两步授权操作，第一次是授权 Travis CI 读取我们在 Github 上的仓库列表，这是一个通过 OAuth 授权的过程；第二次授权是授权 Travis CI 向指定仓库推送或者拉取内容，这是一个通过 Token 授权的过程。我们会在 Travis CI 的后台设置中将 Token 作为全局变量导出，这样我们就可以在 .travis.yml 文件中引用这些全局变量。我意识到这是一个值得一试的想法，首先我们在 Coding 的”个人设置”页面中找到访问令牌，新建一个新的访问令牌，这里我们选第一个权限即可，因为我们只需要为 Travis 提供基本的读写权限，这样我们会生成一个 Token，这里注意保存 Token，因为它在这里只显示这一次，我们将 Token 填写到 Travis CI 的后台，取名为 CO_Token 即可，依次如下图所示： 在Coding中新建访问令牌 在Coding中保存访问令牌 在Travis中新建全局变量 &emsp;&emsp;好了，现在有了Token，就意味着 Travis CI 有权限向 Coding 推送或者拉取内容了，那么怎么让它工作起来呢？我们记得 Travis CI 有一个叫做 .travis.yml 的配置文件对吧？这里我们需要简单修改下这个文件，让 Travis CI 在生成静态页面以后同时推送静态页面到 Coding。修改后的关键配置如下，我已经写好了详细注释，关于这个文件配置可以参考这里，这里不再详细说明： 123456789101112131415161718192021222324252627after_script: - cd ./public - git init - git config user.name \"qinyuanpei\" - git config user.email \"qinyuanpei@163.com\" - git add . - git commit -m \"Update Blog By TravisCI With Build $TRAVIS_BUILD_NUMBER\" # Github Pages - git push --force --quiet \"https://$&#123;CI_TOKEN&#125;@$&#123;GH_REF&#125;\" master:master # Coding Pages - git push --force --quiet \"https://qinyuanpei:$&#123;CO_TOKEN&#125;@$&#123;CO_REF&#125;\" master:master - git tag v0.0.$TRAVIS_BUILD_NUMBER -a -m \"Auto Taged By TravisCI With Build $TRAVIS_BUILD_NUMBER\" # Github Pages - git push --quiet \"https://$&#123;CI_TOKEN&#125;@$&#123;GH_REF&#125;\" master:master --tags # Coding Pages - git push --quiet \"https://qinyuanpei:$&#123;CO_TOKEN&#125;@$&#123;CO_REF&#125;\" master:master --tagsbranches: only: - blogenv: global: # Github Pages - GH_REF: github.com/qinyuanpei/qinyuanpei.github.io # Coding Pages - CO_REF: git.coding.net/qinyuanpei/qinyuanpei.coding.me.git &emsp;&emsp;好了，现在我们就可以同时部署博客到 Github 和 Coding了，现在大家可以使用下面两种方式来访问我的博客。需要说明的是，使用 Coding Pages 的特性需要开启仓库的 Pages 服务，并且 Coding 支持免费托管私有项目，虽然目前仓库的容量存在限制，对我们部署 Hexo 来说完全足够啦，下图是 Coding 上展示的提交历史，排版效果棒棒哒，哈哈，好了，以上就是这篇文章的内容啦，希望大家喜欢哦！ Coding上展示的提交历史 Github Pages 镜像 Coding Pages 镜像 &emsp;&emsp;本文使用的 .travis.yml 文件可以从这里 获取哦！","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://qinyuanpei.github.io/tags/Hexo/"},{"name":"CI","slug":"CI","permalink":"http://qinyuanpei.github.io/tags/CI/"},{"name":"Travis","slug":"Travis","permalink":"http://qinyuanpei.github.io/tags/Travis/"}]},{"title":"基于Python实现的微信好友数据分析","date":"2018-02-24T12:50:52.000Z","path":"posts/2805694118/","text":"&emsp;&emsp;最近微信迎来了一次重要的更新，允许用户对”发现”页面进行定制。不知道从什么时候开始，微信朋友圈变得越来越复杂，当越来越多的人选择”仅展示最近三天的朋友圈”，大概连微信官方都是一脸的无可奈何。逐步泛化的好友关系，让微信从熟人社交逐渐过渡到陌生人社交，而朋友圈里亦真亦幻的状态更新，仿佛在努力证明每一个个体的”有趣”。有人选择在朋友圈里记录生活的点滴，有人选择在朋友圈里展示观点的异同，可归根到底，人们无时无刻不在窥探着别人的生活，唯独怕别人过多地了解自己的生活。人性中交织着的光明与黑暗，像一只浑身长满刺的刺猬，离得太远会感觉到寒冷，而靠得太近则害怕被刺扎到。朋友圈就像过年走亲戚，即便你心中有一万个不痛快，总是不愿意撕破脸，或屏蔽对方，或不给对方看，或仅展示最后三天，于是通讯录里的联系人越来越多，朋友圈越来越大，可再不会有能真正触动你内心的”小红点”出现，人类让一个产品变得越来越复杂，然后说它无法满足人类的需求，这大概是一开始就始料不及的吧！ 引言&emsp;&emsp;有人说，人性远比计算机编程更复杂，因为即使是人类迄今为止最伟大的发明——计算机，在面对人类的自然语言时同样会张惶失措 。人类有多少语言存在着模棱两可的含义，我认为语言是人类最大的误解，人类时常喜欢揣测语言背后隐藏的含义，好像在沟通时表达清晰的含义会让人类没有面子，更不用说网络上流行的猜测女朋友真实意图的案例。金庸先生的武侠小说《射雕英雄传》里，在信息闭塞的南宋时期，江湖上裘千丈的一句鬼话，就搅得整个武林天翻地覆。其实，一两句话说清楚不好吗？黄药师、全真七子、江南六怪间的种种纠葛，哪一场不是误会？一众儿武功震古烁今的武林高手，怎么没有丝毫的去伪存真的能力，语言造成了多少误会。 &emsp;&emsp;可即便人类的语言复杂得像一本无字天书，可人类还是从这些语言中寻觅到蛛丝马迹。古人有文王”拘而演周易”、东方朔测字卜卦，这种带有”迷信”色彩的原始崇拜，就如同今天人们迷信星座运势一般，都是人类在上千年的演变中不断对经验进行总结和训练的结果。如此说起来，我们的人工智能未尝不是一种更加科学化的”迷信”，因为数据和算法让我们在不断地相信，这一切都是真实地。生活在数字时代的我们，无疑是悲哀的，一面努力地在别人面前隐藏真实地自己，一面不无遗憾地感慨自己无处遁逃，每一根数字神经都紧紧地联系着你和我，你不能渴望任何一部数字设备具备真正的智能，可你生命里的每个瞬间，都在悄然间被数据地折射出来。 &emsp;&emsp;今天这篇文章会基于 Python 对微信好友进行数据分析，这里选择的维度主要有：性别、头像、签名、位置，主要采用图表和词云两种形式来呈现结果，其中，对文本类信息会采用词频分析和情感分析两种方法。常言道：工欲善其事，必先利其器也。在正式开始这篇文章前，简单介绍下本文中使用到的第三方模块： itchat：微信网页版接口封装Python版本，在本文中用以获取微信好友信息。 jieba：结巴分词的 Python 版本，在本文中用以对文本信息进行分词处理。 matplotlib： Python 中图表绘制模块，在本文中用以绘制柱形图和饼图 snownlp：一个 Python 中的中文分词模块，在本文中用以对文本信息进行情感判断。 PIL： Python 中的图像处理模块，在本文中用以对图片进行处理。 numpy： Python中 的数值计算模块，在本文中配合 wordcloud 模块使用。 wordcloud： Python 中的词云模块，在本文中用以绘制词云图片。 TencentYoutuyun：腾讯优图提供的 Python 版本 SDK ，在本文中用以识别人脸及提取图片标签信息。以上模块均可通过 pip 安装，关于各个模块使用的详细说明，请自行查阅各自文档。 数据分析&emsp;&emsp;分析微信好友数据的前提是获得好友信息，通过使用 itchat 这个模块，这一切会变得非常简单，我们通过下面两行代码就可以实现：12itchat.auto_login(hotReload = True)friends = itchat.get_friends(update = True) &emsp;&emsp;同平时登录网页版微信一样，我们使用手机扫描二维码就可以登录，这里返回的friends对象是一个集合，第一个元素是当前用户。所以，在下面的数据分析流程中，我们始终取friends[1:]作为原始输入数据，集合中的每一个元素都是一个字典结构，以我本人为例，可以注意到这里有Sex、City、Province、HeadImgUrl、Signature这四个字段，我们下面的分析就从这四个字段入手： 好友信息结构展示 好友性别&emsp;&emsp;分析好友性别，我们首先要获得所有好友的性别信息，这里我们将每一个好友信息的Sex字段提取出来，然后分别统计出Male、Female和Unkonw的数目，我们将这三个数值组装到一个列表中，即可使用matplotlib模块绘制出饼图来，其代码实现如下：12345678910111213141516171819def analyseSex(firends): sexs = list(map(lambda x:x['Sex'],friends[1:])) counts = list(map(lambda x:x[1],Counter(sexs).items())) labels = ['Unknow','Male','Female'] colors = ['red','yellowgreen','lightskyblue'] plt.figure(figsize=(8,5), dpi=80) plt.axes(aspect=1) plt.pie(counts, #性别统计结果 labels=labels, #性别展示标签 colors=colors, #饼图区域配色 labeldistance = 1.1, #标签距离圆点距离 autopct = '%3.1f%%', #饼图区域文本格式 shadow = False, #饼图是否显示阴影 startangle = 90, #饼图起始角度 pctdistance = 0.6 #饼图区域文本距离圆点距离 ) plt.legend(loc='upper right',) plt.title(u'%s的微信好友性别组成' % friends[0]['NickName']) plt.show() &emsp;&emsp;这里简单解释下这段代码，微信中性别字段的取值有Unkonw、Male和Female三种，其对应的数值分别为0、1、2。通过Collection模块中的Counter()对这三种不同的取值进行统计，其items()方法返回的是一个元组的集合，该元组的第一维元素表示键，即0、1、2，该元组的第二维元素表示数目，且该元组的集合是排序过的，即其键按照0、1、2 的顺序排列，所以通过map()方法就可以得到这三种不同取值的数目，我们将其传递给matplotlib绘制即可，这三种不同取值各自所占的百分比由matplotlib计算得出。下图是matplotlib绘制的好友性别分布图： 微信好友性别分析 &emsp;&emsp;看到这个结果，我一点都不觉得意外，男女比例严重失衡，这虽然可以解释我单身的原因，可我不觉得通过调整男女比例就能解决问题，好多人认为自己单身是因为社交圈子狭小，那么是不是扩展了社交圈子就能摆脱单身呢？我觉得或许这样会增加脱单的概率，可幸运之神应该不会眷顾我，因为我的好运气早在我24岁以前就消耗完啦。在知乎上有一个热门的话题：现在的男性是否普遍不再对女性展开追求了？，其实哪里会有人喜欢孤独呢？无非是怕一次又一次的失望罢了。有的人并不是我的花儿，我只是恰好途径了她的绽放。曾经有人说我是一个多情的人，可她永远不会知道，我做出的每一个决定都炽热而悲壮。所谓”慧极必伤，情深不寿；谦谦君子，温润如玉”，世人苦五毒者大抵如此。 好友头像&emsp;&emsp;分析好友头像，从两个方面来分析，第一，在这些好友头像中，使用人脸头像的好友比重有多大；第二，从这些好友头像中，可以提取出哪些有价值的关键字。这里需要根据HeadImgUrl字段下载头像到本地，然后通过腾讯优图提供的人脸识别相关的API接口，检测头像图片中是否存在人脸以及提取图片中的标签。其中，前者是分类汇总，我们使用饼图来呈现结果；后者是对文本进行分析，我们使用词云来呈现结果。关键代码如下 所示：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869def analyseHeadImage(frineds): # Init Path basePath = os.path.abspath('.') baseFolder = basePath + '\\\\HeadImages\\\\' if(os.path.exists(baseFolder) == False): os.makedirs(baseFolder) # Analyse Images faceApi = FaceAPI() use_face = 0 not_use_face = 0 image_tags = '' for index in range(1,len(friends)): friend = friends[index] # Save HeadImages imgFile = baseFolder + '\\\\Image%s.jpg' % str(index) imgData = itchat.get_head_img(userName = friend['UserName']) if(os.path.exists(imgFile) == False): with open(imgFile,'wb') as file: file.write(imgData) # Detect Faces time.sleep(1) result = faceApi.detectFace(imgFile) if result == True: use_face += 1 else: not_use_face += 1 # Extract Tags result = faceApi.extractTags(imgFile) image_tags += ','.join(list(map(lambda x:x['tag_name'],result))) labels = [u'使用人脸头像',u'不使用人脸头像'] counts = [use_face,not_use_face] colors = ['red','yellowgreen','lightskyblue'] plt.figure(figsize=(8,5), dpi=80) plt.axes(aspect=1) plt.pie(counts, #性别统计结果 labels=labels, #性别展示标签 colors=colors, #饼图区域配色 labeldistance = 1.1, #标签距离圆点距离 autopct = '%3.1f%%', #饼图区域文本格式 shadow = False, #饼图是否显示阴影 startangle = 90, #饼图起始角度 pctdistance = 0.6 #饼图区域文本距离圆点距离 ) plt.legend(loc='upper right',) plt.title(u'%s的微信好友使用人脸头像情况' % friends[0]['NickName']) plt.show() image_tags = image_tags.encode('iso8859-1').decode('utf-8') back_coloring = np.array(Image.open('face.jpg')) wordcloud = WordCloud( font_path='simfang.ttf', background_color=\"white\", max_words=1200, mask=back_coloring, max_font_size=75, random_state=45, width=800, height=480, margin=15 ) wordcloud.generate(image_tags) plt.imshow(wordcloud) plt.axis(\"off\") plt.show() &emsp;&emsp;这里我们会在当前目录新建一个HeadImages目录，用以存储所有好友的头像，然后我们这里会用到一个名为FaceApi类，这个类由腾讯优图的SDK封装而来，这里分别调用了人脸检测和图像标签识别两个API接口，前者会统计”使用人脸头像”和”不使用人脸头像”的好友各自的数目，后者会累加每个头像中提取出来的标签。其分析结果如下图所示： &emsp;&emsp;可以注意到，在所有微信好友中，约有接近1/4的微信好友使用了人脸头像， 而有接近3/4的微信好友没有人脸头像，这说明在所有微信好友中对”颜值 “有自信的人，仅仅占到好友总数的25%，或者说75%的微信好友行事风格偏低调为主，不喜欢用人脸头像做微信头像。这是否说明”好看的皮囊”并非是千篇一律，长得好看的人实在是少数中的少数。所以，当女生的妆容越来越向着”韩式半永久粗平眉”、”瓜子脸”和”大红唇”靠拢的时候，当男生的服饰越来越向着”大背头”、”高领毛衣”和”长款大衣”靠拢的时候，我们能不能真正得个性一次。生命中有太多被世俗绑架着的事情，既要和别人不一样 ，同时还要和大多数人一样，这是人生在世的无可奈何。考虑到腾讯优图并不能真正得识别”人脸”，我们这里对好友头像中的标签再次进行提取，来帮助我们了解微信好友的头像中有哪些 关键词，其分析结果如图所示： 微信好友头像标签词云展示 &emsp;&emsp;通过词云，我们可以发现：在微信好友中的签名词云中，出现频率相对较高的关键字有：女孩、树木、房屋、文本、截图、卡通、合影、天空、大海。这说明在我的微信好友中，好友选择的微信头像主要有日常、旅游、风景、截图四个来源，好友选择的微信头像中风格以卡通为主，好友选择的微信头像中常见的要素有天空、大海、房屋、树木。通过观察所有好友头像，我发现在我的微信好友中，使用个人照片作为微信头像的有15人，使用网络图片作为微信头像的有53人，使用动漫图片作为微信头像的有25人，使用合照图片作为微信头像的有3人，使用孩童照片作为微信头像的有5人，使用风景图片作为微信头像的有13人，使用女孩照片作为微信头像的有18人，基本符合图像标签提取的分析结果。 好友签名&emsp;&emsp;分析好友签名，签名是好友信息中最为丰富的文本信息，按照人类惯用的”贴标签”的方法论，签名可以分析出某一个人在某一段时间里状态，就像人开心了会笑、哀伤了会哭，哭和笑两种标签，分别表明了人开心和哀伤的状态。这里我们对签名做两种处理，第一种是使用用结巴分词进行分词后生成词云，目的是了解好友签名中的关键字有哪些，哪一个关键字出现的频率相对较高；第二种是使用SnowNLP分析好友签名中的感情倾向，即好友签名整体上是表现为正面的、负面的还是中立的，各自的比重是多少。这里提取Signature字段即可，其核心代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051def analyseSignature(friends): signatures = '' emotions = [] pattern = re.compile(\"1f\\d.+\") for friend in friends: signature = friend['Signature'] if(signature != None): signature = signature.strip().replace('span', '').replace('class', '').replace('emoji', '') signature = re.sub(r'1f(\\d.+)','',signature) if(len(signature)&gt;0): nlp = SnowNLP(signature) emotions.append(nlp.sentiments) signatures += ' '.join(jieba.analyse.extract_tags(signature,5)) with open('signatures.txt','wt',encoding='utf-8') as file: file.write(signatures) # Sinature WordCloud back_coloring = np.array(Image.open('flower.jpg')) wordcloud = WordCloud( font_path='simfang.ttf', background_color=\"white\", max_words=1200, mask=back_coloring, max_font_size=75, random_state=45, width=960, height=720, margin=15 ) wordcloud.generate(signatures) plt.imshow(wordcloud) plt.axis(\"off\") plt.show() wordcloud.to_file('signatures.jpg') # Signature Emotional Judgment count_good = len(list(filter(lambda x:x&gt;0.66,emotions))) count_normal = len(list(filter(lambda x:x&gt;=0.33 and x&lt;=0.66,emotions))) count_bad = len(list(filter(lambda x:x&lt;0.33,emotions))) labels = [u'负面消极',u'中性',u'正面积极'] values = (count_bad,count_normal,count_good) plt.rcParams['font.sans-serif'] = ['simHei'] plt.rcParams['axes.unicode_minus'] = False plt.xlabel(u'情感判断') plt.ylabel(u'频数') plt.xticks(range(3),labels) plt.legend(loc='upper right',) plt.bar(range(3), values, color = 'rgb') plt.title(u'%s的微信好友签名信息情感分析' % friends[0]['NickName']) plt.show() &emsp;&emsp;通过词云，我们可以发现：在微信好友的签名信息中，出现频率相对较高的关键词有：努力、长大、美好、快乐、生活、幸福、人生、远方、时光、散步。果然我的微信好友都是温暖、正直的好青年啊！ :smile:其实，签名这个设定，从某种程度上是在反映人的一种心态，人在年轻时不免”为赋新词强说愁”，等到你真正到了这个精神境界，突然发现年轻时图样图森破，或许这就是我们不愿意让别人了解过去的原因，因为伴随着人的成长，某一种瞬间的状态简直不忍直视，QQ空间陪伴了我们这代人的整个青春，令人印象深刻的”那年今日”功能，有时让我们感到回忆的温暖，有时让我们感到岁月的萧杀，”当时只道是寻常”的物是人非，”回首向来萧瑟处”的淡定从容，”今夕复何夕”的失落惆怅……都在这一行行签名里留下深深浅浅的印记。在知乎上有关于签名的话题讨论，对此感兴趣的朋友不妨找时间看看。:smile: 微信好友签名信息词云展示 &emsp;&emsp;通过柱状图，我们可以发现：在微信好友的签名信息中，正面积极的情感判断约占到55.56%，中立的情感判断约占到32.10%，负面消极的情感判断约占到12.35%。这个结果和我们通过词云展示的结果基本吻合，这说明在微信好友的签名信息中，约有87.66%的签名信息，传达出来都是一种积极向上的态度。朋友圈中基本上有两类用户，第一类用户使用朋友圈记录自己的生活，第二类用户使用朋友圈输出自己的观点。显然，对于第二类用户，它并不介意别人了解它的过去，它更在乎它从始至终输出的观点是否一致。所以，不管朋友圈里别人在或晒美食、或晒旅游、或秀恩爱、或晒宝宝、或煲鸡汤等等，在我看来这都是一种生活方式，精神层次和物质层次比你高的人群，觉得你朋友圈里的内容”无趣”，这是符合人类一贯的认知方式的，在大多数情况下，反而是那些和你层次差不多的人群，对不熟悉的人或者事物妄加判断，如果你不喜欢我朋友圈里的内容，请直接屏蔽我就好，因为这样我们还可以做朋友；如果你因为喜欢A而在我这里和我说B不好，这就真的是三观不合啦。我相信没有完全兴趣匹配的两个人，即使是男女朋友或者情侣之间，总之人与人相处嘛，真诚和互相尊重是基本要求。 微信好友签名信息情感分析展示 好友位置&emsp;&emsp;分析好友位置，主要通过提取Province和City这两个字段。Python中的地图可视化主要通过Basemap模块，这个模块需要从国外网站下载地图信息，使用起来非常的不便。百度的ECharts在前端使用的比较多，虽然社区里提供了pyecharts项目，可我注意到因为政策的改变，目前Echarts不再支持导出地图的功能，所以地图的定制方面目前依然是一个问题，主流的技术方案是配置全国各省市的JSON数据，这里博主使用的是BDP个人版，这是一个零编程的方案，我们通过Python导出一个CSV文件，然后将其上传到BDP中，通过简单拖拽就可以制作可视化地图，简直不能再简单，这里我们仅仅展示生成CSV部分的代码：1234567891011def analyseLocation(friends): headers = ['NickName','Province','City'] with open('location.csv','w',encoding='utf-8',newline='',) as csvFile: writer = csv.DictWriter(csvFile, headers) writer.writeheader() for friend in friends[1:]: row = &#123;&#125; row['NickName'] = friend['NickName'] row['Province'] = friend['Province'] row['City'] = friend['City'] writer.writerow(row) &emsp;&emsp;下图是BDP中生成的微信好友地理分布图，可以发现：我的微信好友主要集中在宁夏和陕西两个省份。数字时代的神经牵动着每一个社交关系链的人，我们想要竭力去保护的那点隐私，在这些数据中一点点地折射出来。人类或许可以不断地伪装自己，可这些从数据背后抽离出来的规律和联系不会欺骗人类。数学曾经被人称为最没有用的学科，因为生活中并不需要神圣而纯粹的计算，在不同的学科知识里，经验公式永远比理论公式更为常用。可是此时此刻，你看，这世界就像一只滴滴答答转动着的时钟，每一分每一秒都是严丝合缝的。 微信好友地理分布图 本文小结&emsp;&emsp;写这篇文章的时候，我一直不知道该如何下笔，因为微信是一个神奇的存在，它是一个国民级别的全民APP，所以，微信的产品设计一直都是一个有趣的现象，从最初底部Tab的数目、每个Tab的名称、”发现”页面的定制、小程序入口、朋友圈入口到朋友圈评论等等一系列的设计细节，都是值得我们透过人性和心理去研究的。即使是被人们封神的”张小龙”，在面对结构最为复杂的中国用户群体的时候，他的潇洒中依旧不免充满无奈，从对朋友圈的置之不理就可以看出，这是一个怎么做都不会让人满意的功能，任何一个生态在面对巨大的用户群体的时候，功能的增减就会变成一个难题，所谓”林子大了什么鸟都有”，知乎面对的是同样的问题，营销类公众号在不断消费社会话题的同时，引导着一批又一批粉丝的价值取向，人类总渴望着别人了解自己，可人类真的了解自己吗？这篇博客是我对数据分析的又一次尝试，主要从性别、头像、签名、位置四个维度，对微信好友进行了一次简单的数据分析，主要采用图表和词云两种形式来呈现结果。总而言之一句话，”数据可视化是手段而并非目的”，重要的不是我们在这里做了这些图出来，而是从这些图里反映出来的现象，我们能够得到什么本质上的启示，我一位朋友问我怎么什么都想抓取，为什么啊，因为我不懂人类啊！","tags":[{"name":"Python","slug":"Python","permalink":"http://qinyuanpei.github.io/tags/Python/"},{"name":"Wechat","slug":"Wechat","permalink":"http://qinyuanpei.github.io/tags/Wechat/"},{"name":"matplotlib","slug":"matplotlib","permalink":"http://qinyuanpei.github.io/tags/matplotlib/"}]},{"title":"使用Python生成博客目录并自动更新README","date":"2018-02-23T09:32:45.000Z","path":"posts/1329254441/","text":"&emsp;&emsp;各位朋友，大家好，我是Payne，欢迎大家关注我的博客，我的博客地址是：https://qinyuanpei.github.io。首先在这里祝大家春节快乐，作为过完年以后的第一篇文章，博主想写点内容风格相对轻松的内容。自从博主的博客采用 TravisCI 提供的持续集成(CI)服务以以来，博客的更新部署变得越来越简单，所有的流程都被简化为Git工作流下的提交(commit)和推送(push)操作。考虑到博客是托管在 Github 上的，一直希望可以自动更新仓库主页的README文件，这样可以显示每次提交代码后的变更历史。基于这样一个构想，我想到了为博客生成目录并自动更新README，其好处是可以为读者建立良好的文档导航，而且Markdown是一种简单友好的文档格式，Github等代码托管平台天生就支持Markdown文档的渲染。关于博客采用 TravisCI 提供持续集成(CI)服务相关内容，可以参考 持续集成在Hexo自动化部署上的实践 这篇文章。 &emsp;&emsp;好了，现在考虑如何为博客生成目录，我们这里需要三个要素，即标题、链接和时间。标题和时间可以直接从 _posts 目录下的Markdown文档中读取出来，链接从何而来呢？我最初想到的办法是读取每个Markdown文档的文件名，因为我的使用习惯是采用英文命名，这样当博客的永久链接(permalink)采用默认的:year/:month/:day/:title/形式时，每个Markdown文档的文件名等价于文章链接。事实证明这是一个愚蠢的想法，因为当你改变了永久链接(permalink)的形式时，这种明显投机的策略就会彻底的失败。相信你在浏览器种打开这篇文章时，已然注意到链接形式发生了变化，当然这是我们在稍后的文章中讨论的话题啦。至此，我们不得不寻找新的思路，那么这个问题该如何解决呢？ &emsp;&emsp;我意识到我的博客配置了 hexo-generator-json-content 插件，这个插件最初的目的是为博客提供离线的搜索能力，该插件会在博客的根目录里生成一个content.json文件，而这个文件中含有我们想要的一切信息，因此我们的思路转变为解析这个文件，人生苦短啊，我果断选择了我最喜欢的Python，这里我们会提取出所有的文章信息，按照日期由近到远排序后生成列表。Python强大到让我觉得这篇文章无法下笔，所以这里直接给出代码啦：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# -*- coding: utf-8 -*-import osimport reimport sysimport jsonimport datetime# 文档实体结构定义class Post: def __init__(self,date,link,title): self.date = date self.link = link self.title = title def getTitle(self): return self.title def getLink(self): return 'https://qinyuanpei.github.io/' + self.link def getDate(self): d = re.findall(r'\\d&#123;4&#125;-\\d&#123;1,2&#125;-\\d&#123;1,2&#125;',self.date)[0] t = re.findall(r'\\d&#123;2&#125;:\\d&#123;2&#125;:\\d&#123;2&#125;',self.date)[0] dt = '%s %s' % (d,t) return datetime.datetime.strptime(dt,'%Y-%m-%d %H:%M:%S')# 从JSON中加载文档数据def loadData(): json_file = open('./public/content.json','rb') json_data = json.load(json_file) for item in json_data: yield Post(item['date'],item['path'],item['title'])# 从列表生成Markdown文件def mkMarkdown(items): mdfile = open('README.md',mode='wt',encoding='utf-8') itemTpl = '* &#123;0&#125; - [&#123;1&#125;](&#123;2&#125;)\\n' for item in items: mdfile.write(itemTpl.format( datetime.datetime.strftime(item.getDate(),'%Y-%m-%d'), item.getTitle(), item.getLink() ))if(__name__ == \"__main__\"): items = sorted(loadData(),key=lambda x:x.getDate(),reverse=True) mkMarkdown(items) &emsp;&emsp;这里需要注意的有两个地方，第一，从JSON中解析出来的日期形式为：2018-02-23T01:32:45.000Z。对于这个形式的日期，博主先后尝试了内建的time模块和第三方的datetime模块，发现均无法直接转换为日期类型，所以首先采用正则匹配出日期和时间，然后再组合为标准的%Y-%m-%d %H:%M:%S的格式，这样就可以使用datetime模块进行处理啦，我还是想吐槽人类对各种各样format的执着，这些通配符在不同的语言中存在差别，就像SQL和正则引擎或多或少地存在兼容性问题一样。如果有朋友知道如何对这种日期形式进行转换，欢迎在博客中评论留言，再次谢谢大家。第二，使用内置函数sorted()对数据进行排序，lambda表达式使用起来非常棒，因为默认是升序排列地，而我们需要的是日期由近到远，所以这里选择了降序排列。 &emsp;&emsp;现在我们更新博客时的流程将发生变化，首先通过 hexo generate 或 hexo g命令生成博客，这样Hexo会为我们生成 content.json，然后我们执行这段Python脚本，就可以生成REAMD.md文件，这里我们将这个文件推送到blog分支。相对应地，我们修改 TravisCI 的脚本文件 .travis.yml 文件如下：1234script: - hexo clean - hexo generate - cp README.md ./public/README.md &emsp;&emsp;显然，这是告诉 TravisCI 在生成博客以后，将 README.md 文件复制到输出文件，这样当我们推送博客(指生成的静态页面)到 master 分支的时候，它会和 blog 分支同步共享同一份 README 。我想一定有朋友会问我，难道生成 README.md 文件的步骤不能交给 TravisCI 来处理？一定要在推送到 blog 分支以前手动地去执行脚本吗？我最初尝试过让 TravisCI 去执行这个 Python 脚本，可我发现一个残酷的事实时，我们这个虚拟机环境是 nodejs 的，这在我们定义 .travis.yml 文件时就指定了，因此这个环境中可能是没有 Python 支持的。起初我以为 Linux 系统自带 Python ， 因此尝试在 .travis.yml 文件中使用 pip 安装相关依赖，然后我发现持续集成服务华丽丽地挂了，因为 TravisCI 默认的 Python 版本是 Python2.7 , 除非我们指定的是一个 Python 的语言环境，所以这种想法不得不作罢，暂时就手动更新好啦。 &emsp;&emsp;好了，这篇文章核心的内容就这么多，下面想说些关于 Hexo 的延伸话题。 Hexo 是一个基于 nodejs 的静态博客生成器，按理说使用 nodejs 去扩展功能是最佳的实践方式，所以即使 Python 再强大，我们在这里看到的依然存在着天然的割裂感， 我们能不能将执行Python脚本的这个过程合并到 hexo generate 或者 hexo g这个步骤中去呢？ 通过官方文档中关于事件和生成器的描述，我们获得了两种新的思路，分别是在生成页面以后通过 child_process 模块调用 python 脚本、通过 Locals 变量获取全部文章信息后生成Markdown。从方案是否优雅的角度上来讲，我个人更倾向于第二种方案。基本的代码如下：12345678910//方案一hexo.on('generateAfter', function(post)&#123; //TODO:通过content.json文件生成markdown文档&#125;);//方案二hexo.extend.generator.register(\"markdown\", function(locals)&#123; var posts = locals.posts; //TODO:通过posts属性生成markdown文档&#125;); &emsp;&emsp;显然，我是不会写 nodejs 的，如果有时间和精力的话，我可能会考虑采用第二种方案写一个插件，可是像我这么懒的一个人，还是不要提前立 flag 啦，毕竟人生苦短呐，我都选择使用 Python 这门语言来写啦，我干嘛非要再花时间去迎合它呢？好啦，这篇文章就是这样啦，本文中的脚本可以到 这里 来获取，本文生成的目录可以到 这里 来访问，再次谢谢大家！","tags":[{"name":"Github","slug":"Github","permalink":"http://qinyuanpei.github.io/tags/Github/"},{"name":"Python","slug":"Python","permalink":"http://qinyuanpei.github.io/tags/Python/"},{"name":"Script","slug":"Script","permalink":"http://qinyuanpei.github.io/tags/Script/"}]},{"title":"愿你和我一样喜欢蛋炒饭","date":"2018-02-10T16:12:25.000Z","path":"posts/1933583281/","text":"&emsp;&emsp;周末花了一个晚上的时间看了部电影，由黄渤主演的《蛋炒饭》。有人说，这是一部刻意模仿《阿甘正传》的电影，充满胶片质感的纪录片风格，相似的镜头语言和表现手法，无一不在努力告诉你，这是一部本土化的《阿甘正传》。可是如同巧克力之于蛋炒饭，两种截然不同的食物会有不同的味道，电影所反映的实则是两种不同的内涵。如果说《阿甘正传》代表的是极具美国精神的励志故事，那么《蛋炒饭》代表的则是小人物为理想打拼的乌托邦。说《蛋炒饭》是本土化的《阿甘正传》其实不无道理，因为电影里充满了太多相似，这种在由时代感打磨出的细腻的情感，让我觉得这是一部值得一看的电影。 电影《阿甘正传》经典开头 &emsp;&emsp;电影开头苏茉莉坐在游乐园长凳上自下而上的长镜头，不禁让人联想到《阿甘正传》的开场，联想到那片空中摇曳着的羽毛；电影中反复出现的台词，来自大卫父亲的那句：做蛋炒饭要慢要慢，一如《阿甘正传》里的经典台词：人生就像一盒巧克力，你永远不知道下一块会是哪种？电影令我印象深刻的地方，在于它具厚重的时代感，中美建交、改革开放、金融危机、邓丽君、摇滚音乐、周杰伦、周笔畅……看起来王大卫好像和阿甘一样，参与并影响了众多历史事件。可我的理解是，阿甘最终成为了流浪街头的大富翁，而王大卫一直一无所有，因为他一辈子都在做一件事情，那就是做蛋炒饭。 最美好的年纪 &emsp;&emsp;整个电影采用的是倒叙的表现手法。主人公王大卫是一个智商不太高，而且有语言表达障碍的“傻子”，他第一次出场是替好兄弟打抱不平，结果他就像星爷《功夫》里的少年一样，以为自己的武功盖世无双，结果自然是被人打得头破血流；他书包里藏着的“复仇”的板砖，在外国友人访华的时候，一板砖破坏了中美友谊，结果自然是被校长通报批评；他家祖上是宫廷御厨，父亲即将退休食堂安排他去顶岗，一心想做厨师的他差点烧了厨房，结果自然是迫使父亲替他求情以保住工作；他从小喜欢的女孩苏茉莉要和好兄弟发生关系，她吻了他一下叫他在门口把风，结果自然是茉莉被渣男欺骗然后甩了他；他用母亲变卖古董的钱来了饭店，好兄弟嫉妒他做了老板，骗走他的产业后远走高飞，结果自然是他从老板变成杂工。 有些爱就像一阵风 &emsp;&emsp;看这个电影的时候，我一直觉得人生是绝望的，父母先后离开人世，哥哥在面前自杀而死，喜欢的女生抛弃自己，好兄弟发小欺骗自己……周围人对他全部是冷嘲热讽，每次发工资的时候，嘲弄他什么时候攒够钱赎回饭店；每次娱乐圈有绯闻传来的时候，说他“媳妇”苏茉莉又登上杂志封面；“好兄弟“因为金融危机背负债务，他就拎着辛苦攒下的一袋子零钱去帮他还债，结果半夜“好兄弟”开着车跑了……我不知道，我们该不该认同这种无条件“傻”的行为，电影想告诉我们的或许是“以德报怨，以德服人”这种儒家的传统思想，即在复杂的社会中，如何以一种淳朴单纯的心态，追寻本心，不畏曲折。所谓“众生虽苦，诸恶莫作”，这个社会复杂险恶是现实，可温润善良则是一种选择。我们抱怨时代给我们选择狭窄，因为我们放弃了那些艰难的选择，最终选择大多数人选择的那条路。 李红兵：人都是会变的 &emsp;&emsp;可我还是想说，无条件的善良是懦弱，我们选择善良，是因为我们不想伤害别人，可在今天这样一个时代，善良常常被当做是懦弱的表现，一个人努力让心变狠变硬，或许会达到通常意义上的成功，可成功的定义从来都是被人绑架着的，电影中“好兄弟”登上了“胡弄排行榜”，我不知道这是不是导演的一种讽刺，一个人靠着骗取好兄弟的产业而发家，即使收获了声名和利益，当他一个人在高速公路上疾驶，打算远走他乡的时候，内心是不是会有一点羞愧和遗憾呢？我们说，这是一部乌托邦式的电影，因为现实中像李红兵这样的人，绝对不会陡然间良心发现，把饭店归还王大卫，甚至王大卫拉开窗帘阳光照射进来，阳光下苏茉莉牵着女儿的手对他微笑，大卫的蛋炒饭得到溥仪认可，入选国际非遗名录……我宁愿相信，这是一种美好的理想。 大卫做蛋炒饭 &emsp;&emsp;大卫在电影中做过三次蛋炒饭，第一次是他顶替父亲的岗位到食堂工作，结果想做厨师的他差点烧了厨房，付出的代价是，因为御厨身份而自豪的父亲，向一辈子没低过头的食堂经理低头；第二次是他陪苏茉莉到医院流产，打完胎的苏茉莉说自己饿，他冒着被饭店人追打的危险，给苏茉莉做了一份蛋炒饭，付出的代价是，苏茉莉同他告别，独自到南方发展演艺事业；第三次是李红兵归还了饭店，成名后的王大卫，当着记者的面做了一次蛋炒饭，溥仪评价大卫的蛋炒饭，比他爷爷做得还要好，蛋炒饭入选国际非遗名录。大卫的一生都在做一件事情，那就是做蛋炒饭，这种专注是他和阿甘不一样的地方，在一个浮躁的时代，我们每天都在追逐都在忙碌，可我们追逐的是什么呢？或许是一盘蛋炒饭的安宁，从这个角度来说，蛋炒饭这种食物，真的是质朴而简单的存在啦。 有些人像你生命里的天使 &emsp;&emsp;如果你看过《阿甘正传》这部电影，会觉得苏茉莉和珍妮这两个角色是相似的。她们看起来都知道自己想要些什么，苏茉莉选择发展演艺事业进入娱乐圈，珍妮一直知道自己想要什么，她想做一名歌手，为了唱歌吃尽苦头，在酒吧、街头甚至任何可以唱歌的地方，只有有场合给她吉他，她就可以唱，甚至为了唱歌而穷困潦倒到卖身吸毒……她可以真挚地给成名的阿甘一个拥抱，而不愿依附他达到自己成名的目的，她深爱阿甘的同时，深知阿甘不会同自己结婚，因为童年的经历让她内心无比自卑，她始终打不开心里的结，她选择为阿甘生下孩子，这是一种自我成全。 愿茉莉一直这样美好 &emsp;&emsp;苏茉莉成名后取艺名苏菲，据说这个人物原型来自王菲，苏茉莉在成名过程中不断豪门势力，从最初回北京办演唱会拉赞助，到嫁入豪门以后受不了娱乐圈绯闻骚扰，进而宣布退出娱乐圈回到北京，她是一个不知道自己想要什么的人，直到故事最后她终于发现，原来那个深爱着自己的人，一直就在默默地等自己回来。所以对比两部电影中的女主，就可以发现，两部电影阐述的观点是截然相反的，即阿甘是迷茫的，而珍妮是坚定的；王大卫是坚定的，而苏茉莉是迷茫的。当你不知道想要什么的时候，不妨慢下来做份蛋炒饭，或许你就会找到答案。 你饿不饿，我做蛋炒饭给你吃呀 &emsp;&emsp;故事接近尾声的时候，王大卫再次登上三个人从小便常去的城楼，猛然间看到三个孩子正在那里玩耍，孩子们说这是他们的地盘，王大卫还是像从前一样，知趣地准备转身离开，阳光照耀城楼的刹那，我分明看见他脸上满意的笑容，那种历经沧桑后初心不改的从容。每个人，都既注定的命运，同时有偶然，两者都在同时发生，就像那片羽毛，努力飘啊飘啊，终于飘到阿甘脚下，然后又无可奈何的飘离阿甘。羽毛不是飞鸟，无法掌控飞行的方向，其实很想和你在一起，但偏偏风把距离吹得好远。如果可以的话，我想你和我一样，都喜欢蛋炒饭。你饿不饿，我做蛋炒饭给你吃呀？","tags":[{"name":"电影","slug":"电影","permalink":"http://qinyuanpei.github.io/tags/电影/"},{"name":"蛋炒饭","slug":"蛋炒饭","permalink":"http://qinyuanpei.github.io/tags/蛋炒饭/"},{"name":"影评","slug":"影评","permalink":"http://qinyuanpei.github.io/tags/影评/"}]},{"title":"基于Python实现Windows下壁纸切换功能","date":"2018-02-05T16:48:39.000Z","path":"posts/2822230423/","text":"&emsp;&emsp;在过去一年多的时间里，我尝试改变博客的写作风格，努力让自己不再写教程类文章，即使在这个过程中，不断地面临着写作内容枯竭的痛苦。因为我渐渐地意识到，告诉别人如何去做一件事情，始终停留在”术”的层面，而比这个更为重要的是，告诉别人为什么要这样做，这样就可以过渡到”道”的层面。古人云：形而上者谓之道，形而下者谓之器。我们常常希望通过量变来产生质变，可是如果在这个过程中不能及时反思和总结，我们认为的努力或许仅仅是重复的劳作而已。如你所见，在这篇文章里，我们将通过Python和Windows注册表实现壁纸切换功能，主要涉及到的Python中的requests、pyinstaller这两个模块的使用，希望大家喜欢。 故事缘由&emsp;&emsp;人们常常相信事出有因，可这世界上有些事情，哪里会有什么原因啊，比如喜欢与不喜欢。做这样一个小功能的初衷，起源于我对桌面壁纸的挑剔。作为一个不完全的强迫症患者，我需要花费大量时间去挑选一张壁纸，丝毫不亚于在网上挑选一件喜欢的商品。我注意到知乎上有这样的话题：有哪些无版权图片网站值得推荐？，因此对于桌面壁纸的筛选，我渐渐地开始摆脱对搜索引擎的依赖，我个人比较喜欢Pexels和Unsplash这两个网站，所以我想到了从这两个网站抓取图片来设置Windows壁纸的方案。市面上类似的商业软件有百度壁纸、搜狗壁纸等，可这些软件都不纯粹，或多或少地掺杂了额外功能，个中缘由想来大家都是知道的。联想到微信最新版本的更新，”发现”页面支持所有项目的隐藏，甚至是盟友京东的电商入口和腾讯最赚钱的游戏入口，这让我开始正视腾讯这家公司，我收回曾经因为抄袭对腾讯产生的不满，腾讯是一家值得尊重的互联网公司。做一个纯粹的应用程序，这就是我的初心。 设计实现&emsp;&emsp;好了，现在我们考虑如何来实现这个功能，我们的思路是从Unsplash这个网站抓取图片，并将其存储在指定路径，然后通过Windows API完成壁纸的设置。Python脚本会通过pyinstaller模块打包成可执行文件，我们通过修改注册表的方式，在右键菜单内加入切换壁纸的选项，这样我们可以直接通过右键菜单实现壁纸切换功能。在编写脚本的时候，起初想到的是抓包这样的常规思路，因为请求过程相对复杂而失败，后来意外地发现官方提供了API接口。事实上Pexels和Unsplash都提供了API接口，通过调用这些API接口，我们的探索进行得非常顺利，下面是具体脚本实现：123456789101112131415161718192021222324252627282930313233# Query ImagessearchURL = 'https://unsplash.com/napi/search?client_id=%s&amp;query=%s&amp;page=1'client_id = 'fa60305aa82e74134cabc7093ef54c8e2c370c47e73152f72371c828daedfcd7'categories = ['nature','flowers','wallpaper','landscape','sky']searchURL = searchURL % (client_id,random.choice(categories))response = requests.get(searchURL)print(u'正在从Unsplash上搜索图片...')# Parse Imagesdata = json.loads(response.text)results = data['photos']['results']print(u'已为您检索到图片共%s张' % str(len(results)))results = list(filter(lambda x:float(x['width'])/x['height'] &gt;=1.33,results))result = random.choice(results)resultId = str(result['id'])resultURL = result['urls']['regular']# Download Imagesprint(u'正在为您下载图片:%s...' % resultId)basePath = sys.path[0]if(os.path.isfile(basePath)): basePath = os.path.dirname(basePath)baseFolder = basePath + '\\\\Download\\\\'if(not path.exists(baseFolder)): os.makedirs(baseFolder)jpgFile = baseFolder + resultId + '.jpg'bmpFile = baseFolder + resultId + '.bmp'response = requests.get(resultURL)with open(jpgFile,'wb') as file: file.write(response.content)img = Image.open(jpgFile)img.save(bmpFile,'BMP')os.remove(jpgFile) &emsp;&emsp;这部分代码非常简单，需要关注的地方有：第一，这个API对应的密钥是公共的，即所有人都可以使用，这里随机从指定的分类中去搜索图片。第二，这里使用filter()函数过滤出宽高比超过1.33的图片，即分辨率为1366 * 768的图片。这里需要注意的是，在Python3.X下filter需要转化为list，否则会引发一个异常。第三，下载的图片默认为JPEG格式，而Windows下设置壁纸使用的是位图格式，即BMP格式，所以在这里我们使用PIL模块来完成格式转换。这里需要注意的是，PIL模块目前不支持Python3.X以后的版本，我们这里使用的是Pillow模块，该模块可以通过pip直接完成安装。 &emsp;&emsp;现在，我们将壁纸下载到本地以后，就可以着手设置壁纸相关的工作。这些工作主要借助为win32api和win32gui这两个内置模块，我们一起来看具体代码：12345678print(u'正在设置图片:%s为桌面壁纸...' % resultId)key = win32api.RegOpenKeyEx(win32con.HKEY_CURRENT_USER, \"Control Panel\\\\Desktop\",0,win32con.KEY_SET_VALUE)win32api.RegSetValueEx(key, \"WallpaperStyle\", 0, win32con.REG_SZ, \"2\") #2拉伸适应桌面,0桌面居中win32api.RegSetValueEx(key, \"TileWallpaper\", 0, win32con.REG_SZ, \"0\")win32gui.SystemParametersInfo(win32con.SPI_SETDESKWALLPAPER, bmpFile, 1+2)print(u'成功应用图片:%s为桌面壁纸' % resultId) &emsp;&emsp;这部分内容非常简单，基本没有复杂的东西在里面。接下来我们需要通过pyinstaller模块将脚本打包成可执行文件，实际上这个步骤完全可以省略，因为现在我们通过命令行就可以实现壁纸切换，为什么要做这样额外的工作呢？考虑到Windows下GUI更为便捷一点，所以我们打包成可执行文件，主要是为了给右键菜单添加功能，我们最终点击想要实现的功能是，点击右键菜单就可以完成壁纸的切换。首先通过pip安装pyinstaller模块，在终端下执行命令：1python -m pip install pyinstaller 安装完成后按照官方文档即可在./dist/目录中找到生成的可执行文件，如果打包出错可以修改Python根目录下的./Scripts/pyinstaller-script.py文件，修改第一行Python.exe的路径，删除两端的引号即可，如下图所示。关于pyinstaller模块打包时的详细参数设定，请自行查阅官方文档。 pyinstaller-script.py文件 &emsp;&emsp;现在，在生成可执行文件以后，我们打开注册表，定位到以下节点：计算机\\HKEY_CLASSES_ROOT\\Directory\\Background\\shell，然后创建一级子节点WallPaper，其默认值填写”更换壁纸”，接下来创建二级子节点command，注意这个名称不能修改，其默认值填写可执行文件路径，本例中为：E:\\Software\\WallPaper\\main.exe，如下图所示： 为右键菜单增加\"更换壁纸\"选项 &emsp;&emsp;好了，现在我们可以看看在右键菜单中增加”更换壁纸”选项以后的效果： 最终效果 文本小结&emsp;&emsp;本文使用Python实现了Windows下切换壁纸的功能，通过requests模块从网络上抓取图片，通过PIL模块实现JPEG格式到BMP格式的转换，通过win32api和win32gui模块实现壁纸设置，并通过修改注册表的方式，将这一功能整合到系统菜单中，可以非常便捷地更换桌面壁纸。作为一个设计上的扩展，我们需要考虑更多的问题，比如当网络断开的时候如何避免异常，如何接入更多的在线图库API，如何支持可配置的图片分类信息以及如何将修改注册表的过程自动化等等，这些问题博主会利用空闲时间去解决，今天这篇文章就是这样啦，本文源代码可以通过这里获取，谢谢大家！","tags":[{"name":"Python","slug":"Python","permalink":"http://qinyuanpei.github.io/tags/Python/"},{"name":"脚本","slug":"脚本","permalink":"http://qinyuanpei.github.io/tags/脚本/"},{"name":"Windows","slug":"Windows","permalink":"http://qinyuanpei.github.io/tags/Windows/"}]},{"title":"深入浅出理解Python装饰器","date":"2018-01-23T15:55:13.000Z","path":"posts/2829333122/","text":"&emsp;&emsp;各位朋友，大家好，我是Payne，欢迎大家关注我的博客，我的博客地址是https://qinyuanpei.github.io。今天我想和大家一起探讨的话题是Python中的装饰器。因为工作关系最近这段时间在频繁地使用Python，而我渐渐意识到这是一个非常有趣的话题。无论是在Python标准库还是第三方库中，我们越来越频繁地看到装饰器的身影，从某种程度上而言，Python中的装饰器是Python进阶者的一条必由之路，正确合理地使用装饰器可以让我们的开发如虎添翼。装饰器天然地和函数式编程、设计模式、AOP等概念产生联系，这更加让我对Python中的这个特性产生兴趣。所以，在这篇文章中我将带领大家一起来剖析Python中的装饰器，希望对大家学习Python有所帮助。 什么是装饰器&emsp;&emsp;什么是装饰器？这是一个问题。在我的认知中，装饰器是一种语法糖，其本质就是函数。我们注意到Python具备函数式编程的特征，譬如lambda演算，map、filter和reduce等高阶函数。在函数式编程中，函数是一等公民，即“一切皆函数”。Python的函数式编程特性由早期版本通过渐进式开发而来，所以对“一切皆对象”的Python来说，函数像普通对象一样使用，这是自然而然的结果。为了验证这个想法，我们一起来看下面的示例。 函数对象123456def square(n): return n * nfunc = squareprint func #&lt;function square at 0x01FF9FB0&gt;print func(5) #25 可以注意到，我们将一个函数直接赋值给一个变量，此时该变量表示的是一个函数对象的实例，什么叫做函数对象呢？就是说你可以将这个对象像函数一样使用，所以当它带括号和参数时，表示立即调用一个函数；当它不带括号和参数时，表示一个函数。在C#中我们有一个相近的概念被称为委托，而委托本质上是一个函数指针，即表示指向一个方法的引用，从这个角度来看，C#中的委托类似于这里的函数对象，因为Python是一个动态语言，所以我们可以直接将一个函数赋值给一个对象，而无需借助Delegate这样的特殊类型。 使用函数作为参数 1234def sum_square(f,m,n): return f(m) + f(n) print sum_square(square,3,4) #25 使用函数作为返回值 1234567def square_wrapper(): def square(n): return n * n return square wrapper = square_wrapper()print wrapper(5) #25 &emsp;&emsp;既然在Python中存在函数对象这样的类型，可以让我们像使用普通对象一样使用函数。那么，我们自然可以将函数推广到普通对象适用的所有场合，即考虑让函数作为参数和返回值，因为普通对象都都具备这样的能力。为什么要提到这两点呢？因为让函数作为参数和返回值，这不仅是函数式编程中高阶函数的基本概念，而且是闭包、匿名方法和lambda等特性的理论基础。从ES6中的箭头函数、Promise、React等可以看出，函数式编程在前端开发中越来越流行，而这些概念在原理上是相通的，这或许为我们学习函数式编程提供了一种新的思路。在这个示例中，sum_square()和square_wrapper()两个函数，分别为我们展示了使用函数作为参数和返回值的可行性。 12345678def outer(m): n = 10 def inner(): return m + n return outerfunc = outer(5)print func() #15 1234567891011#内函数修改外函数局部变量def outer(a): b = [10] def inner(): b[0] += 1 return a + b[0] return innerfunc = outer(5)print func() #16print func() #17 &emsp;&emsp;对Python这门语言来说，这里的outer()函数和inner()函数分别被称为外函数和内函数，变量n的定义不在inner()函数内部，因此变量n称为inner()函数的环境变量。在Python中，一个函数及其环境变量就构成了闭包(Closure)。要理解闭包我认为我们可以把握这三点：第一，外函数返回了内函数的引用，即我们调用outer()函数时返回的是inner()函数的引用；第二，外函数将自己的局部变量绑定到内函数，其中变量b的目的是展示如何在内函数中修改环境变量；第三，调用内函数意味着发生出、入栈，不同的是每次调用都共享同一个闭包变量，请参考第二个示例。好了，现在讲完闭包以后，我们就可以开始说Python中的装饰器啦。 装饰器&emsp;&emsp;装饰器是一种高级Python语法，装饰器可以对一个函数、方法或者类进行加工。所以，装饰器就像女孩子的梳妆盒，经过一番打扮后，可以让女孩子更漂亮。装饰器使用起来是非常简单的，其难点主要在如何去写一个装饰器。带着这个问题，我们来一起看看Python中的装饰器是如何工作的，以及为什么我们说装饰器的本质就是函数。早期的Python中并没有装饰器这一语法，最早出在Python 2.5版本中且仅仅支持函数的装饰，在Python 2.6及以后版本中装饰器被进一步用于类。 123456789101112def decorator_print(func): def wrapper(*arg): print arg return func(*arg) return wrapper@decorator_printdef sum(array): return reduce(lambda x,y:x+y,array)data = [1,3,5,7,9]print sum(data) &emsp;&emsp;我们注意到装饰器可以使用def来定义，装饰器接收一个函数对象作为参数，并返回一个新的函数对象。装饰器通过名称绑定，让同一个变量名指向一个新返回的函数对象，这样就达到修改函数对象的目的。在使用装饰器时，我们通常会在新函数内部调用旧函数，以保留旧函数的功能，这正是“装饰”一词的由来。在定义好装饰器以后，就可以使用@语法了，其实际意义时，将被修饰对象作为参数传递给装饰器函数，然后将装饰器函数返回的函数对象赋给原来的被修饰对象。装饰器可以实现代码的可复用性，即我们可以用同一个装饰器修饰多个函数，以便实现相同的附加功能。在这个示例中，我们定义了一个decorator_print的装饰器函数，它负责对一个函数func进行修饰，在调用函数func以前执行print语句，进而可以帮助我们调试函数中的参数，通过@语法可以让我们使用一个名称去绑定一个函数对象。在这里，它的调用过程可以被分解为：12sum = decorator_print(sum)print sum() 接下来，我们再来写一个统计代码执行时长的装饰器decorator_watcher:12345678def decorator_watcher(func): def wrapper(*arg): t1 = time.time() result = func(*arg) t2 = time.time() print('time:',t2-t1) return result return wrapper 此时我们可以使用该装饰器来统计sum()函数执行时长：123456@decorator_watcherdef sum(array): return reduce(lambda x,y:x+y,array)data = [1,3,5,7,9]print sum(data) 现在，这个装饰器打印出来的信息格式都是一样的，我们无法从终端中分辨它对应哪一个函数，因此考虑给它增加参数以提高辨识度：1234567891011121314151617def decorator_watcher(funcName=''): def decorator(func): def wrapper(*arg): t1 = time.time() result = func(*arg) t2 = time.time() print('%s time:' % funcName,t2-t1) return result return wrapper return decorator@decorator_watcher('sum')def sum(array): return reduce(lambda x,y:x+y,array)data = [1,3,5,7,9]print sum(data) 装饰器同样可以对类进行修饰，譬如我们希望某一个类支持单例模式，在C#中我们定义泛型类Singleton。下面演示如何通过装饰器来实现这一功能：12345678910111213141516171819instances = &#123;&#125;def getInstance(aClass, *args): if aClass not in instances: instances[aClass] = aClass(*args) return instances[aClass]def singleton(aClass): def onCall(*args): return getInstance(aClass,*args) return onCall@singletonclass Person: def __init__(self,name,hours,rate): self.name = name self.hours = hours self.rate = rate def pay(self): return self.hours * self.rate &emsp;&emsp;除此以外，Python标准库中提供了诸如classmethod、staticmethod、property等类装饰器，感兴趣的读者朋友可以自行前去研究，这里不再赘述。 装饰器与设计模式&emsp;&emsp;装饰器可以对函数、方法和类进行修改，同时保证原有功能不受影响。这自然而然地让我想到面向切面编程(AOP)，其核心思想是，以非侵入的方式，在方法执行前后插入代码片段，以此来增强原有代码的功能。面向切面编程(AOP)通常通过代理模式(静态/动态)来实现，而与此同时，在Gof提出的“设计模式”中有一种设计模式被称为装饰器模式，这两种模式的相似性，让我意识到这会是一个有趣的话题，所以在接下来的部分，我们将讨论这两种设计模式与装饰器的内在联系。 代理模式&emsp;&emsp;代理模式，属于23种设计模式中的结构型模式，其核心是为真实对象提供一种代理来控制对该对象的访问。在这里我们提到了真实对象，这就要首先引出代理模式中的三种角色，即抽象对象、代理对象和真实对象。其中： 抽象对象：通过接口或抽象类声明真实角色实现的业务方法。 代理对象：实现抽象角色，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法。 真实对象：实现抽象角色，定义真实角色所要实现的业务逻辑，供代理角色调用。 &emsp;&emsp;下面是一个典型的代理模式UML图示： 代理模式 &emsp;&emsp;通过UML图我们可以发现，代理模式通过代理对象隐藏了真实对象，实现了调用者对真实对象的访问控制，即调用者无法直接接触到真实对象。“代理”这个词汇是一个非常生活化的词汇，因为我们可以非常容易地联系到生活种的中介这种角色，譬如租赁房屋时会存在房屋中介这种角色，租客(调用者)通过中介(代理对象)来联系房东(真实对象)，这种模式有什么好处呢？中介(代理对象)的存在隔离了租客(调用者)与房东(真实对象)，有效地保护了房东(真实对象)的个人隐私，使其免除了频繁被租客(调用者)骚扰的困惑，所以代理模式的强调的是控制。 &emsp;&emsp;按照代理机制上的不同来划分，代理模式可以分为静态代理和动态代理。前者是将抽象对象、代理对象和真实对象这三种角色在编译时就确定下来。对于C#这样的静态强类型语言而言，这意味着我们需要手动定义出这些类型；而后者则是指在运行时期间动态地创建代理类，譬如Unity、Ca’stle、Aspect Core以及ASP.NET中都可以看到这种技术的身影，即所谓的“动态编织”技术，通过反射机制和修改IL代码来达到动态代理的目的。通常意义上的代理模式，都是指静态代理，下面我们一起来看代码示例： 12345678910111213141516171819202122public class RealSubject : ISubject&#123; public void Request() &#123; Console.WriteLine(\"我是RealSubject\"); &#125;&#125;public class ProxySubject : ISubject&#123; private ISubject subject; public ProxySubject(ISubject subject) &#123; this.subject = subject; &#125; public void Request() &#123; this.subject.Request(); &#125;&#125; &emsp;&emsp;通过示例代码，我们可以注意到，在代理对象ProxySubject中持有对ISubject接口的引用，因此它可以代理任何实现了ISubject接口的类，即真实对象。在Request()方法中我们调用了真实对象的Request()方法，实际上我们可以在代理对象中增加更多的细节，譬如在Request()方法执行前后插入指定的代码，这就是面向切面编程(AOP)的最基本的原理。在实际应用中，主要以动态代理最为常见，Java中提供了InvocationHandler接口来实现这一接口，在.NET中则有远程调用(Remoting Proxies)、ContextBoundObject和IL织入等多种实现方式。从整体而言，生成代理类和子类化是常见的两种思路。相比静态代理，动态代理机制相对复杂，不适合在这里展开来说，感兴趣的朋友可以去做进一步的了解。 装饰器模式&emsp;&emsp;装饰器模式，同样是一种结构型模式，其核心是为了解决由继承引发的“类型爆炸”问题。我们知道，通过继承增加子类就可以扩展父类的功能，可随着业务复杂性的不断增加，子类变得越来越多，这就会引发“类型爆炸”问题。装饰器模式就是一种用以代替继承的技术，即无需通过继承增加子类就可以扩展父类的功能，同时不改变原有的结构。在《西游记》中孙悟空和二郎神斗法，孙悟空变成了一座庙宇，这是对原有功能的一种扩展，因为孙悟空的本质依然是只猴子，不同的是此刻具备了庙宇的功能。这就是装饰器模式。下面，我们一起来看一个生活中的例子。 咖啡种类 &emsp;&emsp;喜欢喝咖啡的朋友，看到这张图应该感到特别亲切，因为咖啡的种类的确是太多啦。在开始喝咖啡以前，我完全不知道咖啡会有这么多的种类，而且咖啡作为一种略显小资的饮品，其名称更是令人目不暇接，一如街头出现的各种女孩子喜欢的茶品饮料，有些当真是教人叫不出来名字。这是一个典型的“类型爆炸”问题，人们在吃喝上坚持不懈的追求，让咖啡的种类越来越多，这个时候继承反而变成了一种沉重的包袱，那么该如何解决这个问题呢？装饰器模式应运而生，首先来看装饰器模式的UML图示： 装饰器模式 &emsp;&emsp;从这个图示中可以看出，装饰器和被装饰者都派生自同一个抽象类Component，而不同的Decorator具备不同的功能，DecoratorA可以为被装饰者扩展状态，DecoratorB可以为被装饰者扩展行为，可无论如何，被装饰者的本质不会发生变化，它还是一个Component。回到咖啡这个问题，我们发现这些咖啡都是由浓缩咖啡、水、牛奶、奶泡等组成，所以我们可以从一杯浓缩咖啡开始，对咖啡反复进行调配，直至搭配出我们喜欢的咖啡，这个过程就是反复使用装饰器进行装饰的过程，因此我们可以写出下面的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142//饮料抽象类abstract class Drink&#123; public abstract Drink Mix(Drink drink);&#125;//牛奶装饰器class MilkDecorator : Drink&#123; private Drink milk; MilkDecorator(Drink milk) &#123; this.milk = milk; &#125; public override Drink Mix(Drink coffee) &#123; return coffee.Mix(this.milk); &#125;&#125;//热水装饰器class WaterDecorator : Drink&#123; private Drink water; WaterDecorator(Drink water) &#123; this.water = water; &#125; public override Drink Mix(Drink coffee) &#123; return coffee.Mix(this.water); &#125;&#125;//一杯浓缩咖啡var coffee = new Coffee()//咖啡里混入水coffee = new WaterDecorator(new Water()).Mix(coffee)//咖啡里混入牛奶coffee = new MilkDecorator(new Milk()).Mix(coffee) &emsp;&emsp;在这里我们演示了如何通过装饰器模式来调配出一杯咖啡，这里我没有写出具体的Coffee类。在实际场景中，我们还会遇到在咖啡里加糖或者配料来收费的问题，此时装饰器模式就可以帮助我们解决问题，不同的装饰器会对咖啡的价格进行修改，因此在应用完所有装饰器以后，我们就可以计算出最终这杯咖啡的价格。由此我们可以看出，装饰器模式强调的是扩展。什么是扩展呢，就是在不影响原来功能的基础上增加新的功能。 区别和联系&emsp;&emsp;代理模式和装饰器模式都是结构型的设计模式，两者在实现上是非常相似的。不同的地方在于，代理模式下调用者无法直接接触到真实对象，因此代理模式强调的是控制，即向调用者隐藏真实对象的信息，控制真实对象可以访问的范围；装饰器模式下，扩展功能的职责由子类转向装饰器，且装饰器与被装饰者通常是“同源”的，即派生自同一个父类或者是实现了同一个接口，装饰器关注的是增加被装饰者的功能，即扩展。两者的联系在于都需要持有一个“同源”对象的引用，譬如代理对象与真实对象同源，装饰器与被装饰者同源。从调用的层面上来讲，调用者无法接触到真实对象，它调用的始终是代理对象，对真实对象的内部细节一无所知，这是代理模式；调用者可以接触到装饰器和被装饰者，并且知道装饰器会对被装饰者产生什么样的影响，通常是从一个默认的对象开始”加工”，这是装饰器模式。 装饰器与面向切面&emsp;&emsp;这篇文章写到现在，我发觉我挖了一个非常大的坑，因为这篇文章中涉及到的概念实在太多，务求每一个概念都能讲得清楚透彻，有时候就像莫名立起来的flag，时间一长连我自己都觉得荒唐。有时候感觉内容越来越难写，道理越来越难同别人讲清楚。写作从一开始坚持到现在，就如同某些固执的喜欢一样，大概连我都不记得最初是为了什么吧。好了，现在来说说装饰器与面向切面。我接触Python装饰器的时候，自然而然想到的是.NET中的Attribute。我在越来越多的项目中使用Attribute，譬如ORM中字段与实体的映射规则、数据模型(Data Model)中字段的校验规则、RESTful API/Web API设计中的路由配置等，因为我非常不喜欢Java中近乎滥用的配置文件。 &emsp;&emsp;C#中的Attribute实际上是一种依附在目标(AttributeTargets)上的特殊类型，它无法通过new关键字进行实例化，它的实例化必须依赖所依附的目标，通过分析IL代码我们可以知道，Attribute并非是一种修饰符而是一种特殊的类，其方括号必须紧紧挨着所依赖的目标，构造函数以及对属性赋值均在圆括号内完成。相比较而言，Python中的装饰器就显得更为顺理成章些，因为Python中的装饰器本质就是函数，装饰器等价于用装饰器函数去修饰一个函数。函数修饰函数，听起来感觉不可思议，可当你理解了函数和普通对象一样，就不会觉得这个想法不可思议。有时回想起人生会觉得充满玄学的意味，大概是因为我们还没有学会把自己看得普通。 &emsp;&emsp;通过这篇文章的梳理，我们会发现一个奇妙的现象，Java的Spring框架采用了动态代理了实现AOP，而Python的装饰器简直就是天生的AOP利器，从原理上来讲，这两门语言会选择什么样的方案都说得通。Java是典型的面向对象编程的语言，所以不存在任何游离于Class以外的函数，代理模式对类型的要求更为强烈些，因为我必须限制或者说要求Proxy实现里面的方法，而装饰器模式相对更为宽松些，遇到Python这样的动态类型语言，自然会显得事半功倍。这说明一个道理，通往山顶的道路会有无数条，从中找出最为优雅的一条，是数学家毕生的心愿。AOP是一种思想，和语言无关，我常常听到Java的同学们宣称AOP和IOC在Java社区里如何流行，其实这些东西本来就是可以使用不同的方式去实现的，有些重要的东西，需要你剥离开偏见去认知。 &emsp;&emsp;关于C#中的Attribute和AOP如何去集成，在Unity和Aspect Core这两个框架中都有涉及，主流的AOP都在努力向这个方向去靠拢，Java中的注解同样不会跳出这个设定，因为编程技术到了今天，语言间的差别微乎其微，我至今依然可以听到，换一种语言就能让问题得到解决的声音，我想说，软件工程是没有银弹的，人类社会的复杂性会永远持续地存在下去，你看微信这样一个社交软件，其对朋友圈权限的粒度之细足以令人叹服。有朋友尝试在C#中借鉴Python的装饰器，并在一组文章中记录了其中的心得，这里分享给大家，希望对这个问题有兴趣的朋友，可以继续努力研究下去，AOP采用哪种方式实现重要吗？有人用它做权限控制，有人用它做日志记录……允许差异的存在，或许才是我们真正需要从这个世界里汲取的力量。 轻量级AOP框架-移植python的装饰器(Decorator)到C#(思考篇) 轻量级AOP框架-移植python的装饰器(Decorator)到C#(编码篇) 本文小结&emsp;&emsp;本文是博主学习Python时临时起意的想法，因为曾经有在项目中使用过AOP的经验，所以在学习Python中的装饰器的时候，自然而然地对这个特性产生了兴趣。有人说，装饰器是Python进阶的重要知识点。在今天这篇文章中，我们首先从Python中的函数引出”函数对象”这一概念，在阐述这个概念的过程中，穿插了函数式编程、高阶函数、lambda等等的概念，”函数是一等公民”，这句话在Python中出现时就是指装饰器，因为装饰器的本质就是函数。然后我们讨论了两种和装饰器有关的设计模式，即代理模式和装饰器模式，选择这两种模式来讨论，是因为我们在Java/C#和Python中看到了两种截然不同的实现AOP的思路，这部分需要花功夫去精心雕琢。博主有时候觉得力不从心，所以写作中有不周到的地方希望大家谅解，同时积极欢迎大家留言，这篇文章就先写到这里吧，谢谢大家！","tags":[{"name":"Python","slug":"Python","permalink":"http://qinyuanpei.github.io/tags/Python/"},{"name":"AOP","slug":"AOP","permalink":"http://qinyuanpei.github.io/tags/AOP/"},{"name":"装饰器","slug":"装饰器","permalink":"http://qinyuanpei.github.io/tags/装饰器/"}]},{"title":"AI时代：聊聊大数据中的MapReduce","date":"2018-01-19T00:45:08.000Z","path":"posts/2911923212/","text":"各位朋友，大家好，我是Payne，欢迎大家关注我的博客。最近读一本并行计算相关的书籍，在这本书中作者提到了MapReduce。相信熟悉大数据领域的朋友，一定都知道MapReduce是Hadoop框架中重要的组成部分。在这篇文章中，博主将以函数式编程作为切入点，来和大家聊一聊大数据中的MapReduce。如今人工智能正成为行业内竞相追逐的热点，选择MapReduce这个主题，更多的是希望带领大家一窥人工智能的门庭，更多深入的话题需要大家来探索和挖掘。 MapReduce的前世今生MapReduce最早是由Google公司研究并提出的一种面向大规模数据处理的并行计算模型和方法。2003年和2004年，Google公司先后在国际会议上发表了关于Google分布式文件系统(GFS)和MapReduce的论文。这两篇论文公布了Google的GFS和MapReduce的基本原理和主要设计思想，我们通常所说的Google的三驾马车，实际上就是在说GFS、BigTable和MapReduce。因此，这些论文的问世直接催生了Hadoop的诞生，可以说今天主流的大数据框架如Hadoop、Spark等，无一不是受到Google这些论文的影响，而这正是MapReduce由来，其得名则是因为函数式编程中的两个内置函数: map()和reduce()。 我们常常说，脱离了业务场景去讨论一项技术是无意义的，这个原则在MapReduce上同样适用。众所周知，Google是一家搜索引擎公司，其设计MapReduce的初衷，主要是为了解决搜索引擎中大规模网页数据的并行化处理。所以，我们可以说，MapReduce其实是起源自Web检索的。而我们知道，Web检索可以分为两部分，即获取网页内容并建立索引、根据网页索引来处理查询关键字。我们可以认为互联网上的每个网页都是一个文档，而每个文档中都会有不同的关键字，Google会针对每一个关键字建立映射关系，即哪些文档中含有当前关键字，这是建立索引的过程。在建立索引以后，查询就会变得简单，因为现在我们可以按图索骥。 互联网诞生至今，网站及网页的数量越来越庞大，像Google这样的搜索引擎巨头是如何保证能够对Web上的内容进行检索的呢？答案是采用并行计算(Parallel)。硬件技术的不断革新，让计算机可以发挥多核的优势来处理数据，可当数据量庞大到单机无法处理的程度，就迫使我们不得不采用多台计算机进行并行计算。我们知道并行计算的思想是，将大数据分割成较小的数据块，交由不同的任务单元来处理，然后再将这些结果聚合起来。因此，可以将MapReduce理解为一种可以处理海量数据、运行在大规模集群上、具备高度容错能力、以并行处理方式执行的软件框架。MapReduce是分治思想在大规模机器集群时代的集中体现(如图所示)，其中，Mapper负责任务的划分，Reducer负责结果的汇总。 MapReduce原理图 MapReduce的推出给大数据并行处理带来了巨大的革命性影响，使其成为事实上的大数据处理的工业标准，是目前为止最为成功、最广为接受和最易于使用的大数据并行处理技术。广为人知的大数据框架Hadoop，正是受到MapReduce的启发。自问世来，成为Apache基金会下最重要的项目，受到全球学术界和工业界的普遍关注，并得到推广和普及应用。MapReduce的非凡意义在于，它提出了一个基于集群的高性能并行计算模型，允许使用市场上普通的商用服务器构成一个含有数十、数百甚至数千个节点的分布式并行计算集群，可以在集群节点上自动分配和执行任务以及收集计算结果，通过Mapper和Reducer提供了抽象的大数据处理并行编程接口，可以帮助开发人员更便捷地完成大规模数据处理的编程和计算工作。今天，Google有超过10000个不同的项目已采用MapReduce来实现。 函数式编程与MapReduce我们提到，MapReduce之得名，其灵感来自函数式编程中的两个内置函数：map()和reduce()。函数式编程中，有一个重要的概念叫做高阶函数，是指函数自身能够接受函数，并返回函数的一种函数。我们所熟悉的C#和Java都是典型的面向对象编程(OOP)的语言，在这类编程语言中类(Class)是第一等公民，即不允许有独立于类的结构出现在代码中。虽然微软从未公开表示C#支持函数式编程，可从LINQ中我们依然可以窥见高阶函数的身影，譬如我们熟悉的Select()、Where()等扩展方法，就可以让我们按照函数式编程的风格去编写代码，这正是为什么Java 8开始支持Stream API的原因。最经典的函数式编程语言当属Haskell语言，我们今天见到的各种编程语言，在考虑引入函数式编程风格的时候，或多或少地都会受到这门语言影响。当你开始适应函数作为第一等公民、高阶函数、柯里化以及惰性求值以后，你或许就会感受到函数式编程特有的美感。 这里我们选择Python来阐述函数式编程与MapReduce的关系。Python可以让我们轻易地在多种不同的编程风格间切换，事实上现在的编程语言都有向着混合式编程风格发展的趋势。我们提到MapReduce来自两个内置函数：map()和reduce()。其中，map()方法可以对指定集合中的元素按照指定函数进行映射，并将映射后的结果以集合形式返回。譬如我们有一个集合[1,3,5,7,9]，我们希望对集合中的每一个元素做平方运算。借助Python中的map()方法和lambda表达式，这个问题可以通过1行代码得到解决。同理，如果我们希望对该集合内的元素做求和运算，我们可以借助于Python中的reduce()方法，该方法位于functools模块中。在某些编程语言中该方法又被成为fold()方法，实际上这两种叫法是等价的，我们关注函数式编程的本质即可。什么是本质呢？当然是函数啦。 1234567891011121314151617181920212223242526272829303132list = map(lambda x: x * x, [1,3,5,7,9]) #[1,9,25,49,81]sum = functools.reduce(lambda x,y: x+y, [1,3,5,7,9]) #25``` 好了，现在我们来分析下这两个函数，这将帮助我们更好地理解MapReduce。map()方法在这里被称为映射函数，它可以将一种类型映射为一种新的类型。举一个生活中的例子，譬如我们做菜的时候，必不可少的一个环节是将各种各样的食材切碎， 此时作用在这些食材的这个操作就是一个Map操作，你给Map一个洋葱就可以得到洋葱丝。同样地 ，你给Map一个番茄就可以得到番茄块。所以Map处理的原始数据，每条数据间没有相互联系，聪明的你告诉我洋葱和番茄有什么关系。相比map()方法，reduce()方法复杂的地方在于，它要求lambda表达式中必须是两个参数。如果继续沿用做菜这个生活化的例子，reduce()方法是将Map操作中切好的食材混合在一起。假设我们要做一份辣椒酱，辣椒酱需要的材料有辣椒、姜和蒜，因此在第一步Map的时候，这些食材将具有相同的Key。对同一类数据，我们就可以使用reduce()进行左/右折叠操作，这相当于我们将同一道菜的食材一起放到锅里，所以 Reduce阶段处理的数据是以Key-Value形式组织的，同一个Key下的Value具有相关性。这样，从理论上它就完全符合函数式编程里的map()和reduce()啦。 # C#并行编程里的PLINQ关于MapReduce中一个经典案例是，统计不同文章中出现的关键字的频率。对这样一个问题，我们基本上可以想到下面四种方法：* 写一个单线程程序，顺序地遍历所有文章，然后统计每个关键字出现的频率。* 写一个多线程程序，并发地遍历所有文章，然后统计每个关键字出现的频率。* 写一个单线程程序，部署到N台不同的计算机上，然后将文章分割成N份分别输入，再由人工汇总N份结果。* 使用MapReduce，程序部署、任务划分、结果汇总全部交给框架去完成，我们定义好任务即可。通过对比，我们可以非常容易地分析出来，第一种方法最简单同时最耗时；第二种方法理论上比第一种高效，尤其是当计算机是多核或者多处理器的时候，缺点是要解决线程同步的问题；第三种方法初现集群的思想，可无法解决程序部署、任务划分和结果汇总等一系列问题；第四种方法本质上就是第三种方法， 可是MapReduce解决了第三种方法全部缺陷，所以它或许是目前最完美的方法。我们下面来考虑，如何模拟这个过程，因为博主不可能为了写一篇科普性质的文章，专门去准备一个Hadoop的开发环境啊，哈哈。PLINQ，即Parallel LINQ，是.NET 4.0中增加的任务并行库(**TPL**)中的一部分。并行编程中有两个基本的概念，**任务并行**和**数据并行**。前者是指，将程序分割成一组任务并使用不同的线程来运行不同的任务，这种方式被称为**任务并行**；而后者是指，将数据分割成较小的数据块，对这些数据进行并行计算，然后聚合这些计算结果，这种编程模型称为**数据并行**。伴随着并行算法的出现，并行集合相继而来，显然LINQ的并行版本就是PLINQ。这里我们来看一个使用PLINQ实现的词频统计代码，这将作为我们实现MapReduce的一个示例：```CSharp//Origin Textsstring strTarget = @\"\";//Mapstring[] words = strTarget.Split(' '); ILookup&lt;string, int&gt; map = words.AsParallel().ToLookup(p =&gt; p, k =&gt; 1); //Reducevar reduce = from IGrouping&lt;string, int&gt; wordMap in map.AsParallel() where wordMap.Count() &gt; 1 select new &#123; Word = wordMap.Key, Count = wordMap.Count() &#125;; //Show Resultsforeach (var word in reduce) Console.WriteLine(\"Word: '&#123;0&#125;' : Count: &#123;1&#125;\", word.Word, word.Count); 本文小结今天Google发布了全新的AI服务工具Cloud AutoML，从这个产品的名字就可以看出，这是一个试图将人工智能大众化的产品。目前AI是行业中不容置疑热点，国外的科技巨头如Google、微软，国内的科技巨头如腾讯、阿里和百度等，无一不在积极布局AI的上下游产业链。最近CSDN发布了人工智能方向的发展规划，整个产品线的基本都在做战略上调整，我们这些曾经的老用户被新的社区 运营搞得非常郁闷，因为所有的资源都在向着人工智能和区块链倾斜。上周在知乎上看到一篇讽刺国内区块链发展乱象的文章，大概就是说国人喜欢拿一个Token当做加密货币来买，实则连底层技术、分布账本、钱包等基础设施都没有。对于这一点我深有体会，任何新的商业模式在中国都火不过1年，譬如在2017年里被发扬广大的共享经济，有多少共享单车是靠技术和产品赢得市场的，我相信大部分都是沾了人口基数大的光。目前的人工智能，核心算法及技术都掌握在科技巨头手上。我们所追逐的人工智能，有多少是需要靠不断调整参数反复去训练来达到的呢？我觉得找到切实可靠的需求落脚点，比追逐一个又一个热点要更现实，我们大部分工程师都是在科学家工作的基础上做集成应用，所以拨开泡沫看清方向比盲目跟风更重要呀。 这篇文章蹭了人工智能的热点，其实它对MapReduce并没有做多少深入的研究。我们从Google的业务场景着手分析，思考为什么Google需要MapReduce，即提出MapReduce是为了解决一个什么样的问题？答案是为了适应Google在大规模Web检索业务方面的需要。通过梳理Web检索的一般流程，我们意识到，Web检索可以分为两部分，即获取网页内容并建立索引、根据网页索引来处理查询关键字，从而引出了Mapper和Reducer两个基本的数据处理单元，MapReduce是分治思想在大规模机器集群时代的集中体现，其中，Mapper负责任务的划分，Reducer负责结果的汇总。接下来，我们顺着函数式编程的思路，分析了函数式编程中的map()和reduce()，这两个核心的函数同MapReduce在思想上的一致性，这正是为了印证前文中MapReduce得名的由来。考虑到C#中提供了PLINQ，而在阅读《C#多线程编程》这本书时，同样提到了MapReduce这种并行计算模型，所以在这里将这两者进行结合，提供了一个通过并行计算统计单词频率的简单示例。以上就是这篇文章的所有内容了，如果大家对文章有什么意见或者建议，可以在文章评论区留言，这篇文章就是这样了，谢谢大家，晚安！","tags":[{"name":"AI","slug":"AI","permalink":"http://qinyuanpei.github.io/tags/AI/"},{"name":"MapReduce","slug":"MapReduce","permalink":"http://qinyuanpei.github.io/tags/MapReduce/"},{"name":"FP","slug":"FP","permalink":"http://qinyuanpei.github.io/tags/FP/"}]},{"title":"无问东西：你曾是少年","date":"2018-01-19T00:42:06.000Z","path":"posts/1983298072/","text":"如果提前了解了你所要面对的人生，你是否还有勇气前来？ 这是电影《无问西东》里提出的一个问题。作为一部清华大学建校100周年的献礼片，在因为种种原因而被雪藏6年以后，终于以这样一种倔强而孤傲的姿态，进入到人们的视野。 绘制彩红的张果果 电影一开始，透过玻璃注视着四胞胎的张果果(张震饰)，第一次向我们发问：如果提前了解了你所要面对的人生，你是否还有勇气前来。而在电影接近尾声的时候，张果果再一次注视着四胞胎，在窗户上为它们勾勒彩虹，此时旁白再次想起，一问一答间，张果果心中已然找到答案。我想知道的是，屏幕前的你，是不是同样找到了答案？ 这是一部讲述传承的电影，它不同于目前电影市场上任何一种主流的类型，它从一开始就注定是一部不讨巧、不友善、不商业的电影。其故事跨度将近一个世纪，或许我们所看到的，不过是历史长河里的星星点点，可依然难掩背后熠熠生辉的文人风骨，这种由时代所赋予的文化气息，让它成为一部瑕不掩瑜的电影，所以即使这部电影在叙事、配乐和剪辑上存在缺陷，这依然是一部值得关注的电影。 电影尝试用四个平行的板块，讲述四个不同历史阶段的故事，这些故事中的人物彼此关联，组成了一幅波澜壮阔的历史画面，而影片中想要去表达的精神内核，恰好是关联起这些人物的一种特质，我们称之为传承的东西。按照影片线性叙事的结构，我们可以梳理出这样四条线索。 上进求学的吴岭澜 1923年，北平，清华学堂的高材生吴岭澜(陈楚生饰)，面对选择文理科时的迷茫与彷徨，校长梅贻绮告诉他什么是真实，适逢泰戈尔访华到清华园演讲，在听到“不要忘记你们的真心和真性”后，开始思考人生的意义。 捐躯赴国的沈光耀 1938年，昆明，世家子弟沈光耀面对山河破碎的现实，在忠与孝的两难抉择中深感困惑，直到听到吴岭澜说“不要放弃对生活的思索，对自己的真实”，毅然选择投笔从戎，成为飞虎队队员，在国家危亡之际战死沙场。 青春阳光的陈鹏 1962年，北京，清华毕业生陈鹏，在面对国家的大爱与恋人的小爱的选择时，饱含着对恋人王敏佳的爱远赴沙漠投身科研，他质问为支边而蒙蔽内心的李想什么是真实，他用爱托着恋人鼓励她努力活下去，为爱而奉献一生。 寻找本心的张果果 2010年，北京，广告总监张果果，在明争暗斗的职场上遭人排挤，在面对职场中的名利诱惑时，在面对四胞胎永无止境的救助要求时，李想用生命拯救了张果果的父母，完成自我救赎，而张果果则在迷茫中找会初心，让爱传承下去。 看这样一部电影的时候，像是在经历一件久远的事情。“这个时代缺少的不是完美的人，缺少的是从自己心底里给出的，真心、正义、无畏和同情”，这是电影中飞虎队教练在招收飞行员时所说的话。我想我们喜欢这部电影，恰恰是因为我们缺少这些东西，这些让我们感到温暖而纯粹的东西。借用吴岭澜在影片中的一句话，“此刻我终于不觉得这样的思考是羞耻的，甚而是你们人生必须的”，面对一个我们无力反驳的现实，或许思考有时候会显得更为苍白。彼时，清华大学校长梅贻绮对迷茫中的吴岭澜这样说道，“人把自己置身于忙碌之中，有一种麻木的踏实，但丧失了真实”，那么你知道什么是真实吗？ 循循善诱的清华校长梅贻琦 聆听泰戈尔演讲的吴岭澜 电影中第一个人物，是1924年就读于清华大学的吴岭澜，他见证过泰戈尔访问清华，最终从摇摆不定到听从内心声音，找寻人生的意义。吴岭澜当时是清华大学的一名学生，他的理科成绩属于不列，而当时最好的学生都会去读理科，所以他开始面临学业选择上的困惑。校长梅贻绮给他的答案是：“真实是你看到什么，听到什么，做什么和谁在一起，有一种从心灵深处满溢出来的不懊悔也不羞耻的平和与喜悦”。当时诗人泰戈尔访问清华，演讲的主题是”对自己的真诚”，这次演讲促使吴岭澜心态发生最终变化，转学文科，并最终成为西南联大的一名文科教授。电影对吴岭澜的描绘着重放在他和校长梅贻绮的谈话，以及他出现在泰戈尔演讲现场时那双坚定而执著的眼睛。影片中泰戈尔并没有给出完整的正脸，我们可以看到的只有他标志性的长头发和白头发，可见当时泰戈尔的演讲激起了这代青年人内心的热潮。 历史上的西南联大 西南联大师生合影 历史上的西南联合大学，始于1938年4月。“七七事变”后，京津地区陷入日军炮火，彼时的清华、北大和南开三校一致决定南迁，遂组成西南联合大学。电影中投笔从戎的沈光耀(王力宏饰)就是这段历史时期的一个缩影，西南联大是中国高等教育史上最伟大的传奇，在短短8年间，汇聚并培养了一大批精英，譬如陈寅恪、钱穆、梁思成、朱自清、闻一多、冯友兰……可以说这是近代最为光华璀璨的时期，可谓群贤毕至、风华绝代。短短8年间，西南联大共毕业学生3882名，其中诺贝尔奖获得者2位、国家最高科学技术奖获得者4位、两弹一星功勋奖章获得者8位、两院院士171位及人文大师100多位。 静坐停雨 电影中这段我最喜欢的场景是“静坐听雨”。历史上西南联大的校舍，是由梁思成夫妇参与设计的。因为战争时期物资非常紧缺，校方无法提供充足的建筑材料，所以梁思成夫妇的设计方案一改再改，从楼房变成了平房，从砖墙变成了泥墙，最终124亩的校园里，只有图书馆和实验室以青瓦覆顶，教室用铁皮，宿舍则用茅草。铁皮屋顶最害怕下雨，而昆明偏偏是多雨气候，因此就有了雨声太大导致学生无法听清老师讲课，老师无奈地在黑板上写下“静坐听雨”四个字，这样苦涩中带着温情的画面。电影中沈光耀推开教室窗户，听到的是雨中体育系学生坚持出操的呐喊，看到的是雨中垂钓者的“一蓑烟雨任平生”的从容。我们今天的大学占地越来越大，楼越盖越高，可再找不回这种令人动容的场景。我本科有位老师喜欢讲《大学》，他说这大学不是“高楼大厦之谓”，而是“大师之谓”，这一刻我很想再听老师讲一次大学之道。 汪曾琪有篇散文《跑警报》，讲述的正是当时的师生躲避日军飞机轰炸的故事，电影中沈光耀(王力宏饰)在锅炉房相遇煮冰糖银耳的桥段，正是取材于这篇散文。在影片中，吴岭澜(陈楚生饰)是一个对沈光耀产生深远影响的人，吴岭澜此时已成为西南联大文学系教授，他冒着被轰炸的危险把煮冰糖银耳的沈光耀从校舍拉了出来，一句“学生不走老师怎么能走”，足以让其形象瞬间高大起来。电影中吴岭澜躲避轰炸的时候带了只鸽子，而历史真实的故事则是金岳霖抱着一只鸡。当时流传着这样一个段子，“陈寅恪跑警报是为了保护国粹，刘文典跑警报是为了庄子，沈从文跑警报到底是为了什么“。在防空洞里吴岭澜讲述泰戈尔的“真实就是你所见所闻”，将真实传承到沈光耀心里，所以他会冒着受罚的风险向饥民空投物资，所以他会不顾家人反对毅然选择投笔从戎、加入飞虎队，直至弹尽粮绝的最后一刻，他毫不犹豫地选择同日军舰艇同归于尽，这是他们的青春故事。 研制原子弹归来的陈鹏 用深情撑住恋人的陈鹏 陈鹏(黄晓明饰)在影片中是清华大学的一名学生，在毕业后参与原子弹的研制工作。他对恋人王敏佳矢志不渝的爱，成为了支撑她熬过人生低谷的强大动力。影片中的王敏佳一心想帮助曾经的老师摆脱“家庭暴力”，结果反倒被师母诬陷她勾引自己老师，而她的虚荣心迫使她被组织审查直至接受批斗。在批斗中王敏佳失去了美丽的面庞，她的好朋友李想为争取支援边区的名额，不敢承认自己的错误并坚决同她划清了界限。只有陈鹏自始至终守护在王敏佳身边。可陈鹏依然在国家和个人的抉择中，选择了远赴沙漠参与原子弹的研制工作，对他而言，照顾王敏佳和研制原子弹，就是他生命的全部。可当陈鹏回到曾经熟悉的地方时，却发现恋人因为“破四旧”运动而不见踪影。在爱人与国家面前，在爱情与理想面前，我们到底应该怎么去选择，我想大概就是电影中陈鹏告诉李想那句话，“死者已矣，生者如斯”，这是“晃晃”哥哥和神父教给他的大爱。 眼神里都是戏的领导 现代人的感情，就剩这么点了 生活在现代都市的张果果(张震饰)，在尔虞我诈的人际关系中艰难前行，他恪守上下级的职场伦理却被有预谋地当作了替罪羊。面对女下属的质疑，不得不以高深莫测的“你猜”来掩饰内心的焦虑。对父母缺乏耐心以至于出去吃饭的时候直接将碗筷丢进垃圾框，他习惯性地防备着身边的一切，一如喜欢给自己覆盖一层冰冷盔甲的你我。他怕四胞胎家人纠缠而从医院匆匆离开，却又主动掏出名片在门口等人家追上来；目睹四胞胎家人住在没有暖气的出租屋里，冷峻着脸转身离开却又悄声让助理帮忙找个好点的两居室；他买来各种奶粉默默研究选出最满意的奶粉并长期供给，却又不愿意让四胞胎家人对他抱太高期望……起初会觉得这个角色和整个故事无关，可当张果果的父母交代出李想在边区为救自己而牺牲的故事，这一刻我们终于明白，这种传承从未改变，经历过迷茫和无助的张果果终于找回初心，自信地对这个世界说：“我和他们不一样”。 我相信每个时代里的青年都曾这样迷茫过，就像我们今天所要面对的这种困局一样。媒体称我们这一代人是得过且过的佛系青年，我们为工作中无法得到别人认可而焦虑过，我们为空有适婚的年龄而无适婚的感情而烦闷过，我们为透支父母毕生积蓄来买房而羞愧过……可你看每一个在时代洪流中挣扎的人，其生命无一不被同时打上时代和民族的烙印。吴岭澜是因真心而重新选择自己的人生，沈光耀是因为正义而投笔从戎，陈鹏是因为无畏而托住恋人投身科研，张果果是因为同情而重拾本心迷途知返。列夫·托尔斯泰说过，幸福的人生都是相似的，不幸的人生各有各的不同。每个时代有每个时代的不幸，我们今天不单单要面对水涨船高的房价，更要面对逐渐枯竭甚至贫瘠的心灵。有人说，这部拍给清华学生看的电影，对改善我们的生活毫无意义，可这世上有多少东西，说出来以后能不变得庸俗呢？ 那时的爱情真美好 这个校服好帅诶 不管多远都要去寻找你 最后的国学大师，王国维 那时的青春真美好 同样是在迷茫的20多岁，有人找到了真性在生命里惊鸿一瞥，有人在沉浮中随波逐流迷失本心，前者是沈光耀目睹战友牺牲与敌舰同归于尽，后者是李想为争取支边名额背弃朋友间的友谊。陈鹏的爱慷慨而深沉，王敏佳不幸而无能为力……每个时代都是写意的，有佚群绝类的意气，有献血淋漓的痛苦，今天的人们注定无法理解曾经艰苦的生活，而曾经的人们同样无法理解现代人所面对的压力。现实中的离婚和出轨，让美好的爱情变得遥不可及。我们今天越是期待什么，我们的心里就越是缺乏什么。白居易说《长恨歌》是虚构的，而感情是真实的，这或许完全是我们的内心在作怪。世道艰辛，梦想与现实，家国与大义，爱情与理想，名利与善良，仿佛冥冥之中被逼迫到进退两难境地的每一个人，众生皆苦，各自悲欢。张果果在酒吧里拎着半瓶红酒自嘲道，“现代人的情感，就这么多了”，当本心迷失，便是我们有火车，有高铁，有飞机，都不知道要去哪里了！ 路一直都在远方 古人说“为天地立心，为生民立命，为往圣继绝学，为万世开太平”，这是传统知识分子对文化传承的一种使命感。在这部电影中，防空洞里师生背诵《楚辞》、讲述泰戈尔，这是我理解的文化上的传道；王国维在一片英语声中转身离去，那个萧疏没落的背景像是很久很久以前的事情；沈光耀的母亲不愿意他为功名荣辱，在不知人生为何物的时候匆匆离开；师母看到被人打得半死的王敏佳，内心残存的善念觉醒愧而坠井……这些游曳在光影里的残余画面，显得温暖而残酷，终于化作电影结束时一个又一个陌生而熟悉的名字。我们之所以怀念青春，是因为青春本该就是这个样子，真实勇敢，无惧无悔。世俗这样强大，强大到生不出改变它们的念头来。可是无论外界的社会如何跌宕起伏，都对自己真诚，坚守原则。内心没有了杂念和疑问，才能勇往直前。愿你在被打击时，记起你的珍贵，抵抗恶意；愿你在迷茫时，坚信你的珍贵，爱你所爱，行你所行，听从你心，无问西东。","tags":[{"name":"电影","slug":"电影","permalink":"http://qinyuanpei.github.io/tags/电影/"},{"name":"影评","slug":"影评","permalink":"http://qinyuanpei.github.io/tags/影评/"},{"name":"无问西东","slug":"无问西东","permalink":"http://qinyuanpei.github.io/tags/无问西东/"}]},{"title":"致前任：愿余生各自安好","date":"2018-01-12T00:39:39.000Z","path":"posts/1358971951/","text":"也许是因为年纪大了的缘故，渐渐地如同上瘾一般喜欢上怀旧，喜欢怀旧到了什么程度呢？想着再次重温下小马哥的英雄本色，想着再次感受下星球大战里的刀光剑影……可是每次都因为不同的原因而落空，之所以没有去看《英雄本色》，是因为附近的电影院都没有排片，那么这一次呢，好像是因为一部和前任有关的电影《前任攻略3：再见前任》。 或许前任与现任永远都是一道无解的题目，就如同网上流传着的一个问题，“我和你妈同时掉水里你会先救哪一个”，我们发现对这个问题而言，即使代入现任和前任这样的设定，它看起来依然是说得通的。那么，在我们心里是如何对待现任和前任的呢？我想，在很多人的潜意识里，前任代表了那个你曾经认定要一直走下去的人。我们曾经用天真对一个人好，发自内心地去爱，最终却用尽全力去遗忘释怀。这部电影所讲述的恰好是这样一个写实的场景。最近看到一段这样的话，我们总是用前任的错误惩罚下一任，或者是用对前任的亏欠弥补下一任。这两种做法均无可厚非，甚至听起来第二种做法更好，可如果扪心自问，到底是爱前任多些，还是爱现任多些，我想这是一个问题。电影里的两对情侣，孟云和林佳，余飞和丁点，同时因为生活中的矛盾分手，好兄弟和好闺蜜再度走到一起，这个时候，我们觉得失恋应该是痛苦的一件事情，没有喝醉到不省人事，没有悲伤到歇斯底里，这都不算做失恋吧。 可或许是我们想多了，有时候两个人分开以后，难过的只有自己，对对方而言或许是种解脱，于是我们在电影里看到了一幕幕单身男女嗨翻天的景象，我们常常听到这样一句话，两个人不合适就分手呗，讽刺的是，我们一边渴望着美好的爱情，一边对待感情弃若敝履，我们谈恋爱的时间越来越短，对彼此越来越没有耐心，有人说，这是因为我们长大了，知道20多岁的年龄，不能再像10多岁一样挥霍，像孟云和林佳这样的情侣，现实中举不胜举，为了彼此一点可怜的自尊，谁都不肯先放下身段同对方和解，等到矛盾积累得越来越多，任何一件事情都有可能成为，压死骆驼的最后一根稻草。这个时候，还要试图用扮演至尊宝说“我爱你”和疯狂吃芒果吃到过敏，这样幼稚可笑的事情来满足各自的虚荣心，好像我们每个人都实现了对彼此的承诺，真正爱你的人，怎么会舍得离开你呢，明明是自私得只懂得爱自己，非要坚持说是对方不够爱自己，真正爱你的人，爱一直都在心里。 我不知道这样一部电影，是如何让大家产生共鸣，在观影的时候哭得稀里哗啦的，电影中两位男主在“隔壁老王”，讨论是生男孩好还是生女孩好，讨论和双胞胎姐妹约会的好处，和一众长着网红脸的95后在Party上狂嗨……各种段子让分手变成一场狂欢，而狂欢下的两种状态，有余飞和丁点这种“以分手的名义，撒着思念的娇”的，有孟云和林佳这种因为沟通不善而渐行渐远的。我们常常听到一个词叫做合适，其实以人类这种奇葩的性格，又怎么会找到完全合适的两个人呢？这一切都是需要去不断磨合的，我们看待感情的角度是功利的，如果两个人走到一起甚至结婚，我们觉得这就是合适的，那么像孟云和林佳这种相爱五年的情侣，我觉得我们很难用一句合适或者不合适来说说清楚，两个人在一起一定要多沟通，有问题不要想着第二天再解决。在感情中不要用“作”这种手段去测试对方，一个人喜欢你，愿意忍让你，并不代表你可以毫无底线。也许很多时候，我们都喜欢把话埋在心里，我们都觉得谁先主动谁就输啦，即使此刻赢得了面子，最终还是会输掉了里子。 这部电影可谓是为“前任系列”画上了一个完美的结局，然而这样一部名不见经传的电影，可以在猫眼电影上获得9.2分的高分，一度超越近期口碑极佳的《芳华》，这种前半段走肾后半段走心的编排方式，成功地将观众的情绪带向高潮。有人说在这部电影里找到了自己的影子，可在我看来大家都在努力给自己加戏，两个人会分开一定是有某种原因的，我们总幻想着离开的时候，如何惊天地泣鬼神一般轰轰烈烈，可真正的离开从来都是悄无声息的。一场体面的分手，是两个彼此伤痕累累的的人，在面对这段感情时，即使知道其中存在的问题，但是发现一切再无法回到以前，因为在这个被称为成长的过程中，感情早已被当作燃料的消耗殆尽。所以，我们说：我依然爱你，但我不再喜欢你了，所以我们只能走到这里了。体面的分手，或许应该是这个样子的，是一切大彻大悟以后的慈悲，是用尽了力气后的平静，是虽然结局不如意，但我没有后悔遇见你，是接受成长带来的痛苦，是学会如何更好地爱自己、爱别人。 有人说，前任就像黑夜中摇曳着的烛火，坍塌在无边的夜色中。或许会有无数根的蜡烛，能照亮你的黑暗，但再不会有这样一个人，能这样一往无前地在黑暗中，为你烫出一个洞，然后用温暖填满。成长是件非常痛苦的事情，你不一定会得到什么，但一定会失去什么，有些人注定是让你成长的，所以请好好再见，不负遇见。有些人会永远停留在你的心里，他们曾经出现，并成为你人生的一部分，我们会爱上下一个，再下一个。放过前任，放过自己，这或许是最好的结局。","tags":[{"name":"电影","slug":"电影","permalink":"http://qinyuanpei.github.io/tags/电影/"},{"name":"前任","slug":"前任","permalink":"http://qinyuanpei.github.io/tags/前任/"},{"name":"公众号","slug":"公众号","permalink":"http://qinyuanpei.github.io/tags/公众号/"}]},{"title":"《C#多线程编程实战》读书笔记","date":"2018-01-07T21:34:36.000Z","path":"posts/345410188/","text":"本文是一篇读书笔记，由《C#多线程编程实战》一书中的内容整理而来，主要梳理了.NET中多线程编程相关的知识脉络，从Thread、ThreadPool、Task、async/await、并发集合、Parallel、PLINQ到Rx及异步I/O等内容，均有所覆盖。为了帮助大家理解本文内容，首先给出博主在阅读该书过程中绘制的思维导图，大家可以根据个人需要针对性的查漏补缺。 《多线程编程实战》思维导图 线程基础 Tips1：暂停线程，即通过Thread.Sleep()方法让线程等待一段时间而不用消耗操作系统资源。当线程处于休眠状态时，它会占用尽可能少的CPU时间。 Tips2：线程等待，即通过Join()方法等待另一个线程结束，因为不知道执行所需要花费的时间，此时Thread.Sleep()方法无效，并且第一个线程等待时是处于阻塞状态的。 Tips3：终止线程，调用Abort()方法会给线程注入ThreadAbortException异常，该异常会导致程序崩溃，且该方法不一定总是能终止线程，目标线程可以通过处理该异常并调用Thread.ResetAbort()方法来拒绝被终止，因此不推荐使用Abort()方法来终止线程，理想的方式是通过CancellationToken来实现线程终止。 Tips4：线程优先级，线程优先级决定了该线程可占用多少CPU时间，通过设置IsBackground属性可以指定一个线程是否为后台线程，默认情况下，显式创建的线程都是前台线程。其主要区别是：进程会等待所有的前台线程完成后再结束工作，但是如果只剩下后台线程，则会直接结束工作。需要注意的是，如果程序定义了一个不会赞成的前台线程，主程序并不会正常结束。 Tips5：向线程传递参数，可以通过ThreadStart或者lambda表达式来向一个线程传递参数，需要注意的是，由lambda表达式带来的闭包问题 Tips6：竞争条件是多线程环境中非常常见的导致错误的原因，通过lock关键字锁定一个静态对象(static&amp;readonly)时，需要访问该对象的所有其它线程都会处于阻塞状态，并等待直到该对象解除锁定，这可能会导致严重的性能问题， Tips7：发生死锁的原因是锁定的静态对象永远无法解除锁定，通常Monitor类用以解除死锁，而lock关键字用以创建死锁，Monitor类的TryEnter()方法可以用以检测静态对象是否可以解锁，lock关键字本质上是Monitor类的语法糖。 123456789101112bool acquiredLock = false;try&#123; Monitor.Enter(lockObject, ref acquiredLock)&#125;finally&#123; if(acquiredLock) &#123; Monitor.Exit(lockObject) &#125;&#125; Tips8：不要在线程中抛出异常，而是在线程代码中使用try…catch代码块。 线程同步 Tips9：无须共享对象，则无须进行线程同步，通过重新设计程序来移除共享状态，从而避免复杂的同步构造；使用原子操作，这意味着一个操作只占用一个量子的时间，一次就可以完成，并且只有当前操作完成后，其它线程方可执行其它操作，因此，无须实现其它线程等待当前操作完成，进而避免了使用锁，排除了死锁。 Tips10：为了实现线程同步，我们不得不使用不同的方式来协调线程，方式之一是将等待的线程设为阻塞，当线程处于阻塞状态时，会占用尽可能少的CPU时间，然而这意味着会引入至少一次的上下文切换。上下文切换，是指操作系统的线程调度器，该调度器会保存等待的线程状态，并切换到另一个线程，依次恢复等待的线程状态，而这需要消耗更多的资源。 Tips11：线程调度模式，当线程挂起很长时间时，需要操作系统内核来阻止线程使用CPU时间，这种模式被称为内核模式；当线程只需要等待一小段时间，而不需要将线程切换到阻塞状态，这种模式被称为用户模式；先尝试按照用户模式进行等待，如线程等待足够长时间，则切换到阻塞状态以节省CPU资源，这种模式被称为混合模式。 Tips12：Mutex是一种原始的同步方法，其只对一个线程授予对共享资源的独占访问，Mutex可以在不同的程序中同步线程。 Tips13：SemaphoreSlim是Semaphore的轻量级版本，用以限制同时访问同一个资源的线程数量，超过该数量的线程需要等待，直到之前的线程中某一个完成工作，并调用Release()方法发出信号，其使用了混合模式，而Semaphore则使用内核模式，可以在跨程序同步的场景下使用。 Tips14：AutoResetEvent类用以从一个线程向另一个线程发送通知，该类可以通知等待的线程有某个事件发生，其实例在默认情况下初始状态为unsignaled，调用WaitOne()方法时将会被阻塞，直到我们调用了Set方法；相反地，如果初始状态为signaled，调用WaitOne()方法时将会被立即处理，需要我们再调用一次Set方法，以便向其它线程发出信号。 Tips15：ManualResetEventSlim类是使用混合模式的线程信号量，相比使用内核模式的AutoResetEvent类更好(因为等待时间不能太长)，AutoResetEvent像一个旋转门，一次仅允许一个人通过，而ManualResetEventSlim是ManualResetEvent的混合版本，一直保持大门开启直到手动屌用Reset方法。 Tips16：EventWaitHandle类是AutoResetEvent和ManualResetEvent的基类，可以通过调用其WaitOne()方法来阻塞线程，直到Set()方法被调用，它有两种状态，即终止态和非终止态，这两种状态可以相互转换，调用Set()方法可将其实例设为终止态，调用Reset()方法可以将其实例设为非终止态。 Tips17：CountdownEvent类可以用以等到直到一定数量的操作完成，需要注意的是，如果其实例方法Signal()没有达到指定的次数，则其实例方法Wait()将一直等待。所以，请确保使用CountdownEvent时，所有线程完成后都要调用Signal()方法。 Tips18：ReaderWriterLockSlim用以创建一个线程安全的机制，在多线程中对一个集合进行读写操作，ReaderWriterLockSlim代表了一个管理资源访问的锁，允许多个线程同时读取，以及独占写。其中，读锁允许多线程读取数据，写锁在被释放前会阻塞其它线程的所有操作。 Tips19：SpinWait类是一个混合同步构造，被设计为使用用户模式等待一段时间，然后切换到内核模式以节省CPU时间。使用线程池 Tips20：volatile关键字指出一个字段可能会被同时执行的多个线程修改，声明为volatile的字段不会被编译器和处理器优化为只能被单线程访问。 Tips21：创建线程是昂贵的操作，所以为每个短暂的异步操作创建线程会产生显著的开销。线程池的用途是执行运行时间短的操作，使用线程池可以减少并行度耗费及节省操作系统资源。在ASP.NET应用程序中使用线程池时要相当小心，ASP.NET基础切实使用自己的线程池，如果在线程池中浪费所有的工作者线程，Web服务器将不能够服务新的请求，在ASP.NET中只推荐使用I/O密集型的异步操作，因为其使用了一个不同的方式，叫做I/O线程。 Tips22：APM，即异步编程模型，是指使用BeginXXX/EndXXX和IAsyncResult对象等方式，其通过调用BeginInvoke方法返回IAsyncResult对象，然后通过调用EndInvoke方法返回结果，我们可通过轮询IAsyncResult对象的IsCompleted或者调用IAsyncResult对象的AsyncWaitHandle属性的WaitOne()方法来等待直到操作完成。 Tips23：ThreadPool.RegisterWaitForSingleObject()方法允许我们将回调函数放入线程池中的队列中，当提供的等待事件处理器收到信号或发生超时时，该回调函数将被调用，这做鱼我们为线程池中的操作实现超时功能。具体思路是：ManualResetEvent + CancellationToken，当接收到ManualResetEvent对象的信号时处理超时，或者是使用CancellationToken来处理超时。 Tips24：CancellationToken是.NET4.0中被引入的实现异步操作的取消操作的事实标准，我们可以使用三种方式来实现取消过程，即轮询IsCancellationRequested属性、抛出OperationCanceledException异常、为CancellationToken注册一个回调函数。 Tips25：Timer对象用以在线程池中创建周期性调用的异步操作。 Tips26：BackgroundWorker组件，是典型的基于事件的异步模式，即EAP，当通过RunWorkerAsync启动一个异步操作时，DoWork事件所订阅的事件处理器，将会运行在线程池中，如果需要需要取消异步操作，则可以调用CancelAsync()方法。使用任务并行库 Tips27：TPL即任务并行库，在.NET 4.0中被引入，目的是解决APM和EAP中获取结果和传播异常的问题，TPL在.NET4.5中进行了调整，使其在使用上更简单，它可以理解为线程池之上的又一个抽象层，对程序员隐藏了与线程池交互的底层代码，并提供了更方便的细粒度的API。TPL的核心概念是任务，一个任务代表了一个异步操作，该操作可以通过多种方式运行，可以使用或者不使用独立线程运行。TPL相比之前的模式，一个关键优势是其具有用于组合任务的便利的API。 Tips28：Task.Run是Task.Factory.StartNew的一个快捷方式，后者有附加的选项，在无特殊需求的情况下，可以直接使用Task.Run，通过TaskScheduler，我们可以控制任务的运行方式。 Tips29：使用Task实例的Start方法启动任务并等待结果，该任务会被放置在线程池中并且主线程会等待，直到任务返回前一直处于阻塞状态；使用Task实例的RunSynchronously方法启动任务，该任务是运行在主线程中，这是一个非常好的优化，可以避免使用线程池来执行非常短暂的操作；我们可以通过轮询Task实例的状态信息来判断一个任务是否执行结束。 Tips30：通过Task实例的ContinueWith方法可以为任务设置一个后续操作，通过TaskContinuationOptions选项来指定后续任务以什么样的方式执行。 Tips31：通过Task实例的FromAsync可以实现APM到Task的转换 Tips32：通过TaskCompletionSource可以实现EAP到Task的转换 Tips33：TaskScheduler是一个非常重要的抽象，该组件实际上负责如何执行任务，默认的任务调度程序将任务放置在线程池的工作线程中。为了避免死锁，绝对不要通过任务调度程序在UI线程中使用同步操作，请使用ContinueWith或async/await方法。使用C# 6.0 Tips34：异步函数是C# 5.0引入的语言特性，它是基于TPL之上的更高级别抽象，真正简化了异步编程。要创建一个异步函数，首先需要使用async关键字标注一个方法，其次异步函数必须返回Task或Task类型，可以使用async void的方法，但是更推荐async Task的方法，使用async void的方法的唯一合理的地方就是在程序中使用顶层UI控制器事件处理器的时候，在使用async关键字标注的方法内部，可以使用await操作符，该操作符可与TPL任务一起工作，并获取该任务中异步操作的结果，在async方法外部不能使用await关键字，否则会有编译错误，异步函数代码中至少要拥有一个await关键字。 Tips35：在Windows GUI或ASP.NET等环境中不推荐使用Task.Wait和Task.Result，因为非常有可能会造成死锁。async可以和lambda表达式联用，在表达式体中应该至少含有一个await关键字标示，因为lambda表达式的类型无法通过自身推断，所以必须显式地向C#编译器指定类型。 Tips36：异步并不总是意味着并行执行 Tips37：单个异步操作可以使用try…catch来捕获异常，而对于一个以上的异步操作，使用try…catch仅仅可以从底层的AggregateException对象中获得第一个异常，为了获得所有的异常，可以使用AggregateException的Flatten()方法将层级异常放入一个列表，并从中提取出所有的底层异常。 Tips38：通过Task实例的ConfigureAwait()方法，可以设置使用await时同步上下文的行为，默认情况下，await操作符会尝试捕捉同步上下文，并在其中执行代码，即调度器会向UI线程投入成千上百个后续操作任务，这会使用它的消息循环来异步地执行这些任务，当我们不需要在UI线程中运行这些代码时，向ConfigureAwait方法传入false将会是一个更高效的方案。 Tips39：async void方法会导致异常处理方法，会放置到当前的同步上下文中，因此线程池中未被处理的异常会终结整个进程，使用AppDomain.UnhandledException事件可以拦截未处理的异常，但不能从拦截的地方恢复进程，async void的lambda表达式，同Action类型是兼容的，强烈建议仅仅在UI事件处理器中使用async void方法，在其他情况下，请使用返回Task或者Task的方法。使用并行集合 Tips40：ConcurrentQueue使用了原子的比较和交换(CAS)，以及SpinWait来保证线程安全，它实现了一个先进先出(FIFO)的集合，这意味着元素出队列的顺序与加速队列的顺序是一致的，可以调用Enqueue方法向对接中加入元素，调用TryDequeue方法试图取出队列中第一个元素，调用TryPeek方法试图得到第一个元素但并不从队列中删除该元素。 Tips41：ConcurrentStack的实现同样没有使用锁，仅采用了CAS操作，它是一个后进先出(LIFO)的集合，这意味着最后添加的元素会先返回，可以调用Push和PushRange方法添加元素，使用TryPop和TryPopRange方法获取元素，使用TryPeek方法检查元素。 Tips42：ConcurrentBag是一个支持重复元素的无序集合，它针对以下情况进行了优化，即多个线程以这样的方式工作：每个线程产生和消费其自身的任务，极少发生线程间的交互(因为要交互就要使用锁)。可以调用Add方法添加元素，调用TryPeek方法检查元素，调用TryTake方法获取元素。 Tips43：ConcurrentDictionary是一个线程安全的字典集合的实现，对于读操作无需使用锁，对于写操作则需要使用锁，该并发字典使用多个锁，在字典桶之上实现了一个细粒度的锁模型(使用锁的常规字典称为粗粒度锁)，参数concurrentLevel可以在构造函数中定义锁的数量。这意味着预估的线程数量将并发地更新该字典。由于并发字典使用锁，如无必要请避免使用以下操作：Count、IsEmpty、Keys、Values、CopyTo及ToArray，因为需要获取该字典中的所有锁。 Tips44：BlockingCollection是一个针对IProducerConsumerCollection泛型接口实现的高级封装，它有很多先进的功能来实现管道场景，即当你有一些步骤需要使用之前步骤运行的结果时。BlockingCollection类支持分块、调整内部集合容量、取消集合操作、从多个块集合中获取元素等。 Tips45：对BlockingCollection进行迭代时，需要注意的是，使用GetConsumingEnumerable()进行迭代，因为虽然BlockingCollection实现了IEnumerable接口，但是它默认的行为是表示集合的“快照”，这不是我们期望的行为。使用PLINQ Tips46：将程序分割成一组任务并使用不同的线程来运行不同的任务，这种方式被称为任务并行将数据分割成较小的数据块，对这些数据进行并行计算，然后聚合这些计算结果，这种编程模型称为数据并行 Tips47：结构并行确实更易维护，应该尽可能地使用，但它并不是万能的。通常有很多情况我们是不能简单地使用结构并行，那么以非结构化的方式使用TPL任务并行也是完全可以的。Parallel类中的Invoke方法是最简单的实现多任务并行的方法，Invoke方法会阻塞其它线程直到所有线程都完成。 Tips48：Parallel类中的For和ForEach方法可以定义并行循环，通过传入一个委托来定义每个循环项的行为，并得到一个结果来说明循环是否成功完成，ParallelOptions类可以为并行循环定义最大并行数，使用CollectionToken取消任务，使用TaskScheduler类调度任务。 Tips49：ParallelLoopState可以用于从循环中跳出或者检查循环状态，它有两种方式：Break和Stop，Stop是指循环停止处理任何工作，而Break是指停止其之后的迭代，继续保持其之前的迭代工作。 Tips50：同Task类似，当使用AsParallel()方法并行查询时，我们将得到AggregateException，它将包含运行PLINQ期间发生的所有异常，我们可以使用Flatten()方法和Handle()方法来处理这些异常。 Tips51：ParallelEnumerable类含有PLINQ的全部逻辑，并且作为IEnumerable集合功能的一组扩展方法，默认情况下结果会被合并单个线程中，我们可以通过ForAll方法来指定处理逻辑，此时它们使用的是同一个线程，将跳过合并结果的过程，除了AsParallel()方法，我们同样可以使用AsSequential()方法，来使得PLINQ查询以顺序方式执行(相对于并行) Tips52：PLINQ中提供了丰富用以PLINQ查询的选项，例如WithCancellation()方法用以取消查询，这将导致引发OperationCanceledException异常，并取消剩余的工作；例如WithDegreeOfParallelism()方法用以指定执行查询时实际并行分割数，可以决定并行执行会占用多少资源及其性能如何；例如WithExecutionMode()可以重载查询执行的模式，即我们可以决定选择以顺序执行还是并行执行的方式去执行查询；例如WithMergeOptions()方法可以用以调整对查询结果的处理，默认PLINQ会将结果合并到单个线程中，因此在查询结果返回前，会缓存一定数量的结果，当发现查询花费大量时间时，更合理的方式是关闭结果缓存从而尽可能快地得到结果；例如AsOrdered()方法，用以告诉PLINQ我们希望按照集合中的顺序进行处理(并行条件下，集合中的项有可能不是按顺序被处理的)使用异步I/O Tips53：异步I/O，对服务器而言，可伸缩性是最高优先级，这意味着单个用户消耗的资源越少越好，如果为每个用户创建多个线程，则可伸缩性并不好，在I/O密集型的场景中需要使用异步，因为不需要CPU工作，其瓶颈在磁盘上，这种执行I/O任务的方式成为I/O线程。在异步文件读写中，FileOptions.Asynchronous是一个非常重要的选项，无论有无此参数都可以，以异步的方式使用该文件，区别是前者仅仅是在线程池中异步委托调用，而后者可以对FileStream垒使用异步I/O。 Tips54：对HttpListener类，我们可以通过GetContextasync()方法来异步地获取上下文。 Tips55：对数据库而言，我们可以通过OpenAsync()、ExecuteNonQueryAsync()等方法异步地执行SQL语句。 好了，以上就是这篇读书笔记的主要内容啦，听说掌握了这55条Tips的人，都敢在简历上写”精通多线程编程“，哈哈，晚安啦，各位！","tags":[{"name":"多线程","slug":"多线程","permalink":"http://qinyuanpei.github.io/tags/多线程/"},{"name":"读书","slug":"读书","permalink":"http://qinyuanpei.github.io/tags/读书/"},{"name":"笔记","slug":"笔记","permalink":"http://qinyuanpei.github.io/tags/笔记/"}]},{"title":"2017，在驻足间回首","date":"2017-12-31T21:30:45.000Z","path":"posts/2676125676/","text":"&emsp;&emsp;当朋友圈开始集体缅怀18岁的时候，我们说，从此以后是00后的天下，因为所以的90后都成年了。或许我们都是喜欢怀旧的人，所以我们选择以这样一种方式，在狂欢中失去的同时，在失去中缅怀着，仿佛这种死磕到底的做法，会让这一切来得更晚一些。一群人抱着手机等待着新年的到来，和曾经无数个无眠的夜晚一样，我们并不知道明天会有什么，就像钟表的指针哒哒地作响，生命的齿轮永不停歇地转动。我们习惯性地期盼明天会更好，因为我们都知道“往者不可谏，来者犹可追”。那么，在新年钟声敲响以前，让记忆彻底来一场独自的狂欢吧！ 多情应笑我&emsp;&emsp;我不知道该从哪里开始回顾我的2017年，如果一定要找一个起点开始说，我想应该是裴武刚离开西安。那时青龙寺樱花正在盛开，在他离开西安以前，我曾带他一起去那里游玩。他曾遗憾没有好好在西安游玩一番，在分别前我们一起去吃羊肉泡馍，真正体会到什么叫做相顾无言，直到十一回家去兰州转车，我们再次联系到彼此，所以当你想做一件事情的时候，最好就是趁着现在去做，一个过期的承诺是没有意义的，人生本就是大海里航行的一叶扁舟，你可以祈祷它不遭遇狂风暴雨，可事实上你并不能替任何人做这样一个决定，越想做好一件事情就越是要减少拖延。“人生不相见，动如参与商”，人生本不完美，缺憾能少一分便是一分。 &emsp;&emsp;我记得我们吃完泡馍，两个人都抢着付钱，老板娘笑着说：“大家都是好朋友，谁付都是一样的，以后还有机会”。两个人一阵默然。从那时算起，到今天差不多8个月，我们再没有见过面，偶尔会在微信上聊聊天。人生的无奈就在于，你埋头忙碌的时候，对离别的处境毫不在意，等到你过头来再看时，不禁怅然若失，感情就这样一天天变淡，可是不是你努力融入对方的生活，就能够留住彼此在心中的位置呢？有人告诉我，她不属于你，她不适合你，可是不是换一个性格完全相反的人，就一定会是合适的人选呢？我们的大脑，同绝对理性的计算机最大的不同是，我们评价和认识一个人的标准，永远没有办法达到统一，就像你喜欢吃葱，而我喜欢吃香菜，你不能因此指责别人三观不正，这或许仅仅是你们的喜好不同而已，这个理性而感性的世界，有时真的让人抓狂。 &emsp;&emsp;我一直没有告诉任何人，我和小古分开快两年的时间了。有人说，时间会慢慢磨去一切痕迹，而对于她，始终就像我心上的一颗痣，时间会把它变成一颗琥珀，时间越久越显得珍贵，我知道有人会嘲笑这固执的感情，就像我会在分开一年后，坐一个晚上的火车到洛阳，仅仅是为了见她一面而已，我永远记得她穿裙子的样子，我永远记得那条挂满灯笼的路，我永远都想再抱她一次……我听到莎莉花园的时候，会突然想起那个下午，当我们听到一家店里传来的音乐声，我们互相对彼此说我知道……我们在彼此不成熟的年龄深爱上彼此，等一天幡然醒悟的时候发现追悔莫及，离开她以后我发现我会单身很久，因为除了她我好像都不会同别人谈恋爱，这种迹象在我身上更加明显，因为无论你怎么尝试去改变，你永远无法逃开被拒绝的命运。我们喜欢喜欢一个人的时候，通常靠眼缘这种特别主观的东西，可太多时候我们无法完全了解一个人。 &emsp;&emsp;从前我们喜欢一个人的时候，喜欢爱得轰轰烈烈，相信爱情可以战胜一切；等到长大以后，我们习惯爱得小心谨慎，试探和套路混杂不清真真假假。有人告诉你，要相信爱情是存在的，你只是还没有等到那个合适的人出现；有的人告诉你，不要在一棵树上吊死。成年人的感情和时间都非常有限，不要把精力浪费在一个不喜欢你的人身上。可兜兜转转就到了25岁，一个谈爱已晚、谈死尚早的尴尬年纪。有时候我会想，大学毕业了就可以结婚成家的人，或许是最幸福的人，因为你再找不到那样单纯的爱情。我见过情侣间吵架无数分分合合，我见过向现实妥协随便找个人结婚……我想找一个可以托付终生的人，因为父母总有一天会先我们而去，如果需要有人陪伴在我生命的一刻，我希望那个人会是你，可我决不会如此自私，因为我不想你在这个世界里孤单。我曾被人温柔地对待过，我想温柔地对待你，不是因为亏欠或者内疚而弥补什么，而是我知道“爱人者人恒爱之”。 &emsp;&emsp;我曾经被一个女孩子拒绝过，我天真的以为，出场顺序会决定两个人的命运，直到她平静地说出，“就算我不和他在一起，我绝不会和你在一起“，原来一个在小古心里待她特别好的人，在别人眼中居然是如此的不堪，我记得我在她面前结结巴巴说英语的窘迫，我记得她告诉我她要订婚时我写满难过的脸……我好像被施诅咒一样，在和小古分开后，我喜欢过两个有男朋友的女生，有时候我都想告诉自己，我不再是那个十八九岁的少年，长大以后的爱情夹杂着现实，变得更加让人迷惑，可我再找不回那种“赌书泼茶”的感觉，或许求而不得是人生常态，王尔德说“人生有两种悲剧，一种是想得到的得不到，一种是想得到的得到了”，我对小古说，给我留一个梦好吗？她说好的呀。对这个世界而言，我们两个人的故事，或许一点都不美丽。可真正让我怀念的，恰好是这些微不足道的故事，有时候我会分不清，喜欢的到底是真实的她，还是想象中的她，或许我真正喜欢的，是曾经那个年轻而勇敢的少年，佛家有”贪嗔痴慢疑“，所谓五毒心者，都说人要学会放下执念，可如果从来没有得到过，又要放下什么呢？人因为“求而不得”而痛苦，从来没有拥有过的人，是无所谓拿起和放下的。 做人没意思&emsp;&emsp;大概从8月份开始学习做饭，而学习做饭的动机早就模糊不清，我只知道，从那一刻开始，我的生活开始慢慢发生变化，从一个不知道做饭需要买什么调味品的人，变成一个喜欢逛超市、喜欢看商品价格的人，变成一个喜欢周末去超市购物、喜欢钻研美食的人，变成一个懂得如何照顾自己、爱惜自己的人。西安的面食对我而言是粗犷的，如同这片关中大地上粗犷的民风，所以最初就买了本菜谱学习做饭，我学做饭的动机，其实是非常简单的，最低要求是以后讨不着老婆不会饿死自己，进阶要求是两口子过日子必须要有一个具备这项生活技能，现在我们看到有把吃作为爱好的吃货，可这样的人是不能称之为吃货的，因为吃货如果就是花花钱动动嘴这样简单，就对不起古往今来的吃货们，譬如苏东坡之于红烧肉，季鹰之于鲈鱼，袁枚之于《随园食单》，能做会吃这是真吃货。有人说，征服一个吃货的心，首先要征服她的胃。可也许这仅仅是一个理由，当你征服她的胃，你会发现还有更多的东西等你去征服。现在，先让我征服这本菜谱，我刚刚学会其中的10来道家常小炒。 &emsp;&emsp;除了做饭这件事情以外，我一直在坚持的事情是读书，去年国庆的时候买了Kindle，而年初则办理了省图的借书卡。一旦这两者结合起来以后，读书就变成了一件趣事。因为Kindle不擅长阅读技术类书籍，所以技术类书籍主要来自纸质书，而人文类书籍主要来自电子书。最早是Wesley推荐读陈忠实的《白鹿原》，这本书让我了解了许多陕西的风土人情。在同名电视剧中，张嘉怡饰演的白嘉轩，生平念念不忘的是妻子亲手做的油泼面。陕西的面食的确让人印象深刻，原本出生在北方的我，在这里仿佛第一次来到北方。此外，由电影《嫌疑人X的献身》追溯到原著，逐渐接触了《白夜行》和《解忧杂货店》这样典型的东野圭吾作品，程浩的《站在两个世界边缘》，毛姆的《月亮与六便士》，堀辰雄的《起风了》，《小王子》，沈复的《浮生六记》以及《追风筝的人》，而纸质书基本都是Web前后端(JavaScript/ASP.NET/SPA)相关的书籍，Python相关的书籍和数学相关的书籍，这些书籍不能在这里展开讨论，感兴趣的朋友可以在博客里留言。 &emsp;&emsp;我是一个喜欢看电影的人，就是单纯地喜欢听人讲故事，这和约会意义上的看电影不同，我就是单纯地去看个电影而已。不过作为一个日常单身狗，总是要学会面对这个世界里满满的恶意。2017年看的第一部电影是韩寒的《乘风破浪》，这是一个笑点中夹杂着泪点的故事，剧情上借鉴了陈可辛导演的《难兄难弟》。接下来，2017年看过的超级英雄电影有《神奇女侠》、《蜘蛛侠 : 归来》、《雷神 : 诸神的黄昏》、《猩球崛起》。2017年看过的动画电影有《大护法》和《寻梦环游记》，其中前者是电影风格和政治隐寓吸引了我，而后者是讲述了一个亡灵节背景下的暖心故事，告诉我们如何去面对死亡、如何平衡家庭与梦想等。2017年看过一部讲述野外探险的电影《七十七天》，由赵汉唐和江一燕主要，这个电影是部旅游风景片，江一燕的存在感略弱，男主最终在雷雨夜里丧生，告诫人们要懂得量力而行，我们觉得去趟西藏就能净化心灵，可比净化心灵更重要的是好好活着。2017年最后一部电影是陈凯歌的《妖猫传》，改编自梦枕貘的《沙门空海》，以唐朝时期僧人空海和诗人白居易为主角，讲述唐玄宗和杨玉环的爱恨纠葛，这部电影视觉美是无与伦比的，虽然后期剧情呈现方式存在瑕疵，但可以让我们重新感受大唐盛景，以一种新的方式解读《长恨歌》，我觉得这样就很好啦！ emsp;&emsp;2017年写作方面相对去年明显退步，因为有两个月一直没有时间写东西，尤其是拖延症发作的时候，一篇博客大概两三个周甚至一个月方能写完，这大概是2017年最让人遗憾的事情。2017年共撰写博客16篇，访客量增加约30万，受到CSDN运营梦姐的离开以及CSDN战略调整的影响，2017年博客流量的主要来源是旧文章。2017年技术博客的写作，基本延续2016年的策略，不再写面向新手的教程类内容，而是侧重对技术的整合和改进，尽可能地去写一种思路或者想法，与此同时，希望在技术博客以外扩展更多的，譬如写对生活的感悟、对电影的思考等等，计划中打算开通知乎专栏(已开通)、开通个人微信公众号(正在准备)。总而言之，希望拓宽博客的流量渠道，提升个人品牌的影响力，你可以不用长得特别帅，但要有一种不怒自威的气场，因为要想成为架构师，这是件任重而道远的事情！ New TodoList(“2018”)&emsp;&emsp;写这样一个TodoList，我总觉得像在立一个个flag，因为2017年计划的MongoDB就没有达到目标，所以2018的TodoList我希望可以更接地气一点，具体来讲，我从技术、生活两个方面来制定目标： 首先，希望2018年的我在技术方面： 学会一个前端框架(Vue/Angular/React) 继续完善HttpServer(支持RESTful) Web后端认证授权及中间件(OWIN/OAuth) 继续学习Python数据分析(Pandas) 写一个微信小程序(词典/小工具) 建立知乎专栏/个人微信公众号 其次，希望2018年的我在生活方面： 认真谈恋爱，找个女朋友 提升整体审美及品味(穿衣/吃饭/健身) 去一趟莫高窟或者苏州园林(做想做的事) 争取涨薪，继续存钱 租一个可以更好做饭的房子 和任何人都聊得来(沟通技巧/情商) 2018，愿期望不负，愿你被温柔对待，岁月静好，现世安稳，心安处即吾家，晚安！","tags":[{"name":"总结","slug":"总结","permalink":"http://qinyuanpei.github.io/tags/总结/"},{"name":"回首","slug":"回首","permalink":"http://qinyuanpei.github.io/tags/回首/"},{"name":"展望","slug":"展望","permalink":"http://qinyuanpei.github.io/tags/展望/"}]},{"title":"基于新浪微博的男女性择偶观数据分析(上)","date":"2017-12-23T20:28:40.000Z","path":"posts/1386017461/","text":"&emsp;&emsp;或许是因为我喜欢的姑娘从来都不喜欢我，而感情上的挫折一度让我陷入无尽的自卑。朋友在朋友圈里发布一条关于皮影戏的动态，我开玩笑说这个皮影戏结局应该是个悲剧，因为我注意到在剧中，无论一个人如何卖力地表演甚至双腿跪倒在地，有的人从故事开场到结束一直对此无动于衷。朋友回复我说，这不就是你现在的状态吗？我沉默半天终于熄灭手机屏幕。我听到过各种各样让我放弃她的话，即使这种念头在我脑海里萌生已久，是幻想让我硬生生地拖了这么久。当你努力想要融入对方的生活，而等待你的是一道冰冷的墙。这种感觉像什么呢？大概就是一个又一个“好友”安安静静地躺在联系人的置顶名单里，不敢发消息让对方知道，更不愿残忍地把对方删除。我安慰自己说，对我而言，我失去的是一个不喜欢你的人；而对对方而言，失去的是一个喜欢她的人。你当然可以说我没有那么喜欢她，如果一定要喜欢到卑微如尘土的地步，我宁愿一个人单身到天荒地老。 &emsp;&emsp;当我意识到人与人间，即使亲近如父母尚且无法完全理解彼此的时候，我忽然发现一个有趣的现象，我们喜欢一个人的时候，首先注意到的会是外表，我们将其称之为眼缘，所以人与人间的感情纽带最初会是吸引，而后是了解彼此的优缺点，最终是相互理解和扶持。可我们知道，外表是可以伪装出来的，所以我们习惯通过外表和言语来评价一个人，这就像是数学归纳法，我们总认为推倒第一块多诺米骨牌，就意味着所有多诺米骨牌都会倒下。可现实世界矛盾的地方就在于，我们认为理所当然正确的事情，或许正是我们无法证明其正确性的，这在数学上称为哥德尔不完备定理。所以，一件残酷的事情是，当你无法吸引一个人的时候，通往内心世界的路就被堵死了。朋友圈里精彩纷呈的社交互动，并不代表有人愿意真正了解你的生活，何况是你吸引不到的人呢？我很想知道，我们在选择伴侣的时候到底看中什么，所以我一直在关注@西安月老牵线上发布的征婚交友类微博，本文的故事从这里正式展开。 身高175的悲伤&emsp;&emsp;或许你以为我会无聊到试图从微博上找到女朋友，可事实上作为一个程序员的我，即使整天投入精力在编程上，依然无法避免对象空引用的异常出现。如果说找到女朋友是个小概率事件，那么在我看来，找到一个真正懂我、喜欢我的女朋友，基本上是不可能事件。你不要觉得我对没有调整好心态、对生活过分悲观，如果你了解贝叶斯公式就会真正地理解我说的话。这个微博开始引起我的注意，是我发现身高在155到165左右的女生，对男生的要求基本上无疑例外地是175+到180+，我想知道到底有多少女生是有这样的想法，这是我想要抓取新浪微博的数据进行分析的初衷。更重要的是，身高不到175的我在面对这种要求的时候是悲伤的，因为我想起了《巴黎圣母院》中的卡西莫多，一个外表丑陋而拥有高尚人格的“丑八怪”。现代人整天都特别忙碌，以至于没有人会有耐心，园艺在忍受着你丑陋的外表的同时，同你讲一只小兔子亲了它喜欢的长颈鹿一下这种故事。 &emsp;&emsp;我听到这样一句话，“好看的皮囊千篇一律，有趣的灵魂万里挑一”，可谁会觉得像卡西莫夫这样的人，会拥有或者配拥有高尚的人格呢？我们这副皮囊不管好看与否，它们都是父母给予我们的最好的礼物。难道一个所谓情商高的人，会在收到别人的时候因为礼物不好看而生气吗？ 我想起《画心》里懊悔受狐妖小唯皮相蛊惑而自毁双目的霍心，美丑都是父母赐予我们的，不该被我们拿来一番大肆炫耀，可我还是想知道，我们评价一个人的标准到底是什么？因为我渐渐明白，有些人不喜欢我们，并不是我们不好，而仅仅是某一点和对方不匹配。喜欢一个人的时候，像拔下身上的一根根刺，因为你越是得不到回应，就越像变成对方期待的样子，这个过程会让你觉得自己一无是处。直到今天看到一句话，一句足以热泪盈眶的话，如果不曾喜欢你，我本来非常可爱的。有时候，人做一件事情，或许就是在和自己过不去，比如说这件事情。 花点时间爬爬微博&emsp;&emsp;好了，现在我们来考虑从新浪微博上抓取@西安月老牵线上发布的微博，因为这是我们进行数据分析的前提。事实上，在写这篇文章前我曾花了大量时间来调试爬虫，然后用了一天的时间对数据进行清洗，最终利用晚上下班的时间生成词云。由此我们可以理出整体的思路： 流程图 &emsp;&emsp;通过流程图我们可以注意到，在这里我选择了Python来实现整个功能。转眼间我已经25岁了，这是种什么样的概念呢？两年前我23岁的时候，听别人讨论结婚这个问题，我觉得它离我还很遥远。如今看着周围人都结婚了，我竟有种“高处不胜寒”的感觉。所以呢，人生苦短，当你不能阻止时间一天天消逝的时候，你只能趁着现在去做你想做的事情，为了节省时间去做技术以外的尝试，我选择拥有全世界最丰富的库的Python。 &emsp;&emsp;这段时间学习数据分析，我渐渐意识到我们所熟悉的这个世界，如果以一种理性的角度，完全通过数据来解构的话，我们在这个数字时代里留下的每一条讯息，都冷冰冰地暴露着我们的喜怒哀乐，每一张照片里细微的表情变化，每一段文字里隐匿着的真实意图，都能被人脸识别和自然语言处理等等，这类人工智能为代表的技术所解读，我们努力想在朋友圈里隐藏些什么，当朋友圈的访问范围从半年逐渐缩小到三天，我们究竟能隐藏下什么呢？ 微博爬虫分析&emsp;&emsp;首先，我们需要从微博上抓取数据下来，我没有去做抓包分析这样的重复性工作，因为我注意到这个问题，在网络上有很多朋友在讨论，我主要参考了以下内容： Python 爬虫如何机器登录新浪微博并抓取内容？ https://github.com/xchaoinfo/fuck-login 用Python写一个简单的微博爬虫 通过以上内容，我了解到在抓取新浪微博数据的问题上，我们基本会有以下思路： 保存cookie信息，利用requests库发起请求并带上cookie 利用requests库模拟登录新浪微博并在请求过程中保持cookie 利用selenium库模拟登录新浪微博然后取得页面内容 利用PhantomJS库模拟登录新浪微博然后取得页面内容 可以看出差异主要集中在cookie的获取以及是否支持headless模式，并且我们得到一个共识，抓取新浪微博移动版要比PC版要容易，因为移动版优先为小尺寸屏幕设备提供服务，因而页面结构相对整洁便于我们提取数据。起初博主认为第一种方式太简单粗暴，坚持要采用第二种方式去实现，最终证明还是太年轻了啊，新浪微博的登录给人的感觉就是蛋疼，这里就简单介绍下思路哈。 &emsp;&emsp;首先我们会向服务器发出一次GET请求，它返回的结果是一段JavaScript代码，然后我们需要用正则匹配出其中的JSON字符，这样我们就获得了第二次请求需要用到的参数；接下来，第二次请求是一个POST请求，我们需要将用户名采用Base64加密，密码则采用RSA加密，需要用到第一次请求返回的参数。实际上，新浪微博官方给我们提供API获取微博数据，可这个API可以获取的微博数据非常有限，更让人难以接受的是新浪微博的应用授权方式，如果我们采用调用API的方式，在这里会有第三次POST请求，有朋友分析了完整的模拟登录过程，可我对此表示毫无兴趣啊。最早我采用了模拟这种方式，抓取第一页的时候还是登录的状态，可等到抓取第二页的时候变成了注销的状态，整个过程使用的是同一个session对象，所以我最后果断放弃了这种方式。 &emsp;&emsp;好了，现在我们只需要在Chrome里F12找到Network选项卡，抓一次包取得cookie，然后在请求的时候带上cookie即可。我们不用过分担心cookie过期的问题，在博主测试的时候，一个cookie可以持续工作3至5天，而且在后面我们会讲到，这个爬虫抓取的数据量其实并不大，在一两个小时内就可以完成抓取，没有必要将爬虫考虑得太严谨。在下图中我们标记出了博主计算机上存储的cookie，我们通过cookie就可以免登录抓取信息啦。 提取Cookie &emsp;&emsp;解决登录的问题以后，回到这个问题本身，我们需要抓取@西安月老牵线发布的所有微博，移动版对微博做了分页处理，所以我们只需要知道总共有多少页，然后循环去提取每一页里的信息即可，因为我们注意到每一页的地址都符合https://weibo.cn/u/3232168977?page=2这样的形式。首先页数，我们可以通过name为mp的隐藏控件来获得，其value属性表示总页数。其次，每条微博存放在class为c，id以M_开头的div标签里，在这里我们只需要文本信息，顺藤摸瓜我们发现信息被存放在class为ctt的span标签里，这里博主遇到一个奇怪的问题，BeautifulSoup默认的解析器html.parser，不知道因为原因无法解析出标签，而lxml当时因为pip的问题无法安装，所以不能使用XPath来解析DOM解构，在这里我认为XPath更适合这个场景，如果有时间可以考虑对代码进行重构。 &emsp;&emsp;在抓取微博的过程中，博主发现官方的反爬虫策略非常给力，连续工作超过5分钟IP就会被封锁，进而无法访问微博的服务器， 大概经过20至30分钟后会自动解封。或许主流的方案是花钱买动态代理，可我这个就是临时起意的一个想法，所以我采取了最简单粗暴的方法，让线程睡一会儿，在这样条件下，我花了大概1个半小时到2个小时左右的时间，从微博上抓取了5600条数据，并将其存储在了SQLite数据库中。什么？你问我为什么不考虑多线程，因为我这个人懒啊，这个问题最难的地方在数据分析，数据抓取方面我不太关注效率，因为我有足够的时间去等这些数据，所以关于性能方面的问题，有时间我们再做进一步讨论吧！ 数据处理过程&emsp;&emsp;数据处理这块，我本来打算尝试下MongoDB这个数据库的，而实际上这是我今年计划要去学习的内容之一，后来因为种种原因一直搁置到现在，可当我注意到Windows下安装MongoDB的繁琐后，我果断放弃了这种念头回归简单的SQLite，我基本上是交叉使用Windows和Linux，而我知道Linux下安装MongoDB是非常简单的。我反复强调我喜欢小而美的东西，就是因为我想保留对方案的选择权。在这里我们的数据处理，主要是数据清洗和中文分词。首先，我们来一起看看数据库表的设计： 数据表结构 &emsp;&emsp;我这里一切从简，所以将这5600多条数据都存储在一张表里，表中有四个字段ID、Post、Wish和Tags。显然，ID是自增的主键，为每条微博提供一个唯一的标识；Post存储我们从微博上抓取的原始信息，这里不含HTML标签，可是会含有微博表情字符啊摔；Wish存储每条微博中对伴侣的要求具体有哪些，这里我们主要通过关键字来截取可谓简单粗暴，具体原因稍后会讲到:)；Tags存储Wish字段经过分词以后的结果，这里我们使用结巴分词和SnowNLP，该字段中存储的是序列化后的JSON字符串，下面我们具体来讲这些字段的处理。 &emsp;&emsp;首先，分析@西安月老牵线发布的微博我们可以发现，所有征婚相关的微博都是以#征婚交友#或者#月老爱牵线#这样的话题开始，并且每条微博都是先介绍个人情况，然后再描述对理想伴侣的期望，所以我们只需要找出每条微博里对理想伴侣的期望相关的描述，然后再根据这条微博是由男嘉宾还是女嘉宾发布的，即可汇总出男、女性对各自伴侣的期望到底是什么，我们将这部分信息更新在Wish字段里，我们一起来看具体的代码： 12345678910111213141516171819202122232425262728# Filter Datasql = \"SELECT ID, Post FROM table_weibo WHERE POST LIKE '%%%%%s%%%%' OR POST LIKE '%%%%%s%%%%'\"sql = sql % (u'#征婚交友#',U'#月老爱牵线#')self.cursor.execute(sql)rows = self.cursor.fetchall()# Adjust Datapatterns = ['想找','希望找','要求','希望另一半','择偶标准','希望对方','希望','找一位','找一个','一半','找','想','喜欢','择偶条件','寻','期待','女孩','男孩','女生','男生','女士','男士','理想型']sql = \"UPDATE table_weibo SET Wish = ? WHERE ID = ?\"for row in rows: id = row[0] post = row[1] match = -1 for pattern in patterns: if(pattern in post): match = post.find(pattern) + len(pattern) break if(match != -1): wish = str(post[match:]) wish = wish.replace('#西安月老牵线#','') wish = wish.replace('[心]@月老蜀黍' ,'') wish = wish.replace('#月老爱牵线#' ,'') self.cursor.execute(sql,(wish,id)) else: self.cursor.execute(sql,('',id))self.connect.commit() &emsp;&emsp;可以注意到，我们首先按照话题对微博进行了筛选，然后通过关键字列表patterns来截取我们所需要的Wish字段，实际上这里是需要反复去调整patterns的，直到所有满足我们期望的数据都被提取出来，所以这是一个渐进式的数据处理过程。或许我们能想到通过NLP相关的技术来分析这段文本，我尝试通过SnowNLP去分析这样一段长度为100到500的文本，因为SnowNLP具备分析一段话的摘要及关键字的能力。可我发现这样实践下来效果并不太好，这是因为SnowNLP本身是以电商网站的评论数据为基础的，所以遇到我们微博这样相对灵活的文本信息时，它提取出的关键字并不能完全地符合我们的期望。固然，我们可以通过训练SnowNLP来达到我们的目的，可训练需要准备大量的文本信息作为支撑。作为一个懒惰的人，我最终选择了通过关键字来提取关键信息，准确度基本可以保证90%以上，因为暴力截取难免会拆分出不符合期望的信息。 &emsp;&emsp;接下来，我们有了针对男、女择偶要求期望的Wish字段，可这些信息对我们而言，依然显得繁重而冗余，所以接下来我们考虑对Wish字段进行分词，最初的设想是通过词性和语法来分析，可当我分完词以后我就不得不佩服中文的博大精深，这里我选择了两个中文处理相关的库，即结巴分词和SnowNLP，它们都是开源项目并且有大量的文档作为参考，这里想说的是，SnowNLP中支持中文文本的情感分析，这是我最初想要使用这个库的一个重要原因，因为我想从这些微博中找出评价一个人的形容词或者名词，而这些词的情感分析，可以作为我们是否将其作为一个评价指标的重要依据。 &emsp;&emsp;可我们有句话叫做“认真你就输了”，尤其在女性的思维模式中，充满太多太多不能直接去理解的信息。这种我不用举例子啦，现在铺天盖地的直男癌/女权癌席卷而来，其实有太多问题无关对错，你输就输在没有照顾好对方的情绪，我们现在常常把情商挂在嘴上，可情商概念中的自我意识、控制情绪、自我激励、认知他人情绪和处理相互关系，有60%说的是自我管理，而其余的40%，恰恰就是我们日常理解中关于人际关系方面的，所以我们说人工智能不能完全代替人类，因为只有绝对理性的世界是恐怖的，可只有情绪化的感情而不讲道理的世界则是空虚的。我们可以去追逐人类内心中的灵性，即真、善、美，这是任何冰冷的计算机所不具备的东西。可我们能不能真诚一点呢，明明知道这一切都是套路可你还满心期待，我们并非不懂得什么是爱，爱不是我用一个又一个套路去套路你，而是我明知这是套路还愿意陪你表演下去，我没有在讽刺浙江卫视某节目，愿温柔的你被这个世界温柔地对待。 &emsp;&emsp;关于结巴分词和SnowNLP地对比评测，大家可以参考：Python︱六款中文分词模块尝试，这里博主发现SnowNLP适合做大颗粒分词拆分，而结巴分词适合做小颗粒分词拆分。其实，从分词效果上来讲，结巴分词是要比SnowNLP效果更好一些的，可我这样说不是会显得情商比较高吗？这样你们会喜欢吗？最终我们采取的方案是两者混用，故而我们有了这样的代码：123456789def generateTags(self,text): snow = SnowNLP(text) sentences = snow.tags tags = [] for s in sentences: words = pseg.cut(s[0]) for w in words: tags.append(&#123;'word':w.word,'flag':w.flag&#125;) return json.dumps(tags) &emsp;&emsp;可以注意到，这里我们使用结巴分词获得了每个词的词性，不过到我写这篇文章的时候，对于词性的处理我依然没有什么好的想法，这里仅将其作为结果以JSON的形式存储到数据库中，现在我们基本上完成了所有数据处理的流程，在这个过程中会有些特殊的中文字符，我们采取暴力替换的方式进行去除即可，对此不在这里展开说啦。下图展示了数据库中部分数据： 处理后的数据 处理结果呈现&emsp;&emsp;说起这篇文章，可以说这是我第一次接触数据分析，我们这个时代积累了大量的数据，所以我们有基于大数据的推荐和预测等等相关场景，知乎和微博的首页Feed流经过无数次算法调整，可人们依然在抱怨算法向人们推荐了无关的内容，这是否说明，我们所期待的智能，仅仅是让我们觉得智能而已，这一系列基于统计的数据分析理论，是否一定是符合某种冥冥之中的规则，我想起《模仿游戏》中和卷福扮演的图灵形成鲜明对比的，正是以休.压力山大为代表的统计方法派，电影中他们试图通过分析字母出现的频率来破解恩尼格玛。对于数据分析而言，如果说可视化是面向人类的分析手段，那么数据挖掘就是面向机器的分析手段。作为一个刚刚入门的萌新，我描述的是我对数据分析的一种感觉。回到本文主题，这里我选择以词云作为最终处理结果的呈现载体。 &emsp;&emsp;词云，即WordCloud，是一种展现关键字出现频率的表达方式，如果你对博客写作比较熟悉的话，就会知道诸如WordPress、Ghost、Hexo等都提供了标签云功能，我们每篇文章中都会给文章添加若干标签，而标签基本可以让读者了解这个博客都有哪些内容，在标签云中出现频率越高的标签其字体通常会越大，这样我们可以非常直观地了解到，每个因素在整体上占到的比重。本文之所以采用这种方案，正是希望通过词云来呈现男女在择偶观上更看重什么。生成词云的方式有很多，具体可以参考这篇文章：除了 Tagxedo外，还有什么好的软件制作可以词云?，而博主最终选择了wordcloud，你可以看到Python基本上是万能的语言，有这么多优秀的第三方库可以用，我就问你怕不怕，关于这个库的用法，请参考：https://amueller.github.io/word_cloud/，如果通过pip无法直接安装该库，可以通过这里下载.whl文件进行安装，注意升级pip到最新版本即可。 &emsp;&emsp;参照官方的示例，我们从数据库中根据Post来过滤性别，根据Tags来获取关键字，然后将所有Tags串联成一个字符串，传递给WordCloud模块即可。下面给出代码片段：1234567891011121314151617# Filter Datasql = \"SELECT Post, Tags FROM table_weibo WHERE Tags &lt;&gt; ''\"self.cursor.execute(sql)rows = self.cursor.fetchall()# Filter Tagsmale_tags = ''female_tags = ''for row in rows: post = row[0] tags = json.loads(row[1]) if u'男嘉宾[向右]' in post: female_tags += ','.join(map(lambda x:x['word'],tags)) elif u'女嘉宾[向右]' in row[0]: male_tags += ','.join(map(lambda x:x['word'],tags)) # WordCloud self.generateWordCloud(female_tags,'female.png','output_female.png') self.generateWordCloud(male_tags,'male.png','output_male.png') &emsp;&emsp;在这里我们主要将男嘉宾/女嘉宾分别筛选出来，然后将分词结果用逗号串联起来，这样即可得到male_tags和female_tags，我们会将其传递给WordCloud模块，可以注意到我们为男性/女性词云分别设置了不同的背景图片，最终会生成两张不同的图片，这里主要参考了Image-colored这个示例，代码片段展示如下：123456789101112131415161718192021def generateWordCloud(self,text,background,output): back_coloring = np.array(Image.open(background)) stopwords = set(STOPWORDS) stopwords.add(u'西安') stopwords.add(u'生活') wordcloud = WordCloud( font_path='simfang.ttf', # 设置字体 background_color=\"white\", # 背景颜色 max_words=5000, # 词云显示的最大词数 mask=back_coloring, # 设置背景图片 stopwords=stopwords, #停用词设置 max_font_size=75, # 字体最大值 random_state=42, width=1000, height=860, margin=15,# 设置图片默认的大小,但是如果使用背景图片的话,那么保存的图片大小将会按照其大小保存,margin为词语边缘距离 ) wordcloud.generate(text) plt.imshow(wordcloud) plt.axis(\"off\") plt.show() wordcloud.to_file(output) &emsp;&emsp;这里我们注意到添加了两个停止词，这是因为我们发现，西安和生活这两个关键词，在整体中所占权重虽然较高，可是因为我们这里抓取的是西安本地的微博，所以这两个关键词对我们而言是没有意义的。再对这两个关键字进行剔除以后，我们最终生成的词云如图： 男性心目中的伴侣 女性心目中的伴侣 这是个看脸的世界&emsp;&emsp;对这样一个显然成立的结论，我是表示失望的，这种感觉像什么呢？就像你期待着对方说喜欢你，结果到最后她还是会说我们不合适。可花费如此大的篇幅来讲这样一个悲伤的故事，我们就象征性地分析下结论吧！首先，我们注意到男性心目中的伴侣，排名靠前关键字是性格、孝顺、善良、懂事、结婚、身高、眼缘，而女性心目中的伴侣，排名靠前的关键字是身高、稳重、责任心、上进心、工作、成熟。所以，我现在完全可以理解，为什么女生会对180的身高如此迷恋，因为她们想被男朋友举高高呀，我的一位朋友如是说。 &emsp;&emsp;与此同时，我们发现很多指标譬如孝顺、善良、稳重、责任心、上进心等，其实都是需要两个人在相处久了以后慢慢去验证的，可这些最终会被眼缘和身高这种因素阻挡在外面。或许你会觉得这样浅显的道理，居然值得我花费时间和精力去思考。一个你吸引不到的人，终究是难以拉近两个人心间的距离的。喜欢是两个人的事情，我不是要卑微地乞求你来见我，而是你想要来见我我就主动迎上去。有天在QQ空间看到有人在看《怦然心动》，就忍不住下载下来一个人看。有时候我们喜欢的那个人，或许并没有那么好，你会渐渐发现，那种因为喜欢而附加在对方身上的光环，会随着时光而慢慢变淡。而有那么一瞬间，我只想比她变得更优秀，而不再幻想她会转身回来看我，或许这就是成长吧！ 本文小结&emsp;&emsp;大概没有谁会像我这样，在写一篇技术文章的过程中，掺杂如此多的个人情感。可有时候，一个人做一件事情的动机，的确就是如此简单。我羡慕175以上的身高，可是不是我具备了这样的身高，你就会喜欢我呢？我想应该不会吧，因为你总能找到新的理由来拒绝我。所以，我写这篇文章，通过Python抓取新浪微博数据并对其进行分析，并不是想告诉你，你因为不具备哪些因素而不被人喜欢，而是想告诉你，我们每一个人都是这个世界上独一无二的存在，我们的优点同我们的缺点组合起来，这才是完整的我们。别人喜欢不喜欢我们到底有什么意义呢？就像我们喜欢许嵩、喜欢林依晨，难道就要让人家喜欢我们吗？我可以非常喜欢你，但我一定要骄傲地喜欢你，因为我骄傲时的样子最帅，谁让这是一个看脸的世界呢？","tags":[{"name":"Python","slug":"Python","permalink":"http://qinyuanpei.github.io/tags/Python/"},{"name":"微博","slug":"微博","permalink":"http://qinyuanpei.github.io/tags/微博/"},{"name":"词云","slug":"词云","permalink":"http://qinyuanpei.github.io/tags/词云/"}]},{"title":"冬天来了，春天还会远吗？","date":"2017-11-19T10:16:17.000Z","path":"posts/3111375079/","text":"&emsp;&emsp;接到妈妈打来的电话时，时间已然接近中午时分，从床上爬起来的刹那间，就听见妈妈熟悉的声音。妈妈问我年底公司有没有什么变动，顿时千万种思绪涌上心头，不知道该对电话彼端的妈妈说些什么。我突然想到二十四岁时的我，从第一家公司裸辞时的情景，可如今再度让父母为此焦虑，让身为人子的我感到惭愧不安。电话里妈妈让我照顾好自己，一个人在外不要太委屈自己。当一个人不被这个世界接纳的时候，就像是浑身长满刺的仙人掌。可在最亲近的家人眼里，我们永远是这个世界上独一无二的存在。我是一个不大主动同家里的人，在那一刻我忽然觉得，这个冬天没有那么冷了，即使我身处没有暖气的出租屋里，即使早晨带着体温的被子早已凉透，我想对自己说一句，冬天来了，春天还会远吗？ &emsp;&emsp;发生在年底的release事件，就像这个冬天里的雾霾如约而至，即使早在去年就经历过这样的事情，可当它真实地发生在自己身上时，依然不免让人感到这个冬天的寒冷。纵观二十朝兴废更替，历史对我们而言常常是相似的。诸葛亮为“克复中原”六次北伐出师未捷而身先死的遗憾，唐玄宗宠溺杨玉环终致“安史之乱”而奔走蜀中避祸时的仓皇，这一切大概是我们如今坐西成高铁时无法想到的吧。有时候人的命运像极了历史的兴衰，记得三年前和同学第一次来西安，那个时候我们说，总有一天我们会再来这里的，那时的我或许完全不知道现在会面临这种处境，看着那些年龄比自己大依然碌碌无为的人，看着那些面临中年危机而不得不向生活妥协的人…..我告诉自己，我永远都害怕自己变成这样的人，所以让我内心无法平静下来的，永远是我近乎自责的自我反省式人格。 &emsp;&emsp;在接受被release的事实以后，就开始频繁地去准备面试和跳槽。可年底时找工作注定是一个艰难的过程。其实回头想想今年面试的表现，前端、数据库等相关经验的匮乏，一度让我在面试中非常被动，而外冷内热的性格常常给人一种不自信的表现，特别是去葡萄城面试的这次体验，让我意识到在面试中我无法展示出和职位匹配的能力，我们说面试是双向选择的一个过程，这看起来有点像是找男女朋友一样，有时候我们太在乎对方而导致表现不佳。我花了时间去听知乎上有关面试技巧的Live，甚至找朋友帮我分析如何给出面试官满意的答案，有时候别人会觉得我对严厉到苛刻的程度，是因为我对某些东西太在乎的缘故，可是不在乎这些问题就能解决了吗？矫枉过正至少意味着出发点是好的，总比发现问题后一直无所作为要好很多。 &emsp;&emsp;我一直想找时间整理下这段时间面试遇到的题目，可令人窒息的拖延症让这种想法一直落空。有时候我怀疑，人和人的缘分都在第一眼就注定好了。或许你花时间和精力去追一个女生，但这种关系永远不会发生改变。人类总是肤浅地相信眼睛看到的，固执地认为自己的想法就是正确的，可人这种复杂的动物怎么会一眼就望穿呢，所以试图通过面试完全了解一个人，原本就是不切实际的想法。很多时候人与人接近并不是他们彼此熟悉，仅仅是因为大家的口味比较接近而已。无论多么熟悉的同事，在分开以后都会逐渐变得冷淡。每个人都像一只刺猬，离得太远会感觉到冷，而靠得太近会刺伤对方。大概是遇见小古花光所有运气，此后遇人不淑的厄运纷至沓来。人啊，简直是世界上最麻烦的一种动物。 &emsp;&emsp;有时候我会埋头去做自己的事情，朝着自己内心的目标一点点靠近，即使曾经想要和她分享这点喜悦的人，早已消失在茫茫的人海里。我写爬虫、做数据分析、做聊天机器人，这其中有太多事情，是我对记忆的一种自我延伸，因为在那些曾经灰暗的日子里，陪伴我的人除了她，就是这些我比任何人都要在乎的技术。《嫌疑人X的献身》里，石神说道：“通往山顶的路或许会有很多条，而找出最优雅的那一条，是数学家永恒的追求”。也许他们说得都是对的，即使翻过了2017年，这个季节依然属于冬天，她只会比以前更让你觉得寒冷，可这一切的一切终究是会过去的，冬天来了，春天还会远吗？","tags":[{"name":"工作","slug":"工作","permalink":"http://qinyuanpei.github.io/tags/工作/"},{"name":"生活","slug":"生活","permalink":"http://qinyuanpei.github.io/tags/生活/"},{"name":"感悟","slug":"感悟","permalink":"http://qinyuanpei.github.io/tags/感悟/"}]},{"title":"迁移Hexo博客到Google渐进式Web应用(PWA)","date":"2017-10-24T23:13:41.000Z","path":"posts/450254281/","text":"&emsp;&emsp;如果说通过TravisCI实现博客的自动化部署，是持续集成这个概念在工作以外的一种延伸，那么今天这篇文章想要和大家分享的，则是我自身寻求技术转型和突破的一种挣扎。前段时间Paul同我聊到Web技术的发展趋势，Paul认为Web应用会逐渐取代原生应用成为主流，我对此不置可否。真正让我陷入思考的是，在这个充满变化的时代，知识的更新速度远远超过你我的学习速度，我们应该如何去追随这个时代的步伐。如同那些淹没在时间河流里的技术名词，当青春不再的时候，我们喜欢把这个过程称之为成长，当发现距离第一次使用FontPage制作网站已过去十年，当发现曾经的网页三剑客在岁月蹉跎里频频改换姓名，当发现那些淹没在历史里的技术来不及学习就成为过往……或许，这个世界真正迷人的地方，就在于它每天都在不断变化。 新一代Web应用——PWA&emsp;&emsp;接着Paul关于Web技术的这个话题，我认为Web技术在短期内会成为原生应用的一种补充。事实上，原生应用和Web应用哪一个会是未来，这个问题的争论由来已久，在业界我们可以看到HTML5、PhoneGap、React/React Native、Electron/NW.js、小程序等方案百家争鸣，每一种方案都可以让我们去Web技术去打破平台间的差异。与此同时，我们注意到移动开发领域对原生技术的需求在缩减，虽然马克·扎克伯格曾表示，“选择HTML5是Facebook最大的错误“，可我们注意到，越来越多的Web技术被运用在原生应用中，Web技术被认为是最佳的打造跨平台应用的技术，可以通过一套代码实现不同平台间体验的一致性。我们注意到知乎和天猫的客户端中都混合使用了一定的Web技术，因为纯粹使用原生技术去开发一个移动应用，其最大的弊端就在于我们要为Android和iOS维护两套不同的代码，从国内曾经疯狂火热的iOS培训就可以看出，单独使用原生技术去开发客户端，其成本实际上是一直居高不下的。 &emsp;&emsp;虽然我们有Xamarin这样的跨平台技术，试图用一种编程语言和代码共享的方式，去开发两种不同平台的应用程序，可是我们注意到，平台间的差异和抗阻是天然存在的，就像SQL和面向对象这样我们再熟悉不过的例子。同样的，Facebook的React Native项目，试图用Web技术去弱化平台间的差异，React Native存在的主要问题是，它依然依赖原生组件暴露出来的组件和方法，所以像DatePickerIOS、TabBarIOS等控件是iOS Only的，这意味着在开发过程中开发者还是要考虑平台间的差异性，其次React本身的JSX(对应HTML)、CSS Layout(对应CSS)本身是具有一定的学习曲线的，虽然底层因为没有使用WebView的原因提高了部分性能，然而整体上是牺牲了扩展性的。总而言之，这是一个介于Web技术和原生技术之间的中间技术，在我看来地位着实蛮尴尬的，因为无论在Web层还是Native层都选择了部分妥协，完美实现跨平台真心不容易啊。 &emsp;&emsp;要掌握一门新技术，最好的方法就是去应用它。我的博客使用的是Indigo主题，这是一个典型的Material Design风格的主题，所以我一直想尝试将其改造成原生应用，我曾经接触过移动端应用开发，如果通过WebView内嵌网页的方式来实现，我需要处理离线状态下页面的显示问题，以及所有混合应用开发都会遇到的一个问题，即原生应用层需要和Web应用层进行通信的问题。而如果采用Hybrid App的思路去开发一个混合应用，意味着我需要去学习Cordova这样的Hybrid开发框架，去了解JavaScript和Native交互的细节。那么有没有一种学习成本相对较低，同时可以提供原生应用体验的思路呢？答案是确定的，这就是我们下面要说的渐进式应用(PWA)。 &emsp;&emsp;渐进式应用(Progressive Web Apps，PWA)是Google提出的新一代Web应用概念，其目的是提供可靠、快速、接近Native应用的服务方案。我们知道传统Web应用有两个关键问题无法解决，即需要从网络实时加载内容而带来的网络延迟和依赖浏览器入口而带来的用户体验，从某种意义上而言，渐进式应用的出现有望让这些问题得到解决，首先，渐进式应用可以显著加快应用加载速度，其提供的离线缓存机制可以让应用在离线环境下继续使用，关键技术为Service Worker和Cache Storage；其次，渐进式应用可以被添加到主屏，有独立的图标、启动页、全屏支持，整体上更像Native App，关键技术为Web.App Manifest；最后，渐进式应用同操作系统集成能力得到提高，具备在不唤醒状态下推送消息的能力，关键技术为Push API和Notification API。 PWA中关键技术解析&emsp;&emsp;Google对外提出PWA这个概念其实是在今天的二月份左右，所以现在我写这篇文章实际上是在赶一趟末班车。我最近比较喜欢的一个男演员张鲁一，在接受媒体采访时媒体称他是一个大器晚成的人，他的确让我找到了理想中成熟男人的一个标准，如果你要问我这个标准是什么，我推荐你去看他主演的电视剧《红色》。那么，好了，为了让大家了解渐进式Web应用(PWA)，相比其它跨平台方案有何优缺点，我们这里来简单讨论下PWA中的关键技术。 ServiceWorker&emsp;&emsp;我们知道，传统的Web应用需要在网络环境下使用，当处在离线环境下时，因为HTTP请求无法被发送到服务器上，所以浏览器通常会显示一个空白页，并告知用户页面无法加载，因此会影响用户在离线环境下的使用体验，与此同时，因为Web页面在打开的过程中需要加载大量资源，因此在页面刚刚打开的一段时间内，用户看到的页面通常都是一个空白页面，考虑到缓存或者是预加载的Web应用，通常都会以预设资源作为占位符来填充页面，因此带来访问者的印象往往会更好。那么渐进式Web应用带给我们最大的惊喜，就是它可以在离线环境下使用，其核心技术就是ServiceWorker，我们来一起看看如何使用SeviceWorker：12345678if (navigator.serviceWorker) &#123; navigator.serviceWorker.register('service-worker.js') .then(function(registration) &#123; console.log('service worker 注册成功'); &#125;).catch(function (err) &#123; console.log('servcie worker 注册失败'); &#125;);&#125; &emsp;&emsp;我们这里看到一个基本的注册ServiceWorker的代码片段，并且它采用了业界流行的Promise的写法。那么首先第一个问题，ServiceWorker到底是什么？ServiceWorker本质上是一个Web应用程序和浏览器间的代理服务器，它可以在离线环境下拦截网络请求，并基于网络是否可用以及资源是否可用，来采取相对应的处理动作，所以ServiceWorker最基本用法是作为离线缓存来使用，而高阶用法则是消息推送和后台同步。通常来讲，ServiceWorker会经历如下的生命周期： ServiceWorker生命周期 注：配图来自 http://web.jobbole.com/84792/ &emsp;&emsp;按照官方文档中的定义，ServiceWorker同WebWorker一样，是一段JavaScript脚本，作为一个后台独立线程运行，其运行环境与普通的JavaScript不同，因此不直接参与Web交互行为，从某种意义上来说，ServiceWorker的出现，正是为了弥补Web应用天生所不具备的离线使用、消息推送、后台自动更新等特性，我们这里来看一个使用ServiceWorker缓存文件已达到离线使用的目的的例子：1234567891011121314var cacheStorageKey = 'minimal-pwa-1'var cacheList = [ '/', \"index.html\", \"main.css\", \"e.png\"]self.addEventListener('install', e =&gt; &#123; e.waitUntil( caches.open(cacheStorageKey) .then(cache =&gt; cache.addAll(cacheList)) .then(() =&gt; self.skipWaiting()) )&#125;) &emsp;&emsp;在这里例子中，我们在ServiceWorker的install事件中添加了待缓存文件列表，这将意味着这些静态资源，会在网页中的ServiceWorker被install的时候添加到缓存中，我们在某个合适的时机到来时就可以再次使用这些缓存资源。事实上考虑到安全性的问题，ServiceWorker在设计时被约束为按照路径给予最高权限，即ServiceWorker在指定路径下是有效的。这里简单提下ServiceWorker的缓存策略，因为这个问题在我看来蛮复杂的，例如官方出品的sw-tool中定义的缓存策略就有如下五种： 网络优先:：从网络获取, 失败或者超时再尝试从缓存读取 缓存优先:：从缓存获取, 缓存插叙不到再尝试从网络抓取 最快：同时查询缓存和网络, 返回最先拿到的 仅限网络：仅从网络获取 仅限缓存：仅从缓存获取 &emsp;&emsp;我们刚刚提到被缓存的静态资源会在合适的时机被再次使用，那么什么时候可以称之未合适的时机呢？在这个问题中，我们是指fetch事件，事实上通过拦截fetch事件，我们就可以拦截即将被发送到服务器端的HTTP请求，ServiceWorker首先会检查缓存中是否存在待请求资源，如果存在，就直接使用这个资源并返回HTTP响应，否则就发起HTTP请求到服务器端，此时ServiceWorker担任的是一个代理服务器的角色。至此，我们就会明白，ServiceWorker的作用其实就是在离线条件下利用缓存伪造HTTP响应返回，这样我们就达到了离线使用的目的，传统的Web应用在离线环境无法使用，根本原因是没有这样一个Mock的Server去伪造HTTP响应并返回，因为HTTP请求此时根本就无法发送到服务端。为了让ServiceWorker全面接管HTTP请求以便利用请求，我们这里的实现方式如下：12345678910111213self.addEventListener('fetch', function(event) &#123; event.respondWith( caches.match(event.request) .then(function(response) &#123; // Cache hit - return response if (response) &#123; return response; &#125; return fetch(event.request); &#125; ) );&#125;); &emsp;&emsp;好了，以上就是ServiceWorker在离线缓存方面的基本用法，希望进行深入了解的朋友，可以参考文末链接做进一步研究。 Web App Manifest&emsp;&emsp;接下来介绍Web App Manifest，它其实是Web开发领域的一个”叛徒”，因为它所做的事情为大家所不齿，基本可以概括为，怎么样假装自己是一个Native App，我们直接看它的定义：123456789101112131415&#123; \"name\": \"Minimal app to try PWA\", \"short_name\": \"Minimal PWA\", \"display\": \"standalone\", \"start_url\": \"/\", \"theme_color\": \"#8888ff\", \"background_color\": \"#aaaaff\", \"icons\": [ &#123; \"src\": \"e.png\", \"sizes\": \"256x256\", \"type\": \"image/png\" &#125; ]&#125; &emsp;&emsp;这个我确认没有什么好说的，详细的参数可以参考这里，通常我们需要将以上文件命名为manifest.json，并通过以下方式引入到HTML结构中，通常是添加在标签下，我们所期望的图标、启动页、主题色等Native App的特性都是在这里定义的，这里想吐槽的是，随着越来越多的平台开始向标签中注入”新血液”，譬如标签和标签：现在HTML结构变得越来越复杂，更不要说主流的AngularJS和Vue这类MVVM框架，基本上都是通过扩展HTML属性来完成数据绑定的。对PWA应用来讲，我们只需要在标签下引入以下内容：1&lt;link rel=\"manifest\" href=\"manifest.json\" /&gt; 这里简单介绍下Web App Manifest中常见的参数含义及其作用： name/short_name：表示应用被添加到屏幕上以后显示的名称，当屏幕空间不足以显示完整的name时，将显示short_name。 start_url：表示用户从屏幕启动应用时所加载网页的URL，通常我们将其指向网站的首页。 theme_color：表示应用程序的主题颜色，PWA事实上是建议使用Material Design设计风格的，因此该属性可以控制应用的主题颜色，并在页面加载完成前展示一个过渡动画。 scope：表示PWA应用的作用域，即哪些页面可以以PWA应用的形式呈现。 display：表示PWA应用呈现的方式，可以是fullscreen、standalone、minimal-ui和browser中的任意取值。 orientation：表示PWA应用的屏幕方向，如果你有移动开发的经验，对此应该不会感到陌生。 icons：表示PWA应用在屏幕上的图标，为了适配不同尺寸的屏幕，这里可以设置不同尺寸下的图标。同样地，如果你有移动开发的经验，对此应该不会感到陌生。 Push/Notification API&emsp;&emsp;关于这两个东西，我们简单说一下啊，PWA中的Push机制主要有Notification和Push API两部分组成，前者用于向用户展示通知，而后者用于订阅推送消息。网络上对这块介绍的并不多，关于推送这个问题，一直是国内Android用户和开发者的一块心病，因为Google的推送服务在国内水土不服，因此国内厂商或者是SDK提供商基本上都有自己的一套方案，这就导致在用户的设备上同时开启着若干个消息推送服务，用户手机里的电就是这样一点点被耗尽的，所以这个问题大家看看就好。在PWA中，我们可以通过ServiceWorker 的后台计算能力结合 Push API 对推送事件进行响应，并通过 Notification API 实现通知的发出与处理：12345678910111213141516// sw.jsself.addEventListener('push', event =&gt; &#123; event.waitUntil( // Process the event and display a notification. self.registration.showNotification(\"Hey!\") );&#125;);self.addEventListener('notificationclick', event =&gt; &#123; // Do something with the event event.notification.close(); &#125;);self.addEventListener('notificationclose', event =&gt; &#123; // Do something with the event &#125;); 移植Hexo博客到PWA应用&emsp;&emsp;现在，我们基本了解了PWA的概念以及实现PWA的关键技术，我们现在考虑将Hexo博客改造成一个PWA应用，我们这里不打算考虑消息推送的相关问题，所以对Hexo这样一个静态博客生成器而言，我们可以做的实际上只有两件事情，即通过Web App Manifest让它更像一个Native应用，通过ServiceWorker为它提供离线缓存的特性。我们从最简单的开始，我们需要在Hexo的根目录中增加一个manifest.json文件，该文件我们可以通过这个网站 manifoldjs.com 来生成。下面给出博主博客中使用的配置：1234567891011121314151617181920212223242526272829303132333435363738394041&#123; \"name\":\"飞鸿踏雪的部落格\", \"short_name\":\"Payne's Blog\", \"description\":\"人生到处知何似，应似飞鸿踏雪泥\", \"icons\":[ &#123; \"src\":\"assets/images/icons/bird36.png\", \"sizes\":\"36x36\", \"type\":\"image/png\" &#125;, &#123; \"src\":\"assets/images/icons/bird48.png\", \"sizes\":\"48x48\", \"type\":\"image/png\" &#125;, &#123; \"src\":\"assets/images/icons/bird72.png\", \"sizes\":\"72x72\", \"type\":\"image/png\" &#125;, &#123; \"src\":\"assets/images/icons/bird96.png\", \"sizes\":\"96x96\", \"type\":\"image/png\" &#125;, &#123; \"src\":\"assets/images/icons/bird144.png\", \"sizes\":\"144x144\", \"type\":\"image/png\" &#125;, &#123; \"src\":\"assets/images/icons/bird192.png\", \"sizes\":\"192x192\", \"type\":\"image/png\" &#125;], \"background_color\":\"#fff\", \"theme_color\":\"#000\", \"start_url\":\"/\", \"display\":\"standalone\", \"orientation\":\"portrait\"&#125; &emsp;&emsp;好了，现在我们来考虑如何去实现一个ServiceWorker，Google官方提供了一个ServiceWorker的示例项目，以及网友提供的Minimal-PWA，这两个项目都可以帮助我们去了解，如何去实现一个ServiceWorker，甚至于我们有sw-toolbox和sw-precache这样的工具，配合gulp和webpack我们定制缓存策略并生成ServiceWorker。可是你要知道，懒惰对程序员而言是一种美德，在这里我选择了Hexo的插件hexo-offline，该插件可以帮助我们生成ServiceWoker，关于它的使用及配置，大家可以自行去了解，我重点想说说支持ServiceWorker以后，我的博客所呈现出来的变化以及PWA实际运行的效果。 ServiceWorker和Cache Storage &emsp;&emsp;通过这张图，我们可以清楚地看到，ServiceWorker确实在后台工作着，而Cache Storage确实对博客内的静态资源做了缓存处理。事实上对Hexo这样的静态博客而言，整个博客都是静态资源，所以在实际运行中它会对所有内容进行缓存，我们可以在终端中验证这个想法： 在Hexo中监听到的缓存请求 &emsp;&emsp;可我想说这一切并没有什么用，因为我并不能如愿地在离线状态下访问我的博客，甚至因为有了缓存机制，当我在撰写这篇博客时，虽然我改变了markdown文档的内容，但当我刷新博客的时候，因为缓存机制的存在，我不能像从前那样直接看到博客的变化，更重要的一点是，整个缓存大概有8M左右的体积，因此每次请求页面时，我能够明显地感觉到页面加载的延迟，看起来我们费了大量周折最终却一无所获，这听起来实在是讽刺不是吗？ &emsp;&emsp;说完了ServiceWorker，我们再来说说Web App Manifest，我尝试从豌豆荚下载了移动版Chrome，可我自始至终无法将应用添加到主屏幕，貌似这需要Android系统底层的支持，我测试了两部手机，一部OPPO手机和一部小米手机，发现都没有明显的PWA支持，当我访问页面的时候，浏览器更加不会主动提示我”将应用添加到主屏”，像UC浏览器是将网站以应用的形式添加到浏览器首页，这的确没有什么值得令人惊喜的地方，因为在PC端的时候，我们就可以做到类似地实现，这篇文章耗费时间蛮长的啦，大概是因为我不知道，该如何描述这个失败的尝试。最近接触到一位前辈的项目，这是一个需要跨PC端和移动端的项目。目前面临的一个挑战就是，移动端有太多依赖原生接口的功能设计，所以一套代码在全平台适配，真的仅仅是一个美好的理想，离实现永远有一段不可逾越的距离。 本文小结&emsp;&emsp;本文主要以Google提出的渐进式Web应用(Progressive Web Apps)为主线，简单探讨了Google的渐进式Web应用及其关键技术。渐进式Web应用试图解决传统Web应用的两个关键问题，即需要从网络实时加载内容而带来的网络延迟和依赖浏览器入口而带来的用户体验。首先，渐进式应用可以显著加快应用加载速度，其提供的离线缓存机制可以让应用在离线环境下继续使用，关键技术为Service Worker和Cache Storage；其次，渐进式应用可以被添加到主屏，有独立的图标、启动页、全屏支持，整体上更像Native App，关键技术为Web.App Manifest；最后，渐进式应用同操作系统集成能力得到提高，具备在不唤醒状态下推送消息的能力，关键技术为Push API和Notification API。在此背景下，我们对静态博客Hexo进行了改造，尝试将其迁移到一个PWA应用上，虽然最终以失败告终，可是在整个过程中我们依然有所收获，我觉得一件事情能让我们有所思考或者有所感悟的话，这就已然是一种幸运、一种成功啦。 &emsp;&emsp;其实Web应用与原生应用并非彼此水火不容，除了纯粹的Web技术和Native技术以外，在这两者之间我们看到的更多是混合技术的应用，所以我认为开发人员在未来一定要具备两种能力，即跨语言和跨平台开发的能力。比如小程序是在微信原生生态下建立的定制化Web应用，它有着类似HTML/CSS/JavaScript的技术方案，同时提供了统一的应用程序外观和使用体验；而跨平台游戏引擎cocos2d-x，通过JavaScript Bridge等类似技术，则可以实现将Web技术转化为Native技术…..总而言之，在技术选型这个问题上，我们可以选择的方案越来越多，如何让想法可以伴随技术产生优秀的产品，这是我们在这个时代真正该去思考的问题。目前来讲，国内普遍重视iOS，可惜遗憾的是iOS不支持PWA；国内的Android系统经过阉割以后，国内用户无法使用Chrome，以及各个厂商定制的浏览器存在兼容性问题；国内因为政策及现实原因，第三方推送相对GCM推送要活跃很多，厂商并不会太关注对PWA应用推送的支持。虽然现实如此，可Web技术发展到今天为止，我们能做的就是希望它越来越好，在此引用黄玄的一句话： 我们信仰 Web，不仅仅在于软件、软件平台与单纯的技术，还在于『任何人，在任何时间任何地点，都可以在万维网上发布任何信息，并被世界上的任何一个人所访问到。』而这才是 web 的最为革命之处，堪称我们人类，作为一个物种的一次进化。」 PWA 初探：基本特性与标准现状 Service Worker API Using the Push API Service Worker初体验 PWA 入门: 理解和创建 Service Worker 脚本 PWA 入门: 写个非常简单的 PWA 页面 下一代 Web 应用模型 —— Progressive Web App","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://qinyuanpei.github.io/tags/Hexo/"},{"name":"Web","slug":"Web","permalink":"http://qinyuanpei.github.io/tags/Web/"},{"name":"PWA","slug":"PWA","permalink":"http://qinyuanpei.github.io/tags/PWA/"}]},{"title":"持续集成在Hexo自动化部署上的实践","date":"2017-10-21T22:57:55.000Z","path":"posts/3521618732/","text":"&emsp;&emsp;曾经听到过这样一句话，”不要用战术上的勤奋掩盖战略上的懒惰”，所以战术和战略更像是抽象类和具体类，而面向对象设计实际上是现实等级制度的一种映射。因此我们注意到，决策者通常关注的是战略层面的抽象概念，而执行者通常更关注战术层面的具体实现，正如在代码的架构设计中，处在顶层的代码以发送指令为主要使命，处在底层的代码以实现功能为主要使命。面对日新月异的互联网技术，当我们听到越来越多的新名词，譬如微服务、DevOps、单页面应用、前后端分离等等，这些概念曾让我们迷恋于追寻一个又一个风口，一如曾经的O2O、VR、共享经济和人工智能，那么我们真的懂得如何让这些概念落地吗？在今天这篇文章中，我想和大家一起探讨持续集成相关的话题，并以Hexo结合TravisCI实现自动化部署为例，聊聊我心目中的DevOps。 从DevOps谈谈持续集成&emsp;&emsp;不知从何时起，DevOps开始成为大家竞相追捧的概念，同ThoughtWorks所倡导的微服务、敏捷开发一样，大家仿佛抓住了一根新的救命稻草一般，那么我们在说DevOps的时候，我们到底想要表达什么观点呢？想要搞清楚这个问题，我认为首先要明白，什么是DevOps？从概念上讲，DevOps是一个面向IT运维的工具流，以IT自动化以及持续集成(CI)、持续部署(CD)为基础，目的是优化开发、测试、运维等所有环节，所以DevOps本质上是一组部门间沟通协作的流程和方法，其目的是为了协调开发(DEV)、测试(QA)、运维(OPS)这三种角色，使开发运维一体化，通过高度自动化工具和流程，来确保软件构建、测试和发布更加快捷、频繁和稳定。 &emsp;&emsp;所以，我们在说DevOps的时候，我们想表达的或许是流程和管理、运维和自动化、架构和服务、文化和组织等等的概念，那么在这些观点中，最重要的是什么呢？我认为是持续集成(CI)和持续部署(CD)，这是DevOps中从始至终贯穿的一条主线。通过Git这样的源代码控制工具，我们可以确保项目在一条主干上开发。而自动化测试/部署等周边工具，则为我们提供了实施持续集成/持续部署的必要条件。从公司角度出发，公司普遍更看重项目的交付能力，所以在传统持续集成/部署的基础上，我们时常会听到持续交付这样的声音，这时我们就会意识到，DevOps实则是持续集成思想的一种延伸，它并不是一个新的概念，事实上我们这个行业，每年都喜欢这种“旧酒换新瓶”的做法，持续集成/部署/交付是DevOps的核心技术，如果没有自动化测试和自动化部署，DevOps就是难以落地的空中楼阁。 &emsp;&emsp;由此，我们就引出今天这篇文章的主题，即持续集成。我们提到，DevOps是是一套面向IT的跨部门协作的工作流，它是持续集成思想的一种延伸，所以持续集成首先是一组工具链的集合。从某种意义上来讲，决策者喜欢DevOps，并不是真正喜欢DevOps，而是形式上的DevOps非常容易实现，因为有形的工具资源的整合是非常容易的，真正困难的是无形的流程资源的整合。你可以让两个陌生人在一起假装情侣，但你永远不可能真正拉近两个人心间的距离。通常而言，我们会用到下列工具： 版本控制和协作开发：Github、GitLab、BitBucket、Coding等。 自动化构建和测试：Apache Ant、Maven、Selenium、QUnit、NUnit、XUnit、MSBuild等。 持续集成和交付：Jenkins、TravisCI、Flow.CI等。 容器/服务部署：Docker、AWS、阿里云等。 &emsp;&emsp;从术和道的角度来看待持续集成，我们会发现在术的层面上，我们有非常多的选择空间，所以接下来我们主要从道的层面，来说说持续集成的核心思想。我们提到在实践DevOps的时候，需要有一条项目主干，那么持续集成的基本概念，就是指频繁地提交代码到主干分支，这样做的目的是，保证问题被及时发现以及避免分支大幅度偏离主干。 &emsp;&emsp;在使用Git的场景下来看待持续集成，及时提交代码到主分支，可以避免因为分支改动过大而带来的冲突问题。按照敏捷开发的理论，每个feature通过迭代开发来集成到最终产品中，那么持续集成的目的，就是为了让产品可以在快速迭代的同时保证产品质量。在这里产品质量有两层含义，第一，本次feature提交通过测试；第二，本次feature提交无副作用。我们可以注意到，持续集成的第一个目的，即保证问题被及时发现，对应前者；持续集成的第二个目的，即避免分支大幅度偏离主干，对应后者。 &emsp;&emsp;所谓持续集成，是指代码在集成到主干前，必须要通过自动化测试，只要有一个测试用例失败，就不能集成到主干，所以持续集成和自动化测试天生就是紧密联系在一起的。我们不能只看到持续集成/部署/交付，如果连流程上的自动化都无法实现，这些都是无从谈起的，从开发者的角度来看，理想的状态是编译即部署，我们提交的每一行代码，都是可以集成、交付和部署的代码，所以实际上是对开发者的代码质量提高了要求。所有我们觉得美好的事情，其实核心都在于人如何去运作，想到一位前辈说过的话，“软件开发没有银弹”，所有试图通过某种方法论解决软件工程复杂性的想法，都是天真而幼稚的。 Jenkins持续集成落地实践&emsp;&emsp;博主曾经在公司项目上实践过持续集成，深感持续集成想要真正在团队里落地，受到太多太多的因素制约。我们采取的方案是，使用Git/Github作为源代码版本控制工具，使用Jenkins作为持续集成工具，使用MSBuild作为项目构建工具，使用MSTest/NUnit作为单元测试框架，使用Selenium/UI Automation作为UI自动化测试框架，这些工具可以很好地同Jenkins整合起来。在持续集成工具的选择上，我们并没有太多的选择空间，因为公司需要同时支持Java和JavaScript/Nodejs项目的持续集成，在持续集成落地这件事情上，我们最终选择了妥协，我们不再追求自动化部署，而是选择通过这个过程来快速定位问题，具体原因我们下面来讲。 &emsp;&emsp;首先，我们期望的是开发者在提交代码以后，可以触发编译、构建、测试和部署等一系列操作，我们会通过Git从远程仓库拉取最新代码，然后通过MSBuild来编译整个代码，由于MSBuild提供了定制化的脚本，可以对编译、测试和部署等环节进行精准控制，所以我们在Jenkins上触发的实际上是一系列动作，而这些都是可以在Jenkins上进行配置的，我们通常会将Jenkins上的日志以邮件形式发送给开发者，所以在很长一段时间里，每天到公司第一件事情，就是查看邮箱里的邮件，一旦发现有测试用例没有通过测试，我们就需要重复“修改代码“-&gt;“提交代码“这个过程，直至所有用例都完全通过测试，理论上通过测试的代码就可以直接部署上线，因为MSBuild可以帮助我们生成最终文件，我们只需要将其打包然后上传到服务器即可，可是实际上这是我们假想的一种场景而已，因为现实场景中我们考虑得通常会更多。 &emsp;&emsp;一个关键的问题是，我们没有可以量化的标准去评估，本次提交是否可以集成到主干。我知道你一定会说测试，事实是开发者不喜欢写测试，或者是写了不可测的测试，前一种观点认为写测试会占用开发时间，所以在开发时间相对紧张的时候，这就变成了我们不写测试的借口；后一种观点则是不会写可测试代码的表现，典型的表现是代码耦合度高、依赖大量无法Mock的对象实例、不会合理使用断言，所以在这种情况下，持续集成是没有意义的，我们不知道何时代码可以集成、交付和部署。我承认自动化测试无法全面替代人工测试，但当我们的关注点放在交付和部署上的时候，是否应该考虑先让持续集成落地，这实在是比DevOps更基础、更接地气，因为我相信持续集成是一种思想，它对开发团队中的每一个人都提出了更高的要求，持续集成是为了在保证产品质量的同时快速迭代，如果你心中没有产品质量的概念，DevOps并不能帮你提高产品质量。 &emsp;&emsp;第二个关键的问题是，开发和运维该如何去协作，DevOps是为了促进部门间沟通协作而提出的一套工作流，自动化是这套机制能够良好运行下去的前提，可是在现实场景中一切并没有那么理想。以我们公司为例，开发组和运维组分属两个不同的部门，运维组在上线、部署等关键环节设置了严格的审批流程，即运维组牢牢地控制着线上生产环境，所以即使我们通过MSBuild在Jenkins上为程序打好了包，我们依然需要按照运维组的要求，提交上线请求、人工上传程序以及等待部门审批，通常我们上线只有等到每周五，而上线流程所需的东西，我们需要在一周前准备好，所以你可以注意到一个现象，虽然在流程上开发团队和运维团队是结合在一起的，但实际上两者的工作目标依然是分离的。那是不是将两个团队放在一起工作，就能解决这个问题呢？我想合作的前提是相互理解和信任，如果彼此都不愿意去了解对方的工作流程，DevOps可能仅仅是我们用工具堆积出来的虚幻感。 实现Hexo博客的自动化部署&emsp;&emsp;好了，在公司使用Jenkins实践持续集成，在现实场景中总会受到各种各样的制约，这并不是因为持续集成这个想法不好，而是在现实面前我们都选择了妥协。有句话说，“如果没有见过光明，我本可忍受黑暗”，我们喜欢一个人或者是一样东西，都是因为我们觉得它是美好的，可以让我们觉得这个世界温暖，那么在公司以外的地方，我想更加自由地做些我喜欢的事情。在公司实践持续集成的时候，因为公司对权限的严格控制，我难以实现那种想象中的持续集成，即在成功地在提交代码以后直接触发编译和部署，我想在公司之外做成这件事情。 &emsp;&emsp;为什么想到要给博客做持续集成呢？首先，持续集成和单元测试联系紧密，我自认为我的单元测试刚刚入门，为了写出更好的单元测试，我必须要这样做，来强迫自己努力去写好单元测试；其次，持续集成可以将开发和部署分离，所以我在任何一台计算机上撰写博客，都可以通过TravisCI实现编译和部署，对Hexo这种静态博客而言，部署其实就是推送页面到Github而已，整体难度并没有太高。最后，我平时更新博客都是手动推送页面，因为我不喜欢用Hexo提供的部署功能，现在我想让自己专注在内容写作上，而一切都可以在我的控制范围内。这正是我所想，如果能让一切更好一点，我都愿意去尝试和努力。 &emsp;&emsp;关于Hexo这类静态博客生成器搭建博客的原理，我这里不想在赘述，因为我愿意相信，懂得搭建博客的人，一定是了解Git、Github Pages和Markdown等等的概念的，关于配置相关的细节大家可以参考官网。这里想着重介绍下TravisCI，TravisCI是一个在线的、分布式的持续集成服务，可以用来构建和测试托管在Github上的代码，并且其本身就是开源的。TravisCI提供了主流编程语言如C#、Java、JavaScript、Ruby、PHP、Node.js等的支持，相比Jenkins而言，它是一个轻量级的持续集成平台，它会在每次提交代码后，根据配置文件来创建一个虚拟机，并执行用户定义的Build任务，这个虚拟机提供版本控制(Git)、项目构建(Node.js)等，在此前提下，我们下面着手Hexo的自动化部署。 方案设计&emsp;&emsp;Hexo博客实际上可以分成两部分，即博客源代码和静态页面。其中博客源代码主要是指Hexo及其相关模块、博客内容(source)、博客主题(theme)，而静态页面由Hexo动态生成，通常放置在public目录中。对Hexo来讲，我们最终部署需要的是这些静态页面，所以我们设计得一个方案是，将静态页面存放在master分支，将博客源代码存放在blog分支。当用户提交代码到blog分支后，会触发TravisCI中定义的一系列操作，它会首先从blog分支拉取博客源代码，然后在TravisCI中完成静态页面的生成，最后将其提交到master分支以完成博客的更新，整个过程非常优雅，终于让我彻底摆脱了手动更新博客的过去，而更重要的是，从此写博客不再受地点的制约，因为写博客就是提交代码，生成静态页面以及部署到Github Pages，现在全部交给了TravisCI. 配置TravisCI&emsp;&emsp;TravisCI是一个轻量级的持续集成方案，其轻量级主要体现在它的配置文件，即使用TravisCI并不需要我们安装任何软件，我们仅仅需要提供一个.travis.yml文件即可，该文件通常被放置在项目根目录里。和Jenkins这样的持续集成工具不同，我们在这个文件中即可定制Build任务，下面给出一个基本的配置文件：12345678910111213141516171819202122232425262728language: node_jsnode_js: stable# S: Build Lifecycleinstall: - npm installscript: - hexo clean - hexo generateafter_script: - cd ./public - git init - git config user.name \"qinyuanpei\" - git config user.email \"qinyuanpei@163.com\" - git add . - git commit -m \"Update Blog\" - git push --force --quiet \"https://$&#123;CI_TOKEN&#125;@$&#123;GH_REF&#125;\" master:master# E: Build LifeCyclebranches: only: - blog env: global: - GH_REF: github.com/qinyuanpei/qinyuanpei.github.io &emsp;&emsp;如果大家熟悉Jenkins的使用，就会发现这里定义的Build任务似曾相识。在这里我们首先指定了项目构建语言，即这是一个node.js的项目，然后我们会通过npm安装所有依赖，我们注意到在根目录里有一个package.json文件，该文件定义了整个项目依赖的项目。如果你使用过Nuget，你会发现这一切都是如此的合理。那么当整个环境准备就绪以后，我们就可以着手博客的构建啦，和平时一样，我们会执行hexo clean和hexo generate命令，这样Hexo会帮助我们生成所有的静态页面，现在我们通过Git将其推送到master分支，通常基于Github Pages托管的页面都是存放在gh-pages分支的，可是对Hexo而言，我们放在master分支是没有问题的，这就是TravisCI构建整个博客的具体过程。 关联TravisCI&emsp;&emsp;到目前为止，我们定义好了TravisCI将会在虚拟机中执行的Build任务。我们知道，这里TravisCI是需要访问我们托管在Github上的代码仓库的，所以我们必须将这个代码仓库和Travis关联起来，这样它就具备了从代码仓库拉取代码(Pull)和向代码仓库推送(Push)代码的能力。印象中公司是给每一个Jenkins服务器关联了一个Github账户，这样需要持续集成的项目只需要添加这个账号，并为其赋予基本的读写权限即可。在这里是类似的，我们有两种方案来关联TravisCI，即为TravisCI虚拟机添加SSH-Key和使用Github提供的Personal Access Token。 &emsp;&emsp;前者和我们平时使用Git时配置SSH-Key是一样的，但考虑到公开密钥产生的安全性问题，TravisCI建议我们使用官方的一个工具来对密钥进行加密，这是一个基于Ruby开发的命令行工具，加密后的内容可以在TravisCI中解密，这种方案需要安装Ruby，博主选择放弃。如果你要问我为什么放弃Ruby，大概是因为我忘不了曾经被Jekyll支配的恐惧感。而后者的原理是将Github生成的Token作为一个环境变量存储在TravisCI中，我们在定义TravisCI中的Build任务时可以引用这些环境变量，我们只需要在执行Git命令时带上这个Token就可以了。显然这种方式更合我的胃口，它的缺点是对此Github采用了粗放式的权限控制，即这个Token时可以访问所有代码仓库的，这一点大家自己可以根据自身情况来决定要使用哪一种方式。 &emsp;&emsp;我们在Github中的Setting-&gt;Developer Settings找到Personal Access Token，然后选择所有repo相关的权限，生成这个token后将其复制下来备用，因为它只有在这个地方是可见的。接下来我们打开TravisCI，在使用Github登录后我们就可以在这里看到所有的项目，如图是我个人的TravisCI界面： TravisCI主界面 大家可以注意到，这里我开启了qinyuanpei.github.io这个仓库的持续集成服务，如果大家没有在这里看到项目列表，可以点击”Sync account”按钮进行同步。好了，现在我们继续配置： 配置TravisCI 在这里我们配置了名为CI_TOKEN的环境变量，该值对应.travis.yml文件中的${CI_TOKEN}。现在我们在本地提交代码到blog分支，就会触发TravisCI执行Build任务，在这里Build任务是从blog分支拉取博客内容及主题，通过npm安装依赖的nodejs模块，最终Hexo生成的静态页面会被推送到master分支，这样就完成了整个自动化构建的流程。下面是TravisCI执行Build过程中的日志界面： TravisCI日志 &emsp;&emsp;从计划写这样一篇文章，到我一边写博客一篇将它发布在网络上，前后花了大概我3天左右的时间。这段时间发生了太多太多的事情，所以写东西受难免受到情绪影响，你现在看到这篇由TravisCI自动生成的博客，大概无法想象屏幕前的我有着怎样复杂的心绪，有时候我告诉自己要沉下心来学点什么，有时候我会觉得此时的我和过去没有什么区别。转眼间忙忙碌碌一年到头，可会想起来顿时觉得时间像虚度一般，有人说，当你对未来不再有什么期许的时候，就是你开始衰老的迹象，可我真的老了吗？我不是只有25岁吗？好啦，夜深人静，该去睡觉了，这篇文章就是这样子啦。","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://qinyuanpei.github.io/tags/Hexo/"},{"name":"CI","slug":"CI","permalink":"http://qinyuanpei.github.io/tags/CI/"},{"name":"Travis","slug":"Travis","permalink":"http://qinyuanpei.github.io/tags/Travis/"}]},{"title":"不如归去","date":"2017-10-21T22:31:48.000Z","path":"posts/720539850/","text":"&emsp;&emsp;独自一个人在火车上望着窗外出神，而这种情景我再熟悉不过，或许风景会因为季节而不同，或许时间会因为年龄而不同，但对我而言，这个过程熟悉得就像一个我讲了无数遍的故事，从开篇布局到故事脉络都清楚到严丝合缝。印象中是从初中时候就开始寄宿生活，所以这种漂泊的感觉成为我生命里重要的烙印，而从那一刻起，我最期待的是寒暑假期，因为这象征着一段漂泊旅程的结束。大概是因为双子座属于风象星系，所以每次回家的旅程都伴随着忧愁风雨，我喜欢将这个过程理解为，生命不经意的装点。风有质而无形，或飞沙走石，或拈花弄叶；雨有质而无形，或坠散成珠，或凝聚成流。大概都是在世间漂泊的浪子，每一刻都摇曳不定。 &emsp;&emsp;有人说，放假回家是学生时代做的事情，因为那时我们还没有脱离父母的庇护。可当我工作了以后，当我同他们的距离不再是学校和家的距离，当我同他们打电话不再是因为生活费告拮，我忽然发现我同他们交换了这场漂泊里的角色，从前是我期待着假期，因为我可以见到他们；现在则是他们期待着假期，因为他们可以见到我。我忽然发现我一年中我陪他们的日子屈指可数，从前向往远方觉得在那里能找到我的梦，现在越发地觉得他们一天天老去，想努力长大成熟，让他们能够放心，可更怕因为距离而疏远了他们，古人说『树欲静而风不止，子欲养而亲不待』，这个世界固然不再是古人所认识的世界，这种感情却超越了时间和空间轮回至今。 &emsp;&emsp;国庆本来打算不回家的，因为即使无人可约无人可陪，我一个人同样可以给自己放假。我从来都是这样，如果有人愿意陪我做一件事情，我会很乐意接纳这番好意，并尝试用最好的状态去让彼此享受这个过程。如果没有人愿意陪伴我做一件事情，我不会勉强更不会因此而沮丧，因为当你习惯了一个人去面对所有事情，你会发现你从来不缺乏做一件事情的动力。可当家里人问我国庆要不要回家的时候，我突然心软得像融化了的雪，我意识到是我心底涌出的一股暖流，快速地打开微信买回家的火车票，结果发现15号的时候票就没有了，妈妈发微信给我说，『如果实在买不到火车票，就买机票回来吧，不用太心疼钱，人回来了就好』。 &emsp;&emsp;我记得以前他们都不大会用这类IM产品的，但现在他们学会了怎么发消息发朋友圈。记得过年的时候，我教妈妈怎么样发红包，虽然只有三块钱这样来回发着玩，但她玩得比我都开心，或许父母就是这样，曾经青春期叛逆时觉得他们的世界和自己格格不入，等他们老去的时候依然在努力着融入我们的世界。小时候他们紧紧追逐着我们，是怕我们在成长路上摔倒；长大了他们依然紧紧追逐着我们，是怕我们的世界里没有了他们。可他们在一天天地老去，如果有一天他们追不动了，我们是否愿意停下来等等他们呢？窗外的若明若暗的，像极了我往常回家路上数过的每一盏灯，可是我最喜欢的那一盏，是来自那个叫做家的地方，它或许并不璀璨耀眼，但向来不吝于为你释放光和热，永远为你指示着家的方向。 &emsp;&emsp;早上去北客站取票坐车，就接到朋友从中卫打来的电话，询问我国庆是不是要回家，这种感觉就像家里人一直记挂着你。我经常会想起高中时候，有时同朋友出去玩到很晚回家，常常会到朋友家里借宿，两个人寝则同床食则同桌，到今天我们依然是特别特别好的朋友。我幸运的是一直被朋友这样照顾着，即使我们两个在毕业后天各一方，我这个人不大懂得经营感情，被这样的朋友一直照顾着，我该是有多幸运啊。因为没有买到直达的车票，所以坐动车到兰州去转车，然后遭遇了人生中第一次火车晚点。火车晚点近三个小时，第一次迫切地感觉离家好远好远，每次回家都是披星戴月，或者在夜深人静时，或者在曙光初现时，让家人和朋友等我，我总是过意不去的。大概他们都太了解我，知道我会永远都是这副『长不大』的样子，可我总要长大成熟啊！ &emsp;&emsp;我记得以前还在父母身边时，我脑子里想的是『父母在，不远游，游必有方』，我一位同学曾问我，何谓有方，当时的我真的是不知道该怎么样回答。后来，一个人去西安发展，终于明白，以前公司里一个女生所说的，在哪里都一样。想到父母孤零零地待在家里，想到每年屈指可数的回家次数，曾几何时，我们想去更广阔的世界寻找诗和远方，可父母逐渐蹒跚的步履注定无法，陪伴我们去那些遥远的地方。诗经里说『青青子衿，悠悠我心，纵我不往，子宁不来』，如果他们不能再紧紧追随我们的步伐，我们为什么不停下甚至转身回去去看望他们呢？以前和我徒弟聊天，她说男生都不大喜欢和家里人联络，我本来就是沉默寡言的性格，从初中时候就不主动和家里人联络，现在我想改变这种想法，因为我想有空就陪陪家里人。 &emsp;&emsp;我喜欢在漫长的旅途中看书，这种习惯在我有了Kindle以后变得更为明显。早上看到这样一句话，『你懂得越多，就越觉得自己像这个世界里的孤儿』，人生而孤独，父母总有一天会离开我们，但他们教会我们如何去爱这个世界，我希望我可以用他们教会我的，在他们有生之年做些在他们眼里不再『孩子气』的事情，虽然在他们眼里我们永远都是孩子，我觉得真正的成熟并不是变得冷酷麻木，而是你知道这个世界有黑暗的一面，依然愿意相信那些温暖的事情。我到现在依然不喜欢听别人讲“道理”，因为我觉得人生最奇特的地方就在于，即使别人讲得这些“道理”都对，别人依然无法代替你去体验整个生活。每个人都是生活这片大海里的一朵浪花，为了不被岁月冲上荒凉寂寞的沙滩，我们唯有追逐巨浪努力生存。有那么一瞬间，我想和我喜欢的姑娘生活在一个城市里，等有空了就带上她回家陪陪父母。 &emsp;&emsp;或许有些地方有比故乡更广阔的天空，或许有些地方有比故乡更湿润的土壤，或许有些地方有比故乡更精彩的旅程，我想说的是，不论你是在追求诗和远方，还是在忍受眼前的苟且，如果你觉得累了，请停下忙碌的脚步，找找回家的路，那里永远有人在等你！","tags":[{"name":"成长","slug":"成长","permalink":"http://qinyuanpei.github.io/tags/成长/"},{"name":"回家","slug":"回家","permalink":"http://qinyuanpei.github.io/tags/回家/"},{"name":"亲情","slug":"亲情","permalink":"http://qinyuanpei.github.io/tags/亲情/"}]},{"title":"秋风劲似去年时","date":"2017-09-25T00:56:50.000Z","path":"posts/2617501472/","text":"&emsp;&emsp;连续数日的秋雨绵绵，依然固执地不肯转身离开，而之所以选择在国庆节前徘徊，或许是为了让离开家的人，多些同江湖风雨漂泊的味道。印象中这样的日子常常是相似的，譬如穿行在骤雨中被来往车辆溅得一身水，或者行走在上班的路上抬头看见第一场雪，或者是倚靠在公交车窗边上看风景转眼即逝，这些再熟悉不过的场景对我熟悉而又陌生，我惊异于记忆常常像盗梦空间般重叠，我感概于时间常常像钟表指针般流连。我不知道这个世界上是不是有平行世界，但我知道我再回不去曾经某一个时刻，我一直想写下这段时间的状态，可当我准备下笔时才发现，它需要我努力想好多事情，我依然还是曾经的我，风景依稀还是曾经的风景，到底是谁在一直变化呢？ &emsp;&emsp;我不知道要从什么时候回忆这些事情，这种感觉就像是你期待了许久之后，在触碰到她的那一刻都不复存在了。我曾经答应过一个人要去看望她，如果你读过《一个人的朝圣》这本书，或许就会明白这是一种怎么样的执念，即使在明明知道一切再无法挽回的时候，这种执念还是让我想要达成这个愿望。我一直不知道两个人怎么就自然而然地在一起了，那种感觉如果一定要用语言来形容，我觉得是一种熟悉到灵魂里的默契。你想要牵着她的手的时候，她假装挣扎下后就一直让你牵着，那种娇羞中透着可爱的神情，在四目相对的时候眼睛里都是闪着光的。我忘不了在人潮中牵着她的手穿过整条街市，我忘不了抱着她的时候街市两边灯笼通红。有时候觉得人生充满了遗憾，好像错过她花光了我这辈子的好运气，从那以后我总是重复着昨天的故事。 &emsp;&emsp;其实我自己都不清楚，我到底喜欢什么样的女孩子，甚至有时候我喜欢的是，我心中她最美好的样子。一个人少不经事的时候，大概会喜欢对女孩子说甜言蜜语，可当他经历过失去以后，他变得不再轻易许诺，这就好像我小时候是一个特别喜欢说话的人，在经历过因为紧张而变得口吃以后，我终于变成了今天这副沉默寡言的样子。有时候会陡然间觉得自己并没有怎么变，或许是因为她说过她喜欢我这个样子，所以我就固执地不肯改变，因为我怕有一天她回来的时候认不出我来，即使这是我脑补的一个剧情。曾经看过一个电影《这个男人来自地球》，当我们熟知的宗教历史变成一个人的回忆，这种超越哲学意义上的时间我认为是荒凉的。曾经的小伙伴Alex、Sandy、Kent、Andy、Kent、Kavin和Joe都渐行渐远，到底是我停留在原地还是我超越了时间？ &emsp;&emsp;不知道该怎么样描述这种感觉，或许我就是一个不擅长联络感情的人，生命中有太多太多东西，我眼睁睁看它离我远去而又无可奈何，想要安慰我的人总是劝我同昨天告别。但像我这样太看重感情的人，无论外表多么风平浪静，内心永远不肯残忍地删除回忆。所以，我记得Jackson、Lynn、Candy他们陪我度过的二十五岁生日，我记得Candy问我当时暗自许了什么样的愿望，坦白来讲，我没有想着脱单这样离我很遥远的愿望，我只想时间能够永远定格在那一刻，大家都可以开开心心地直到永远。你一定觉得我幼稚或者是不成熟啦，我问过人家要怎么样变得成熟，人家说你去找一个女朋友就好啦，然后就会在喜欢的人面前紧张甚至自卑，我曾一度很讨厌下雨天，因为我怕两个人遇到一起，我既没有伞亦没有外套。 &emsp;&emsp;二十五岁的我，喜欢一个人还是和从前一样无所顾忌，我还是学不会那些复杂的套路，不喜欢单方面付出，不喜欢卑微地爱一个人，每一次都会因为喜欢某个女孩子而尝试改变，想和她站在一起的时候不会被她的光芒完全覆盖，想和她待在一块的时候不让她觉得我这个人枯燥，想和她抱在一起的时候给她讲我从书里看到的某个故事……我一直在想，如果我们的感情不是以异地恋这种方式会不会有不一样的结局，我喜欢《星月神话》这首歌，是因为我们的确呼吸着同一片天空的气息而注定无法再相遇，就像两条相交的直线一样从陌生到熟悉再到陌生。我现在再看《嫌疑人X的献身》这部电影，我总在想，如果那天我们看的是这部电影会怎么样，此时的我比上大学时候胖了许多，大概一开始我在她心目中的样子，应该是张鲁一这样温润如玉的谦谦君子吧！生命就是这般离奇玄妙，你不能假设更无从假设应该发生什么，因为每一天都是无法重现的Case，你觉得它相似，仅仅是因为相似而已。 &emsp;&emsp;我喜欢穿裙子的女孩子，这一点完全是因为受到她的影响，虽然她一再告诉我，是我喜欢这样的女孩子，而她恰好喜欢穿裙子而已，可这些淹没在风声里的话语，谁会去盘问孰是孰非呢，如果她此刻愿意同我争论这个问题，我直接认输就好啦，我对输赢看得并不重要，这就像在工作中，没有人在意做的产品是不是好用，大家关注的是始终是它能节省多少个FTE，所以为了达到这些光鲜亮丽的指标，没有人会在意工程师的代码被改成什么样子，我们所追求的东西是否显得舍本逐末，我们所在意的东西到底是否真正发自你我的本心。以前觉得两个人在一起简单，是因为我们没有想那么多；现在觉得两个人在一起困难，是因为我们习惯性想太多。你有没有在脑海中设想过，和一个人走完一生是种什么样的体验，我想说那是一个很美好的想象。","tags":[{"name":"感悟","slug":"感悟","permalink":"http://qinyuanpei.github.io/tags/感悟/"},{"name":"回忆","slug":"回忆","permalink":"http://qinyuanpei.github.io/tags/回忆/"},{"name":"年华","slug":"年华","permalink":"http://qinyuanpei.github.io/tags/年华/"}]},{"title":"从React专利事件看开源软件许可","date":"2017-09-20T23:06:45.000Z","path":"posts/1166840790/","text":"&emsp;&emsp;各位朋友，我是Payne，大家好，欢迎大家关注我的博客，我的博客地址是https://qinyuanpei.github.io。最近前端技术圈因为React专利事件再次被大家关注，印象中Angular和Vue的纷争刚刚过去不久，果然前端技术圈对”造轮子”和”搞事情”有着近乎执著的追求。作为一个在知乎吃瓜的伪前端工程师，我对这凑热闹这种事情从来都是是颇为喜欢的。如果说Angular和Vue冲突主要来自大漠穷秋和尤小尤的个人战场，那么这次React专利事件则是商业公司之间对社区主导力量的一次争夺和抗衡。开源是一种近似乌托邦般的理想社会，它倡导的”人人为我，我为人人”这种近乎大同社会的观念，在面临商业化浪潮洗礼的时候难会和商业利益发生冲突，譬如Google因为使用Java而和甲骨文纠纷不断，最终不得不选择Kotlin作为Android开发的主力语言。所以这篇文章我想和大家通过React专利事件来聊聊开源软件许可，以及我们如何在商业化和开源社区间找到一个平衡点。 事件始末&emsp;&emsp;其实React专利事件由来已久，如果不是在知乎上看到“百度要求内部全面停止使用React/React Native”的问题，我是完全没有意识到事态居然发展到如此严重的。每次前端技术圈”搞事情”的时候，基本上都会在我的知乎首页刷屏，可是对我这样的伪前端工程师而言，我仅仅是关注了”Web开发”这个话题而已。忽略知乎首页推荐算法的缺陷，这的确动侧面说明了目前前端领域非常热门的事实，可它不能说明某些前端工程师的技术水平有多高，在引入前后端分离和前端构建工具以后，前端开发的基础设施渐渐地丰富起来了，可是前端开发目前经历着的一切，无一不在后端开发中涉及到，我没有想要成为全栈工程师的野心，在讨论这个事件以前我认为有必要了解下整个事件的始末： 2016年7月，Facebook在React.js的开源许可协议中添加的附加专利条款首次在社区中引发广泛讨论。 2016年11月，Facebook发布官方问答，对附加专利条款进行了澄清，强化了其BSD许可证 + 专利许可证的概念。 2017年4月，Apache Cassandra项目正在考虑是哟过Facebook开源的数据库RocksDB作为存储引擎，可是考虑到专利授权的问题，Jeff Jirsa向Apache法律社区寻求帮助。 2017年6月，Apache 法律社区开始讨论Facebook Patents License协议专利授权的不对称问题，且该协议与Apache Software License，即Apache 2.0等不兼容。 2017年7月15日，Apache软件基金会正式发表声明称：Facebook BSD + Patense License正式被列入”Category X”列表，因此Apache项目中将不能含有或者依赖任何该协议的代码，而已发布的代码必须在8月31日前完成替换。 2007年8月19日，Facebook对Facebook BSD + Patense License有了新的解释，解释指出，专利许可证的存在是为了防御无量的专利诉讼，Facebook增加专利许可证是为了保护核心技术。 2017年9月16日，百度内部全面禁止使用React/React Native的消息在知乎上引发热烈讨论。 2017年9月17日，Wordpress官方称因为React专利问题而停止在博客程序Wordpress中使用React技术。 2017年9月23日，Facebook迫于社区压力对外宣称将在数周后将React授权许可修改为MIT。 主流软件许可&emsp;&emsp;其实作为一名软件工程师，这些和法律息息相关的内容，原本是不需要我们去关注的，因为即使公司在使用这些开源软件中发生法律纠纷，通常都会有法务人员协助公司去解决相关事宜，无论如何都轮不到我们这些人来关心的。不过这个事件的现实意义是，我们在做技术选型时，专利等可能引起法律纠纷的问题，一样是需要纳入考虑范围的。因为如果是个人性质或者纯玩性质的项目，我们的确无需在意太多。而如果你是商业性质项目、或者是公司自营项目，或者是服务于甲方，那么你必须考虑你使用开源软件的方式是否符合相关的软件许可。国内因为盗版软件盛行的原因，大家在心底里好像都不认同软件许可，但是像外企或者是对信息安全比较重视的企业，通常要么对许可证书比较看重，要么对开源软件不太感冒，所以像最近的WePhone创始人自杀这种事件，都在告诉我们一个道理，程序员不要整天都关注技术层面上的东西，虽然技术世界有很多纯粹而美好的事情，但当它和人类联系在一起、和政治联系在一起的时候，它就完全不在我们的控制之中了，所以我觉得我们有必要了解些法律相关的事情，那么从何处开始呢？我们不妨就来说说主流的开源软件许可吧！ &emsp;&emsp;这个世界上的开源软件许可证书大约有上百种，我们不可能也没有必要了解所有的开源软件许可证书。对于主流的开源软件许可，我们有GPL、BSD、MIT、MPL、Apache和LGPL，相信大家都没有兴趣去阅读这些晦涩深奥的License，所以我们不打算在这里逐一介绍它们，事实上搞清楚它们在具体限制上的差异是件非常困难的事情。我们希望用最简洁的语言来描述这些开源软件许可： GPL： 即GNU通用公共授权(GNU General Public License)，其出发点是代码的开源/免费使用和引用/修改/衍生代码的开源/免费使用，但是不允许修改后和衍生的代码做为闭源的商业软件发布和销售。这就是为什么我们能用免费的各种包括商业公司在内的Linux版本，以及Linux上各种各样的由个人、组织和商业软件公司开发的免费软件。 BSD： 即Berkly Software Distribution， 基本上是一个给予使用者极大自由空间的一种开源协议，使用者可以自由地对代码进行使用、修改和二次发布，该协议鼓励代码共享，其出发点是尊重代码作者的著作权，要求保留原代码中的BSD协议，保留创作者署名权利，即不得以开源软件作者/机构的名义进行市场推广。 MIT： 即Massachusetts Institute of Technology，这是一个完全给予使用者自由空间的 简短而宽泛的授权协议，作者唯一的诉求是保留版权，使用者可以复制、修改、合并、发布、分、授权和销售软件副本，并根据程序的需要适度修改授权条款，唯一的要求是必须在发行版里附加原许可协议的声明，无论是以源代码还是二进制形式发布。 MPL：即The Mozilla Public License，该协议同GPL和BSD基本一致，差异主要体现在：源代码提供者不能提供已经受到专利保护的源代码、要求再发布者必须提供对代码程序修改的说明、允许通过MPL许可获得的源代码同其他类型源代码进行混合(第二条献给那些不好好在Git里写注释的同学)。 Apache：即著名的非盈利开源组织Apache采用的协议，该协议和BSD类似，同样鼓励代码共享和尊重原作者的著作权，同样允许代码修改，作为开源或商业软件再发布，主要关注点有：（1）需要给代码的用户一份Apache License；（2）如果改动代码需要在被修改文件中做出说明；（3）衍生代码必须保留原有协议、商标、专利或者说明等；（4）不得对Apache协议进行修改。 LGPL：LGPL，即GPL V2，是GPL的一个为主要为类库使用设计的开源协议，和GPL要求任何使用/修改/衍生之GPL类库的的软件必须采用GPL协议不同。LGPL 允许商业软件通过类库引用(link)方式使用LGPL类库而不需要开源商业软件的代码。这使得采用LGPL协议的开源代码，可以被商业软件作为类库引用并发布和销售的同时，保障作者的知识产权，避免有人利用源代码复制并开发类似产品。 &emsp;&emsp;好了，相信到这里大家就能够明白，为什么这次React专利事件能在社区里引起轰动。我认为主要的原因有两点： &emsp;&emsp;第一，React在BSD协议许可的基础上增加的专利许可，对许可证书授权方和被授权方而言，存在待遇上的不对等性。实际上在React为前端带来虚拟DOM、单向数据流和不可变对象等一系列函数式编程的概念的同时，Facebook在开源社区中的话语权同样越来越大，Facebook在开源协议中夹藏私货的确让人有种”挟天子以令诸侯”的感觉，曾几何时，社区指责微软没有开放全部的OpenXML标准，因为大家都觉得按照这个标准实现的Office文档和微软家的存在差异，可是面对这种和自家产品紧密联系的项目要开源，我觉得这不单是Facebook会有所提防，恐怕所有的商业公司都会有类似的想法吧，所以在这个事件中，隐含的一个点就是，一旦当使用React的公司和Facebook发生业务上的竞争，React将成为Facebook获得诉讼胜利的一个重要筹码，因为根据React的专利协议，Facebook有权在开展诉讼时从被授权方手中收回React的使用权，所以我们不难理解为什么百度和Wordpress都宣称要停止使用React，除了不想受制于人以外，像百度这种未来可能会和Facebook在AI等领域发生竞争的公司，宁可自己造一套轮子而不愿让自家专利被对方使用的做法，我觉得是可以理解的。 &emsp;&emsp;第二，React在开源协议中附加专利许可的做法，从商业公司自我保护的角度来看，的确是无可厚非，不过这种做法未免会给开源社区带来不好的风气。我们都知道开源软件并不等同于免费软件，因为开源软件通过许可证书来保证开源软件代码是以一种合理的方式被使用。在很久很久以前，MySQL是我非常喜欢的一个数据库，因为它可以让我摆脱SQLServer臃肿的体积。什么？你说.NET技术体系中怎么会出现MySQL？可这正是.NET选择开源、选择了跨平台，我们才有机会在更广阔的世界里去做些有趣的事情不是吗，我们必须承认开源对这个世界的重要意义，当你发觉你身边的同事都在重复写些垃圾的代码时候，你或许就会意识到，其实在这个世界上有很多东西，我们是可以站在巨人的肩膀上看得更远的。当你因为目光短浅而小心谨慎地维护着那些破旧的代码的时候，我们除了一天天老去别无所获。自从MySQL被甲骨文收购以后，我觉得这个世界开始缺少些有趣的东西，甲骨文和Google关于Java的官司让Google最终选择了Kotlin，所以你可以看到开源这件事情对这个世界是绝对有利的，很多人担心这些代码开源到互联网上对商业公司不利，其实我们都清楚，没有环境和生态的代码基本不会有人关心，我们是不是该重新审视下开源？ &emsp;&emsp;OK，我知道现在大家都在思考一件事情，既然开源对这个世界的进步是有利的，那么是否开源就不应该成为我们思考的问题，我们真正应该考虑的问题是，如何选择一个合适的开源软件许可证书，在商业化和开源间找到一个平衡点。对于这个问题，我想大家一定会犯选择困难症，不过没有关系啦，我想下面这张图可以帮到大家： 如何选择开源软件许可证书 何去何从&emsp;&emsp;或许在数日前，你还在为React专利事件而苦恼，或者考虑在Preact的基础上实现一个新的React，或者考虑转向Angular和Vue这两个框架，此时此刻Facebook宣布将React的开源协议修改为MIT，或许这算是开源社区的一次胜利，或许这算是整个专利事件的尘埃落定，或许有人继续担心Facebook搞其他事情，可是这个世界原本就是在每天都发生变化着的，对于未来我们常常是无从得知它的足迹会在哪里。人生本来就是一个人的逆旅，要想在这充满变化的世界里获得安全感，唯有努力让自己处于不败之地，技术何尝不是这样呢，想想这20年间我们经历了多少技术的变革，从来没有一门框架可以让我们一劳永逸，所以对于小公司而言，大可不必担心Facebook会因为专利问题和你产生法律上的纠纷，该用什么就用什么框架，因为没有绝对完美的框架，能结合业务场景选择合适的框架，为这个世界带来一点点微小的变化，这样子我们就足够开心啦！而对于BAT这样的互联网大厂，则应该考虑走自主研发的差异化路线，因为如果你不想受制于人，最好的方法就是让别人依赖你，而不是去努力依赖别人。作为一个伪前端工程师，我觉得不管什么时候，我们都要努力打好基础，而不是在一堆框架中疲于奔命，对热衷于搞事情和造轮子的前端技术圈来说，下一次的讨论热点会是什么，你我都未必能想到，这个时候还有什么比努力更重要的事情呢。好了，这篇文章就是这样了，希望大家能够喜欢，我们下一篇见。","tags":[{"name":"前端","slug":"前端","permalink":"http://qinyuanpei.github.io/tags/前端/"},{"name":"React","slug":"React","permalink":"http://qinyuanpei.github.io/tags/React/"},{"name":"开源","slug":"开源","permalink":"http://qinyuanpei.github.io/tags/开源/"}]},{"title":"Redis缓存技术学习系列之Lua脚本","date":"2017-09-17T10:49:07.000Z","path":"posts/4197961431/","text":"各位朋友，大家好，我是Payne，欢迎大家关注我的博客，我的博客地址是https://qinyuanpei.github.io。想起来大概有一个月没有更新博客啦。或许是因为这中间发生了太多的事情，想来人生原本就充满曲折和变数。在微信群里得知家中舅爷去世的消息，突然意识到时间早已摧毁你我的一切。那个曾经同你有千丝万缕联系的人，会在某一刻同你彻底失去联系。所以我更珍视彼此在一起的时光，因为在这个世界上每天都面临着改变。有时候工作上遇到不开心的时候，会想着一个人去一个陌生的地方，我们就在不断地相聚和离别中慢慢老去。这段时间一直在学习做饭，为此特意买了本菜谱，结果发现，最难的并不是如何去做好一道菜，而是你为了做好一道菜需要准备各种食材，就像人与人交流并没有什么困难，真正困难的地方，是你找不到一个可以一直陪你说话的人。熟悉的店面会被拆迁转让，熟悉的人事会被错过改变，上帝想把世界煮成一锅粥，可味道的调配却由我们来掌控。 好了，所谓“如人饮水，冷暖自知”，人生奇就奇在你没有办法用三言两语去描述它。这段时间面试过两三家公司，整体上感觉自己的生活太安逸了些，虽然我现在依然住在租来的房子里，转眼间2017年接近尾声啦，可是回想起来今年年初制定的计划，在广泛阅读和提升技术上都是不及格的状态，印象中打算研究Redis和MonogoDB这两种数据库的(因为没有购买为知笔记会员导致部分笔记损坏或者丢失)，然而到现在为止我还有研究完Redis。尤其当我面试的时候，我发现好多我写在简历上的内容，都会成为某种意义上的呈堂证供，这让我更加确信好多东西需要不断地去巩固，所以尝试在实际项目上使用Moq、考虑怎么写出更好的测试方法以及时刻保持自我的不可替代性，这些都是我最近在考虑的事情，有时候发脾气是因为觉得自己在浪费生命，可越是被这种无力感笼罩的时候，就越是要对自己狠一点儿，所以在这篇博客中，让我们重新拾起对Redis的学习兴趣，今天我们来说说Redis中的Lua脚本。 熟悉我博客的朋友一定都知道，我曾经开发过Unity3D相关的项目，而Lua脚本正是Unity3D中主流的热更新方案。关于Lua脚本相关的文章，大家可以通过下面的链接来了解，在这里我们不再讲述Lua的基础内容，本篇文章所讲述的是如何通过Redis内置的Lua解释器来执行脚本，我们为什么使用脚本语言进行开发呢，因为这样可以降低开发的难度啊。 脚本语言编程：Lua脚本编程入门 在Windows下使用Visual Studio编译Lua5.3 Unity3D游戏开发之Lua与游戏的不解之缘(上) Unity3D游戏开发之Lua与游戏的不解之缘(中) Unity3D游戏开发之Lua与游戏的不解之缘(下) Unity3D游戏开发之Lua与游戏的不解之缘终结篇：UniLua热更新完全解读 好了，既然我们已然了解到Redis是通过内置的Lua解释器来执行脚本，所以Redis中的Lua脚本其实可以理解为Lua语法 + Redis API。为了写作这篇文章，我不得不将我的操作系统切换到Linux，因为这样我可以随时在写作过程中使用终端，我写作的一个重要特点，就是所有的内容都尽量保证有测试覆盖，我知道有许多人都不喜欢写测试，测试虽然不能保证你没有BUG，可是有了BUG以后可以直接在测试中定位问题，这就是我们为什么要重视测试的原因所在。在Redis中我们有两类命令用以处理和脚本相关的事情： Eval系列 熟悉JavsScript的朋友应该会更熟悉这个方法，因为Eval在JavaScript是个神奇的存在，它可以执行任何合法的JavaScript代码，我和我的同事就曾经在一个项目中写过两层嵌套的Eval方法，显然这是为了实现某种奇怪的需求。那么在Redis中有EVAL和EVALSHA两个命令可以使用，这两个命令是从Redis2.6.0版本开始的，通过内置的Lua解释器来实现对脚本求值。EVAL命令的基本格式如下： 1EVAL script numkeys key [key ...] arg [arg ...] 我们可以注意到在这里EVAL命令由三部分组成，即第一个部分，表示一段Lua脚本程序，并且这段脚本不需要更不应该定义函数；第二部分，表示参数列表，指在脚本中需要用到的键，因为Redis是一个键值数据库，这些键名可以通过全局变量KEYS来访问，默认索引将从1开始，事实上我们更推荐你使用这种方式来访问键名；第三部分，表示除建键名参数以外的附加参数，和第二部分类似，这里我们可以通过全局变量ARGV来访问，这里就不再赘述啦。我们一起来看下面的例子： 1EVAL \"return &#123;KEYS[1],KEYS[2]&#125;\" 2 ab cd 此时我们会返回一个由KEYS[1]和KEYS[2]组成的集合，集合中的两个元素分别是ab、cd，注意到这里有一个参数2,它表示我们这里将有两个参数，事实上Redis将从这个位置开始解析参数，所以我们必须告诉Redis参数解析到什么位置结束，因为主要参数(KEYS)和附加参数(ARGV)是从解析的角度上是无法区分的，所以我们期望的结果会是： 121) \"ab\"2) \"cd\" 现在我们来增加点难度，显然你明白我在说什么，请注意我要引入附加参数(ARGV)啦！ 1EVAL \"return &#123;KEYS[1]..ARGV[2] ,KEYS[2]..ARGV[1] &#125;\" 2 ab cd ab cd 这里我们尝试对KEYS和ARGV进行拼接，需要说明的是Lua中连接字符串使用的是. .，所以这里将得到结果： 121) \"abcd\"2) \"cdab\" 好了，现在大家应该理解EVAL这个命令的使用方法啦，那么对EVALSHA命令来说，顾名思义，它就是使用了SHA1验证的EVAL方法，我们注意到现在脚本都是定义在EVAL命令的第一个参数上，假如我们需要复用一个脚本，而该脚本可以为我们提供Sum这样的功能，即它可以返回一组参数的和给我们，显然参数的个数是不同的，那么这个时候我们总不能每次都重复写这个脚本吧，所以Redis会为脚本创建一个指纹，我们使用EVALSHA命令来传入一个指纹，Redis将从缓存的脚本中找到这个脚本，并结合我们的参数来调用它，这样我们就可以获得脚本执行以后的结果，关于指纹的这种说法，大家可以结合Git提交代码时的感受进行理解，除此以外，它和EVAL在使用方法上是完全一致的，所以不再举例子说明啦。 Script系列 好了，下面我们来介绍第二类和Lua脚本相关的API，相比Eval给人云里雾里的感觉，Script系列的命令处处洋溢着规范命名的美好气息，我们通过这些命令的名字基本上就可以知道它是做什么事情的，这告诉我们平时写代码的时候如何去写出优雅的代码。我们通过下面一组命令来了解Script系列命令的具体用法： 1234567891011121314/* 载入一个脚本到缓存中 */SCRIPT LOAD \"return 'Hello Redis'\" /* Redis返回该脚本的指纹信息 */\"e509eb0869056563287758d23146eb00e0518da5\"/* 查询脚本是否存在于缓存中 */SCRIPT EXISTS \"e509eb0869056563287758d23146eb00e0518da5\"/* Redis返回1表示脚本存在，反之不存在 */1) (integer) 1/* 从缓存中清空所有脚本 */SCRIPT FLUSHOK/* 此时脚本在缓存中是不存在的 */SCRIPT EXISTS \"e509eb0869056563287758d23146eb00e0518da5\"1) (integer) 0 至此，我们了解到了Redis中对Lua脚本支持的主要特性，坦白地讲，我认为Lua脚本在这里的应用极其薄弱，完全达不到我们印象中Lua脚本的强大，甚至我对Redis中的KEYS和ARGV依然有些模糊，大概越想搞明白的事情有时候就越搞不清楚。这里我没有提到的一个SCRIPT系列的命令是SCRIPT KILL，这个命令的作用是杀死当前正在运行的脚本，并且当且仅当这个脚本没有执行过任何写操作时，这个命令才会生效，所以这个命令主要用于杀死长时间运行的脚本，执行完这个命令后，执行这个脚本的客户端将从阻塞的EVAL命令中退出，并收一个错误作为返回值，所以我们可以理解为这是一个强行终止脚本执行的方法，因为我这里这个脚本非常的简单，所以它执行起来非常快，而我没有这样一个足够长的脚本去验证这个命令，所以在上面的脚本示例中我没有去验证这个命令，对此感兴趣的朋友可以自行去研究啦。 Lua脚本应用 通过本文前面两个部分，我们基本了解了Redis中Lua脚本是如何工作的，在演示示例脚本的时候，我是直接在终端下运行redis-server和redis-cli的，并且所有的命令都是在终端下手动键入的，难道在实际的使用中我们要这样子玩Redis吗？想起来都觉得好可怕是不是？所以我们下面来通过一个具体的案例，来演示Redis怎么去和一个Lua脚本脚本进行交： 首先，我们来定义一个简单的Lua脚本文件script01.lua，该脚本将对集合中的元素进行求和： 1234567891011local sum = 0;local key = KEYS[1]local length = redis.call(\"LLEN\",key)local index = 0while (index &lt; length)do sum = sum + redis.call(\"LINDEX\",key,index) index = index + 1endreturn sum 现在我们在终端中执行这个脚本，为了方便起见，我们这里将其放在redis-3.2.8目录下的scripts目录。我们首先在Redis中准备些数据来做好准备，在终端中执行命令： 1234LPUSH data 2 4 6 8 10(integer) 5src/redis-cli --eval ~/文档/redis-3.2.8/scripts/script01.lua data(integer) 30 好了，我们下面来解释下这段脚本，我们向Redis中键名为data的集合中添加了5个元素，注意这句脚本是在执行src/redis-cli后执行的，这部分内容我们在前面讲解Redis中的数据结构的时候提到过，博主表示在写这篇文章的时候依然要去看文档，总之现在我们有一个集合，并且这个集合中有5个元素，与此同时呢，我们编写了一个Lua脚本文件script01.lua，这个脚本的作用是对集合中的元素进行求和。在这里我们注意到，我们可以通过redis.call()这个方法来调用redis中的命令，具体到这里我们使用LLEN命令获取了集合的长度，使用LINDEX命令获取了集合中的元素。我们在前面提到两个全局变量KEYS和ARGV，可以完全当作Lua脚本中的两个变量来处理，从编程角度来讲，我们可以将其直接在脚本中写死。可是考虑到Redis是一个键值数据库，所以我们很容易想到键名应该对外暴露出来，以满足复用Lua脚本的目的。这里我们直接用redis-cli来运行EVAL命令，所以我们注意到它的传参方式有点不一样，事实上KEYS和ARGV中间使用逗号隔开即可。 所以我们可以想到一种Lua脚本自动管理的思路，即通过命令行读取指定目录下的Lua脚本文件，通过SCRIPT LOAD方法获得其在Redis中的SHA1指纹，然后我们将脚本名称或者ID和这个指纹关联起来并将其存储在Redis中，此时我们只需要传入脚本名称和参数即可返回脚本执行后的结果，这样是不是感觉非常优雅呢？虽然Redis是一个键值性数据库，它不具备传统关系型数据库的查询能力，但是现在我们有了Lua脚本以后一样可以通过脚本来定制出查询，而到此时此刻我或许才真正明白Redis中Lua脚本是一种怎样神奇的存在。我们心怀敬畏，同时对这个世界永远充满期待，因为我们从来不知道人类潜能开发的极限在哪里。我们创造了太多不可思议的事情，有时候甚至连我们自己都怀疑，为什么我们会走到今天这一步。在脚本语言里我最喜欢的编程语言是Lua和Python，如果说我喜欢Lua源于我对游戏开发的兴趣，喜欢Python源于我对编写网页爬虫的兴趣，那么我很庆幸今天我又多了一个使用Lua的原因。世上美好的事情莫过于，你喜欢一样东西，恰好有人和你一样喜欢，可惜那是很久以前的事情啦。 我们现在可以了解到，Redis提供了一种机制可以让Lua脚本同Redis进行交互。可是事实上Redis和Lua在数据结构定义上存在一定差异。所以，下面我们来了解下这两种数据结构是如何进行转换的，了解完这些我认为这篇文章就可以结束啦，因为现在接近1点钟啦而明天还要上班。在Lua脚本中调用call()或者pcall()方法来执行Redis命令时，Redis命令执行的结构会被转换为Lua中的数据结构。同理，当Lua脚本在终端中执行时，Lua脚本的返回值会被转化为Redis的协议并经由EVAL返回给客户端。关于call()和pcall()这两个方法，一个显著的区别是前者在出错时返回的是错误信息，而后者返回的是经由Lua table包装后的结果。我们知道table在Lua语言中是一个非常强大的数据结构，显然后者对调用者更为友好些啦。通常在处理类型转换时我们有以下原则： Lua table结构中不能含有nil，否则Redis将从第一个为nil的位置返回 Lua number结构中不能区分浮点类型，默认会转换为整型并舍弃小数部分，如果需要保留小数部分请返回string类型 Lua boolean结构在Redis中会被转换为0和1的取值 Redis提供了redis.error_reply()和redis.error_status()两个辅助方法来完成Lua-&gt;Redis的转换 好了，这篇博客就是这样子啦，关于为什么使用Lua脚本这个问题，我认为可以从减少网络开销、原子性和脚本复用三个角度来考虑，尤其是第二点，因为Redis执行脚本的时候是整体的、阻塞的执行，中间不会被插入新的命令，因此它完全可以不用担心出现竞态或者事务相关的问题，可是即使这样我们还是建议编写短小精悍的Lua脚本。以上就是这篇博客的全部内容啦，感谢大家关注，欢迎在博客留言及讨论相关技术问题，谢谢大家。 参考文章 Xbynet - Redis与Lua及Redis-py应用Lua 一路向前走 - 【原】Redis基本操作 小咚 - Redis Lua 总结 Redis中文网 - Redis 脚本","tags":[{"name":"Redis","slug":"Redis","permalink":"http://qinyuanpei.github.io/tags/Redis/"},{"name":"缓存","slug":"缓存","permalink":"http://qinyuanpei.github.io/tags/缓存/"},{"name":"数据库","slug":"数据库","permalink":"http://qinyuanpei.github.io/tags/数据库/"}]},{"title":"基于特性(Attribute)的实体属性验证方案设计","date":"2017-08-21T14:25:41.000Z","path":"posts/3873710624/","text":"&emsp;&emsp;各位朋友，我是Payne，大家好，欢迎大家关注我的博客，我的博客地址是https://qinyuanpei.github.io。在这篇文章中，我想和大家探讨下数据校验的相关问题，为什么我会对这个问题感兴趣呢？这其实是来自最近工作中相关需求场景，而这篇文章其实是我在去年就准备要写的一篇文章，这篇文章一直存放在草稿箱里没有发布出来，所以结合这段时间项目上的思考，对当初的设计方案进行了改进，所有就有了大家现在看到的这篇文章，我始终认为思考是一个持久的过程，就像我们对这个世界的理解，是会随着阅历的变化而变化的。我们知道现实通常都会很残酷，不会给我们太充裕的时间去重构。可是思考会是人生永远的功课，当你忙碌到无暇顾影自怜的时候，不妨尝试慢下来抬头看看前方的路，或许原本就是我们选择了错误的方向呢，因为有时候作出一个正确的选择，实在是要比埋头苦干要重要得多啊。 &emsp;&emsp;好啦，既然我们提到了思考，那么我们来一起看一个实际项目中的业务场景，在某自动化项目中，用户会将大量数据以某种方式组织起来，然后藉由自动化工具将这些数据批量上传到一个系统中，该系统实际上是一个由各种表单组成的Web页面，并且这些Web表单中的控件都有着严格的验证规则，当数据无法满足这些验证规则时将无法上传，因此为了提高自动化工具上传的成功率，我们必须保证用户组织的这些数据是合法的，假设我们的用户是一个仅仅会使用Office三件套的普通人，他们可以想到的最好的方式是将这些数据录入到Excel中，而Excel中的数据有效性验证依附在单元格上，一旦验证规则发生变化，我们就不得不去维护这个Excel文件，这绝对不是一个软件工程师该做的事情好吗？我们当然是需要在提交数据前做验证啦，然而我看到Excel中100多列的字段时，我瞬间就不淡定了，这么多的字段难道我们要逐个写if-else吗？不，作为一个提倡少写if-else的程序员，我怎么可能会去做这种无聊的事情呢？下面隆重推出本文的主角——Attribute。 你的名字是？&emsp;&emsp;如你所见，本文的主角是Attribute，那么当它出现在你面前的时候，你是否会像《你的名字。》里的泷和三叶一样，互相问候对方一句：你的名字是？因为我们实在不知道应该叫它特性还是属性。可事实上这篇文章的标题暴露了这个问题的答案，这里我们应该叫它特性。好了，按照数学理论中的观点，任何问题都可以通过引入一个中间层来解决，现在我们有了一个新的问题，Attribute和Property到底有什么区别？虽然这两者都可以翻译为”属性”，可实际上它们表达的是两个不同层面上的概念，一般我们倾向于将Attribute理解为编程语言文法上的概念，而将Property理解为面向对象编程里的概念。 Attribute/特性&emsp;&emsp;我们将Attribute称为特性，那么我们在什么地方会用到特性呢？两个个非常典型的例子是超文本标记语言(HTML)和可扩展标记语言(XML)。首先这两种标记语言都是结构化、描述性的标记语言。结构化表现在节点间可通过父子或者兄弟的关系来表示结构，描述性表现在每个节点都可以附加不同的描述来丰富节点。例如下面的XML文件中，我们使用了描述性的特性来提高元素间的辨识度，即特性为元素定义了更多的额外信息，而这些额外信息并不作为元素数据结构的一部分： 1234567891011121314&lt;bookstore&gt;&lt;book category=\"COOKING\"&gt; &lt;title lang=\"en\"&gt;Everyday Italian&lt;/title&gt; &lt;author&gt;Giada De Laurentiis&lt;/author&gt; &lt;year&gt;2005&lt;/year&gt; &lt;price&gt;30.00&lt;/price&gt; &lt;/book&gt;&lt;book category=\"CHILDREN\"&gt; &lt;title lang=\"en\"&gt;Harry Potter&lt;/title&gt; &lt;author&gt;J K. Rowling&lt;/author&gt; &lt;year&gt;2005&lt;/year&gt; &lt;price&gt;29.99&lt;/price&gt; &lt;/book&gt;&lt;/bookstore&gt; &emsp;&emsp;在这个例子中，bookstore节点由两个book节点组成，而每个book节点则由title、author、year和price四个节点组成，显然这些节点描述的是一种结构化的数据，而这些数据同时附加了相关描述性的信息，例如book节点有category信息，title节点有lang信息。在XML中最基本的一个内容单元我们称之为元素，即Element，而描述这些元素的最基本内容单元我们称之为特性。所以，这种在语言层面上进行描述而与实际抽象出的对象无关的概念就称为”特性”，人们认知和描述一个事物的方式会有所不同，所以在XML中会有这样一个历史遗留问题，我们应该使用Element还是Attribute，而产生这个问题的根源在于我们认识这个世界，是通过语言描述还是通过概念抽象。 &emsp;&emsp;如果我们了解GUI相关技术的演进过程，就会发现历史总是如此的相似。为什么微软会在XML的基础上扩展出XAML这种专门为WPF而设计的界面设计语言呢？因为历史告诉我们GUI中的大量特性都应该使用声明式的、描述式的语法来实现，从苹果的Cocoa、微软的XAML、Qt的QML、Android的XML等无一不证明了这个观点，而采用过程式的MFC、WinForm、Swing等，我们常常需要为它们编写大量的交互性的逻辑代码，今天我们会发现前端领域的声明式编程、MVVM、组件化等技术点，其实都是这种思想的无限延伸，我们可以使用jQuery去直接操作DOM，但面向过程的命令式代码一定不如声明式容易理解。虽然在面向对象编程的世界里，我们最终还是需要将这些描述性的语法结构，转化为面向对象里的类和属性，可这已然是一种进步了不是吗？ Property/属性&emsp;&emsp;我们认识这个世界的过程，恰恰折射出这两者截然不同的风格，从孩提时代理解的“天空是蓝色的”到学生时代认识到“大气是由氮气、氧气和稀有气体组成”，这种转变从本质上来看其实是因为我们认识世界的角度发生了变化。《西游降魔篇》里玄奘寻找五行山，第一次是风尘仆仆“看山是山”，第二次是由“镜花水月”启发“看山不是山”，第三次借“儿歌三百首”降伏孙悟空后“看山还是山”。面向对象编程(OOP)的一个重要思想是抽象，而抽象即是我们从描述性的语言中对事物属性进行构建的一个过程。例如现实生活中的汽车会有各种各样的数据信息：长度、宽度、高度、重量、速度等等，而与此同时汽车会有启动、刹车、减速、加速等等的行为，所以将事物的“数据”和“行为”提取出来进行抽象和模拟的过程，就是面向对象编程，我们在这个过程中可以注意到一点，所有的这一切都是针对对象而言的，所以Property是针对对象而言的。 &emsp;&emsp;这里提到的一个重要概念是抽象，什么是抽象呢？我认为它恰好和具体相对的一个概念。所谓具体，即相由心生，你看到什么就是什么，与此同时通过一组描述性的语言将其描述出来，我以为这就是具体。例如”火辣辣的太阳挂在天上”，这是具体到太阳颜色和温度的一种描述；所谓抽象，即返璞归真，我们看到的并非世间阴晴圆缺的月亮，而是这浩瀚宇宙中国一颗遥远的行星，此时此刻我们将行星具备的特点概括出来，推而光之，我以为这就是抽象，所以对我们而言，属性是事物抽象后普遍具有的一种特征，它首先要达到一种抽象的层次，其次它要能表现出事物的特性，我更喜欢将Property称之为属性，它和我们在面向对象编程中的概念是完全统一的。 方案设计及其实现设计目标 免除配置开箱即用：无需任何配置文件，直接在实体上添加Attribute即可实现验证 非侵入式验证设计：验证与否对实体结构无任何副作用，可以随时添加验证或卸载验证 扩展灵活高度复用：可以自由派生自定义特性，通过泛型来支持不同实体类型的验证 设计思路&emsp;&emsp;所有校验相关的Attribute都派生自ValidationAttribute这个父类，其核心方法是Validate()方法，该方法被声明为一个虚方法，因此所有的子类都必须对这个方法进行重写，它将返回一个叫做ValidationResult的结构，这是一个非常简单的数据结构，它仅仅包含Success和Message两个属性，前者表示当前校验是否成功，后者表示验证失败时的错误信息。显然，一个实体结构中将包含若干个不同的属性，所以在对一个实体结构进行验证的时候，会通过反射遍历每一个属性上的ValidationAttribute并调用其Validate()方法，所以最终返回给调用者的应该是由一组ValidationResult组成的集合，为此我们设计了ValidationResultCollection这个类，该类实现了ICollection接口，在此基础上我们增加了一个Success属性，当集合中所有ValidationResult的Success属性为true时，该属性为true反之为false。我们将数据校验的入口类EntityValidation设计成了一个静态类，它提供了一个泛型方法Validate()方法，所以对整体设计而言，它的灵活性和扩展性主要体现在：(1)通过派生自定义特性来增加验证规则；(2)通过泛型方法来支持不同类型的校验。下面给出UML类图供大家参考，最近刚刚开始学习UML，有不足之处请大家轻喷哈： UML类图 技术要点&emsp;&emsp;首先，在.NET中特性的基类是Attribute，Attribute从表现形式上来讲类似Java中的注解，可以像标签一样添加在类、属性、字段和方法上，并在运行时期间产生各种不同的效果。例如[Serializable]标签表示一个实体类可以序列化，[NonSerializable]标签则可以指定某些属性或者字段在序列化的时候被忽略。而从本质上来讲，Attribute是一个类，通常我们会将派生类以Attribute结尾，而在具体使用的时候可以省略Attribute，所以[Serializable]标签其实是对应.NET中定义的SerializableAttribute这个类。在我们定义Attribute的时候，一个需要考虑的问题是Attribute的作用范围，在.NET中定义了AttributeUsageAttribute这个类，它可以是Class、Property、Field、Method等，所以Attribute本质上是在运行时期间为元素提供附加信息的一种机制，即Attribute可以添加元数据。我们知道元数据是(MetaData)实际上是程序集(Assembly)中的一部分，显然这一切都是在编译时期间定义好的，所以Attribute的一个重要特征是在运行时期间只读(Readonly)。Attribute必须依附在指定目标上，当当前目标与AttributeUsage定义不符时，将无法通过编译。Attribute的实例化依赖于目标实例的实例化，无法直接通过new完成实例化。通常我们需要配合反射来使用Attribute，在运行时期间做些有意义的事情，例如ORM中实体字段与数据库字段的绑定、Unity中配合AOP使用的ExceptionHnadler等等，都是非常典型的Attribute的应用。 &emsp;&emsp;了解了Attribute是什么东西，接下来我们要考虑的就是如何访问Attribute，在.NET中主要有两种方式来获取Attribute，即通过Attribute类提供的静态方法获取Attribute和通过Attribute依附的对象实例的元数据来获取Attribute。下面我们来看一段简单的代码实例：123456public static T GetAttribute&lt;T&gt;(this PropertyInfo propertyInfo)&#123; var attrs = propertyInfo.GetCustomAttributes(typeof(T), false); if(attrs == null || attrs.Length&lt;=0) return null; return atts[0] as T;&#125; &emsp;&emsp;这段代码展示了如何通过反射访问附加在属性上的Attribute，事实上除了PropertyInfo以外，它还可以从任何支持附加Attribute的元素，例如MethodInfo、FieldInfo、ConstructorInfo等。Attribute类提供了类似的静态方法，第一个参数可以是这些元素中的任何一个，第二个参数和第三个参数和这里的示例代码一致，分别是返回的Attribute的类型，以及是否要搜索父类的Attribute，它的返回值类型为Attribute[]。在这个方案中，我们通过下面的方式来对实体属性进行验证：123456789101112131415161718192021222324252627282930313233public static ValidationResultCollection Validate&lt;T&gt;(T entity)&#123; var type = entity.GetType(); var properties = type.GetProperties(); var results = new ValidationResultsCollection(); foreach(var property in properties) &#123; var propertyValue = property.GetValue(entity,null); var validationAttributes = property.GetCustomAttributes(typeof(ValudationAttribute),fasle); if(propertyValue == null &amp;&amp; (validationAttributes == null || valudationAttributs.Length &lt;= 0)) continue //优先验证RequiredAttribute var requiredAttributes = property.GetCustomAttributes(typeof(RequiredAttribute),false); if(requiredAttributes.Length &gt; 0) &#123; var requiredResult = (requiredAttributes[0] as ValidationAttribute).Validate(propertyValue); results.Add(requiredResult); if(propertyValue == null) continue; &#125; //其次验证ValidationAttribute foreach(var validationAttribute in validationAttributes) &#123; if(propertyValue != null &amp;&amp; !validationAttribute.GetType().Equals(typeof(RequiredAttribute))) &#123; var validationResult = (validateAttribute as ValidationAttribute).Validate(propertyValue); results.Add(validationResult); &#125; &#125; &#125; return results;&#125; &emsp;&emsp;在这里我们注意到在对ValidationAttribute进行处理的时候，优先验证了RequiredAttribute，因为如果它验证失败意味着下面的验证都不需要了，所以当一个Property上附加了RequiredAttribute并且它的值为null的时候，我们将不会进行下面的验证，这是在设计过程中发现ValidationAttribute的优先级不同而做出的一个简单地调整。关于ValidationAttribute，我们提到这是所有自定义特性的基类，实际在使用中我们会有各种各样的派生类，我们这里以RegexAttribute为例来看看它具体怎么实现：12345678910111213141516171819202122232425public class RegexAttribute : ValidationAttribute&#123; private string regexText; private string defaultMessage = \"value is required to match a Regex rule &#123;$regex&#125;; public RegexAttribute(string regexText,string message = null) &#123; this.regexText = regexText; this.message = message == null ? defaultMessage : message; &#125; public VelidationResult Validate(object value) &#123; var regex = new Regex(regexText); var match = regex.match(value.ToString()); var success = match.Success; if(!success) &#123; message = message.Replace(\"&#123;$regex&#125;\",regexText); return new ValidationResult()&#123;Success = success, Message = message&#125;; &#125; return new ValidationResult()&#123;Success = success&#125;; &#125;&#125; &emsp;&emsp;好了，以上就是整个校验设计中关键的技术点啦，我认为整体上没有多少难点，因为这是我在项目上造的一个简单的轮子，相比ASP.NET MVC 中的校验要简单很多，相信大家可以根据这些内容轻松地实现一个自己的版本，虽然不主张”重复造轮子”，可博主在很多时候都是通过”造轮子”来学习的啊，哈哈。 数据校验示例&emsp;&emsp;下面我们来通过一个简单的示例来了解，如何在实际项目中使用这个验证方案：12345678910111213public class Foo&#123; [Required] [Regex(\"(\\d+)&#123;3&#125;-(\\d+)&#123;1&#125;-(\\d+)&#123;6&#125;\")] public string CardNumber &#123;get; set;&#125; [Required] [MaxLength(20,\"AccountNumber is required within 20 characters\")] public string AccountNumber &#123;get; set;&#125; [Values(\"FCY,DCP,ATM\")] public string TransactionType&#123;get；set;&#125;&#125; &emsp;&emsp;这里使用了三种验证规则，Required表示该字段不可以为空，Regex表示字段值要匹配指定的正则表达式，MaxLength表示字段长度不能超过指定长度，Values表示字段允许的取值范围，在实际使用中我们可以通过派生定义更多的验证规则，每一种验证规则都可以设置一个验证失败的信息，例如当AccountNumber的长度超过20时，将会返回指定的错误信息。我们可以通过下面的代码来验证Foo这个实体中的属性：12345678910var foo = new Foo();foo.CardNumber = \"234-7-4567\";foo.AccountNumber = \"12345678900\";foo.TransactionType = \"DCP\"var results = EntityValidation.Validate&lt;Foo&gt;(foo);if(!result.Success) results.ToList().Foreach(r =&gt; &#123; Console.WriteLine(r.Message);&#125;); #本文小结&emsp;&emsp;本文首先讲述了特性和属性两者在概念上的不同，即特性是编程语言文法上的概念，而属性是面向对象编程里的概念。接下来，我们针对.NET中的Attribute的表象和具象进行了讨论，Attribute从表象上看是和Java中的注解类似，可以像使用标签一样附加在类、方法、属性或者字段等元素上，而从具象上看Attribute提供了一种在运行时期间通过元数据访问附加信息的能力，Attribute是附加在类、方法、属性或者字段等元素上的一个类，需要继承自Attribute，它的实例化必须依赖这些附加对象的实例化，并且Attribute在运行时期间是Readonly的，Attribute通常需要配合反射来使用。在具备这些基础知识以后，我们开始和大家分享这个验证方案的设计思路及其技术要点，所谓抛砖引玉，本文的目的是想让大家借鉴这种思路，努力让业务代码更干净些，因为只有我们在乎这件事情，我们才会努力去将它做好。好了，今天这篇文章就是这样啦，谢谢大家关注！","tags":[{"name":"C#","slug":"C","permalink":"http://qinyuanpei.github.io/tags/C/"},{"name":"校验","slug":"校验","permalink":"http://qinyuanpei.github.io/tags/校验/"},{"name":"特性","slug":"特性","permalink":"http://qinyuanpei.github.io/tags/特性/"}]},{"title":"《大护法》—— 花生镇里的成人童话","date":"2017-07-30T20:38:22.000Z","path":"posts/1684318907/","text":"猛然间驻足回首这些错落的旧时光，我渐渐意识到我已经有三个月没有写博客了。如果一定要我说出这是种什么样的感觉，大概就是你永远都不会知道永远到底有多远。或许你会喜欢上一个陌生的人，源自不经意间的惊鸿一瞥；或许你会开始厌倦一个熟悉的人，源自不经意间的怅然若失。时间如风起云涌，一边熟悉着一边陌生着，永远像极了一场你追我赶的拉力赛。从办公室里走出来被热风吹袭的一瞬间，我居然有种久违的暖人肺腑的感觉。每个人都像一粒炭火，都知道要通过抱团来取暖，可是有谁会愿意燃烧自己呢？所以孤独是人类如宿命一般的社会属性。我一位朋友曾向我讲述过，这种若即若离的感觉，而此时此刻，我想将这种感觉结合一部电影来说出来。 这段时间好像看了挺多电影的，借我一位朋友的话说就是，“两只单身狗跑到电影院里去找刺激”。而对于《大护法》这部电影，我是选择了一个人去看的，因为我觉得这部电影的主题是“反乌托邦式”的，所以我宁愿自己独自去消化这些内容，而不是将消极悲观的情绪在观影时传播给别人。对这部电影我将其看作是一个成人童话，因为它的确不适合带小孩子去观看，而这部电影恰恰采用了PG-13的影片分级。我喜欢这个电影，某种意义是因为它在现有体制内，讲述一群被奴役的“花生人”，如何在外人的帮助下，从愚昧麻木转变为意识清醒，并最终产生自我意识推翻统治者暴政的故事，所以这其实是一个关于觉醒和反抗的故事。 而这基本上是人类历史里永恒的话题啦，熟悉苹果公司历史的朋友一定知道，乔布斯当年曾经拍摄过一部名为《1984》的广告片，这部广告片取材自乔治.奥威尔的同名小说，该书中刻画了一个令人窒息的恐怖世界，在假想的 未来社会中，独裁者以追求权利为最终目标，自由被彻底剥夺，思想被严酷控制，人民被迫屈从于“老大哥”的统治。而将书中这个背景对应到苹果公司，我们就部难理解乔布斯是在用“老大哥”来影射当时的IBM公司，在这则广告片中“老大哥”被铁锤击碎后缓缓消失，此时旁白平静地念道：“1月24日，苹果电脑公司将推出麦金塔电脑，你将明白为什么1984不会变成《1984》”，这段传奇故事在《硅谷传奇》和《乔布斯》两部电影中均有反映，对此感兴趣的朋友可以自己去了解，显然乔布斯在当时试图向世界证明，苹果公司是唯一一家有希望打败IBM的公司。 因此在很长一段时间里，我一直有想要通读《1984》的愿望，这种行为在某些人看来是矫情和装逼，可事实上连周星驰都表示没有读完《演员的自我修养》这本书，我就不明白这个想法为什么会遭人厌恶。这个世界上最令人厌恶的事情就是，我们所有人都生活在一个被道德和法律约束的世界，我们从出生就在适应接受某一种意识形态或者社会法则，可总有人试图告诉你生活是这样或者那样，并且出自尊重你必须接受和感谢这种建议，因为这些人最后会说我是为了你好。那么在导演不思凡的视角里，这种回归哲学意义上的最为追根溯源的问题，即我是谁，是如何通过电影表现出来的呢？欧阳吉安，即花生镇村名眼中的老神仙，他说鬼蘑菇是一种可怕的传染病，一旦花生人长了鬼蘑菇就必须被立即处死，花生人不能开口说话，即使他们都贴着假眼睛和假嘴巴，花生人不能拥有意识和思考，一旦说出事实就会被认为染了疯病必须被立即处死，所有的村民都循规蹈矩地听着老神仙的话，可事实上鬼蘑菇根本就不是传染病，它是花生人成熟的标志，老神仙这样一个统治者，从来不会将花生人视为人，它们活着的唯一意义就是等死后，由庖卯从脑袋里取出黑石头。古话说：流言止于智者，可在这个荒诞诡异的世界里，流言会因为恐惧而掩盖真相，村民始终生活在一种令人窒息的恐怖阴影里。 故事开篇即点明主旨，即奕卫国大护法，即故事主角“红冬瓜”为寻找太子下落，而来到了充斥着腐烂气息的花生镇，虽然主角对这些像人而又不像人的“花生人”表示了反感，因为在大护法沿着山路来到小镇的时候，经过了一个类似拱门的建筑，可细思恐极的是这个拱顶堆满了花生人的头颅，而且头颅上的眼睛是真正的眼睛，而散落在地面上的贴纸其实是假的眼睛，联想整个故事情节，在花生镇敢于揭露真相、寻找真相的人都被杀鸡儆猴地处理掉了，这可以说是故事开篇埋下地一个伏笔了，可是为了寻找太子的下落，大护法不得不去向这些村民打探消息。可是大护法很快就发现，在花生镇这样一个奇怪的地方，随时随地都会有人杀戮村民和外来者，这些人被称为刑法者，负责帮助老神仙欧阳吉安杀死“该死”地村民，所以在故事一开始大护法在村子里就遭到了袭击，可是说起大护法来，这是一个战斗力爆表的反差萌系设定，而通过故事我们知道，这些刑法者由一个称为罗单的人管理，他不属于花生镇，和欧阳吉安这些人类不一样，他对彩这个神秘女子有种强烈的占有欲，他偷看她洗澡被发现便转身离开，可当他发现下属产生感情的时候，他毫不留情地杀死了他们，所以大概到现在为止，我们所认识的世界存在着严格的等级区分，整个故事从此定性，罗单压抑着自己的情欲，却不允许下属产生情欲，所以当他杀死欧阳吉安的时候，我们不会感到太意外，因为他心里隐藏了太多东西。 太子是整个故事里，唯一一个清楚知道自己想要什么的人。他不喜欢朝廷里的纷争，便遁走江湖寄情山水，去寻找自己真正喜欢的事情。从来没有人将花生人当作人，他却视小姜为花生镇里最好的朋友。可我们都知道这样一句话：哪有什么岁月静好，不过是有人负重前行。在整个故事设定中，大护法的爷爷的爷爷起就一直是弈卫国的大护法，所以大护法的职责就是要保护太子，在故事安排上这部电影相对枯燥，因为后期基本上一直在找太子，所以太子有这样的机会，去选择做自己想做的事情，其实是因为有大护法在一直保护他，相反普通人可能不会有这样的机会，这一点我们稍后会提到。太子除了承担整部电影的笑点以外，我个人认为最出彩的地方是，他在被庖卯打得头破血流时，亲眼目睹了小姜的死，从那一刻开始，我相信他终于明白了身为帝王的那种担当，他不再是以前那个避世逃脱的太子，所以这种成长的感觉会非常好，他在看到大护法以后重复了两次“杀了他”，而在此之前他是坚决反对杀人的。 小姜是唯一一个自我意识觉醒的花生人，他通过隐婆了解到自己是怎么来到这个世界上的，了解到毒蘑菇到底是怎么一回事情，了解到花生人来自蚁猴子却又以蚁猴子为食的真相，这里有一个有趣的设定，花生人是以蚁猴子作为食物的，这就好像喂猪的泔水里会有猪肉一样，想通了这一点，或许人吃猪肉和人吃人并没有本质的区别。小姜会说话这件事情，让欧阳吉安和疱卯都感到异样，前者是担心危及到自己的统治，后者是对自己的职业产生了怀疑。小姜最终还是死了，就像被庖卯杀死的那些花生人一样，不同的是那颗石头不再是黑石头，而是晶莹剔透的宝石。这让我想起蚌这种可以孕育出珍珠的海洋生物，普通的砂砾经过时间的磨洗可以变成美丽的珍珠。或许答案会是什么，更多的是因为你想要什么，内心贫瘠的土壤寸草不生，内心肥沃的土壤鲜花遍地。小姜内心善良所以懂得回报太子，但现在这个世界善良越来越被人忽视，小姜被老神仙视作圈养的猪啰，可太子会把他当作好朋友，所以说选择非常重要啦，遵从内心的选择更重要。 庖卯这个角色其实挺悲哀的，他代表是那一类被理想绑架而失去自我的人。“庖”在古代就是指厨师这一类职业，我们熟悉的庖丁解牛这个词就是出自这里。可在影片中颇为讽刺的是，一个想成为厨师的人的最大理想，居然是想要一刀取人心脏，我们不能说这种想法不是一份理想，用大护法的话说就是“你的理想，杀气这么重，怕是实现得一天，会是你的终年”。我们注意到卯和丁一字之差，所谓“丁是丁，卯是卯”，当你被仇恨蒙蔽双眼的时候，看到的东西和实际相比大概会相差很多吧！庖卯在听见花生人说话以后就开始呕吐，这种感觉让他开始思考，自己每天屠杀的到底是些什么东西。试想我们每天吃的这些食物开口说话的话，我们同样会感到恐惧的吧，或许我们想和疱卯一样成为一名绝世大厨，但现实给我们的却是一份杀人的差事，我想坚持初心，知道自己从哪里来要到哪里去，就不会在路上迷失方向，他的死作为一种解脱，在这个故事里算是善终了吧。 说了这么多，始终没有提到我们的大护法，个人感觉这个角色给我的印象确实不够深刻，它是一个古龙式的侠客形象，拥有和外表极不相称的武力值，这是一个用生命在战斗的人，从故事开头一直战斗到故事结尾，主角光环让它在断了数根肋骨后依然可以活到最后一刻，它是什么样子的呢？一个喜欢朗诵诗歌、自带莎士比亚腔调的文艺大护法，从台词的角度来讲，整部电影深刻中带着些许中二，但这部电影吸引的我，恰恰是这些硬伤很突出的地方，它整体的画风给人一种怪诞和虚无，可它的故事在国内审查体制下让人耳目一新，电影里说“假眼睛、假嘴巴都说贴着难受为什么还要贴？都摘掉它们会怎么笑话我？就因为怕被笑话，所以我们活成了笑话”，或许这是一部给成人看的童话，但透过这部电影多一点思考、多一点想象，大概是我们回报导演不思凡的最好方式之一，因为他想说的或许就是我们想说的。","tags":[{"name":"电影","slug":"电影","permalink":"http://qinyuanpei.github.io/tags/电影/"},{"name":"大护法","slug":"大护法","permalink":"http://qinyuanpei.github.io/tags/大护法/"},{"name":"童话","slug":"童话","permalink":"http://qinyuanpei.github.io/tags/童话/"}]},{"title":"基于过滤器实现异常处理的探索","date":"2017-05-20T20:10:28.000Z","path":"posts/570888918/","text":"&emsp;&emsp;正如你所看到的那样，今天我想和大家聊聊异常处理这个话题。对于异常处理这个话题，我相信大家都有各自的方法论。而我今天想和大家探讨的这种异常处理方案，我将其称之为基于过滤器的异常处理。我不知道这种定义是否准确，我们的项目上在要引入AOP的概念以后，我们对异常处理的关注点就从try-catch转向Interceptor。虽然首席架构极力推荐，使用Unity框架来拦截代码中的各种异常，可从我最初纠结于”return”和”throw”的取舍，到现在我可以灵活地使用和捕捉自定义异常，对我而言老老实实地实践异常处理的经典做法，比使用AOP这样一种高大上的概念要有意义地多，因为我相信在某些情况下，我们并不是真正地了解了异常处理。 异常和错误 或许是因为人类对机器时代充满了近乎苛刻的憧憬，我们的计算机程序在开始设计的时候，就被告知不允许出现错误，甚至我们的教科书上会用一种充满传奇色彩的口吻，来讲述一个因为粗心的工程师计算错了小数点而导致航天飞行器机毁人亡的故事。可是人类常常会对自己选择宽容，而对他人则选择严格，这种观点在整个数字时代更为凸显，当我们无法容忍一个糟糕的应用程序的时候，无论曾经人们为此付出过多少努力，在这一瞬间他们的价值都将不复存在。我们的这种苛刻迫使我们不允许软件出现错误，我们尝试通过各种各样的测试来避免错误发生，可是事实上软件工程实践最终会演变为一个妥协的产物，这意味着我们任何的形式化方法最终都会失败，没有人可以保证一生都不会犯错，而软件工程师同样是人，为什么我们一定要求他们不可以犯错呢？ 我们不得不承认软件产品是一个持续演进的过程，如果抛开商业意义上的Deadline来说，实际上软件是永远没有写完的那一天的，这就是为什么工程师都有点理想主义的原因，不考虑外界环境因素的变化，而期待软件永远不会有新的问题产生，这实在是一种苛刻地要求。好了，我们在这里频繁地提到错误，那么在软件工程学意义上的异常和错误分别是指什么呢？具体来讲，异常是指我们可以明确预测到它会发生并且需要我们进一步处理的流程，而错误是指我们无法明确预测到它会发生并且它会程序流程中断而导致程序崩溃，所以我认为区分”异常”和”错误”最直观、最简单粗暴的方法就是，如果你捕捉到了一个异常并处理了这个异常，那么它就是异常。反之，如果任由异常导致程序Crash，那么它就是错误。如果我们因为畏惧异常而给所有方法增加try-catch，我不得不遗憾得告诉你，你还没有真正明白什么是异常。 &emsp;&emsp;在早期的Win32 API中，微软大量使用了错误码来表示方法执行过程中发生的错误，这样就引出异常处理中的第一个问题，我们到底是应该是使用错误码还是异常来表示方法执行中发生的错误？事实上这两者在程序的表达能力上等价的，它们都可以向调用者传达”异常发生“这个事件，譬如我们在集合中查找一个元素，如果元素不存在则返回-1，这其实就是一个使用错误码来表示”错误“的经典案例，显然这种从C/C++时代遗留下来的传统解释了Win32 API为什么会选择这样的设计方式，换言之，选择哪种方式，本质上是一种从API风格、代码风格和性能指标等方面综合考虑后的结果，错误码这种方式的缺陷主要在于，错误码不能明确地告诉调用者到底发生了什么错误，除非我们定义更多的错误代码，而且在没有引入可空类型以前，我们没有办法避免错误码污染返回值的值域，比如在这个例子，如果集合中恰好有一个元素-1，那么通过-1这个返回值我们是没有办法判断出，这个-1到底是不是因为方法内部发生了错误而返回-1. &emsp;&emsp;好了，现在我们来说说异常，异常在主流的编程语言里基本上是一个标配。异常可以保存从异常抛出点到异常捕获点间的相关信息，所以异常相比错误码可以持有更多的信息，或许你可以尝试去设计一种数据结构来让返回值更丰富:)。我们常常听到”使用异常会降低程序性能”这样的说法，可这部分性能上的差异仅仅是因为，我们需要在抛出异常的时候给调用者更多的信息，所以这是一个非常公平的事情。第二个问题，我们是不是在所有情况下都使用异常？使用异常的好处是它可以让我们以一种更安全的方式去处理异常，可一旦发生了异常程序的性能就会降低，所以我们可以看到.NET中提供TryParse这样的方法，这其实是在告诉我们：如果预测到异常一定会发生，正确的策略不是去捕捉它而是去回避它。在《编写高质量的C#代码》一书中曾建议：不要在foreach内部使用try-catch，就是这个道理，即采用防御式编程的策略来回避异常，而不是总是抛出异常。 &emsp;&emsp;那么，总结下行文至此的观点：异常是强类型的，类型安全的分支处理技术，而错误码是弱类型的，类型不安全的分支处理技术。元组等可以让函数返回多个返回值的技术，从理论层面上可以模拟异常，即将更多的细节信息返回给调用者，可是这种方式相比由运行时提供支持的异常机制，在性能指标和堆栈调用上都存在缺陷。异常在被运行时抛出来的时候，程序性能是下降的，这是因为调用者需要更多的细节信息，所以不建议在所有场合都抛出异常，建议使用防御式编程的策略去回避异常，直到确定程序没有办法处理下去的时候再抛出异常。理论上所有自定义的异常都应该去捕捉并处理，否则定义这些自定义异常是没有意义的。异常处理应该拥有统一的入口，在代码中到处try-catch和记日志是种非常丑陋的做法，理论上应该坚决摒弃。 Checked Exception 最近垠神写了一篇新的文章《Kotlin和Checked Exception》，在这篇文章中垠神提到了Checked Exception这种针对异常处理的设计，而恰好我这篇文章写的同样是异常处理，并且我在下面提到的基于过滤器的异常处理方案，实际上就是为了解决这种Checked Exception的问题，虽然在.NET中不存在Checked Exception。 要了解什么是Checked Exception，要从Java中的异常机制说起。Java中的异常类全部继承自Throwable，它有两个直接子类Error和Exception，通常情况下Error是指Java虚拟机中发生错误，所以Error不需要捕捉或者抛出，因为对此表示无能为力；而Exception则是指代码逻辑中发生错误，这类错误需要调用者去捕捉和处理。那么在这样的分类下，Java中的异常可以分为Checked Exception(受检查的异常)和Unchecked Exception(未受检查的异常)，前者需要需要方法强制实现throws声明或者是使用try-catch，如果不这样做编辑器就会直接报错，后者就相对宽容啦，没有这样霸道的条款，可是诡异的是RuntimeException是一个UncheckedException，可它居然是继承自Exception而不是Error，这实在令人费解，Java的设计模式果然博大精深。 那么对一个Checked Exception，Java的处理方式是十分地霸道的，我们一起来看下面这段代码：1234void Foo(string fileName) throws FileNotFoundException&#123; if(...) throw new FileNotFoundException();&#125; 我们可以注意到Java强制让Foo()方法实现了throws声明，原因是在该方法内部可能会引发FileNotFoundException，如果我们不遵从这一”霸王条款”，那么我们的代码将无法通过编译，而在调用者层面上，Java的霸道则体现在要求调用者使用try-catch结构处理这种异常，或者继续使用throws声明来使异常继续向上传递，我更喜欢将这种设计称之为一种理想状态下的异常处理机制，比如我们读写一个文件的时候，除了FileNotFoundException以外，可能还会遇到FileLoadException、PathTooLongException、EndOfStreamException等等的异常，如果这些异常在业务层面上是无差别的，那么我认为将异常细分到如此精细的程度是没有意义的，因为对用户而言这个时候它关心的是否成功读写了这个文件，具体的异常原因用户并不想真的知道，可是Java的Checked Exception在面对这种处境的时候，整体而言是显得力不从心的，因为我们不得不在方法从声明该方法会引出哪些异常，这对方法的编写者和方法的调用者来说都很痛苦。 &emsp;&emsp;垠神这篇文章其实在说一个问题，Checked Exception鼓励开发者主动告知调用者来捕获特定异常，这种思路完全是没有问题的，问题是调用者如何能够知道它需要捕获哪些异常，我们不可能每次都通过”转到定义”功能去看一个方法会引发哪些异常，垠神从PL的角度出发，想到了通过代码静态分析的方法来处理异常，垠神吐槽的其实是不分青红皂白滥用try-catch的做法，实际上Java标准库里对异常处理相当混乱，虽然官方鼓励使用Checked Exception，但是标准库实现和工程实践上不乏将异常包装为RuntimeException来规避Check的做法，我认为Checked Exception在工程学意义上最大贡献是，在开发阶段该抛出什么异常就应该抛出异常，因为这样可以方便我们快读定位问题，而到了发布阶段则应该将这些异常都catch住即可，这样用户就不会看到这些奇葩的异常。换句话说，我们不必在程序中去处理所有的异常，而是将异常机制作为我们定位问题的工具，去捕获那些有可能出现的异常即可。 &emsp;&emsp;C#中其实是由类似Checked Exception的概念存在的，不过所有的Check都不是强制去实现的，我们知道.NET中一个方法会抛出哪些异常完全是由注释来说明的，XML注释中的exception节点表示该方法会引发何种异常，我们一起来看下面的例子：12345678910/// &lt;exception cref=\"MasterFileFormatCorruptException\"&gt;&lt;/exception&gt;/// &lt;exception cref=\"MasterFileLockedOpenException\"&gt;&lt;/exception&gt;public static void ReadRecord(int flag) &#123; if (flag == 1) throw new MasterFileFormatCorruptException(); else if (flag == 2) throw new MasterFileLockedOpenException(); // …&#125; 可以注意到C#采用的是一种相对温和的策略，即文档会明确告诉你，某个方法是否会引发异常以及引发哪些异常，但是是否要捕获这些异常则完全由调用者决定，我认为这是C#之父Hejlsberg在权衡后在工程实践上选择的一种妥协，因为Java的Checked Exception理想主义色彩稍重，并不是在所有场景下我们都需要去处理所有的异常，所以Checked Exception带来的问题是，即使在只需要捕获基类异常的情况下，我们依然不得不去捕获各种子类异常，这难道不有点矫枉过正的感觉吗？事实上所有工程实践中，不分青红皂白直接捕获Exception父类的做法，就是因为调用者完全不想关注发生得异常细节，这是垠神在文章中吐槽的”糟糕的代码”，C#相对Java在异常处理上好的一点就是，优秀的工程师会自觉地处理异常，如果他们清楚地知道异常会发生就一定会去捕获异常。你不能强迫他们去做他们不喜欢做的事情。 让异常处理更优雅&emsp;&emsp;好了，现在我们来考虑这样一个问题，设计Checked Exception的初衷是为了让我们处理业务逻辑中不同的具体的异常，当这些异常在业务逻辑层面上无差别的时候，其实我们可以完全忽略这些异常的细节，因为不管是哪种具体的异常，在业务逻辑层面都被认为是任务执行失败，这种情况下我们直接捕获基类异常即可，例如在读写文件的例子中我们关注IOException即可。那么如果这些具体异常在业务逻辑层面上存在差异呢？这种情况下我们就应该向Checked Exception方向靠拢，下面我们来一起听一个实际的故事。 &emsp;&emsp;我们的项目上需要从多个相互独立的系统中抓取数据并生成报表，因为这些系统在设计上都存在缺陷，所以在抓取数据的过程中非常容易出现错误，所以我们必须非常谨慎地处理这些异常，用户要求我们必须一种视觉友好的方式将报表输出出来，当异常发生时我们需要将抓取失败的数据高亮显示出来，并输出相关的错误信息来提醒用户来Check这些信息，而事实上每种异常发生的时候其处理逻辑是完全不同的。为此我们定义了将近10种的自定义异常，并为用户设计了完善的操作日志记录机制，这一切听起来非常不错，最终写出来的代码大概是下面这个样子：12345678910111213try&#123; Foo()&#125;catch(ExceptionA ex)&#123; &#125;catch(ExceptionB ex)&#123; &#125;catch(ExceptionC ex)&#123; &#125;carch(ExceptionD ex)&#123; &#125;// ... 相信在Java的相关工程实践中，这种教科书般的代码基本上是异常处理的金科玉律啦，可是这种代码实现写起来会让人感觉头重脚轻，因为我们所有重要的逻辑都写在了catch块里，这让我非常不喜欢这种”臃肿”的代码，而且事实上在这个案例中catch块里的代码具备可重用的可能，所以我决定以一种更优雅的方式来重构这段代码。数学领域中有一个不变的真理，即任何问题都可以通过引入一个新的问题来得到解决，这个理论在编程中同样适用，因为在公司里受到同事Wesley的影响，我对Ioc和AOP都从思想上有了一定认识，公司在推行Unity的过程中我并没有看到多少实际的意义，所以我对”道”的重视远远超过对”术”的追求，因为我相信框架学习起来并不会花费多少实践，可怕的是你从来不试图去了解框架背后的秘密，所以我借由AOP中拦截器和MVC中过滤器的概念，想到了我接下来要说的这种异常处理的方案。 其实我们在这里的核心目的是为了消除分支，所以采用多态是我们重构这部分代码的第一步。我们首先定义一个针对Foo方法的异常基类ExceptionBase，然后让这里的ExceptionA、ExceptionB、ExceptionC等全部继承自ExceptionBase，这样我们就可以将这些具体的异常子类向上转型为ExceptionBase统一进行处理。与此同时，我们注意到处理各种异常子类的逻辑各不相同，虽然我们可以直接将处理异常的逻辑写到异常中(通过一个虚方法来实现)，可这样会造成异常子类里的职责负荷，我更希望异常子类是一个朴素的贫血模型，所以我们这里引入过滤器的概念(不知道这样叫是否合适)，Filter全部继承自FilterBase，它有一个Invoke的方法，我们最终会在这里实现异常处理的方法，为此我们需要定义各种各样的Filter，然后通过Attribute将每一种Filter和特定的Exception关联起来，比如我们希望在所有异常的地方打日志，那么我们只需要实现一个LoggerFilter，然后给所有的Exception添加Attribute，这可以显著改善我们的代码。 现在，我们只需要给ExceptionBase类提供一个GetFilter()方法，该方法的返回值类型为FilterBase，我们将通过反射来创建一个Filter并将其返回，所以我们写出来的代码会是下面这个样子： 12345678[ExceptionFilter(FilterName = \"FilterA\")]class ExceptionA : ExceptionBase &#123; &#125;[ExceptionFilter(FilterName = \"FilterB\")]class ExceptionB : ExceptionBase &#123; &#125;[ExceptionFilter(FilterName = \"FilterC\")]class ExceptionC : ExceptionBase &#123; &#125; 此时此刻，我们的关注点就从一堆catch块中转移到了不同的filter中，虽然我们编写代码的工作量没有减少，但这样的做法无疑增强了代码的可维护性，因为我们只需要到不同的Filter里去修改逻辑即可，我在书上看到这样一句话，无论什么时候合并代码总是比拆分代码要容易，当你不确定某个功能是否要放在特定模块中的时候，最好的解决方案就是将他们完全独立设计。降低代码的耦合度是一件我们常常挂在嘴边的事情，可是如何去真正地降低代码耦合度，这件事情需要我们一直思考下去。好了，现在我们完成了分支结构上的精简，而最终调用的代码会是： 12345678try&#123; Foo()&#125;catch(ExceptionBase ex)&#123; var filter = ex.GetFilter(); filter.Invoke();&#125; 现在的代码是不是比原来清新了好多呢？虽然这相比真正的AOP还是稍显稚嫩，可它的出现成功地让一段”丑陋”的代码变得优雅起来，我们不必再担心修改异常处理流程时会原来的代码产生副作用，如果需要增加新的处理逻辑我们继续派生异常类和过滤器即可，这就是代码设计上以不变应万变的道理，你要相信程序员都是非常懒惰的，如果有可以不用修改代码就适应变化的设计，他们是一定会喜欢的，因为这个世界对程序员并不友好，如果你不想你的代码被这个世界修改得面目全非，最好的选择就是不给它们这样的机会，他们说人长大一定会变成自己讨厌的样子，我想告诉这个世界永远不要忘记初心。 好了，这篇文章唠叨到现在，写了大概5000多字，花了我整整两个下午的时间，我在向Paul和John询问这个问题的看法时，他们都告诉我这个问题没有好的解决方案或者是劝我不要做这样探索，可是事实上我只用了半天时间就完成了这个设计，在去年的时候我曾向房燕良前辈请教好异常处理的问题，当时我的关注点主要在使用错误码还是使用异常。在上一个项目中，我对于异常处理其实实践得并不好，因为我一直不知道哪里是捕获异常的入口，我个人并不认同直接捕获到异常直接throw这种做法，因为你在自定义异常的时候就应该想清楚，哪些异常是需要捕获并处理的，哪些异常时可以直接让它Crash的，如果每个人都仅仅是抛出异常而不去拦截异常，那么异常机制设计得再好又有什么用呢，关于Java的异常有一个梗，是说Java的异常给出了详细的堆栈信息，可就是不直接告诉你到底是哪里异常了，事实证明我设计的这个方案运行的很好，其实我很想吐槽操作日志真的有存在的必要吗？很多时候，我们要学会遵从自己内心的声音，所谓世间难道不就是我们吗？真正绑架我们的永远都只有别人，让我们时刻谨记：万物为虚，万事皆允。","tags":[{"name":"异常","slug":"异常","permalink":"http://qinyuanpei.github.io/tags/异常/"},{"name":"设计","slug":"设计","permalink":"http://qinyuanpei.github.io/tags/设计/"},{"name":"架构","slug":"架构","permalink":"http://qinyuanpei.github.io/tags/架构/"}]},{"title":"异步Lambda表达式问题的探索","date":"2017-04-15T21:10:47.000Z","path":"posts/187480982/","text":"各位朋友，大家好，欢迎大家关注我的博客，我是Payne，我的博客地址是:http://qinyuanpei.com。今天博主想和大家探讨的是，.NET中异步Lambda表达式的问题。为什么要讨论这个问题呢，这或许要从公司首席架构推广内部框架这件事情说起。我其实很久以前就有这种在团队内部做技术演进的想法，即通过公共类库、团队Wiki和技术交流等形式逐步地推进和完善团队整体架构的统一，因为一个团队在业务方向和技术选型上基本是一致的，因此团队内的技术演进对提高开发效率和交付质量意义重大，所以我能理解首席架构在内部推广公共类库这件事情，因为除了KPI这种功利性的目标以外，从长远来看这些东西对一个团队来说是积极而有利的，可是我们都知道工程师是这个世界上最傲慢的人，如果一个东西设计得不好，他们一定会尝试去改进甚至重新设计，所以架构并非是一种虚无缥缈的、凭空想象出来的东西，它的存在必须是为了解决某种问题。 所以我始终认为，架构设计必须由一线开发人员来提炼和抽象，因为只有真正经历过”坑”的人，才会清楚地知道团队里最需要解决的问题是什么，一个良好的架构绝对不是由某些所谓”专家”闭门造车的结果，你只有真正了解了一个问题，懂得如何去定义一个问题，你才会知道目前这个团队中最迫切需要去解决的问题是什么，虽然说团队里技术层次存在差异，一个技术选型必然会和普通社会学问题一样存在众口难调的情形，可是一个东西设计得不好它就是不好，你不能强迫团队成员必须去使用它，因为这实在有悖于”自由”和”分享”的黑客文化。我相信软件开发没有银弹可言，这意味着它没有一种一劳永逸的解决方案，即使它的抽象层次再高、代码鲁棒性再好，所以团队内部技术演进应该采取”自下而上”的方式，对待工程师最好的方式就是给他们充分的自由，”自上而下”的行政命令不适合工程师文化，自计算机文明诞生以来，那种来自内心深处的”极客思维”决定了我们的基因，所以啊，”请原谅我一生不羁放纵爱自由”。 好了，现在回到这个问题本身，问题产生的根源来自ICommand接口，而我们都知道该接口主要承担命令绑定作用。通过ICommand接口的定义我们可以知道，ICommand接口的Execute方法是一个同步方法，因此常规的做法如RelayCommand或者DelegateCommand，基本上都是传入一个Action来指向一个具体方法，最终ICommand接口中的Execute方法执行的实际上是这个具体方法。截止到目前为止，这个策略在主流的场景下都实施得非常好，可是我们在引入Task、async/await这些新的概念以后，我们突然发现ICommand接口存在一个亟待解决的问题，即它缺乏一个支持异步机制的Execute方法，显然这是一个历史遗留问题。 我开始关注这个问题是当我在同事John和Charles的项目中看到类似下面的代码，事实上他们都是非常优秀的高级工程师，在对这个问题理解和探讨的过程中，我要特别感谢他们愿意分享他们的想法。我们一起来看看下面的代码：123456789public RelayCommand RunCommand&#123; get &#123; return new RelayCommand(async ()=&gt;&#123; /* await awaitable */ &#125;); &#125;&#125; 请相信你的眼睛，因为你没有看错，让我倍感纠结的的正是这样一段简单的代码。这段代码让我迷惑的地方有两处，第一，RelayCommand实现了ICommand接口，而ICommand接口的Execute方法是一个同步的方法，为什么我们可以在这个里传入一个异步方法，并通过Action这种委托类型来对其进行包装；第二，Action是一个void类型，即无返回值的委托类型，我们这里显然使用async关键字修饰了一个无返回值的方法，因为我们在这个匿名方法内部使用了await语法。可是我们知道微软官方的建议是，使用async关键字来修饰一个返回值类型为Task或者Task的方法。在我了解到async关键字还可以这样使用以后，对第二处疑惑我稍稍有些许释怀，因为事实上Charles就是正式通过这种思路来启发我，可我始终无法理解，为什么我们可以在一个同步的方法里执行一段异步代码，并试图去安慰自己说这段代码是异步的，在执行一个非常耗时的任务时界面不会阻塞。 我们的项目需要在整个任务执行过程中输出操作日志，这意味着消息会实时地输出到界面上并且不会阻塞界面。我们在为此设计了一个基于观察者模式的消息队列，所有需要发送实时消息的模块被抽象为一个消息主题，而界面模块、日志模块等被抽象为消息观察者，所有订阅过的消息主题都会将消息推送到消息队列中，这一切目前在设计上是符合业务需求的。可是很快我们就会发现一个问题，使用await或者Wait()方法时，消息并不是实时地发送到界面上去的，因为我们知道await或者Wait()方法会一直等待一个异步任务执行完成，所以消息会在任务结束的一瞬间被全部发送到界面上，这显示是不符合我们的期望的，所以Execute()方法里执行的必然是一个同步方法，它不会因为我们传入了一个异步方法而改变，况且同步和异步是相对而言的，如果我们将await语法修改为Task.Run()，我们就会发现在异步任务执行完成前同步方法就开始执行了，而这正是我们想要的结果。 在这里我更感兴趣的一个问题是，.NET框架中的委托、匿名方法、Lambda表达式和Task是不同时期.NET的产物，那么我们在这里使用一个async关键字来修饰一个匿名方法，编译器在处理它的时候到底会怎么做呢？因为我们知道委托会被编译成一个包装类，那么现在在这篇文章中的提到的这个问题背景下，它会有什么不同呢？我们一起来看下面的代码： 12345static void Main(string[] args)&#123; Action action1 = async () =&gt; await DoWorkAsync(); Action action2 = () =&gt; DoWork();&#125; 我们注意到这里声明了两个Action，即两个没有返回值的委托类型，它们的不同点在于前者使用了async/await这两个关键字，而后者则是一个普通的同步方法，那么这两者生成的IL代码是否有区别呢？我们可以通过IL DASM或者是IL Spy这两个工具来查看IL代码： 查看IL代码 我们可以注意到两点，第一，两个委托类型生成的中间代码完全一致，都是CachedAnonymousMethodDelegate，这在某种程度上说明不管Action里包装的是一个同步方法还是一个异步方法，最终生成的IL代码应该都是相同的。第二，同匿名方法和扩展方法一样，async/await并未引入新的IL指令，async/await内部应该是在维护一个状态机，这一点和yield关键字应该是相似的，并且对于异步的匿名方法(指voild类型)，通过IL代码可知它是由AsyncVoidMethodBuilder类来生成的，而对于异步的方法(指Task和Task类型)，则是由AsyncTaskMethodBuilder类来生成，需要说明的是这两者在功能上相差无几，唯一的区别就在于异常处理。 关于异步编程中异常的处理，老赵在其博客关于C#中async/await中的异常处理（上）和 关于C#中async/await中的异常处理（下）这两篇博客中做了非常详细的解释，建议大家有时间的话去阅读这两篇文章，我们在这里关注结论就好。 具体来讲，async Task或者async Task方法引发异常时，会捕获异常并将其放置在Task对象里，并且只有Task对象被await时会引发异常。特别地，在调用Task.WhenAll()方法时，一个Task对象中可能会含有多个异常，此时await仅仅会重新抛出第一个异常，但是在 Task 上使用 Task.Wait 或 Task.Result 同步阻塞时，所有异常都会用 AggregateException 包装后引发。对于嵌套的Task，即含有子任务的Task，应该采用AggregateException来获取和处理所有的异常。Task/Task中未捕获的异常可以通过TaskScheduler.UnobservedTaskException来处理，这些异常不会继续向上抛导致程序异常退出。 async void方法引发异常时，因为它没有Task对象来放置异常，因此它的异常SynchronizationContext上引发，而且因为AsyncVoidMethodBuilder内部并没有使用TaskScheduler，因此对于async void方法来说，线程池中未捕获的异常将会一直向上抛并最终导致程序异常终止，虽然我们可以在AppDomain.UnhandledException这个事件中捕捉到这些”未处理的异常”，但这并不能阻止程序异常终止，通过我们可以通过注册这个事件来记录异常日志，以帮助我们快速定位问题。 好了，现在我们回到这篇文章开始的问题，我们现在知道async Task和async Task引发的异常，都不会是程序立即终止，除非我们显式地去await一个Task对象会引发异常，可是对async void来讲，一旦它引发异常，常规的try-catch时无法捕捉到异常的，这种”未处理的异常”会一直向上抛并最终导致程序异常终止。我为什么要说这个问题呢，因为我们在文章开始的时候写了一个异步的lambda表达式，最终它会被编译为async void，我们现在应该会了解到，async void非常容易引发未处理的异常并导致程序异常退出，所以这是微软官方最佳实践中不推荐使用async void的原因，因为使用async void就意味着我们要去捕获所有的异常。可是对标记为async的lambda表达式来讲，这个问题是非常隐蔽而且蛋疼的，或许不使用async void就是最为正确的选择了吧！ 最后，其实坦白讲，我自己是不清楚在这篇文章里我到底说什么的，因为这样一个在项目开发中遇到的问题，其实并不是一个特别重要的内容，因为它实在是太容易被我们给忽略啦。我最初关注这个问题完全是因为好奇，因为我从来没有见到过这种lambda表达式的写法，虽然纠结这样一个语法上的问题，和孔乙己讨论茴香豆的”茴”字由几种写法一样，都是一个相当迂腐不堪的表现，可我庆幸这份好奇让我了解到了更多的东西。其实总结下这篇文章中关注的点，主要有： 由同步方法和异步方法包装的委托类型在IL层面上是无差别的，委托关注的是参数列表和返回类型，和是否有async关键字修饰没有关系。 匿名方法或者lambda最终依然会被编译为一个方法，在有async关键字修饰的情况下，建议使用Func而不是Action，因为前者可以生成async Task或者async Task，而后者仅仅可以生成async void。 async Task/async Task和async void在异常处理机制上存在差异，前者未处理的异常不会继续向上抛导致程序异常退出，而后者未处理的异常会继续向上抛并导致程序异常退出，因此如果坚持要使用async void，就一定处理各种异常。 参考文章：Microsoft - async/await - 异步编程中的最佳做法TianFang - C# 5.0 async 函的提示和技巧","tags":[{"name":"异步","slug":"异步","permalink":"http://qinyuanpei.github.io/tags/异步/"},{"name":"编程","slug":"编程","permalink":"http://qinyuanpei.github.io/tags/编程/"},{"name":"Lambda","slug":"Lambda","permalink":"http://qinyuanpei.github.io/tags/Lambda/"}]},{"title":"Redis缓存技术学习系列之发布订阅","date":"2017-04-15T21:03:57.000Z","path":"posts/1444577573/","text":"各位朋友，大家好，我是Payne，欢迎大家关注我的博客，我的博客地址是http://qinyuanpei.com。最近这段时间的天气可谓是变幻莫测，常常是周一到周五像夏天般热烈，而周六和周天像秋天般冷清。你不知道它到底会在何时下雨，即使你可以一直带着伞等雨落下来。但是对于没有伞的我来说，学会努力奔跑以至于不那么狼狈，或许是在这个世界上我唯一可以去做的事情。可是你知道一个人孤独的时候，即使是下雨这种再平常不过的事情，他都可以从雨声里听出孤独的感觉来，所以这个周末我决定继续研究Redis缓存技术，而今天我想和大家讨论的话题是Redis中的发布-订阅(Pub-Sub)，希望大家喜欢！ 从观察者模式说起 如果你熟悉常见的设计模式，就应该会知道在24种设计模式中，有一种称为观察者模式的设计模式，该模式又被称为发布-订阅模式。在正式讨论Redis中的发布-订阅特性前，我想先花点时间来为大家讲解下这种设计模式。观察者模式定义了一种一对多的依赖关系，让多个观察者同时监听同一个主题对象，当该主题对象在状态发生变化时，会通知所有观察者对象并使其自动更新自己。下面是该模式的UML类图： 设计者模式的UML类图 通常我们提到设计模式的时候，都认为实际模式是非常抽象而晦涩的概念，事实上设计模式是一种经过反复验证的编程经验。我们每天面对这个世界对其进行抽象并认识它，所以设计模式本质上是根植自生活的一种编程思想。以观察者模式为例，我们或许会在微信里订阅各种各样感兴趣的公众号，当这些公众号的内容发生更新时，就会主动向我们推送新的内容。在这里，我们订阅的公众号称为”主题”，而我们则称为”观察者”或者”订阅者”，而这正是观察者模式又被称为”发布-订阅模式”的原因所在，这种定义了一种一对多的依赖关系，让多个观察者同时监听同一个主题对象，当该主题对象在状态发生变化时，会通知所有观察者对象并使其自动更新自己的设计模式就被称为”观察者模式”。而通过这张图我们可以了解到，观察者模式试图解决的问题是，在不同的实例对象间相互协作的时候，如果在降低其各自耦合度的同时，维持这些示例对象间的一致性。在该模式中，主要存在四种角色，即： 抽象主题(Subject)：抽象主题将所有观察者对象的引用保存到一个集合里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加(Attach方法)和删除(Detach方法)观察者对象。 具体主题(ConcreteSubject)：具体主题将在其内部定义相关状态，并将相关状态存入具体观察者对象。在具体主题内部状态发生变化时，通知所有注册过的观察者发出通知，即UML类图中定义的Notify()方法。 抽象观察者(Observer)：抽象观察者将为所有具体的观察者定义一个接口，在获得主题更新通知时更新自己，即UML类图中定义的Update()方法，执行该方法后观察者与主题的状态实现同步。 具体观察者(ConcreteObserver)：具体观察者将实现抽象观察者所定义的更新接口，来使得观察者自身的状态与主题状态协调，即具体观察者需要重写Update()方法并维护其内部状态同主题保持一致。 至此我们就从思想上理解了观察者模式，观察者模式本质上是在维护一种一对多的依赖关系，因为观察者与主题都是依赖于抽象而非具体，两者分别属于两个不同层次上的抽象，因此观察者和主题两者间是解耦的。可是当你去实现一个具体的主题或者具体的观察者的时候，你会发现这两者间依然存在一定的依赖，因为观察者和主题在接口设计上需要协调，因为两者分别作为消息的”接收方”和”发送方”存在。观察者模式虽然在解耦上效果显著，可这并不代表它就是完美的。事实上，当观察者数目特别多的时候，为了通知所有的观察者将花费大量的时间；其次，当观察者间存在依赖关系时，观察者模式将导致这些观察者出现循环调用；再者，当主题通过异步的方式来通知观察者时，需要考虑通知本身是以自洽的方式进行的；最后，观察者模式可以确保观察者捕捉到主题的变化，可是观察者模式机制本身不具备知晓主题如何变化的能力。好了，下面我们来讲解如何实现一个基本的观察者模式。 观察者模式的实现 现在，我们已然了解到在观察者模式中主要有四类角色，即抽象主题、抽象观察者、具体主题和具体观察者。因此，要实现观察者模式，实际上就是要实现这四种不同的角色。回到我们最初讨论过的场景，即微信用户订阅公众号，假设博主希望在博客更新的时候，以邮件或者公众号的形式来通知读者朋友博客更新的内容，这是一个典型的一对多的依赖关系维护的问题，显然此时观察者模式是一个最佳的设计思路。在这个设计中，邮件和公众号是两个具体的观察者，而博客是一个具体的主题。参照观察者模式的UML类图，我们应该首先提取出来两个抽象类，即Subject和Observer。 对Subject类而言，首先它需要提供一个订阅(Subscribe的方法和取消订阅(Unsubscribe)方法，这和我们在日常生活中订阅报纸是完全一样的；其次，它需要有一个更新(Update)的方法，该方法负责向所有的订阅者广播消息。为什么叫做广播呢？因为所有的订阅者都会收到这条消息，这种订阅者被动接受主题推送消息的方式我们称为”推送模式”，即在Update的时候，主题会主动推送”参数”给订阅者；而订阅者主动拉取主题消息的方式我们称为”拉取模式”，即在Update的时候，主题并不主动推送”参数”给订阅者，而是由订阅者通过注入的主题来获取消息。这两种方式我们都可以称之为观察者模式，在这里我们选择”推送模式”，代码实现如下： 12345678910111213141516171819public abstract class Subject&#123; private IList&lt;Observer&gt; observers = new List&lt;Observer&gt;(); public void Attach(Observer observer) &#123; observers.Add(observer); &#125; public void Deatch(Observer observer) &#123; observers.Remove(observer); &#125; public void Notify(string message) &#123; observers.ToList().ForEach(o =&gt; o.Update(message)); &#125;&#125; 对Observer而言，它在观察者模式中承担着消息接收者的角色，所以我们需要为其定义好接收消息的接口，需要注意的是该接口必须与具体主题保持一致，这便是我在文章中提到的，主题和观察者存在一定程度依赖的问题。考虑到不同的观察者所做的事情是完全不同的，例如邮件和公众号采取两种不同的方式来推送消息，因此Update方法应该被声明为虚方法，以为不同的观察者提供重写的扩展能力。它的代码实现如下： 1234567public abstract class Observer&#123; public virtual void Update(string message) &#123; &#125;&#125; 对具体观察者而言，我们需要做的就是继承Observer类然后重写Update方法，在这里我们需要实现两个不同的类EmailObserver和WechatObserver，它们分别来实现邮件和公众号接收到主题推送消息以后的逻辑，这里以EmailObserver为例，代码实现如下：1234567public class EmailObserver:Observer&#123; public override void Update(string message) &#123; Console.WriteLine(\"邮箱接收到订阅消息:&#123;0&#125;\", message); &#125;&#125; 对具体主题而言，我们不再关心如何向所有的观察者发送消息，该功能在Subject父类中已然完成。我们可以为新的主题类添加更多的属性来描述其内部发生变化时的状态，例如文章数目、评论数目或者是内容更改等等。在这个例子中我们选择最简单的方式，即简单通知这两个观察者，因此我们直接继承Subject类即可。此时，完整的调用代码如下：1234BlogSubject blog = new BlogSubject();blog.Attach(new EmailObserver());blog.Attach(new WechatObserver());blog.Notify(\"Payne更新了Redis缓存技术学习系列文章\"); 好了，现在通过下面的截图，我们就可以看到两个观察者EmailObserver和WechatObserver，都接收到了来自主题Blog的消息推送。这就是观察者模式啦，看起来是不是非常简单。可是相信大家使用公众号以后就会发现一个问题，随着你订阅的内容越来越多，你的微信消息列表里出现的消息推送就越来越多，这个时候如果你不想接收消息推送该怎么办呢？答案好像只有一个，那就是取消订阅。这个场景可以看出”推送模式”让订阅者饱受消息骚扰，而为了解决这个问题，我们就有了”拉取模式”，此时主题仅仅是告诉观察者博客内容有更新，而更新的内容需要观察者自己去处理，这种模式大同小异，大家可以参照”推送模式”来自己实现。 观察者模式基本实例 这些就是观察者模式的核心内容啦，观察者模式的优点是它解除了主题和观察者间的耦合，并且使得这两者各自都依赖于抽象而非具体，观察者模式适用的场景是当一个对象的改变需要给变其它对象时，而且它不知道具体有多少个对象有待改变时。在C#中我们可以通过委托、事件以及Observable接口这三种方式来更好、更快的实现观察者模式，自然这些都是后话啦，如果以后有机会我们可以继续进行探讨。 Hey Redis Pub-Sub 好了，了解完观察者模式即发布-订阅模式以后，我们现在就可以开始学习Redis中的发布-订阅模式啦。为什么我们要在开始学习Redis中的发布-订阅模式前，了解设计模式相关的概念呢？这是因为Redis中的发布-订阅模式和Gof设计模式一脉相承，譬如事件机制、消息机制等概念其实都是观察者模式的一种实际应用，一旦我们掌握了观察者模式的核心思想，即使这个世界充满了套路，可是这对你我而言又有什么不同呢？我们学习设计模式不是为了记住这些类图，而是能在最恰当的场景中合理使用这些模式来解决问题，这是我们学习的最终目的。 Redis中的发布-订阅模式是一种消息通信模式，即发布者发布消息，订阅者接收消息。在Redis中客户端可以订阅任意个频道，当该频道内接收到一个新消息时，所有订阅该频道的客户端都会收到这条新消息。我们可以这样理解这种消息通信模式，我们每个微信账号都是一个客户端，每个客户端都可以订阅任意个微信公众号，当微信的后台服务上接收到某个微信公众号的请求消息时，所有订阅了该微信公众号的客户端都会收到该推送。一个简单的图示如下： Redis中的消息模式 我们可以注意到这和我们在文章中提到的”观察者模式”非常相似，在这个通信模式下，客户端作为消息的订阅者，即观察者。而频道作为消息的发布者，即主题。在Redis中频道是一个字符串类型的值，你可以将其理解为一个Id。虽然我们在这篇文章中花费大量时间来讲观察者模式，事实上Redis中的发布-订阅是非常轻量并且强大的，下面是常见的命令： PSUBSCRIBE：该命令用于订阅一个或者多个符合模式匹配的频道 PUBSUB：该命令用于返回由活跃频道组成的列表，即可以查询订阅与发布系统的状态 PUBLISH：该命令用于发送消息到指定的频道 PUNSUBSCRIBE：该命令用于退订所有符合模式匹配的频道 SUBSCRIBE：该命令用于订阅一个或多个频道 UNSUBSCRIBE：该命令用于退订一个或多个频道 以上这些就是和发布-订阅相关的命令啦，从整体上而言它是相当简洁和紧凑的。在这篇文章中我们通篇都在说观察者模式，事实上Redis的发布-订阅从本质上来讲还是观察者模式，Redis内部会维护一个频道的字典，首先它会从频道字典中查找所有的客户端，如果字典中不存在该频道，则将订阅该频道的客户端列表添加到字典中，否则它会返回字典中已经存在的客户端列表。在获取到所有客户端列表以后，Redis将会遍历客户端列表中的客户端，然后给每个客户端发送消息，这部分代码的解读可以参考这篇文章：15天玩转redis —— 第九篇 发布/订阅模式。好了，这篇文章暂时就是这样子啦，为什么感觉最近学习Redis没有动力了呢？这篇文章没有实际的命令演示，这是因为我是在Windows系统下写完的这篇文章，深夜啦，睡吧！ &emsp;&emsp;现在我们一起来看一个简单的示例，在这个示例中我们让两个客户端A和B，订阅同一个频道News，然后由客户端C来向这个频道News广播一条消息，理论上客户端A和客户端B都将会收到这条消息，需要注意此时服务端是开启的。首先，对于客户端A和客户端B，我们在两个不同的终端窗口中打开redis-cli，然后输入命令： 1&gt; SUBSCRIBE News 在按下回车后，我们可以看到下面的信息： 1231) \"subscribe\"2) \"News\"3) (integer) 1 好了，现在我们在客户端C中来广播一条消息： 1&gt; PUBLISH News \"This is a message sent by 127.0.0.1:6379\" 此时我们可以看到下图中所示的结果： Redis中发布订阅模式","tags":[{"name":"Redis","slug":"Redis","permalink":"http://qinyuanpei.github.io/tags/Redis/"},{"name":"缓存","slug":"缓存","permalink":"http://qinyuanpei.github.io/tags/缓存/"},{"name":"设计模式","slug":"设计模式","permalink":"http://qinyuanpei.github.io/tags/设计模式/"}]},{"title":"Redis缓存技术学习系列之事务处理","date":"2017-04-08T21:46:40.000Z","path":"posts/335366821/","text":"&emsp;&emsp;在本系列的第一篇文章中，我们主要针对Redis中的“键”和“值”进行了学习。我们可以注意到，Redis是一个C/S架构的数据库，在我们目前的认知中，它是通过终端中的一条条命令来存储和读取的，即它是一个非常典型的“请求-响应”模型。可是我们知道在实际的应用中，我们要面对的或许是更为复杂的业务逻辑，因为Redis中不存在传统关系型数据库中表的概念，因此在使用Redis的过程中，我们要面对两个实际的问题，即如何更好的维护数据库中的”键“、如何在高效执行命令的同时保证命令执行成功。对于前者，我认为这是一个设计上的问题，而对于后者，我认为这是一个技术上的问题。所以，这篇文章的核心内容就是找到这两个问题的答案。带着这样的问题出发，我们就可以正式进入这篇文章的主题：Redis中的事务处理。 从数据库事务说起​&emsp;&emsp;通常我们提及数据库都不可避免的要提到事务，那么什么是事务呢？事务是指作为单个逻辑工作单元执行的一系列操作。所以，首先事务是一系列操作，这一系列操作具有二态性，即完全地执行或者完全地不执行。因此事务处理可以确保除非事务单元内的所有操作的成功完成，否则不会永久更新面向数据的资源。我们这里举一个例子，数据库中除查询操作以外，插入(Insert)、删除(Delete)和更新(Update)这三种操作都会对数据造成影响，因为事务处理能够保证一系列操作可以完全地执行或者完全不执行，因此在一个事务被提交以后，该事务中的任何一条SQL语句在被执行的时候，都会生成一条撤销日志(Undo Log)，而撤销日志中记录的是和当前擦作完全相反的操作，比如删除的相反操作是插入，插入的相反操作是删除等。我们通常所说的事务回滚其实就是去执行这些插销日志里的相反操作，这同样告诉我们一个道理，只有事务中的一系列操作完全执行的情况下可以回滚，如果是在意外情况下导致事务中的一系列操作没有完全执行，这个时候我们是不能保证数据一定可以回滚的。 ​&emsp;&emsp;在数据库相关理论中，一个逻辑工作单元想要成为事务，就必须满足ACID，即原子性、一致性、隔离性和持久性。(1)：原子性这个概念其实就是指，一个事务内的所有SQL操作都是一个整体，因此只有所有的SQL操作都完全执行成功，该事务方可以认为提交成功。如果在提交事务过程中某一条SQL语句执行失败，则整个事务必须回滚到事务提交前的状态。(2)：而一致性这个概念则是指，事务在完成的时候，必须要保证所有的数据都保持一致的状态，而落实到数据库的各个组成部分上，则要求开发人员能够保证数据、索引、约束、日志等在事务前后具备一致性。(3)：隔离性这个概念主要针对并发，其核心思想就是不同的并发事务对数据产生的修改必须是相互隔离的，假设有两个不同的事务A和B并发执行，那么对A来讲，它在执行前的状态只有两种，即B执行前和B执行后。同理，对B来讲同样是如此，这样的特性我们就称为隔离性。(4)：持久性相对简单，是指事务完成以后它对数据的影响是永久性的。 Redis中的事务处理​&emsp;&emsp;好了，截止到目前为止，我们对数据库中事务处理的相关理论有了一个基本的认识，或许这个世界上的数据库系统千差万别，但我相信在事务处理这个问题上它们最终会殊途同归，就像我们解决并发过程中的冲突问题，常规的做法依然是加锁一样，这是我之所以要花费精力去理解和解释这些理论知识的原因，技术可谓是日新月异，如果我们总是一味地为新技术而疲于奔命，那么或许我们会渐渐地失去对这个行业的热爱，我相信原理永远比框架更为重要，没有系统学习过计算机专业的课程，这件事情让我至今都颇为遗憾。Redis中的事务是可以视为一个队列，即我们可以通过MULTI开始一个事务，这相当于我们声明了一个命令队列。接下来，我们向Redis中提交的每条命令，都会被排入这个命令队列。当我们输入EXEC命令时，将触发当前事务，这相当于我们从命令队列中取出命令并执行，所以Redis中一个事务从开始到执行会经历开始事务、命令入队和执行事务三个阶段。下面是一个在Redis中使用事务的简单示例： 123456789101112127.0.0.1:6379&gt; MULTIOK127.0.0.1:6379&gt; SET Book_Name \"GIt Pro\"QUEUED127.0.0.1:6379&gt; SADD Program_Language \"C++\" \"C#\" \"Jave\" \"Python\" QUEUED127.0.0.1:6379&gt; GET Book_NameQUEUED127.0.0.1:6379&gt; EXEC1) OK2) (integer) 43) \"GIt Pro\" 我们可以注意到Redis中的事务和通常意义上的事务基本上是一致的，即 事务是由一系列操作组成的单个逻辑工作执行单元。特别地，因为在Redis中命令是存储在一个队列中，所以，事务中的所有命令都会按顺序执行，并且在执行事务的过程中不会被客户端发送的其它命令中断。 事务是一个原子操作，事物中的命令只有两种执行结果，即全部执行或者全部不执行。如果客户端在使用MULTI命令开启事务后因为意外而没有执行EXEC命令，则事务中的所有命令都不会执行。同理，如果客户端在使用MULTI命令开启事务后执行EXEC命令，则事务中的所有命令都会执行。 Redis中的事务可以使用DISCARD命令来清空一个命令队列，并放弃对事务的执行。如果命令在入队时发生错误，Redis将在客户端调用EXEC命令时拒绝执行并取消事务，但是在EXEC命令执行后发生的错误，Redis将选择自动忽略。 &emsp;&emsp;我们知道，常见的并发控制方案主要有悲观锁和乐观锁两种方案，这里首先来解释下这两种概念。所谓悲观锁，顾名思义是一种悲观的策略，悲观锁认为：在对任何记录做修改前都应该加锁，如果加锁失败则表明该机录正在被修改，此时应该抛出异常；如果加锁成功则修改记录并在事务完成后解锁；如果有其它人修改则应该等待当前修改解锁或者是抛出异常。而所谓乐观锁，顾名思义是一种乐观的策略，乐观锁认为：每次从记录中查找数据别人都不会修改，因此这个过程中不需要加锁，但是在更新记录的时候，会通过版本号来判断别人是否修改过当前记录。 &emsp;&emsp;通常来讲，乐观锁适合在写冲突相对较少的场合下，悲观锁适合在写冲突相对较多的场合下。Redis中提供了一种称为check-and-set的机制，该机制主要通过WATCH命令来实现，其原理正是基于乐观锁的策略，Redis会在执行EXEC命令前检查被监视的键对应的值是否发生变化，如果该值发生变化表明有人修改过这个键中存储的值，此时Redis将会自动取消当前事务。我们来看这个简单的例子： 123456WATCH Record_Countval = GET Record_Countval = val + 1MULTISET Record_Count $valEXEC &emsp;&emsp;在这个例子中，我们尝试在事务中对Record_Count做一个自增操作，这段代码在非并发的情况下是没有问题的，可是在并发的情况下，如果在执行EXEC命令前有一个用户修改了Record_Count的值，那么我们此时的结果就会比期望的结果小1，现在我们有了WATCH，Redis就会对Record_Count进行监听，当Redis监听到该值发生变化的时候，这个事务就会被自动取消，进而避免造成冲突。 如何管理Redis的键​&emsp;&emsp;其实从切题的角度来讲，这篇博客基本上说清楚了事务处理问题，因此这篇博客虽然没有给大家带来多少惊喜，却依然可以非常恰到好处的结题，可是因为之前有朋友在博客中留言并问到Redis的键管理的问题，所以博主决定在这里简单的讨论下这个问题，鉴于博主和大家一样都是感刚接触Redis，所以下面的观点仅仅是一家之言，如果有疑问可以在博客中留言，欢迎大家批评指正。我认为Redis中的键的管理，基本上有两种策略，即惰性删除和定期删除，而实际上这正是Redis默认的键删除策略： redis使用惰性删除和定期删除两种策略来删除过期的键：惰性删除策略在碰到过期键时方进行删除操作，定期删除策略则每隔一段时间主动查找并删除过期键。 所以，基于这两种键删除策略，我们可以想到的做法有： 对于临时变量可以采用临时键来存储，在数据库全局设定一个过期时间，由Redis在键过期后自动删除。 对于持久化数据可以采用普通键来存储，通过服务器和客户端间定义协议来由客户端主动删除键。 对于不同模块中的键采取统一规范的命名规则来命名键，从而解决Redis中键管理混乱的问题。 设计合理的键回收机制，避免Redis使用超过95%以上的内存，或者通过设置Redis中的最大内存容量及其内存策略来主动触发Redis对键的淘汰。具体可以参考：Sunnyxd - Redis学习笔记-事务、键空间的维护与性能 &emsp;&emsp;好了，这篇文章就是这样了，希望大家喜欢，下篇见！","tags":[{"name":"Redis","slug":"Redis","permalink":"http://qinyuanpei.github.io/tags/Redis/"},{"name":"缓存","slug":"缓存","permalink":"http://qinyuanpei.github.io/tags/缓存/"},{"name":"数据库","slug":"数据库","permalink":"http://qinyuanpei.github.io/tags/数据库/"}]},{"title":"时间如灰烬般遥远","date":"2017-04-03T00:25:21.000Z","path":"posts/1357715684/","text":"&emsp;&emsp;春天，常常是万物复苏的日子，是以这段时间喜欢去各种地方赏花阅景。相比起三月中旬里裹挟着清冷的青龙寺，此刻到处人山人海的景象，仿佛洋溢着某种热闹的气息。从前读朱自清的《荷塘月色》，一直不明白“热闹是他们的，我什么都没有”这句话该做何解。当你面对梨花胜雪、桃花人面的景致的时候，心中却是如灰烬一般孤独的时候，大概终于明白，为何在熙熙攘攘的人群中会感到一丝清冷，因为唯有行走在人群里的时候，你会发现原来你一个人走了这么久。天地间万事万物更迭交替，本来是自然界中最普通的规则，可是如果每年的这个时候，你都是一个人去看这山山水水，相比时空上的孤寂感，人的孤寂感会更为强烈，“良辰美景奈何天，赏心乐事谁家院”，外面的世界再纷繁多变，对你而言不过是活着的时间。 &emsp;&emsp;我常常像一个淡漠世情的路人，这个世界上发生什么都和我无关，路人纷纷成双入对，而我依然孑然一身，或许这就是我的生活。每天你会和不同的人相处，可每个人都在忙着自己的事情，我们和这个世界息息相关，与此同时，我们和这个世界毫无关联。我记得周五我帮Kent办理离职手续的时候，我一个人从七楼到十三楼再到十六楼，反复地奔波着。同事让他帮忙向公司归还一台笔记本，结果这台笔记本让整个过程都充满了落寞感。部门与部门间的相互推脱，同事与同事间的相互推诿，让我感到从未有过的窒息感：有一群人每天都坐在一起，每个人都看起来在努力工作，然而在你真正需要帮助的时候，你不能完全指望任何一个人。或许这和我外冷内热的性格有关，可是有那么一瞬间，我突然好想离开那个地方。 &emsp;&emsp;组里的人都走得差不多啦，现下终于剩下我一个人。自此项目上全凭我一个人做主，可对我而言却没有多少欢喜。我还是喜欢和大家在一起，虽然我时常让他们生气，像个孩子一样，可你知道我从来都不是无理取闹的。『射雕英雄传』我看了不下十遍，世人都道东邪黄药师行事乖张、狂傲不羁，可他对妻子冯蘅的深情世间谁人能及，夜夜笙箫相伴墓前，打造花船赴死沧澜，及闻爱女葬身大海，悲痛之际以玉箫扣舷而歌，其深情亦如此。没有人可以一直像个孩子，可以永远都不长大。前段时间看韩寒的电影《乘风破浪》，电影的主题曲从发布就被人吐槽直男癌，其实那仅仅是丈夫在妻子面前“撒娇”的心态，有句话说『在你身边我是个孩子，可你需要了，我就是无坚不摧的勇士』，人人都在说情商如何如何重要，可在真性情面前它的确有点虚伪。 &emsp;&emsp;Kent是坐周五晚上的火车离开，晚上两个人一块儿吃饭，聊到了家里的琐事，聊到了工作的想法，唯独没有提到离别，大概是我不愿意说起。结账的时候，两个人抢着付钱，老板娘笑着说两个人谁付都是一样的，反正以后还有的是机会。可是未来的事情有谁能够说得准呢？或许期望越高，失望就越大，就像我答应了她许多事情，即使我常常在脑海里想起，她现在都不会在乎了吧。可我总是很怀念那些日子，在这世上有那么一个人，绘画、舞蹈、诗文、书法无所不通，我如果能学会吹奏洞箫，为她跳舞时伴奏一曲可好？人生相识不易，或许不是我不愿意去认识别人，而是我知道知音难觅、知己难求，得不到的永远都是最好的。对Kent来说，他有根可寻，回去是最好的选择。而我则是无根枯蓬，风吹到哪里就在哪里。我知道我再难遇见那样的人，人生与我而言，离别总是常态，孤独是种绝症。 &emsp;&emsp;或许Kent说得是对的，这个世界上并没有那么多，真正看重技术的公司，这个世界上普通如你我的人，无一不在做着普通的事情。寻找一家新的公司，对目前的我来说，是件极具挑战的事情。虽然邹老师最后帮我推荐了简历，但是对方并没有适合的项目，这种处境既危险而困窘，我不能再像以前一样，我必须让自己拥有自信的生活，一个人如果不能做到爱自己，又怎么能够做到爱别人呢？可她永远不会再出现了，看到路人成双入对的时候，或许爱对我而言是件太困难的事情，佛门有“贪嗔痴”三戒，求而不得是为执，一个人孤零零地在这个城市里，从明天开始，我会经历更多的一个人，一个人吃饭，一个人工作，一个人游曳……长夜听雨，自今日始，你知道一个人数梅花该是何等的寂寞，你就会知道一个人听雨滴下该是何等的孤独，当然这对我而言是没有区别的。 &emsp;&emsp;有时候会在B站上看以前的影视剧，忽然发现原来一切都已然过去那么久。可当时的心性却不再回复，取而代之的是无限的回想，人生总是如此匆忙的别离，你每天都会认识不同的人，你每天都会错过不同的人，光影恍惚间，一切都仿佛是时间的灰烬爬上了镜子，这像什么呢？或许这就是世事无常，如白云苍狗；或许这就是人生不见，动如参商……时间啊，像极了爬满窗台的灰烬，我却还惦念着窗台外的爬山虎…… Payne, 于4月3日夜","tags":[{"name":"心情","slug":"心情","permalink":"http://qinyuanpei.github.io/tags/心情/"},{"name":"孤独","slug":"孤独","permalink":"http://qinyuanpei.github.io/tags/孤独/"},{"name":"别离","slug":"别离","permalink":"http://qinyuanpei.github.io/tags/别离/"}]},{"title":"Redis缓存技术学习系列之邂逅Redis","date":"2017-03-30T23:31:40.000Z","path":"posts/3032366281/","text":"&emsp;&emsp;作为一个反主流的开发者，在某种程度上，我对传统关系型数据库一直有点“讨厌”，因为关系型数据库实际上和面向对象思想是完全冲突的，前者建立在数学集合理论的基础上，而后者则是建立在软件工程基本原则的基础上。虽然传统的ORM、序列化/反序列化在一定程度上解决了这种冲突，但是软件开发中关于使用原生SQL语句还是使用ORM框架的争论从来没有停止过。可是实际的业务背景中，是完全无法脱离数据库的，除非在某些特定的场合下，考虑到信息安全因素而禁止开发者使用数据库，在主流技术中数据库是一个非常重要的组成部分。为了弥补这个技术上的短板，从这篇文章开始，我将会学习一个经典的缓存技术：Redis。我们这里将Redis定性为一门缓存技术，这说明Redis和MySQL等主流的数据库存在本质上的区别，那么这些区别到底在哪里呢？或许在看完这个系列文章以后，你心中自然就会有了答案。 Redis是什么?&emsp;&emsp;Redis是什么?这是本文第一个问题。Redis是一个开源的使用ANSI C语言编写的、支持网络、 基于内存的、支持持久化的日志型、Key-Value数据库。从如此丰富的修饰语中，我们基本可以抽离出这些信息： Redis是一个Key-Value存储系统 Redis的数据全部缓存在内存里 Redis可以通过网络实现主从同步 Redis支持丰富的数据类型可实现持久化 那么该如何给Redis一个准确的定义呢？或许这个定义可以帮助我们更好的理解Redis，即Redis是一个高性能的Key-Value数据库。我们知道主流的数据存储方案，可以分为关系型数据库和非关系型数据库两大类。传统的Oracle、MySQL和SQLServer都是关系型数据库，关系型数据库将复杂的数据结构归结为二元关系，即二维表形式，而对数据的操作则建立在一个或多个关系表格中，并通过这些表格间的分类、合并、连接和选取等运算实现数据处理。如同天地万物，有阴影的地方就会有阳光。和关系型数据库相对应的，我们称之为非关系型数据库，这是一个泛指的概念。实际上非关系型数据库，根据设计原理的不同，具体可分为：键-值存储数据库、列存储数据库、文档数据库和图数据库四种。我们通常称非关系型数据库为NoSQL，即”Not Only SQL”，从这个概念我们或许可以明白，SQL和NoSQL并非是完全对立的两个世界，它们各自在其擅长的应用场景中发挥着重要的作用。 所以我选择Redis这样一个非关系型数据库，从某种意义上来说，我是想说明一件事情，数据库技术并非绝对代表着关系型数据库和SQL，实际上SQL这门语言存在一定缺陷，就像我们提及Web技术常常想到是如何去做一个网站(MVC)，可你同样会意识到Web API是更为重要的Web技术。这个世界并非是一成不变的，每一天都是新的挑战。 开始使用Redis 好了，在了解了Redis是一个什么东西以后，现在我们来正式开始使用Redis。Redis作为一个开源的键-值数据库，我们可以从它的官方网站或者是从Github来获取。这里推荐从官方网站下载相对稳定的版本，这里博主选择的是3.2.8版本，需要注意我们这里从官方网站下载的是源代码版本，所以首先第一件事情就是编译源代码。如果你非常擅长在Window下编译类似项目，可以尝试在Windows下进行编译。博主这里推荐大家使用Linux或者MacOS来编译，因为主流开源项目使用的Makefile都是Unix世界里的产物，所以使用Linux或者MacOS能够为我们节省大量的时间。博主这里使用的是Elementary OS这个Linux发行版(对应Ubuntu14)，编译方法如下： Redis的编译与安装1234$ wget http://download.redis.io/releases/redis-3.2.8.tar.gz$ tar xzf redis-3.2.8.tar.gz$ cd redis-3.2.8$ make 在这里，除了make的步骤严格依赖命令行以外，其余的步骤都可以手动完成，所以因为惧怕命令行而不愿意接触Linux的世界，事实证明，对一个真正的程序员来讲，命令行是一个唯一可以让人不被外界所干扰的高效地工具，Git是这个世界上最好没有之一的版本控制工具，如果你喜欢Git，那么你更应该尝试去喜欢Linux。好了，在完成对Redis的编译后，我们就可以开始使用Redis了。Redis是一个C/S架构的键-值数据库，这意味着我们需要Redis的服务端程序和客户端程序。在完成编译以后，我们将得到redis-server和redis-cli这两个内置服务端程序和客户端程序。实际使用中我们会接触到不同语言下的redis客户端，在这里我们直接使用Redis内置的客户端： 1234//开启Redis服务$ src/redis-server//开启Redis客户端$ src/redis-cli 需要注意的是在这里服务端和客户端，是在两个不同的终端窗口中运行的，当我们看到下面的窗口时，即表明Redis服务开启就绪，此时我们就可以通过客户端来输入各种命令来完成数据的存取，默认情况下Redis每次会随机分配一个端口，这里Redis采用6379端口进行通信： Redis服务 Redis是一个采用键-值存储方案的数据库，因而传统关系型数据库里的SQL在这里将不再适用。你可以将Redis理解为一个字典，我们可以向这个字典中储存任何Redis支持的数据类型，并通过键名来获取字典中存储的对应数值。我们来看下面的例子，以下命令均在redis-cli中执行： 1234SET foo barOKGET foo\"bar\" Redis中支持的数据类型 这个例子演示了如何在Redis中存储和读取一个简单的字符串类型的值，看起来这一切都非常简单啊，的确Redis就是这样一个简单而高效的键-值数据库。我们在前面提到Redis支持各种各样的数据类型，那么它到底支持哪些数据类型呢？具体来讲，Redis支持5种基本的数据类型： 字符串(Strings)：最基本的数据类型，使用SET/GET命令来存储和读取字符串类型的值。在Redis中最多可支持512兆字节的字符串长度，这意味着我们可以常见的数据类型序列化后再存储到Redis中。 散列/哈希(Hashes)：专门用来表示对象的数据类型。散列/哈希是键-值对的集合，可以维系字符串字段和字符串值间的映射关系，因此它主要用来表示对象。在Redis中可以使用HMSET、HMGET、HGET、HGETALL四种命令来存储和读取散列类型的值。 列表(Lists)：指按照插入顺序排序的字符串元素的集合，特别地，Redis中的列表是采用链表实现的，因为对数据库系统而言，一个非常重要的特性是可以支持在含有大量元素的集合中快速添加元素。常见的应用于列表的命令主要有LPUSH、RPUSH、LPOP、RPOP和LRANGE。 集合(Sets)：指不重复且无序的字符串元素的集合。针对列表，常见的命令主要有：SADD、SPOP、SCARD、SMEMBERS和SISMEMBER。例如SADD命令可以向集合中添加元素，SPOP命令可以从集合中删除元素，SCARD命令可以返回集合内元素个数，SMERMERS命令可以枚举集合的所有元素，SISMEMBER命令可以判断指定元素是否在指定集合内。 有序集合(Sorted Sets)：有序集合与集合相似，不同点在于集合中的每一个元素都会关联一个浮点型的数值，该数值称为score，事实上Redis正是根据score来对集合内的元素进行排序的。集合内的元素是不允许重复的，但是score是可以允许重复的。常见的命令有：ZADD、ZCARD、ZCOUNT、ZREM、ZSCORE等。 Redis中和键有关的命令 我们知道Redis是一个键-值数据库，所以在了解了Redis中支持的数据类型，即“值”以后，现在让我们将关注点回归到“键”上面来，这是因为作为一个键-值数据库，键是我们从数据库中获取值的唯一方式，因此在这里说说Redis中那些和键有关的命令，这些命令基本都遵循下面的命名格式，常见的命令有： 1COMMAND KEY_NAME DEL：该命令将在键名存在时从数据库中删除指定键，成功则返回1，否则返回0。 DUMP：该命令将序列化指定键，并返回被序列化的值。 EXISTS：该命令用以判断指定键是否存在。 EXPIRE：该命令用以给指定键设置过期时间。 KEYS：该命令用以返回所有满足匹配模式的键。 PERSIST：该命令用以移除指定键的过期时间。 RENAME：该命令用以重命名指定键。 ​ 好了，这就是这篇博客的内容了，自我感觉Redis中的内容相对分散，这种细小的知识点都隐藏在命令中，最初在介绍不同的数据类型的时候，在文章中均做了详细的介绍并辅以终端脚本，可是最后发现这样写下去还不如去看官方文档，像Redis这种即使学习了都不见得有机会使用的技术，当然我并不是说Redis不好啊，关系型数据库目前依然是主流的技术驱动力量，所以我觉得我们学习的时候最好是“观其大略”、“不求甚解”，首先注重整体知识体系上的理解，微枝末叶上的细节问题可以在使用的时候去查阅文档。在下面的文章中，我重点关注的内容是Redis的事务、脚本、发布/订阅及不同语言下Redis的使用，希望大家继续关注我的博客，本篇结束！","tags":[{"name":"Redis","slug":"Redis","permalink":"http://qinyuanpei.github.io/tags/Redis/"},{"name":"缓存","slug":"缓存","permalink":"http://qinyuanpei.github.io/tags/缓存/"},{"name":"数据库","slug":"数据库","permalink":"http://qinyuanpei.github.io/tags/数据库/"}]},{"title":"使用C#开发HTTP服务器之支持HTTPS","date":"2017-03-05T14:01:39.000Z","path":"posts/2734896333/","text":"&emsp;&emsp;各位朋友大家好，我是秦元培，欢迎大家关注我的博客，我的博客地址是http://qinyuanpei.com。本文是“使用C#开发HTTP服务器”系列的第六篇文章，在这个系列文章中我们实现了一个基础的Web服务器，它支持从本地读取静态HTML页面，支持GET和POST 两种请求方式。该项目托管在我的Github上，项目地址为https://github.com/qinyuanpei/HttpServer，感兴趣的朋友可以前往了解。其间有朋友为我提供了HTTPS的PR，或许这偏离了这个系列开发HTTP服务器的初衷，可是我们应该认识到普及HTTPS是大势所趋。所以在今天这篇文章中，我将为大家带来HTTPS相关知识的普及，以及如何为我们的这个Web服务器增加HTTPS的支持。 &emsp;&emsp;2017年我们听到这样一个声音，苹果将强制实施ATS，即App Transport Security。首先我们要了解的是ATS，它是苹果为了保证应用数据在网络中安全地传输而制定的一种规则，其核心是鼓励开发者使用安全的HTTPS协议和服务器进行通讯。在此之前考虑到大量的应用还在使用HTTP协议，所以苹果并未强制要求应用遵守这个规范，而此时苹果发出这样一种声音，我们终于意识到苹果这是在推广HTTPS啊！无独有偶，同样作为科技巨头之一的Google，宣布在新发布的Chrome 56中会将仅支持HTTP协议的网页标记为“不安全”。HTTPS到底是什么呢？为什么科技巨头纷纷开始对它青眼有加呢？这或许要从HTTPS协议说起。 &emsp;&emsp;HTTPS，即Hyper Text Transfer Protocol Over Secure Socket Layer的简称，是指以安全为目标的HTTP协议。我们可以将其理解为在HTTP协议的基础上增加了安全机制，这里的安全机制是指SSL,简单来讲HTTPS协议依然采用HTTP协议，不过它在HTTP和TCP间增加了加密/身份验证层，因此在保证数据传输安全的同时，为服务器提供了身份校验机制。任何采用HTTPS协议的网站，均可通过浏览器地址栏中的“锁”标志来查看网站的认证信息，或者是通过CA机构颁发的数字证书来查询。下图展示的是HTTPS协议中客户端和服务器端通信过程： HTTPS协议中客户端和服务器通信过程 从图中我们可以看出，在HTTPS协议中客户端和服务器端分为六步： 客户端请求服务器，发送握手消息给服务器。 服务器端返回客户端加密算法、数字证书和公钥。 客户端对返回的数字证书进行验证，如果验证通过则产生一个随机数，否则提示验证失败。 客户端使用公钥对产生的随机数进行加密，然后将其发送给服务器端。 服务器对该随机数进行解密，并以此作为密钥发送握手信息给客户端。 客户端收到消息后对消息进行解密，如果解密成功则表示握手结束。 &emsp;&emsp;这恰恰印证了我们最初的观点，即HTTPS协议依然采用HTTP协议(三次握手)进行通讯，不同的地方在于中间环节增加了加密处理，例如在客户端和服务器端相互验证的环节采用的是非对称加密，在客户端验证通过以后双方采用随机数作为密钥是对称加密，而三次握手以后验证消息是否被篡改则是采用HASH算法。所以我们应该可以注意到，HTTP协议和HTTPS协议的一个显著的区别是，前者采用明文来传输消息，而后者采用密文来传输消息，因此HTTPS协议比HTTP协议在通讯上更为安全。而详细来说，两者的区别主要有： HTTPS需要证书，而HTTP则不需要证书，证书由CA机构颁发。 HTTP采用明文来传输消息，C/S端无身份验证；HTTPS采用密文来传输消息，C/S端有身份验证。 HTTP默认采用80端口进行通信，而HTTPS默认采用443端口进行通信。 &emsp;&emsp;好了，现在我们对HTTPS协议有了一个基本的认识：HTTPS协议相比HTTP协议增加了身份验证和消息加密的机制，因此HTTPS协议能够保证通讯过程中的数据传输安全。在今天这样一个数字时代，当个人隐私安全彻底地暴露在浏览器、应用程序面前，能够提供更安全的互联网服务无疑会让人更有安全感，我想这是苹果和谷歌这样的科技巨头公司，之所以要去努力推广HTTPS协议的原因吧！因为客户端需要对服务器的证书进行验证，所以这意味着在客户端拥有访问所有受信证书的能力，例如我们在使用传统网银产品时都需要安装网银证书，这其实就是为了让客户端在向服务器端发起请求时方便对服务器进行验证，因此如果客户端请求的URL遭遇劫持，被重定向到某个不被信任的站点上，那么客户端发起的请求就会被拦截。同样的道理，服务器端会对客户端的请求进行验证，所以这里就不再详细展开去说啦。 &emsp;&emsp;我们最初设计这个HTTP服务器的时候，没有考虑过要支持HTTPS协议。可是当我们了解了HTTPS协议后，我们发现，如果要让最初设计的Web服务器支持HTTPS协议，我们需要关注的是Security，即身份验证和数据加密，我们知道这里的Security指的是SSL，所以需要了解SSL相关的内容。其次，我们需要提供一个数字证书给服务器端，目的是在客户端发起请求的时候，将数字证书、加密算法和公钥返回，保证客户端可以完成证书校验。从这两点可以看出，我们首先需要从CA机构购买证书，这一点毋庸置疑。关于证书的购买及服务器的设置，我们通过搜索引擎可以找到相关参考。目前主流的服务器如Apache、IIS、Tomcat和Ngnix都可以非常方便地支持HTTPS，这些问题更像是一种基础设施，所以我会在文章末尾列举出相关文章供大家查阅。 &emsp;&emsp;这篇文章的核心是开发一个服务器，所以在保证这些基础设施完备的前提下，让我们将关注点落实到代码上面来。我们提到，HTTPS除了证书以外关键点是SSL，而在.NET中提供SSL相关的API，所以这里我们直接使用这些API就可以完成证书的创建、加载等工作。下面是相关的代码示例： 12345678910111213141516171819202122232425262728293031// 使用OpenSSL.NET生成密钥RSA rsa = new RSA();BigNumber number = OpenSSL.Core.Random.Next(10, 10, 1);rsa.GenerateKeys(1024, number, null, null);CryptoKey key = new CryptoKey(rsa);//创建X509证书，Subject和Issuer相同 X509Certificate x509 = new X509Certificate();x509.SerialNumber = (int)DateTime.Now.Ticks;x509.Subject = new X509Name(\"CN=DOMAIN\"); //DOMAIN为站点域名 x509.Issuer = new X509Name(\"CN=DOMAIN\");x509.PublicKey = key; //指定公钥 x509.NotBefore = Convert.ToDateTime(\"2011-1-1\"); //起始时间 x509.NotAfter = Convert.ToDateTime(\"2050-1-1\"); //失效时间 x509.Version = 2;//使用私钥签名x509.Sign(key, MessageDigest.MD5);//生成CRT证书BIO x509bio = BIO.File(\"CA.crt\", \"w\");x509.Write(x509bio);//生成PFX证书var certs = new OpenSSL.Core.Stack&lt;X509Certificate&gt;();PKCS12 p12 = new PKCS12(\"PASSWORD\", key, x509, certs); //PASSWORD为保护密钥 BIO p12Bio = BIO.File(\"CA.pfx\", \"w\");p12.Write(p12Bio);//加载证书var certifiate = X509Certificate.CreateFromCertFile(\"CA.crt\"); &emsp;&emsp;在我们获得证书以后，我们就可以通过SSL对Socket通信过程中传递的消息进行加密了，一个基本的示例代码如下：12345SslStream sslStream = new SslStream(clientStream);sslStream.AuthenticateAsServer(serverCertificate, false, SslProtocols.Tls, true);sslStream.ReadTimeout = 10000;sslStream.WriteTimeout = 10000;return sslStream; &emsp;&emsp;个人感觉加密相关的问题深奥而晦涩，这篇文章中涉及到的相关概念和技术，都大大地超出了我目前的认知范围。不过既然这位朋友热心地提交了这个PR，我就将这个过程视为向别人的一次学习吧！我会继续去完善这个项目：https://github.com/qinyuanpei/HttpServer。这篇博客终于算是写完了，周末开心！ 参考文章 Zery - HTTPS原理解析 阮一峰 - SSL/TLS协议运行机制的概述 维基百科 - 超文本传输安全协议 猫尾博客 - HTTPS工作原理 MSDN - 如何在 IIS 中设置 HTTPS 服务 Dudu - 给IIS添加CA证书以支持https 温柔易淡 - Apache配置HTTPS功能 王浩宇 - 配置Tomcat使用https协议","tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://qinyuanpei.github.io/tags/HTTP/"},{"name":"服务器","slug":"服务器","permalink":"http://qinyuanpei.github.io/tags/服务器/"},{"name":"C#","slug":"C","permalink":"http://qinyuanpei.github.io/tags/C/"}]},{"title":"愿浮萍乘风破浪","date":"2017-02-04T22:31:33.000Z","path":"posts/2314414875/","text":"或许是今年的贺岁档电影全部遭遇“滑铁卢”的缘故，在这种情况下，电影《乘风破浪》或许会成为拯救整个贺一个岁档的奇迹。同往常一样，我依然选择一个人去看电影，而庆幸的是韩寒真的没有让我们失望。虽然前期在微博上经常看到韩寒在为这部电影做宣传，但我一直想知道它会一种什么样的方式来讲述这个故事，我隐隐约约觉得徐太浪(邓超饰)、徐正太(彭于晏饰)、小花(赵丽颖饰)三个人之间的关系非同寻常，我甚至臆想这是一部俗套的三角恋的故事。可结果却是完全出人意料的，我很喜欢这个故事。 &emsp;&emsp;首先，电影一开头就项我们展示了一个非常常见的矛盾冲突，从小喜欢赛车的儿子徐太浪和坚决反对儿子以赛车作为职业的父亲徐正太。我们从小到大或许都会有这样的经历，我们曾经执著地喜欢过什么或是热爱过什么，可这种喜欢在父母眼中常常被视为叛逆。我大学四年里最反感的一件事情就是我的本科专业，我一直很喜欢计算机技术，确切地说是通过编程来理解这个世界，可是因为我高考成绩并不理想，当时在父亲的建议下选择了一个我不喜欢的专业，在这四年里我做过最多的事情，就是极力想要摆脱这个专业。我从那个时候开始将编程视为我主要的兴趣，我从大学时候就开始研究自己感兴趣的技术，开始在技术社区里撰写博客。 &emsp;&emsp;这段经历让我至今都难以忘怀，这件事情教会我一个道理，当你认准去做一件事情的时候，其实没有任何一个人可以左右你的选择，2016年上半年我经历了一段时间的失业。虽然周围人都在告诉我，考公务员或者选择我本专业或许会比我的选择更为光明，但那个时候我一直找不到喜欢的工作，我常常在心里问我自己：难道我注定不能去做我喜欢的事情吗？后来我独自一个人来到西安，我畏惧逃离北上广的那种无力感和孤独感，可其实一个人在西安同样是孤独的。父母自然是为了我们好，可这种两代人的矛盾不管什么时候都会持续下去，当徐太浪面对着镜头大声说出那些压抑在心底的话的时候，我们所看到的那个懦弱而苍老的父亲，或许在每个人身上都可以找到影子吧！ &emsp;&emsp;或许是因为太想在父亲面前证明自己，所以当徐太浪取得赛车比赛冠军时，他迫不及待地让父亲坐在自己的副驾驶位上，一如电影开头那呼啸而过的一抹车影，当赛车穿过蜿蜒的山路、穿过废旧的城镇，在恍惚间我好像看到了，在《平凡之路》中一直蔓延着的无尽的长路，当镜头和画面频繁切换着，你以为是时间穿越了历史，其实时间就静止在那里，我们所看到的不过是那些转瞬即逝的风景，所听到的不过是那些呼啸而过的风声。我特别喜欢徐太浪的赛车与货车擦肩而过时，一切变得支离破碎的那组慢镜头，它就像一层层地褪去外表华丽的油漆，直接让斑驳的纹理一点点地裸露出来，当车窗玻璃破碎并跌落在空气里，当庆祝成功的香槟和奖杯混杂在空气里。或许此时此刻所有的一切都不再重要了吧，我们说洗去铅华返璞归真，大概只有在这种情况下，当我们的灵魂完全变得纯净的时候，或许穿越这种影视表现手法才会真正起作用，我们注意到徐太浪在医院病床上醒来的时候，眼角是带着泪水的，所以对这个电影里所叙述的故事，我宁愿将其当作是徐太浪的一个梦吧！他因为从小没有见过母亲，所以想要努力知道母亲长什么样子，在死亡边缘成为了他的一种执念。影片为了刻意制造笑点，让徐太浪身上多了许多“穿越”的特质，其实对观众而言这仅仅是一种代入的符号，换句话说，“穿越”以后的这个人是不是徐太浪本身已经不再重要了，重要的是我们通过这个人了解了整个故事。 &emsp;&emsp;整个故事其实是一个解惑的过程，所有的线索都是为了让徐太浪明白，自己的父亲为什么会变成这个样子，而围绕这些线索，整理的冲突发生在以徐正太、六一、阿浪、小马为代表的“正太帮”和黄志强、罗力为代表的“黑社会”，双方的利益冲突交织在一间歌舞厅。我们知道徐正太的一个梦想是“歌舞厅里只唱歌，桑拿房里就洗澡”，而这是一种近乎乌托邦的存在，所以年轻的徐正太有理想和抱负，想成为杜月笙那样的老大，而这一切的初衷是为了让自己的妻子做歌舞厅的老板娘。而通过阿浪夜寻小花这个事情，我们同时知道，徐正太是一个可以因为朋友一句话就等对方一个晚上的人，这说明他是一个守信用的人，而导致徐正太坐牢的直接原因是他为朋友六一报仇，这是一个重义气的表现，那么他的局限性在哪里呢？他认为录像厅比电影院有前途，就大量购买录像带；他认为BP机代表了通信行业的未来，就大量囤积BP机。所以这个时候我们就会明白，他后来会对阿浪采取“棍棒教育”，其实是因为他的眼界就局限在这里，他在对待新事物上存在局限性，所以看不到世界的变化，他在天台上说的那句“世界是不会变的”就是最好的证明。六一代表了那种并不聪明但愿意为朋友两肋插刀的“傻气”，小马则代表了那种愿意去追逐梦想的“执着”，当OICQ这个名字从他口中说出来的时候，我就知道这个人的一生都将注定不平凡。黄志强代表的是商业利益既得者，而罗力则代表的是失去一切后迷途知返的回头浪子。 &emsp;&emsp;如果说男人们的故事都是这般粗犷的话，那么这部电影里女性角色则显得细腻。首先从小花说起，小花和阿浪一样，都是对自己的父亲怀有敌意的，因为作为飞行员的父亲舍弃了和家人在一起的时间，投入全部身心到飞行事业上去，以至于在她婚礼的时候，父亲都没有来参加。影片中一个细节是，最后徐正太和阿浪杀死黄志强以后，怀有身孕的小花匆匆赶来，将满身血污的徐正太紧紧抱在怀里，小花说徐正太有时候像个孩子，其实男人都会有像孩子的一面，所以小花其实代表的是一种母性的关怀吧！值得一提的是电影里佳怡和松子这个女性角色，虽然六一喜欢佳怡，可依琳说她有喜欢的人的时候，他默默地选择放手，即使他心里依然有她，而最终六一躺在太平间里，此时陪伴在他身边的，不过是哭成泪人地佳怡和那条巡回犬，大概我们都习惯了忽视身边人的爱吧，从父母到伴侣，影片中正太和小花从四岁结识从始自终，这大概就足以令人唏嘘了吧。顶风作案的罗力，承诺要给松子一方天地，然而等他从狱中出来，见到的却是坐在黄志强车上神色复杂的那个人，你说这个世界是会变的，可它会变成什么样我们永远无从得知，小马希望的是那个拨号上网频频掉线的时代诞生一款OICQ的软件，徐正太希望的是像杜月笙那样收“物业费”……我们期望着什么，我们等待着什么，其实都不重要，世界一直都在变化，而我们如浮萍，或随风漂泊，或乘风破浪，一切都在我们的选择。 &emsp;&emsp;电影结尾，阿浪和正太在同一个平行宇宙，一如影片开始，两个人坐在同一辆车上一样，阿浪问正太：“你的车技这么好是跟谁学的？”，正太回答：“天赋来的”。同样，正太问了阿浪相同的问题，阿浪说：“遗传来的”。其实到这里，我们看到的是父子间真正的握手言和，最终两个人互相理解了对方，电影开头两个人的矛盾冲突，以这样一种形式化解，是件让人欣慰的事情，如果那些被时代抛弃的BP机，或许你我都不再认同它们的价值，但那曾是父母眼中给我们的最好的爱，世界每天都在变化，而起风了，唯有努力生存。","tags":[{"name":"电影","slug":"电影","permalink":"http://qinyuanpei.github.io/tags/电影/"},{"name":"韩寒","slug":"韩寒","permalink":"http://qinyuanpei.github.io/tags/韩寒/"},{"name":"青春","slug":"青春","permalink":"http://qinyuanpei.github.io/tags/青春/"}]},{"title":"函数式编程常用术语","date":"2017-02-02T19:21:12.000Z","path":"posts/2171683728/","text":"&emsp;&emsp;近年来函数式编程这种概念渐渐流行起来，尤其是在React/Vuejs这两个前端框架的推动下，函数式编程就像股新思潮一般瞬间席卷整个技术圈。虽然博主接触到的前端技术并不算深入，可这并不妨碍我们通过类似概念的延伸来理解这种概念。首先，函数式编程是一种编程范式，而我们所熟悉的常见编程范式则有命令式编程(Imperative Programmming)、函数式编程(Functional Programming)、逻辑式编程(Logic Programming)、声明式编程(Declarative Programming)和响应式编程(Reactive Programming)等。现代编程语言 在发展过程中实际上都在借鉴不同的编程范式，比如Lisp和Haskell 是最经典的函数式编程语言，而SmartTalk、C++和Java则是最经典的命令式编程语言。微软的C#语言最早主要借鉴Java语言，在其引入lambda和LINQ特性以后，使得C#开始具备实施函数式编程的基础，而最新的Java8同样开始强化lambda这一特性，为什么lambda会如此重要呢？这或许要从函数式编程的基本术语开始说起。 什么是函数式编程？&emsp;&emsp;我们提到函数式编程是一种编程范式，它的基本思想是将计算机运算当作是数学中的函数，同时避免了状态和变量的概念。一个直观的理解是，在函数式编程中面向数据，函数是第一等公民，而我们传统的命令式编程中面向过程，类是第一等公民。为什么我们反复提到lambda呢？因为函数式编程中最重要的基础是lambda演算(Lambda Calculus)，并且lambda演算的函数可以接受函数作为参数和返回值，这听起来和数学有关，的确函数式编程是面向数学的抽象，任何计算机运算在这里都被抽象为表达式求值，简而言之，函数式程序即为一个表达式。值得一提的是，函数式编程是图灵完备的，这再次说明数学和计算机技术是紧密联系在一起的。虽然在博主心目中认为，图灵这位天纵英才的英国数学家，是真正的计算机鼻祖，但历史从来都喜欢开玩笑的，因为现代计算机是以冯.诺依曼体系为基础的，而这一体系天生就是面向过程即命令式的，在这套体系下计算机的运算实则是硬件的一种抽象，命令式程序实际上是一组指令集。因此，函数式程序目前依然需要编译为该体系下的计算机指令来执行，这听起来略显遗憾，可这对我们来说并不重要，下面让我们来一窥函数式编程的真容： 12squares = map(lambda x: x * x, [0, 1, 2, 3, 4]) print squares 这是使用Python编写的函数式编程风格的代码，或许看到这样的代码，我们内心是完全崩溃的，可是它实现得其实是这样一个功能，即将集合{0, 1, 2, 3, 4}中的每个元素进行平方操作，然后返回一个新的集合。如果使用命令式编程，我们注定无法使用如此简单的代码实现这个功能。而这个功能在.NET中其实是一个Select的功能： 12int[] array = new int[]&#123;0, 1, 2, 3, 4&#125;;int[] result = array.Select(m =&gt; m * m).ToArray(); 这就是函数式编程的魅力，我们所做的事情都是由一个个函数来完成的，这个函数定义了输入和输出，而我们只需要将数据作为参数传递给函数，函数会返回我们期望的结果。好了，下面再看一个例子： 12sum = reduce(lambda a, x: a + x, [0, 1, 2, 3, 4])print sum 即使我们从来没有了解过函数式编程，从命名我们依然可以看出这是一个对集合中的元素求和的功能实现，这就是规范命名的重要性。幸运的是.NET中同样有类似的扩展方法，我喜欢Linq，我喜欢lambda： 12int[] array = new int[]&#123;0, 1, 2, 3, 4&#125;;int result = array.Sum(); 考虑到博主写不出更复杂的函数式编程的代码示例，这里不再列举更多的函数式编程风格的代码，可是我们从直观上来理解函数式编程，就会发现函数式编程同lambda密不可分，函数在这里扮演着重要的角色。好了，下面我们来了解下函数式编程中的常用术语。 函数式编程的常用术语&emsp;&emsp;函数式编程首先是一种编程范式，这意味着它和面向对象编程一样，都是一种编程的思想。而函数式编程最基本的两个特性就是不可变数据和表达式求值。基于两个基础特性，我们延伸出了各种函数式编程的相关概念，而这些概念就是函数式编程的常用术语。常用的函数式编程术语有高阶函数、柯里化/局部调用、惰性求值，递归等。在了解这些概念前，我们先来理解，什么是函数式编程的不可变性。不可变性，意味着在函数式编程中没有变量的概念，即操作不会改变原有的值而是修改新产生的值。举一个基本的例子，.NET中IEnumerable接口提供了大量的如Select、Where等扩展方法，而这些扩展方法同样会返回IEnumerable类型，并且这些扩展方法不会改变原来的集合，所有的修改都是作用在一个新的集合上，这就是函数式编程的不可变性。实现不可变性的前提是纯函数，即函数不会产生副作用。一个更为生动的例子是，如果我们尝试对一个由匿名类型组成的集合进行修改，会被提示该匿名类型的属性为只读属性，这意味着数据是不可改变的，如果我们要坚持对数据进行“修改”，唯一的方法就是调用一个函数。 高阶函数(Higer-Order-Function)&emsp;&emsp;高阶函数是指函数自身能够接受函数，并返回函数的一种函数。这个概念听起来好像非常复杂的样子，其实在我们使用Linq的时候，我们就是在使用高阶函数啦。这里介绍三个非常有名的高阶函数，即Map、Filter和Fold，这三个函数在Linq中分别对应于Select、Where和Sum。我们可以通过下面的例子来理解： Map函数需要一个元素集合和一个访问该元素集合中每一个元素的函数，该函数将生成一个新的元素集合，并返回这个新的元素集合。通过C#中的迭代器可以惰性实现Map函数： 12345IEnumerable&lt;R&gt; Map&lt;T,R&gt;(Func&lt;T,R&gt; func, IEnumerable&lt;T&gt; list)&#123; foreach(T item in list) yield return func(item);&#125; Filter函数需要一个元素集合和一个筛选该元素结合的函数，该函数将从原始元素集合中筛选中符合条件的元素，然后组成一个新的元素集合，并返回这个新的元素集合。通过C#中的Predicate委托类型，我们可以写出下面的代码： 12345678IEnumerable&lt;T&gt; Filter&lt;T&gt;(Predicate&lt;T&gt; predicate, IEnumerable&lt;T&gt; list)&#123; foreach(T item in list) &#123; if(predicate(item)) yield return item; &#125;&#125; Fold函数实际上代表了一系列函数，而最重要的两个例子是左折叠和右折叠，这里我们选择相对简单地左折叠来实现累加的功能，它需要一个元素集合，一个累加函数和一个初始值，我们一起来看下面的代码实现： 1234567R Fold&lt;T,R&gt;(Func&lt;R,T,R&gt; func, IEnumerable&lt;T&gt; list, R startValue = default(R))&#123; R result = startValue; foreach(T item in list) result = func(result, item); return result;&#125; 相信现在大家应该理解什么是高阶函数了，这种听起来非常数学的名词，当我们尝试用代码来描述的时候会发现非常简单。相信大家都经历过学生时代，临近期末考试的时候死记硬背名词解释的情形，其实可以用简洁的东西描述清楚的概念，为什么需要用这种方式来理解呢？为什么我这里选择了C#中的委托来编写这些示例代码呢？自然是同样的道理啦，因为我们都知道，在C#中委托是一种类似函数指针的概念，因为当我们需要传入和返回一个函数的时候，选择委托这种特殊的类型可谓是恰如其分啦，这样并不会影响我们去理解高阶函数。 柯里化(Curring)/局部套用&emsp;&emsp;柯里化(Curring)得名于数学家Haskell Curry，你的确没有看错，这位伟大的数学家不仅创造了Haskell这门函数式编程语言，而且提出了局部套用(Currin)这种概念。所谓局部套用，就是指不管函数中有多少个参数，都可以函数视为函数类的成员，而这些函数只有一个形参，局部套用和部分应用息息相关，尤其是部分应用是保证函数模块化的两个重要技术之一(部分应用和组合(Composition)是保证函数模块化的两个重要技术)。众所周知，在C#中一个函数一旦完成定义，那么它的参数列表就是确定的，即相对静态。它不能像Python和Lua一样去动态改变参数列表，虽然我们可以通过缺省参数来减少参数的个数，可是在大多数情况下，我们都需要在调用函数前准备好所有参数，而局部套用所做的事情与这个理念截然相反，它的目标是用非完全的参数列表去调用函数。我们来一起看下面这个例子：1Func&lt;int,int,int&gt; add = (x,y) =&gt; &#123;return x + y;&#125;; 这是一个由匿名方法定义的委托类型，显然我们需要在调用这个方法前准备好两个参数x和y，这意味着C#不允许我们在改变参数列表的情况下调用这个方法。而通过局部套用：1234Func&lt;int,int,int&gt; curriedAdd =&gt; (x) =&gt;&#123; return (y) =&gt; &#123; return x + y;&#125;;&#125;; 实际上在这里两个参数x和y的顺序对最终结果没有任何影响，我们这样写仅仅是为了符合人类正常的认知习惯，而此时我们注意到我们在调用curriedAdd时会发生质的的变化：1234//x和y同时被传入addadd(x,y)//x和y可以不同时被传入curriedAddcurriedAdd(x)(y); 而如果我们将这里的函数用Lambda表达式来表示，则会发现：12Func&lt;int,int,int&gt; add = (x,y) =&gt; return x + y;Func&lt;int,Fucn&lt;int,int&gt;&gt; curriedAdd = x = &gt; y =&gt; x + y; 至此，对一般的局部套用，存在：12Func&lt;...&gt; f = (part1, part2, part3, ...) =&gt; ... 可转换为：Func&lt;...&gt; cf = part1 =&gt; part2 =&gt; part3 ... =&gt; ... 则称后者为前者的局部套用形式。 惰性求值&emsp;&emsp;我们在前文中曾经提到过，在函数式编程中函数是第一等公民，而这里的函数更接近数学意义上的函数，即将函数视为一个可以对表达式求值的纯函数，所以我们这里自然而然地就提到了惰性求值。首先，博主这里想说说求值策略这个问题，求值策略通常有严格求值和非严格求值两种，而对C#语言来讲，它在大多数情况下使用严格求值策略，即参数在传递给函数前求值。与之相对应的，我们将参数在传递给函数前不进行求值或者延迟求值的这种情况，称为非严格求值策略。一个经典的例子是C#中的“短路”效应：1bool isTrue = (10 &lt; 5) &amp;&amp; (MyCheck()) 因为在这里表达式的第一部分返回值为false，因此在实际调用中第二部分根本不会执行，因为无论第二部分返回true还是false，实际上对整个表达式的结果都不会产生影响。这是一个非常经典的非严格求值的例子，同样的，布尔运算中的”||”运算符，同样存在这个问题。所以，至此我们可以领会到惰性求值的优点，即使程序的执行效率更好，尤其是在避免高昂运算代价的时候，我们要牢记：懒惰是程序员的一种美德，使用更简洁的代码来满足需求，是一名游戏程序员的永恒追求。我们可以联想那些在代码片段中优先return的场景，这大概勉强可以用这种理论来解释吧！例如我们强大的Linq，原谅我如此执著于举Linq的例子，Linq的一个特点是当数据需要被使用的时候开始计算，即数据是延迟加载的，而在此之前我们所有对数据的操作，从某种意义上来讲，更像是定义了一系列函数，这好像和数据库中的事务非常相近啦，其实这就是在告诉我们，懒惰是一种美德啊，哈哈！ 函数式编程的利弊探讨&emsp;&emsp;好了，现在让我们从函数式编程的各种术语中解放出来，高屋建瓴般地从更高的层面上探讨下函数式编程的利弊。当你讨论一种东西的利弊时，一种习惯性的做法是找一种东西来和它作比较，如果Windows和Linux、SQL和NoSQ、面向对象和函数式…等等，我们常常关注一件事物的利弊，而非去寻找哪一个是最好。可惜自以为是的人类，常常以此来自我设限，划分各自的阵营，这当真是件无聊的事情，就像我一直不喜欢SQL和正则表达式，所以我就去了解数据库的设计、模式匹配相关内容，最终感觉颇有一番收获，我想这是我们真正的目的吧！好了，下面我们说说函数式编程有哪些优缺点？首先，函数式编程极大地改善了程序的模块化程度，高阶函数、递归和惰性求值让程序充分函数化，函数式让编程可以以一种声明式的风格来增强程序语义。当然，函数式编程的缺点是，我们这个现实世界本来就不是纯粹的，函数式编程强调的数据不可变性，意味着我们无法去模拟事物状态变化，因此我们不能为了追求无副作用、无锁而忽视现实，这个世界上总有些肮脏的问题，无法让我们用纯函数的思维去解决，这个时候我们不能说要让设计去适应这个世界，任何技术或者框架的诞生归根到底是为了解决问题，而函数式编程或者是面向对象编程，本质都是一种编程思想，我们最终是为了解决问题，就像这个世界有时候并不是面向对象的，我们用面向对象来描述这个世界，或许仅仅是我们自己的理解，这个世界到底是什么样子的，大概只有上帝会知道吧！ 本文小结&emsp;&emsp;本文主要对函数式编程及其常见术语进行了简要讨论，主要根据《C#函数式程序设计》一书整理并辅以博主的理解而成。首先，函数式编程中强调无状态、不可变性，认为函数是一等公民，并且在函数式编程中每一个函数都是一个纯函数，它是数学概念咋计算机领域的一种延伸，和冯.诺依曼计算机体系不同，函数式编程的核心思想是以lambda演算为基础的表达式求值，并且函数式编程强调无副作用。本文对函数式编程中的常见术语如高阶函数、局部套用/柯里化、惰性求值等结合C#语言进行了简单分析。或许对我们而言，函数式编程是一个新鲜事物，可正如我们第一次接触面向对象编程时一样，我们并不知道这样一种编程思想会持续到今天。我不认为函数式编程会彻底替代面向对象编程，就像Web开发无法彻底替换原生开发一样，函数式编程会作为面向对象的一种延伸和补充，所以本文对函数式编程的理解实际上是非常肤浅的，可这个世界本来就是在不断变化的，希望我们可以在恰当的场景下去权衡选择什么样的技术，对这个世界而言，我们永远都是探索者，或许永远都不存在完全能满足现实场景的编程范式吧！","tags":[{"name":"读书","slug":"读书","permalink":"http://qinyuanpei.github.io/tags/读书/"},{"name":"函数式编程","slug":"函数式编程","permalink":"http://qinyuanpei.github.io/tags/函数式编程/"},{"name":"编程","slug":"编程","permalink":"http://qinyuanpei.github.io/tags/编程/"}]},{"title":"基于Mono和VSCode打造轻量级跨平台IDE","date":"2016-11-18T20:23:44.000Z","path":"posts/3568552646/","text":"&emsp;&emsp;最近Visual Studio推出Mac版本的消息迅速在技术圈里刷屏，当工程师们最喜欢的笔记本电脑Mac，邂逅地球上最强大的集成开发环境Visual Studio的时候，会碰撞出怎样精彩的火花呢？在微软新任CEO纳德拉的“移动为先、云为先”战略下，微软的转变渐渐开始让人欣喜，从.NET Core、VSCode、TypeScript再到近期的Visual Studio For Mac，这一系列动作让我们感觉到，微软的技术栈越来越多地向着开源和跨平台两个方向努力。我们曾经固执地认为，微软的技术栈注定永远无法摆脱Windows的束缚，而事实上这个世界每天都在发生着变化。或许这次Visual Studio推出Mac版这件事情，本质上是微软收购的Xamarin公司旗下产品Xamarin Studio的一次改头换面。可是这件事情说明，微软正在努力让.NET技术栈融入更多的应用场景。对我而言，我是没有钱去买一台Mac的，所以在这篇文章中，我们将在Linux下通过Mono和VSCode来打造一个轻量级的IDE。而据说Mono会和Xamarin一样，将来会成为.NET基金会的一部分。 &emsp;&emsp;好了，我们首先在Windows世界里进行彩排，在开始下面的内容以前，请保证你的计算机上安装了Mono和VSCode。假如你经常关注我的博客，你应该会知道Mono在这里的作用是什么？，简而言之，Mono为我们提供了编译器环境和运行时环境，在这个基础上VSCode这个天生带着Visual Studio基因的编辑器，则可以为我们提供基础的代码调试功能，这是我们这篇文章写作的关键因素。如果你还对Mono一无所知，下面的两篇文章可以帮助你快速了解： 使用Mono让.NET程序跨平台运行 使用Mono打造轻量级的.NET运行时 &emsp;&emsp;在我们了解了Mono以后，就可以考虑将Mono作为VSCode的运行时环境，这意味着我们可以在使用VSCode的同时直接编译代码。目前在VSCode中内建的运行时支持为Node/Node2，所以如果我们希望在VSCode中调试更多的语言，我们就必须要为VSCode安装相应的插件。因为事实上在VSCode中编译代码我们可以直接通过Task来完成编译，但当我们希望在VSCode中对代码进行调试的时候，我们就必须借助插件来完成调试任务，这或许从侧面印证了VSCode的产品定位就是一个文本编辑器。 &emsp;&emsp;而对于微软推出的这样一款产品，我们或许会疑惑，为什么这个编辑器提供的内建支持居然是Node，而不是我们所熟悉的.NET技术体系。这个原因非常容易理解，如果你听说过Github出品的编辑器Atom，或者是使用过Electron/Node-Webkit相关技术，那么你一定会深刻地理解，VSCode本质上和Atom一样，都是采用Web技术来构建跨平台应用，而Node天生就具备Web属性加成，所以我们就不难理解为什么VSCode内建的支持是Node而非.NET技术体系。同样地，为了实现跨平台的目标，在对C#语言的支持这个问题上，微软选择了OminiSharp这样一个跨平台的代码自动补全工具，而非我们在Visual Studio中所熟知的Intellisense技术。在.NETCore推出以后.NET跨平台不再是梦想，我们对技术的探索就不应该再局限在Windows平台上。 &emsp;&emsp;博主关注Mono始于Unity3D引擎，因为Mono真正实现了.NET技术的跨平台，而Unity3D引擎最为人所称道的当属其强悍的跨平台能力，在这一点上Mono功不可没。在此之前收费的Xamarin让人望而却步，所以Mono自然而然地就成为了我的选择。因为博主的计算机上安装了Mono，所以在一开始使用VSCode的时候，就先入为主地认为在不安装插件的情况下，应该就可以直接在VSCode中编译和调试代码了。首先我们在VSCode中创建一个C#代码文件，既然在程序世界里万事万物都从Hello World说起，那么我们这里依然遵循这个原则。在创建该代码文件以后，我们将其所在的目录在VSCode中打开，这是因为： 在VSCode中仅支持以目录方式打开的文件的编译和调试 所以这个时候我们在VSCode中的界面应该是如图所示： 在VSCode中编写代码 好了，下面我们直接按下Ctrl+Shift+B来编译代码，此时VSCode将提示我们“配置任务运行程序”，这里需要说明的是，在VSCode中你可以感受到微软对命令行和配置文件的偏执，这让适应了Visual Studio这样功能强大的我们相当不习惯，按照VSCode的提示或者是通过Ctrl+Shift+P打开命令面板，VSCode将在当前工作目录下为我们创建.vscode目录和tasks.json文件，在VSCode中任何和项目相关的配置信息都会存储在这里啦。此时我们配置tasks.json: 12345678910111213&#123; // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format \"version\": \"0.1.0\", // 该命令需要在系统变量内定义 \"command\": \"mcs\", // 或者使用完整的可执行路径 // \"command: \"C:\\Program Files\\Mono\\bin\\mcs.exe\" \"isShellCommand\": true, \"args\": [\"*.cs\"], \"showOutput\": \"always\"&#125; 在这里需要说明的是一个tasks.json中可以通过tasks属性来配置多个任务运行程序，例如我们的项目中有Python和C#两种代码需要编译，那么我们就可以配置两个task，VSCode将在运行程序的时候让用户由哪一个task来编译代码。如果你看过我在前面介绍过的两篇文章，就应该知道这里的mcs.exe其实是Mono提供的C#编译器，它负责将我们的C#代码编译为IL文件，然后IL文件再交由CLR来转换为本机代码。Mono提供的C#编译器可以将C#代码编译为.exe或者是.dll，可是在VSCode中好像默认都是编译为.exe，所以如果有知道如何在这里配置编译输出项的朋友，希望可以告诉我怎么去实现。 &emsp;&emsp;现在，我们应该会得到一个MainClass.exe的文件，最初博主尝试直接去配置launch.json，发现直接填写type为mono在VSCode中是无法识别的，最后决定去安装mono-debug的插件，安装插件在VSCode中是非常简单的，按下Ctrl+Shift+X打开插件界面，可以在这里查看最流行的插件列表、官方推荐的插件列表等等，我们直接搜索mono-debug然后安装插件即可。可是我不曾想到的是，我猜中故事的开头，却没有猜中故事的结尾，这个插件是不支持Window平台的，这个插件是不支持Windows平台的，这个插件是不支持Windows平台的。 &emsp;&emsp;好吧，现在看起来Linux是我唯一可以去尝试的平台了，博主这里选择的是颜值最高的Elementary OS，这是一个衍生自Ubuntu的Linux发行版。在VSCode正式版发布以后，在Linux下用VSCode来编程是我一直在尝试的事情，请不要说Linux系统使用起来会非常困难，博主在安装这些软件的过程中可以说是相当顺利。建议大家在Linux平台下安装C#、Mono-Debug和Python这3个插件，需要说明的是C#和Mono-Debug在第一次使用的时候，需要在网络环境下下载相关依赖。下面是博主目前的插件安装情况： VSCode中插件安装界面 &emsp;&emsp;我们现在按F5进行调试，和编译时一样，如果用户没有为当前项目配置“任务调试程序”，VSCode会提示我们去创建一个配置文件launch.json，我们这里选择mono，该选项在安装Mono-Debug插件以前是没有的，该配置文件如下，我们注意到这里需要修改program属性为MainClass.exe: 123456789101112131415161718192021222324&#123; \"version\": \"0.2.0\", \"configurations\": [ &#123; \"name\": \"Launch\", \"type\": \"mono\", \"request\": \"launch\", \"program\": \"$&#123;workspaceRoot&#125;/MainClass.exe\", \"args\": [], \"cwd\": \"$&#123;workspaceRoot&#125;\", \"preLaunchTask\": \"\", \"runtimeExecutable\": null, \"env\": &#123;&#125;, \"externalConsole\": false &#125;, &#123; \"name\": \"Attach\", \"type\": \"mono\", \"request\": \"attach\", \"address\": \"localhost\", \"port\": 5085 &#125; ]&#125; &emsp;&emsp;这里有一个小插曲，在博主运行这个简单的程序的时候，提示Mono的版本和Mono-Debug插件的版本要求不一致，因为Mono-Debug插件使用的是最新版本的Mono。所以，果断卸载目前的mono，然后安装最新的mono，安装方法为：1sudo apt-get install mono-complete 这样我们就可以看到眼前的成果啦，我们成功地在VSCode运行了一个C#程序： VSCode中调试代码 &emsp;&emsp;虽然我很想在这篇博客中搞点干货出来，但是当我折腾数天以后，我大概就能够写出这样一篇相当零碎的文章，到目前为止我还是没有搞明白，为什么我在调试地过程中，VSCode不会在我设置了断点地地方停下来，希望知道这个原因的朋友可以告诉我啊。这个过程最有意义的地方在于让我进一步熟悉了Linux，在不一样的地方，会有不一样的风景，这个世界很大，不要给自己设限。后续我会去研究VSCode中的调试技巧以及.NETCore相关内容，能看到C#跨平台运行是件幸福的事情，而跨平台开发是我一直在探索的方向之一。夜晚已然来临了，而这篇文章就是这样了，谢谢大家的关注，晚安！","tags":[{"name":"Mono","slug":"Mono","permalink":"http://qinyuanpei.github.io/tags/Mono/"},{"name":"跨平台","slug":"跨平台","permalink":"http://qinyuanpei.github.io/tags/跨平台/"},{"name":"VSCode","slug":"VSCode","permalink":"http://qinyuanpei.github.io/tags/VSCode/"}]},{"title":"在Kindle上阅读Markdown文档","date":"2016-11-13T13:58:35.000Z","path":"posts/1152813120/","text":"&emsp;&emsp;其实我一直希望Kindle能够成为我知识管理的一部分，我们此刻所处的这个时代实则是一个信息爆炸的时代。我们每天都不得不去面对各种各样的信息，可这些信息中有多少是我们真正需要的呢？在一个信息碎片化的时代，有人说我们要懂得如何去利用碎片化的时间，有人说我们要懂得如何去高效查找需要的信息，微信和微博这类社交产品加速了信息的碎片化，或许当我们发现自己无法再集中精力去做一件事情的时候，我们就应该停下来反思如何去做好个人知识管理，我一直希望Kindle可以成为我知识管理的一部分，因为Kindle的阅读体验完全超越主流的电子设备，而且它可以让我们更加专注地去关注内容本身，Kindle的同步机制为了提供了良好的知识管理契机，所以这篇文章我主要想分享我在以Kindle作为知识管理载体这件事情上的想法，希望对大家有所启发。 记录，成为更好的自己&emsp;&emsp;相信大家都有在阅读中收集和整理内容的习惯，尤其是当我们需要在写作过程中参考大量资料的时候。对博主而言，写博客其实是我学习和理解技术的一种方式，我始终相信：写作是一种自我鞭策式的学习方法。当我们通过描述来向别人传达一种概念时，如果连自己都没有想清楚其中的关节，那么我们必然无法想别人清晰地传达这种概念。或许我们会畏惧犯错，畏惧向别人传达出错误的概念，可是如果你永远不愿意迈出那一步，那么我们就永远无法知道自己的弱点在什么地方。所以，当我们尝试对自我进行知识管理的时候，我们就需要一种良好的方式来管理这些零散的知识，在这里Markdown和Kindle会成为我们的强力工具，来帮助我们收集和整理各种各样的信息，正如我在写这篇博客的时候，我需要Markdown文档撰写和Kindle电子书格式的相关内容，我可以快速地从我的为知笔记中找到参考内容。 &emsp;&emsp;我最早一直使用网易的“有道云笔记”来做笔记，选择“有道云笔记”更多的原因是我使用着“网易云音乐”、“网易邮箱”和“网易云阅读”等众多的网易旗下产品。虽然国内不乏有OneNote、为知笔记、有道云笔记、EverNote、马克飞象等众多笔记类产品，可是选择一款适合自己的笔记产品非常困难的。让我逐渐想要放弃有道云笔记的一个重要原因是，有道云笔记在推出“云协作”功能后，整体上显得非常臃肿，即使在后来推出了我喜欢的Markdown功能，我还是决定渐渐地从这个产品中过渡出来，或许是网易公司这样的大厂更注重产品线的全面化，“有道云笔记”在一段时间里产品定位一直相对尴尬，而且“有道云笔记”不支持导出笔记到同类产品这个举动，让我觉得这不符合网易相对国内厂商一贯良心的风格，所以我不得不去寻找一款它的替代产品。 &emsp;&emsp;而最终我选择了为知笔记，它整体天蓝色的风格让我非常喜欢，虽然没有“有道云笔记”功能强大，而且内置付费模板，但对我来说，因为大部分记录都是在手机上，所以对我来讲，其实免费的功能基本足够我使用了，当然选择为知笔记的一个重要理由是它可以支持Markdown，而且它的笔记存储格式为.zip和.html，这意味着我们可以将笔记从云端同步到本地以后，我们可以将其导出到其它笔记产品中，这是我非常喜欢的特性。对为知笔记来说，它提供了类似Kindle通过邮箱传输电子书的功能，因此我们可以通过这个机制来将喜欢的资料推送到为知笔记中，目前主流笔记类产品在微信公众号中都提供了发送文章到笔记的功能，显然亚马逊官方公众号提供的Send To Kindle可以为我们提供类似的体验。即使微信公众号的出现让信息变成了新的信息孤岛，可我们通过这种方式来让我们感兴趣的内容被收集到笔记中，这是否在说明笔记类应用和Kindle阅读器冥冥之中就存在某种联系呢？ 使用Markdown来写作&emsp;&emsp;可能你想象不到，你眼前看到的这篇博客，正是我通过Markdown这种“语言”来完成撰写的。而事实上，我使用Markdown超过三年了，对我而言Markdown是一种能让我专心写作的一种利器，不要告诉我Word是这个世界上标准的文档编写工具，如果我告诉你，使用Markdown你仅仅需要的是一个记事本，你是否还会对它的强大产生怀疑呢？事实上Word作为文档编制标准，对我们使用Markdown并没有太多影响，因为写作本来就应该是一件让自己开心的事情，如果我们不喜欢它，为什么不尝试更好的方式呢？一种让你可以关注核心内容的撰写，而非字体、段落或者是排版这种和样式息息相关的事情，我并不是说这些东西不重要，仅仅是因为从此时此刻开始，它开始变得不再重要起来。 &emsp;&emsp;或许对普通人而言，Markdown是一种陌生的语言，因为Markdown天生就有着极客的基因，我们最早接触Markdown或许是从Github上的某种一个开源项目开始，这种与生俱来就在全球最大的同性交友网站上活跃的语言，或许会被人们下意识地打上“程序员”的标签，这个世界从来不乏因为一知半解而肆意猜度的人，其实Markdown在写作领域是一种非常时尚的语言，我经常被别人问一个问题，Markdown到底能为我们提升多少效率呢？这让我们从Markdown的语法说起。虽然我们称Markdown为一种语言，事实上Markdown是由John Gruber设计的一种标记语法，它的基本元素有： 标题&emsp;&emsp;Markdown中定义标题采用#来完成，按照标题的级别，我们在需要提升为标题级别的内容前面，添加指定数目的#就可以了。例如我们可以定义下面的标题，以此类推总共有6级标题：123# 一级标题## 二级标题### 三级标题 列表&emsp;&emsp;熟悉HTML的朋友都知道，在HTML中存在有序列表和无序列表两种，而在Markdown语法中无序列表采用-或者*来完成，有序列表采用1.、2.等来完成。我们来看一个简单的示例：123456789//这是一个无序列表* 无序列表元素1* 无序列表元素2* 无序列表元素3//这是一个有序列表1. 有序列表元素12. 有序列表元素23. 有序列表元素3 引用&emsp;&emsp;我们在写作时经常需要引用相关观点来作为辅证，我们学习一种知识通常是一种由内而外的方式，我们从这个世界吸收知识和思想，通过内化来形成我们独立的世界观，世界原本就不是非此即彼的，就像自然界中的熵增定律一般，永远处在一种动态的平衡中。对Markdown来说，它采用&lt;来完成引用的定义。例如，愿洞察之父指引我等：1&gt; 万物皆虚，万事皆允。当其它人盲目追寻真相的时候，记住万物皆虚；当其它人被道德和法律约束的时候，记住万事皆允。 图片与链接&emsp;&emsp;互联网的重要精神是分享，我们说没有人是一座孤岛，对互联网来讲，没有链接就意味着没有一切。在Markdown语法中图片和链接的定义方式是非常接近的：12[Google](http://www.google.com)![这是一张图片](http://mouapp.com/Mou_128.png) 加粗与倾斜&emsp;&emsp;我们通常会在文档中将重要信息加粗或者倾斜以表示其重要性，这种习惯在工作以后写邮件的时候得到了进一步的强化，虽然我们说Markdown更关注内容本身，即认为内容是写作的核心，可是这并不代表Markdown就此黯淡无光，相反地通过定义CSS样式，我们可以让Markdown文档更加美观和优雅。在Markdwn语法中，我们使用两个来表示加粗，一个表示倾斜。比如下面这个例子：12**这是一个加粗的文本***这是一个倾斜的文本** 代码高亮&emsp;&emsp;没有什么比看到一段支持代码高亮的代码片段更让人开心的了，所以你至此就会明白，为什么Markdown会如此深受工程师们的喜爱，尤其当我们需要撰写一篇技术文章并且需要在文章中展示代码的时候，如你所见，这个博客中所有的代码片段都支持代码高亮，这样可以给阅读者更好的阅读的体验，我想吐槽的一件事情是公司内部的Jira居然不支持Markdown语法，虽然公司的第一架构经常会在这里Share技术文章，可是糟糕的代码片段完全让人没有继续看下去的冲动。在Markdown中定义一个代码块的语法使用三个`符号：123456789using System;class MainClass&#123; public static void Main(string[] args) &#123; Console.WriteLine(\"Nothing is true, Everything is permitted.\"); &#125;&#125; 表格&emsp;&emsp;表格在Markdown中使用频率相对较低，因为如果没有编辑表格内容的需求，通常采用图片来展示表格内容会是一个更好的选择，而表格在Markdown中的表示同样是最复杂的，当然更复杂的是Markdown中的LeTex和FlowChar，这些均属于Markdown的扩展语法，因为违背Markdown语法简洁的原则，所以我们在这里简单说下Markdown中的表格：12345| Column1| Column2| Column3||:-------|:------:|-------:|| Left | Center | Right || Left | Center | Right || Left | Center | Right | 这里我们定义了一个四行三列的表格，我们这里使用:符号来表示表格中的对齐方式，显然这三列分别表示左对齐、居中对齐和右对齐，我们说表格这种元素复杂，主要是因为当表格中内容特别复杂的时候，这个表格定义就会降低可读性，而且它无法处理在单元格内换行的情况，所以它主要适用于表格内数据相对简单的情况下。 &emsp;&emsp;好了，这些就是基本的Markdown语法所定义的元素啦，我觉得这是一种非常优雅的标记语言，如果你觉得纯文本的内容太单调，如果你觉得Word使用起来太复杂，那么Markdown就在这两者间找到一个平衡点，我没有劝大家放弃Word然后转而投身Markdown写作，可是作为一个经常码字的博客作者，我可以负责任的说，Markdown是一种可以让你专注写作的工具，而且作为一名工程师，你会发现StackOverflow、Segmentfault、Github等知名技术社区，无一例外地都在支持Markdown语法，所以Markdown其实是开源社区里除了英语以外的第二大通用语言，所以如果你喜欢写作或者是喜欢开源，Markdown都会是你不错的选择，而它的语法相信你此时已然学会了。 从Markdown到Kindle&emsp;&emsp;有人说，Markdown是一个人的狂欢，因为即使你再喜欢Markdown语法，如果你身边的同事都在使用Word等不同的工具，那么你该如何和他们写作呢？这听起来好像是一个严重的缺陷，所以Markdown注定是一种小众的写作语言。Markdown可以转化为HTML或者PDF，相比HTMLPDF相对会好些，因为HTML需要依赖CSS样式文件，没有样式文件的HTML是无论如何都不能彰显Markdown的优雅的。那么，难道我们就要坐以待毙接受这种妥协，Markdown注定要被人们抛弃吗？不，让我们勇敢地说不，下面我们介绍常见的Markdown导出/转换工具： 文档转换神器Pandoc&emsp;&emsp;如果说Markdown是这个世界上最为简洁、优雅的书写语言，那么Pandoc就是标记语言转换领域的瑞士军刀。我们知道Markdown是一种轻量级的标记语言，它可以允许写作者使用纯文本标记来来编写文档。通常我们会在Markdown编辑器中完成Markdown文档的编辑，然后将其发布到支持Markdown语法的站点上。以博主为例，博主会在Sublime中安装了Markdown插件，通常我会在Sublime中编写好文章，然后利用Hexo这个静态博客生成器生成静态HTML页面，利用Github Pages提供的静态网页托管服务，我将这些博客发布到了互联网上，大家此刻所看到的这篇文章就是通过Markdown语法撰写的。可是一旦Markdown语法出现在一个不被支持的场合，Markdown的简洁、优雅都将大打折扣，这个时候就该我们的Pandoc登场啦！ &emsp;&emsp;Pandoc是一个采用Haskell语法编写的命令行工具，或许你对Haskell这样的函数式编程语言闻名已久，但是我相信Panndoc对我们每一个人来说都是一个新颖的事物。Pandoc采用GNU GPL授权协议进行发布，属于Linux世界的自由软件。庆幸的是，Pandoc支持主流的Windows、Mac和Linux三大平台，这里我们以Windows平台为例介绍Pandoc这个工具。Pandoc支持HTML、.docx、Markdown、LaTex、.TXT、.epub等常见格式的转换，以Markdown为例： Markdown转HTML 1pandoc README.md -o README.html Markdown转Word 1pandoc README.md -o README.docx Markdown转Pdf(需要安装LaTex) 1pandoc README.md --latex-engine=xelatex -o README.pdf &emsp;&emsp;好了，现在通过Pandoc我们可以将Markdown转换为可读性更为良好的文档，而我们知道Kindle阅读器是可以支持.pdf格式的文档的，虽然这种格式在Kindle并不能做到尽如人意，可是这对于我们而言，是将Markdown和Kindle紧密联系在一起的重要一步，这意味着我们只要Markdown文档转换为Kindle支持的文档格式，就可以实现Markdown+Kindle的个人知识管理方案。 支持导出HTML/PDF的Cmd Markdown编辑器&emsp;&emsp;下面推荐的是由作业部落出品的Cmd Markdown编辑器，这款自称为国内国内最强大的Markdown编辑器，实现了全平台覆盖，可以在线编辑同步预览，同时支持自动保存文档和云同步，支持一键发布文章到社区，是一个集文档编辑、预览、同步和发布等功能于一身的综合型Markdown编辑器，支持一键切换黑、白两种主题，支持直接导出HTML/PDF，整体上是一个非常出色的Markdown编辑器。我不太喜欢这个编辑器的一个重要原因是，我喜欢在离线环境下写文章，然后将其发布在我的个人博客上面，而这款编辑器和社区耦合过紧，虽然提供了离线版本的Markdown编辑器，但是对我而言功能上略显臃肿，我在这里推荐这个Markdown编辑器的原因是，它提供了HTML/PDF的导出功能，当我们在线编辑Markdown文档时即可通过浏览器导出HTML/PDF，如果你不需要经常导出Markdown为其它的文档格式，我会推荐你使用Sublime、VSCode、马克飞象、为知笔记、小书匠等编辑器，虽然Markdown语法对使用者的要求并不高，但我相信有一个体验良好的Markdown编辑器，会让我们的写作过程更为开心，从而达到事半功倍的效果。我们这篇文章的主题是希望将Markdown和Kindle结合起来形成一套个人知识管理的方案，所以在这里的核心关注点就变成了如何快速、高效的导出Markdown为其它文档格式，而在这一点上，相信Cmd Markdown不会让你我感到失望。 支持导出PDF/Mobi/Epub格式的GitBook&emsp;&emsp;好了，下面我们介绍一个使用Github/Git和Markdown来构建电子书的网站GitBook，请不要误会，这个网站和全球最大的同性交友网站Github没有任何直接的关系，两者的关系可以理解为，GitBook是一个基于Github/Git的静态页面生成器，其本身是一个由NodeJS编写而成的命令行工具，而通过这个工具和Markdown语法，我们就可以创建出足以媲美专业电子书籍的电子书，和Hexo类似，我们可以将这些生成的静态页面部署到Github Pages来供其它人浏览和阅读，除此以外GitBook本身就是一个相当优秀的内容发布平台，截止到今天GitBook上已经有18036本电子书。如果说在此以前，我们讨论的话题，即如何将Markdown转换为Kindle支持的电子书格式，是一个和Kindle电子书没有多少交集的话题，那么此时此刻我们已然和电子书密切地发生着关系，并且我们可以编写一本属于自己的电子书然后将其存放在Kindle上来阅读，这是一件非常酷的的事情，不是吗？如同王力宏在《开讲啦》节目中提到他幼时曾憧憬在广播里听到自己的歌一样，相信每一个喜欢写作的人，都渴望有朝一日看到自己的作品被发布出来，而GitBook就给了你这样一个梦想成真的机会。GitBook提供了epub、moni和pdf等非常Kindle的文档格式导出功能，因此我们可以在编写完Markdown文档后直接导出为Kindle支持的文档格式，这是多么美好的一件事情呀！除此以外，我们还可以使用Calibre这个Kindle电子书管理软件来完成Markdown文件的支持，但这个世界上没有绝对完美的事情，经过博主尝试后发现，使用Calibre转换的电子书在Kindle上阅读体验并没有想象中出色，对此感兴趣的朋友可以自行尝试，这些都是后话啦！ #本文小结&emsp;&emsp;个人知识管理其实是一个非常答案开放的问题，常言道“世事洞察皆学问，人情练达即文章”，当你渐渐地建立个人知识管理的意识，开始经常性地去梳理和完善自我的知识体系，这个时候到底选择什么样的方式来管理，其实是并不重要的，就像我们管理项目可以使用Github，同样可以使用Jira，这并不意味着这其中哪一种就是最好的，只有适合自己的才是最好的，就像我们使用Jira来管理项目并不意味着我们就在践行敏捷开发，我更愿意相信Wesley的观点，当你真正领会一件事情的思想和本质的时候，其实采用什么样的形式反而是次要的，我们从小到大常听到的一句话是，”如果连形式化的东西都不愿意去实践，又有什么资格来妄谈超脱形式化呢？”，我们暂且不管这句话对不对，我们必须认同的一点是，从Git到Github到Markdown到GitBook再到Kindle，一个明显的趋势是，我们这个时代，信息会越来越趋于碎片化，而与此同时，开源让我们每一个人离信息越来越近，当每一个人都成为信息的提供者，我们这个时代是一个百家争鸣、集思广益的时代，所以不管你愿不愿意，不管你有没有意识到这一点，学会去高效地检索信息、学会高效地管理信息、学会高效地利用信息，这是这个时代对我们个人知识管理能力的一种要求。好了，这篇文章就是这样啦，再次谢谢大家的关注！","tags":[{"name":"Kindle","slug":"Kindle","permalink":"http://qinyuanpei.github.io/tags/Kindle/"},{"name":"Markdown","slug":"Markdown","permalink":"http://qinyuanpei.github.io/tags/Markdown/"},{"name":"阅读","slug":"阅读","permalink":"http://qinyuanpei.github.io/tags/阅读/"}]},{"title":"生命的朝圣者","date":"2016-11-05T21:44:52.000Z","path":"posts/3657008967/","text":"&emsp;&emsp;最初开始读这本书的时候，并没有想到这本书会讲这样一个故事，甚至它不像一本畅销书一样让人充满期待，可是当你逐渐理清整个故事的来龙去脉以后，或许你会喜欢这个故事甚至被这个这个故事所震撼。我从未对宗教意义上的朝圣进行过深入了解，我所知道的朝圣，比如每年伊斯兰教历的第十二月，都会有数以百万计的伊斯兰教徒前往麦加参与朝觐仪式，而国内每年都会有从各地前往布达拉宫下的大昭寺朝佛的佛教信徒，而对藏传佛教信众来说“叩长头”是最为至诚的礼佛方式之一。所以朝圣是一项具有重大的道德或者灵性意义的旅程或者探寻，它关乎对信仰的思考同时注重身体力行，因为朝圣者始终相信前往一个重要的地方，能够从中获得灵性或者是得到治愈。 &emsp;&emsp;本书的主人公哈罗德.弗莱，一个六十岁的老头儿，在酿酒厂工作了四十年后默默无闻地退休。在他平静如水的生活中，不曾经历过升迁的起起落落，他不曾得罪过别人到处树敌，更没有可以亲近到交心的朋友。他和心存隔阂的妻子住在乡下，生活平静却彼此感情疏离，日复一日，年复一年。直到有一天，一封来自二十年未见的老友奎妮地信，让哈罗德原本平静地生活开始发生变化。在信中奎妮告诉他自己患了癌症，哈罗德感到莫名的震惊和悲痛，此时他做了一个疯狂的决定：从英国最西南一路到最东北，徒步跨越整个英格兰去看望她。而让他产生这个想法的原因是他想当然地认为，只要自己去看奎妮她就能够活下来。这听起来确实是一个疯狂的想法，可是谁能够真的预料这个世界下一刻会发生什么呢？ &emsp;&emsp;当哈罗德决定要开始做这件事情的时候，我们或许不会想到，这场以生命的名义发起的朝圣，其实是哈罗德内心深处的一种自我救赎。哈罗德是一个平凡如你我的普通人，甚至从他波澜不兴的人生轨迹中，我们完全找不出他的生命里有过哪些闪光点。当我们以今天这样一个世俗的眼光来审视哈罗德的时候，或许沉默寡言的哈罗德完全就是一个失败者，可当他徒步走完627英里的这段旅程以后，我们或许会明白，我们每一个人都是不完美的，而哈罗德所做的，无非是希望通过一个原始而质朴的方式，找回埋藏在内心多年的善良和温情，他曾经不是一个合格的丈夫、更不是一个合格的父亲，可是在经历过这段旅程以后，他终于找回了一个愈加真实的自己，这是一场关于生命地修行。 &emsp;&emsp;有时候我们完全无法认清自我，因为随着年龄的增长，我们常常会因为这个冰冷的世界而变得麻木，我们开始学会沉默、学会妥协，那份与生俱来的骄傲终于被岁月磨去棱角。我们开始欺骗自己，认为这就是所谓的成熟。我特别喜欢这句话，“知世故而不世故，方为最善良的成熟”。当我们回首哈罗德的生平的时候，我们会意识到，这是一个一生都被挫败感塞满的男人，从小就害怕成为大家关注的焦点;一辈子都弯着腰生活，习惯像影子一样悄无声息，甚至于在他退休的时候，公司都没有为他举行过欢送仪式;他害怕被抛弃，结果因为儿子的死和妻子产生隔阂;他太害怕失去眼前，所以在儿子溺水时犹豫不决选择停下来解鞋带;他太害怕错过美好，所以在新婚之夜躲进厕所而不敢直视美丽的妻子.人们常常无法接纳不完美的自己，或许是因为我们心怀执念，或许是因为我们习惯自卑。可是不管怎么样，生活的意义就是去发现自我，更好地接纳这个世界。 &emsp;&emsp;在这段旅行中，哈罗德遇到了加油站女孩、客店旅人、玛蒂娜等等不同的人，对哈罗德来说，这些人是他旅途中遇到的路人甲，可正是这些路人甲教会了哈罗德很多东西，让他学会了聆听别人的故事，学会了坦陈内心分享自己的故事。我们的人生是一个过程，它的起点和终点都是上天安排好的，我们要做的就是去让这个过程变得丰富起来。所以，试着去接受些你不了解的东西、去争取和相信自己可以改变某些事情。与其踟蹰不前犹豫不决，不如去接受这些来自未来的恐惧，当我们心中坚信自己一定可以做到的时候，其实我们离目标已然接近了一步。我们都还年轻，所以为什么不趁着现在，去做些真正疯狂的事情，如果当我们垂垂老矣的时候，发现生命是如此的苍白，大概我们会更加因为年轻时的碌碌无为而悔恨终生吧。人们都是憧憬着未来，期待着无限美好可能性。当我们明白爱是一种发自本性的情感，我们便真正具备了爱一个人的能力。 &emsp;&emsp;我时常会因为控制不住情绪而伤害到别人，虽然我知道我的本意并不是为了去伤害别人，可是当对别人的伤害已然造成，它就会像钉满篱笆的钉子即使钉子被拔出来，可是永远无法再让篱笆变回它原来的样子。所以，在读这本书的过程中，我有时候会同情哈罗德的妻子莫琳，如果你面对的是一个终日木纳寡言的丈夫，甚至他从来都学不会浪漫或者是哄你开心，你会怎么想呢？最初莫琳对丈夫的困惑不解、担忧愤怒，随着故事的推进逐渐演变为探寻改变、尝试了解，甚至到故事的最后两个人终于重新走到一起，我最喜欢的情节是两个人尽释前嫌，手牵着手走向海边，一边走一边回忆第一次两个人在舞会上认识的情景，这个旅程是一个人的远行，可是它却是两个人的灵魂回归，当哈罗德逐渐接受自己懦弱的一面，开始学会承担责任；当莫琳开始反思过去的种种经历，回想起丈夫曾经温情的一面，我想说，世间所有的相遇都是久别重逢，有什么比相逢一笑泯恩仇更开心的事情呢？不愿意放下过去是执念，不愿意重新开始是执念，我们本来就应该温暖善良的样子，即使生活让我们暂时穷困潦倒、失意落寞，那又怎么样呢？ &emsp;&emsp;一个让我更加感兴趣的地方是，当哈罗德因为独自远行这件事情而声名远播的时候，在那一瞬间形形色色的朝圣者都表示要加入这个旅程，可是很快我们就发现，这些朝圣者或多或少的都各怀心机，有的人是为了追求名利而加入队伍，有的人是为了出一本传奇书籍而加入队伍，有的人是为了挽救一段失败的婚姻而加入队伍，有的人是为了写一篇成为头条的新闻报道而加入队伍……这就像我们这个世界，当所有人都开始尝试按照自己的理解来揣度哈罗德的用意的时候，朝圣这件事情本身地意义就会被无限的忽略，没有一个人尝试去理解哈罗德的本意，当所有人都对此趋之若鹜的时候，或许并不代表这件事情本身为人们所理解所推崇，人们喜欢的仅仅是这种被关注的感觉而已，所以请放下那颗浮躁的心，努力去聆听自己内心的声音，我们生来并不是因为我们需要这样一场添油加醋的作秀，就像我始终相信爱情是两个人彼此吸引自然而然地走到一起，我不擅长刻意的事情，或许是因为我天生就喜欢本色出演。 &emsp;&emsp;哈罗德最初开始旅程的时候，基本上是一无所有的，他腿脚不便同时患有老年痴呆，正是这样的状态让妻子莫琳对他的所作所在困惑而愤怒，可是随着旅途的深入，那些在旅途中遇到的路人们，常常会馈赠给哈罗德如地图、指南针、药物等等这些东西，所以对哈罗德而言，这个过程是一个装备逐渐增加的过程，可是当他离目标越来越近的时候，他不得不将这些东西转赠给其他人或者是不慎在旅途中丢失，我印象比较深的一点是，他在旅途中收留了一条流浪狗，在相处的过程中逐渐培养出了感情，此时的哈罗德想起自己的儿子曾经想要养一条小狗，可是因为他的固执和懦弱，这个愿望最终成为永远的遗憾，正当他为此而费心伤神时，这条流浪狗忽然不知所踪，等哈罗德找到它时，发现它跟上一个年轻女孩儿上了一辆公交车，或许这告诉我们，我们的人生其实就是一个由简至繁再由繁至简的过程，我们曾经年少轻狂、我们曾经迷失方向，可当我们洗净铅华、丢掉一切附庸的时候，我们或许会不由得感谢，那些生命里教会我们某些东西的人。从始至终我们面对的这个世界的悲欢离合其实都是我们自己，可能有些人会在特定的时候出现然后陪伴我们一段时间，可我们最终会发现，有些路只能我们一个人来走。 &emsp;&emsp;我们总要尝试去做一件想做的事情，我们总要学会去放下过去重新开始，这是一个人的涅磐，这是哈罗德的朝圣。“也许当你走出车门真真切切用双腿走路的时候，绵延不绝的土地并不是你能看到的唯一的事物”。我忘记这句话是故事中的哪个人物曾经说过的话啦，我对小说一直没有完全能股投入阅读的感觉，我想人的大脑里有太多的东西我们不明白，但是你想想，如果有信念，你就一定能把事情做成。你是否还记得最初开始这个旅程时说过的话： 我现在马上出发。只要我一天还在走，她一天就要活着。请告诉她这次我不会让她失望。 Payne 于 2016/11/12","tags":[{"name":"生活","slug":"生活","permalink":"http://qinyuanpei.github.io/tags/生活/"},{"name":"读书","slug":"读书","permalink":"http://qinyuanpei.github.io/tags/读书/"},{"name":"朝圣","slug":"朝圣","permalink":"http://qinyuanpei.github.io/tags/朝圣/"}]},{"title":"基于C#中的Trace实现一个简单的日志系统","date":"2016-10-25T20:16:13.000Z","path":"posts/1254783039/","text":"&emsp;&emsp;最近在做的项目进入中期阶段，因为在基本框架结构确定以后，现阶段工作重心开始转变为具体业务逻辑的实现，在这个过程中我认为主要有两点，即保证逻辑代码的正确性和容错性、确定需求文档中隐性需求和逻辑缺陷。为什么我说的这两点都和用户需求这个层面息息相关呢？或许这和我这段时间的感受有些关系吧，我觉得当我们在面对用户提出的需求的时候，一个非常让我们不爽的一个地方是，我们总是需要花费大量的时间来和用户确定某些细节，而这些细节无论在BRD或者PRD中都无从体现。固然从用户层面上来讲，我们无法要求用户提供，详尽到每一个细节的需求文档。可我觉得这是一个修养的问题，我们习惯于宽以律己、严以待人，可是如果我们连自己都说服不了，我们该如何尝试去说服别人呢？我不认为我们就应该被用户限制自由，我们共同的目的都是想要好做一件事情，所以我们的关系应该是平等的伙伴的关系，这种上下级的、命令式的主仆关系让我感觉受到了侮辱。 关于最近的碎碎念&emsp;&emsp;其实对我而言，我更希望在工作中能找到一种释放天性的氛围，因为我觉得我们这个世界每天都有新的技术诞生。可是当我发现，我们的用户依然在使用着20多年前的技术的时候，我常常感觉到一种难以言表的紧迫感，或许对银行这类用户而言，它对安全和可靠的需要远远超过对新技术和新工具的需要，可是当我看到身边的同龄人甚至是人到中年的时候，我忽然间发现，原来这一切离我是如此的近，当你看到身边的同龄人对代码开始厌烦，继而将其当作糊口的工具的时候，我有时候就常常在想，我离这种状态会有多远，我讨厌自己不像期望中那样好，因为我曾错失过一个我爱的人，所以我有时候会像强迫症晚期一样，刻意地去追求完美。或许接受平庸会更像一个正常人，可我怕我再没有勇气去轻易喜欢一个人。我承认，我在这件事情上偏执是因为我在某种程度上自卑，可是如果我们能做得更好，为什么不去尝试做得更好呢？ &emsp;&emsp;这段时间，我喜怒无常的性格，或许让我身边的同事受到了伤害，其实我从来都不是针对任何人，我只是对这种无法掌控的现实的一种愤怒，我们常常被用户要求，为他们开发某种自动化的工具，可是我们所有的工具流，都是建立在一套尚未健全的设计上的，甚至用户内部使用的相关系统存在各种各样的设计缺陷，而这些完全不适合做自动化的特性，常常面临被设计到需求文档中的尴尬。虽然工程师喜欢解决问题，可解决问题并不代表要以牺牲技术上的先进性为代价，就像今天我们同样可以使用汇编语言来开发应用程序，可是有谁会选择这样做呢？这是因为汇编作为工具本身就是一种相对低级的编程语言，所以在这种情况下，我不认为花费精力来为落后的工具填坑，是一种值得称赞的事情，我们早已告别了石器时代，可有人因为学会了钻木取火而沾沾自喜，这是一种悲哀。我们既然让计算机来替人们做事情，所以就应该明确告诉计算机到底想做什么。一切没有任何规则可言，同时妄图实现自动化的过程，都是在赤裸裸的耍流氓，而规则和约束常常让人性的缺点暴露无疑。 &emsp;&emsp;所以，这种向现实妥协的做法，常常会让我们编写出肮脏的代码。我们总是想要编写出优雅、通用的代码，可因为工具流的落后、需求频繁变动、设计缺陷等等的原因，我们在面对这些东西的时候，常常感觉被人类的愚蠢的打败，人们说是人类发明了计算机，可是这是否就意味着我们一定会比计算机聪明，难道计算机无法通过深度学习超越人类吗？Google的AlphaGo凭借当今火热的深度学习理论以4:1的战绩打败了韩国棋手李世乭，可是不愿意去学习新知识的人类居然可以自信到能够驾驭计算机，我说将来会有越来越多的工作被计算机代替，我的一位长辈不以为然的说，不管计算机如何智能它总需要人类来控制它吧，我真的很想问一句，如果计算机真的超越了人类它为什么还需要人类来管理，而人类依靠什么样的技术来管理这些计算机。我认为在这个世界上，总是存在某种永恒的规则，它可以超越生与死的界限，而这些规则永远不会被打破，人类就像一个任性的孩子一样，可真理不就是用来敬畏的吗？我们对这个世界了解的越多，发现自己越来越渺小，此时此刻，你是否还有信心说我们可以驾驭计算机？ &emsp;&emsp;写这些碎碎念，其实是想反映我这段时间的心理状态，有人说，摆脱失恋最好的方法就是投入一段新的感情，可是其实你永远都清楚地知道，在你心里最看重什么，所以我对代码有一种特殊地感情，你可以清楚地从代码中读出一个人的所思所悟，因为那就是你独特个性的一种写照，所以每一次或许Alex让我改代码的时候，我都是在和我自己赌气吧，我不愿意让那些奇怪的逻辑破坏它的纯粹性，它必须是统一的、简洁的、纯粹的，它不能掺杂丝毫的丑陋的设计。而这种情况常常是因为用户在设计需求的时候忽略了某些细节，所以对我而言我生气、我愤怒，并非是我觉得这个需求无法实现，而是它在某种程度上是冗余的，即它可能破坏了一致性原则，灵活的人类是比呆板的计算机有趣，可和人相处得久了，你难免会觉得人显得不靠谱，这就是我厌恶的理由，在这个世界上所有一切计算机可以处理的问题，在某种程度上都可以转化为数学问题，一旦我们将设定突破这个规则，就会让代码因为妥协而变得丑陋不堪，我显然不允许这样的事情发生。 花十分钟解锁新技能&emsp;&emsp;好了，现在我们来回到这篇文章的主题，基于C#中的Trace来实现一个简单地日志系统。我们的项目上存在大量和用户内部系统关联的特性，所以我们会在远程计算机上耗费大量的时间来测试代码，这个时候我们会遇到两个问题，第一，我们开发环境中的Visual Studio版本和生产环境中的Visual Studio版本不一致，所以如果直接远程调试，因为项目中使用的相关语法在低版本Visual Studio中不被支持，如果修改代码会非常痛苦，我们实在没有精力去兼容两个版本的开发环境。第二，项目中默认使用的日志系统Log4Net，默认是在指定用户的我的文档目录中产生日志信息，而我们在远程调试时因为权限问题无法访问日志文件，所以虽然我们可以根据界面上反馈的信息，来粗略判断异常发生在什么时候，但这对我们追踪和定位问题来说是非常不利的。我们在研究了Log4Net的文档后，认为这个库的配置文件非常复杂，所以我们在想有没有一种更为简单地方案可以帮助我们解决这个问题。 &emsp;&emsp;我们了解到.NET中实际上提供了两个类Trace和Debug来满足类似的需求，而这两个类位于System.Diagnostics空间下，所以我们完全有理由相信基于这两个类，我们同样可以构建出一个相对简单的日志系统。首先我们通过MSDN了解到官方对它们各自用途的定义： Trace：提供了一组方法和属性，可以帮助您追踪您的代码执行，该类无法被继承。 Debug: 提供了一组帮助调试代码的方法和属性，该类无法被继承。 &emsp;&emsp;显然，我们通过这里给出的定义，可以非常容易的理解这两个类都可以用来追踪和调试代码，那么它们本质的区别在什么地方呢？如果我们的解决方案配置类型为Release，则会忽略Debug类的输出。换句话说，当我们处在开发调试阶段时，使用Debug类能够帮助我们在控制台或者是文件以及任意自定义的输出位置输出相关的调试信息，而当产品上线发布以后这些调试信息则不会输出。而Trace无论是在Debug还是Release模式下都会输出相关的追踪信息。通常我们会在发布以后的产品中部署日志生成模块，这样可以方便开发者定位问题、维护产品，那么在这种情况下，我们采用Trace这种方式来追踪程序的执行情况是非常适合的，而这正是我想写这篇博客的一个原因。 &emsp;&emsp;现在，在确定了使用Trace来开发一个简单的日志系统这样一个技术路线以后，现在我们来了解下Trace都提供了那些东西吧！对Debug和Trace这两个类来说，.NET为它们提供了下面这些相同的方法： WriteLine: 该方法会在输出设备中写入一条调试信息，而通过实现不同的监听器(Listener)并对其中的方法进行重写(OverWrite)，就可以将调试信息以不同的形式输出。例如Debug类产生的调试信息默认输出在Visual Studio中的输出窗口，我们可以通过自定义监听器将调试信息输出到文件或者控制台中。同样地，对Trace类来说，它同样遵循这个原则，这体现出了一种宏观上的统一。所谓“和而不同”，我们可以尊重这个世界的规则、尊重宇宙苍生，可是我们每一个人都是一个完全独立的个体，人可以被打倒，但决不会被打败。 12Trace.WriteLine(\"This is a Debug message!\");Trace.WriteLine(\"This is a Debug message!\",\"Debug\"); WriteLineIf: 该方法是WriteLine的增强版，仅当条件满足时会在输出设备中写入一条调试信息，同样，它支持通过实现不同的监听器(Listener)来完成重写，进而将调试信息以不同的形式输出，该方法在需要根据条件处理不同响应的场景下会非常有用。例如在项目中我们会通过一个窗口来输出程序执行过程中的细节信息，这些信息对我们开发人员来讲是非常重要的，因为我们可以通过这些信息来快速地定位问题。可是这些信息对用户而言是可以完全忽略的啊，难道肤浅的我们要在这里处理这两种情况吗？不，我们只需要定义一个全局开关，从此整个世界都变得安静了。 1Trace.WriteLineIf(i&gt;10,\"This message will only output when i&gt;10\"); Indent/Unindent: Log4Net中提供了对日志输出样式的支持，它被定义在一个Xml形式的配置文件当中，我们发现一件有趣的事情，复杂和简单是矛盾而统一的，就像我对编辑器这类工具，我会喜欢它提供的各种强大的扩展能力，而对集成开发环境这类工具，我会喜欢它提供的简单上手、零配置、开箱即用这种良好特性。当你发现你提供的功能越来越多的时候，就应该停下来思考这种做是否是正确的举动，一个东西的灵活性越强，它的复杂性就会越高，因为这意味着你需要去兼顾各种各样可能的组合。在这里Indent方法可以为输出提供缩进样式，相反Unindent方法可以为输出清除缩进样式。 Assert: 断言不一定就出现在单元测试中，就像骑白马的不一定都是唐僧。严格的来讲，这里的断言相对单元测试中的断言会显得相对薄弱，因为它没有Assert这个类的功能丰富。在这里我想说的是，Assert方法会在条件不满足时显示“断言失败”对话框，在对话框中会显示当前程序堆栈调用的详细情况，这是非常有意思的一个功能。有时候我们或许会因为业务而忽略技术，业务是现实规则的一种映射，所以我们可以理解业务本身地复杂性，可我们从古到今所认识的世界难道都是这样子的吗？或许由人类定义出来的这些规则本身就是错误的呢？ 1Trace.Assert(i&gt;10,\"This message will only output when i&lt;=10\"); Flush: Flush方法可以理解为一个通知监听器的方法，因为在调用Flush方法以后，每一个Listener对象将接收到它的所有输出，我们可以理解为，WriteLine方法执行以后，无论Trace还是Debug，其监听器都不会理解响应输出，只有当Flush方法被调用以后调试信息才会被响应和输出。 &emsp;&emsp;好了，再了解了这些以后，现在我们就可以开始设计一个日志系统了。按照国际惯例，我们当然是从设计接口开始，其实在做一项设计的时候，是不是要从接口开始，完全取决于你对接口持怎样的态度，人生或许有各种各样的套路，可是需不需要遵守这些套路完全是取决你的啊，编程同样是这个道理，我的习惯是在没有理解一个东西以前，永远不要尝试去使用它，可能你会说如果永远都不去尝试，那你就永远失去了了解它的机会，我想说的是，请不要滥用：1234567interface ILoger&#123; void Warn(object msg); void Info(object msg); void Debug(object msg); void Error(object msg);&#125; 可以注意到在这里，我定义了四种级别的Log，这自然是模仿Log4Net，更重要的是这些不同的级别，我并不清楚他们之间的区别。这听起来好像挺尴尬啊。定义好接口以后，我们就可以考虑具体的实现啦！日志系统对整个应用程序而言哼，是独立且贯穿整个软件开发的生命周期的，所以将其设计为单例模式会更加友好：12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class SimpleLoger : ILoger&#123; /// &lt;summary&gt; /// Single Instance /// &lt;/summary&gt; private static SimpleLoger instance; public static SimpleLoger Instance &#123; get &#123; if (instance == null) instance = new SimpleLoger(); return instance; &#125; &#125; /// &lt;summary&gt; /// Constructor /// &lt;/summary&gt; private SimpleLoger() &#123; Trace.Listeners.Clear(); Trace.Listeners.Add(new LogerTraceListener()); &#125; public void Debug(object msg) &#123; Trace.WriteLine(msg, \"Debug\"); &#125; public void Warn(object msg) &#123; Trace.WriteLine(msg, \"Warn\"); &#125; public void Info(object msg) &#123; Trace.WriteLine(msg, \"Info\"); &#125; public void Error(object msg) &#123; Trace.WriteLine(msg, \"Error\"); &#125;&#125; &emsp;&emsp;现在我们来重点关注SimpleLoger的构造函数，显然在这里它应该是私有的，在这里我们首先从Trace类的Listeners中移除所有的监听器，这样做的目的是改变Trace类的输出行为，因为在前面介绍Trace的时候我们了解到，Trace类和Debug类默认将调试信息输出在“输出”窗口中的，而我们现在希望将调试信息输出到日志文件中，所以我们需要改变Trace类的输出行为，改变的方式非常简单啦，移除默认的监听器，然后添加我们自己定义的监听器哇，对对对，就是这样简单粗暴。下面我们来看看如何定义这样一个监听器LogerTraceLitener，它继承自TraceListener这个类，这意味着我们如果要实现一个自定义监听器，只需要继承TraceListener然后重写相关方法即可： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293public class LogerTraceListener:TraceListener&#123; /// &lt;summary&gt; /// FileName /// &lt;/summary&gt; private string m_fileName; /// &lt;summary&gt; /// Constructor /// &lt;/summary&gt; public LogerTraceListener() &#123; string basePath = AppDomain.CurrentDomain.BaseDirectory + \"\\\\Logs\\\\\"; if(!Directory.Exists(basePath)) Directory.CreateDirectory(basePath); this.m_fileName = basePath + string.Format(\"Log-&#123;0&#125;.txt\", DateTime.Now.ToString(\"yyyyMMdd\")); &#125; /// &lt;summary&gt; /// Write /// &lt;/summary&gt; public override void Write(string message) &#123; message = Format(message, \"\"); File.AppendAllText(m_fileName,message); &#125; /// &lt;summary&gt; /// Write /// &lt;/summary&gt; public override void Write(object obj) &#123; string message = Format(obj, \"\"); File.AppendAllText(m_fileName, message); &#125; /// &lt;summary&gt; /// WriteLine /// &lt;/summary&gt; public override void WriteLine(object obj) &#123; string message = Format(obj, \"\"); File.AppendAllText(m_fileName, message); &#125; /// &lt;summary&gt; /// WriteLine /// &lt;/summary&gt; public override void WriteLine(string message) &#123; message = Format(message, \"\"); File.AppendAllText(m_fileName, message); &#125; /// &lt;summary&gt; /// WriteLine /// &lt;/summary&gt; public override void WriteLine(object obj, string category) &#123; string message = Format(obj, category); File.AppendAllText(m_fileName, message); &#125; /// &lt;summary&gt; /// WriteLine /// &lt;/summary&gt; public override void WriteLine(string message, string category) &#123; message = Format(message, category); File.AppendAllText(m_fileName, message); &#125; /// &lt;summary&gt; /// Format /// &lt;/summary&gt; private string Format(object obj, string category) &#123; StringBuilder builder = new StringBuilder(); builder.AppendFormat(\"&#123;0&#125; \",DateTime.Now.ToString(\"yyyy-MM-dd HH:mm:ss\")); if (!string.IsNullOrEmpty(category)) builder.AppendFormat(\"[&#123;0&#125;] \", category); if (obj is Exception)&#123; var ex = (Exception)obj; builder.Append(ex.Message + \"\\r\\n\"); builder.Append(ex.StackTrace + \"\\r\\n\"); &#125; else&#123; builder.Append(obj.ToString() + \"\\r\\n\"); &#125; return builder.ToString(); &#125;&#125; &emsp;&emsp;在这里我重写了好多好多方法，可是实际上我在SimpleLoger中仅仅用到WriteLine这个方法，大家可以发挥自己的想象力，因为我始终相信编程是一件有趣的事情，我们有时候会感到沮丧，完全是因为这个糟糕的世界里充满了同样糟糕的事情。其实程序员是一个理性与感性并存的职业，如果是操作系统、编译原理和图形学可以并称为程序员的三大浪漫，那么Big Clean Problem将是我们最这个世界最好的敬畏，我们喜欢解决问题本质上是因为我们对这个世界充满好奇，可这并不意味着我们对问题来者不拒，这个世界产生的大部分问题都是因为人类的无知，可人类到此刻依然认为这一切非常合理。 &emsp;&emsp;现在，让我们来检验我们的这个小玩意儿，我们将编写一个非常简单的单元测试案例，我们都知道当除数为0时在数学上是没有任何意义的，所以在计算机中当我们尝试除以0的时候会引发异常，由此我们会写出下面的代码： 12345678910[TestMethod]public void Test()&#123; try&#123; int i=0; Console.WriteLine(5/i); &#125;catch (Exception e)&#123; SimpleLoger.Instance.Debug(e); &#125;&#125; 理论上它会在程序根目录下生成一个Logs的文件夹，然后每天会生成一个以日期命名的文本文件。现在，它看起来工作得很好，我没有想要做出一个更好的日志系统的野心，我更喜欢去探索一种全新的可能性，我更在意在这个过程中我们收获了什么，人生本来就充满了各种各样无意义的事情，我们之所以热爱生命，是因为我们希望它变得有趣，这样就足够了，不是吗？ 效果演示","tags":[{"name":"日志","slug":"日志","permalink":"http://qinyuanpei.github.io/tags/日志/"},{"name":"Trace","slug":"Trace","permalink":"http://qinyuanpei.github.io/tags/Trace/"},{"name":"调试","slug":"调试","permalink":"http://qinyuanpei.github.io/tags/调试/"}]},{"title":"当黑客遇见画家","date":"2016-10-09T18:38:03.000Z","path":"posts/4205536912/","text":"&emsp;&emsp;其实一直想读《黑客与画家》这本书，所以在我买了Kindle以后，这本书就成为我读完的第一本书。本书作者是美国互联网界举足轻重、有“创业教父”之称的哈佛大学计算机博士保罗·格雷厄姆 (Paul Graham )，而这本书是由他的思考整理而成的一本文集，虽然这本书的名字叫做《黑客与画家》，可实际上作者在这本书中观点，并非局限于黑客与画家本身，相反地它涉及编程、软件、创业、财富、设计、研究等等多个领域。我认为这本书带给我的，更多的是一种思想上的提升，当我们沉迷在代码中无法自拔的时候，我们其实应该意识到，这个世界原本是由理性和感性两种认识混合而成的。当科技与人文发生碰撞进而共鸣，这本书会告诉你这一切是如此的美妙。 &emsp;&emsp;我们目前所处的这个时代，本质上是一个机器的时代，这是自工业革命以来，人类历史上又一个革命性的时代。越来越多迹象表明，未来的人类生活不仅是人与人的互动，而且更多的将是人与计算机的互动。所以想要把握这个时代，就必须理解计算机。而理解计算机的关键，则是要理解计算机背后的人。我们的时代是程序员主导的时代，而伟大的程序员就是黑客。 &emsp;&emsp;普通人认为“黑客”就是入侵计算机的“计算机罪犯”，其实“黑客”的本意是指出于兴趣而解决某个难题，不管它有没有用的这类人(出自自由软件基金会创始人理查德·斯托尔曼)，所以黑客从一开始就是有精神追求的，它代表着求解问题过程中产生的精神愉悦或享受，黑客们只是比我们普通人更崇尚分享、开放和民主，他们对任何被禁止的东西都怀有特别强烈的好奇心，他们喜欢去思考那些似乎不应该被思考的问题，他们相信计算机会深刻地改变人们的生活，由此我们可以认识到“黑客伦理”的一个推论：黑客不服从管教，具有叛逆精神。黑客就像一群有知识的海盗。编程与绘画异曲同工，黑客是数字时代的艺术家，他们都是创作者，都试图创造出优秀的作品。 &emsp;&emsp;书呆子之所以不受欢迎，是因为他们不如普通人聪明。可是作为普通人的我们没有意识到，这些书呆子和周围环境显得格格不入，或许从某种程度上说明他们领先了一步，或许书呆子已经在思考的东西，正是真实世界看重的东西，他们并非不想让自己受大家环境，他们只是没有时间来做这些普通人所看重的事情。虽然现实中的图灵并不像电影《模仿游戏》中塑造的那样怪癖、不合群，可是通过这部电影，我们依然能够感受到那种天才般的疯狂，图灵将全部精力都专注在制造“克里斯托弗”，因为不通世故而被同事嘲笑和指责，是琼教会他如何和大家相处。我们可以发现当图灵尝试改变以后，他可以像普通人一样收获友谊，所以所谓天才无非是，他们比常人更专注他们认为重要的事情。 &emsp;&emsp;中国企业更加关注软件作为科学和工程的一部分，即我们都将编程作为一种技术，其实编程同样有它作为人文与艺术的部分，我们必须认识到编程是一种艺术创作。编程语言是用来帮助我们思考程序，而不是用来表达我们已经想好的程序。你只有以一种“设计”软件，而非“实现”软件的思路来应用程序，你才能在这个过程中发现编程的乐趣，这和我们的兴趣相辅相成，因为如果你不爱一件事，你不可能把它做得真正优秀，要是你很热爱编程，你就不可避免地会开发你自己的项目。 &emsp;&emsp;坚持一丝不苟，就能取得优秀的成果，因为那些看不见的细节累加起来，就变得可见了。当一个黑客认为他是一个创作者的时候，他从事的就不再是机械性的工作，因为这就要求他具备灵感。如果编程时与绘画和写作同一类的工作，黑客是否有机会像伟大艺术家一样备受推崇、流芳百世呢？我认为这是有可能的，譬如Linus一生有Linux和Git两个作品就足以彪炳史册，而更重要的是他能让更多的人从中收益，这是黑客精神的价值所在。 &emsp;&emsp;我们总是习惯于，给那些为我们所看不惯的人，贴上各种各样的标签。其实做自己喜欢的事情，是不需要伪装的，我只是我而已，不需要满足你们过高的期望。在我们这个世界里，程序员毫无例外地被人们误解，从阿里月饼事件我们就可以看出，普通人对技术的理解基本保持在白痴这样的水平上，可讽刺的是我们的命运被被掌握在这样的人手里，我们绞尽脑汁来复原产品经理们的脑洞，我们费尽心机来防止白痴用户们的错误……可我们依然被这场无情而可笑的舆论打败，我们对这个世界充满敬畏，因为它的复杂程度远远超过我们能够想象以致于抽象的范围。 &emsp;&emsp;可我们依然在尝试让自己更努力一点，因为我们编写代码的同时，在不断地认识着这个世界，就像这个世界上本来没有算法、数据结构和设计模式，可当我们创造和了解这一切以后，我们对这个世界的看法或许会发生变化。我们不能接受的人类的愚蠢、狂妄和无知，因为当你越接近真理时，你就越会认识到自己的渺小。我们曾自以为是地相信，现代人比古代人更聪明、更高尚，可是当我们了解的历史越多，就会越明白事实并非如此，古人与我们是一样的人，他们不是更勇敢亦或着更野蛮，而是像我们一样的普通人，不管他们产生怎样的想法，都是正常人产生的想法。 &emsp;&emsp;不管你是否愿意去相信，这个时代已经无可避免地，和计算机紧紧地联系在一起，计算机可以帮助人类完成大量工作。可你必须认识到，计算机存在的意义并非是让人类变得更懒惰。相反地，它希望人类向着更好的方向去发展、希望人类更有效率的工作和生活，因为计算机可以做的事情越多，人类面临的这种失业的紧迫感就应该越强烈。我们不应该想当然地认为，人类一定会凌驾于智能机器之上。人类在和大自然抗衡的过程中其无知与愚蠢昭然若揭，我们今天意识到地球环境面临威胁，这难道不是为儿时的任性付出的代价？ &emsp;&emsp;图灵在这个世界上尚未出现计算机的时候，就能够想到有一天机器会比人更聪明，可我们普通人居然狂妄而无知地认为，所有的一切在工程师眼中都是非常简单的事情，工程师们懂得敬畏自然、敬畏真理，可普通人反而不愿意去理解这些原理和事实，更讽刺的事情是，一个软件工程的话语权是掌握在这样的人手中。我们从来不畏惧去挑战艰难的任务，仅仅是因为在这个世界上，有值得我们永远去敬畏和尊重的东西，那就是真理，那是像伽利略、布鲁诺、图灵等等对人类进步做出卓越贡献的人们，愿意用生命去捍卫的东西，现代计算机的理论基础是数学，所以你必须承认计算机是一门科学，其次它是一门艺术。 &emsp;&emsp;我喜欢这种科学和艺术完美融合的感觉，就像现代科技发展到今天，我们面对地不再是冷冰冰的控制台终端，而是注重人性化和用户体验的图形化界面。苹果和微软都曾经窃取过施乐公司的图形化界面技术，这段故事在电影《硅谷传奇》中更是被演绎得淋漓尽致。可为什么乔布斯会一直评价微软的产品没有品味呢？或许这是因为乔布斯站在了一个科技与人文的十字路口。我并非果粉，甚至在某种意义上我一直是软粉，可这并不妨碍我对科技和美的一种热爱，技术本身并不能在商业化策略中起到决定性作用，可是一个优秀的产品一定是将技术和艺术完美地融合在一起，所谓“一张一弛，文武之道”，从这个意义上来说，黑客和画家志同道合，理性与感性相辅相成，即使我们不能这个世界改变什么呢？可那有什么关系呢？","tags":[{"name":"人文","slug":"人文","permalink":"http://qinyuanpei.github.io/tags/人文/"},{"name":"黑客","slug":"黑客","permalink":"http://qinyuanpei.github.io/tags/黑客/"},{"name":"程序员","slug":"程序员","permalink":"http://qinyuanpei.github.io/tags/程序员/"}]},{"title":"像诗人一样睿智，像天才一样疯狂","date":"2016-10-01T17:12:43.000Z","path":"posts/3653716295/","text":"&emsp;&emsp;我不知道大家如何定义程序员这个工作，在我看来，在某种意义上，程序员和艺术家们具有相同之处，我们都是创作者，和诗人、画家、作家等等这些职业相近，我们都在试图创作出优秀的作品，我们借助编程语言来重构我们对这个世界的认识、借助抽象的概念来创造这个世界上不存在的东西，所以我们对自由和创造的渴望，来源自我们在这个世界上写下的第一行代码，或许这像是一个充满理想主义的臆想，可这并不重要，重要的是你如何看待这个世界、如何看待你自己，我更喜欢将程序员视为造梦者，就像每一个孩子在搭积木的时候，都有一个建筑师的梦一样，你可以选择让代码简洁、优雅，你同样选择让代码肮脏、丑陋，你相信什么，你执着什么，它就会是什么，所以为什么不给我们自己更多创造的机会。 &emsp;&emsp;在这个世界上，伟大的艺术家都是孤独的。从梵高那忧郁而狂野的绘画作品，到永远如童话王国里天真孩子一般的顾城……或许这种与生俱来的孤独感会成为一种宿命般的诅咒吧！程序员同样是孤独的，虽然我们今天的现代文明，高度依赖着程序员们创作的各种程序代码，可程序员就像一个被隐藏在幕后的魔术师，永远被人们忽略甚至是遗忘，同样地，程序代码和程序员一样孤独，当一段代码经过链接和编译，然后转化为可执行程序以后，没有人会再记得它们的样子，这种感觉就像人们需要你，可是人们从来不想了解你，而这种孤独会从心灵上摧毁一个人。“古来圣贤皆寂寞，唯有饮者留其名”，这种感悟在司马迁的《报任安书》里表现得更加玲离尽致：盖文王拘而演周易；仲尼厄而作春秋；屈原放逐，乃赋离骚；左丘失明，厥有国语；孙子膑脚，兵法修列；不韦迁蜀，世传吕览；韩非囚秦，孤愤说难；诗三百篇，大抵圣贤发奋之所为作也。 &emsp;&emsp;所以，我希望，程序员能够将每一行代码，都当做诗歌一样的艺术品，你必须在字里行间折射出明显的个人气质。在这个世界上，没有人会真正在乎这些代码是什么样子，因为人们需要的是一个可以对自己有用的东西，而对于它到底是什么永远没有人关心。我们整天面对着冷冰冰地液晶屏幕，所以我们理所当然地认为这些数字设备、应用程序都没有感情，它们就应该是被我们人类无情嘲弄的数字化工具。可讽刺的是，在一种称为手机的移动设备中，我们所有人的秘密都隐藏在这个我们不愿意去理解的东西里，这就相当于我们将我们的秘密，交给一个我们不愿意去深入了解的人一样，而仅仅是因为我们需要这样的一个人。这听起来像个笑话，所以，我们所有的努力，都是为了让这些代码，看起来不再那么孤独，你可以让它们成为你在这个世界上的烙印，你可以使用注释帮助人类理解代码、理解你自己，你可以创造出一种无限接近真相或者真理的信仰，你可以通过这一行行代码影响历史或者生活，我们不是仅仅为了活着。 &emsp;&emsp;乔布斯曾经引用毕加索的名言：优秀的艺术家复制，伟大的艺术家偷窃，并以此作为理由对施乐公司进行了疯狂的“盗窃”，乔布斯身上最让我着迷的是那灵魂深处那种艺术家的气质，他始终相信任何产品都应该是人的一种自然延伸，而正是这种对质量、理想和心灵的专注，让苹果公司的产品在设计和品味上显得与众不同。在麦金塔电脑这个项目上，他对完美的极致追求，让他对艺术和设计的那种天性得到释放，可与此同时他被斯卡利排挤出苹果公司，或许在这个以成败论英雄的时代，乔布斯是一个失败者，可这个世界依然需要理想主义，多年后，当人们提到苹果电脑总会不由自主地想到Mac这个品牌，我想说这是理想主义的胜利。 &emsp;&emsp;天才与普通人的区别在于，他们会做出在我们普通人眼中显得“疯狂”的事情，在电影《乔布斯》的结尾，乔布斯说：“只有疯狂到相信自己能改变世界的人，才能真正改变世界”，而这里对天才的定义是什么呢？他们特立独行、桀骜不驯、麻烦制造者，他们是格格不入的一群人，习惯用不同眼光看事情的人，不受规则约束的人，对既成事实不屑一顾的人，你可以引用他们，亦可反驳他们，或赞颂或诋毁他们，你唯一做不到的就是忽视他们，因为他们带来变革，他们推动人类向前，或许有些人将他们视作疯子，而我们将其视为天才。对大部分而言，我们都是普通人，可这并不代表我们就要停止努力，因为大部分的努力都尚未达到拼天赋的程度，何况我们可能连天赋都没有呢？ &emsp;&emsp;这意味着我们需要去做些疯狂的事情，我们追求极致和完美，是因为我们想在这个世界上，留下属于我们自己的印记，没有人会明白，为什么乔布斯天生就有一种想要和IBM抗衡的想法，这种想法促成了让人们印象深刻的”1984”广告，其创意来自乔治·奥威尔的小说《一九八四》，并借助小说中的“大佬”映射当时的蓝色巨人IBM，这个举动让苹果公司、让Mac成为人们心中理想主义的化身，这个举动相当地疯狂，不是吗？甚至在《硅谷传奇》这部电影中，这种疯狂被表现得更加淋漓尽致：我们正在创造一个新的信仰，你应该这样来认识，像艺术家或者诗人一样，我们正通过我们的所作所为，重写人类思想的历史。所以，当我们极力追求代码的优雅、性能的出众以及架构的良好，这一切都是因为我们想要做些，真正可以让我们在乎的事情。因为我们的生活常常被需求和问题左右，如果我们都不在乎我们所做的事情，我相信这个世界上不会有第二个人更加在乎。 &emsp;&emsp;天才在某种意义上来讲是孤独的，因为天才的想法，注定会超越时间和空间。古往今来，无数仁人志士，为这个世界所付诸的努力，其实都是为了帮助我们更好的认识这个世界而已。遥想太古时期，在这个世界上尚流传着诸神创造世界的传说，地球上或许还没有人类出现，最早的古猿还没有学会直立行走，这段时间对我们人类来说非常漫长，可它对整个宇宙、整个地球来讲，或许是短暂到可以忽略的一段时间，甚至当我们将视野放大到整个宇宙的时候，我们可能会突然意识到，我们所处的世界，可能仅仅是宇宙中的时光，曾经驻足过的，一个小城镇，因此我们对这个世界既熟悉又陌生，所以我们有什么理由不去发现更多的事情呢？对这个世界永远保留好奇心，是天才的基本要求，我们必须认识到，相对整个宇宙，我们每个人都显得狭隘而无知，所以我们有什么理由不去探索这个陌生的世界呢？我们目前所处的这个时代，大量的开源项目和第三方SDK，为我们提供了前人所不能想象的丰富的资源，无疑我们是幸福的，我们仅仅需要再努力一点。 &emsp;&emsp;一位同事给我推荐了《模仿游戏》这个电影，在此之前我对图灵这个人物的了解，无外乎他对整个计算机行业做出的革命性的贡献，以及他像谜一样的人生经历，可是通过这部电影，我看到的是一种天才般的疯狂和执著，图灵在被通知去接受破解德国加密装置“恩尼格玛”的任务时，军方对其进行了一个简单的面试，在面试中我们发现图灵或许不懂得什么是幽默，这种被我们称为“书呆子”的性格，在实际生活中是不讨喜的，在《黑客与画家》中作者明确地指出，“书呆子”不受欢迎是因为他们比普通人聪明，可是图灵很快就能发现，团队中有哪些人是不合格的解密者，而在这个过程中他因为不太懂得如何和别人相处，而被团队里的成员指责和谩骂，可他从来没有放弃过制造他的机器，而最终的结果的确是依靠他的机器计算出来的，天才的孤独在于常常不被常人理解，可是当图灵被强迫关闭他的机器的时候，团队中的成员愿意站在这一边，这一幕是让我感受到温情存在的，而这一切来自一个走进他生命中的女孩子：琼。 &emsp;&emsp;或许我们普通人穷尽一生都无法达到天才的万分之一，甚至有人想要告诫我，不要在一件事情上投入大量的热情，因为我们都期望获得成功，可现实难免会在这个时刻，无情地为我们浇下一盆凉水，这种感觉就像你对一个女孩子投入了大量感情，结果最后被她伤心到心灰意冷……可是人生其实本来是没有意义的，你从出生到走向死亡早已安排好，你需要做的就是“重写”这个过程，所以我们来到这个世界上，无非是想要认识些有趣的人、经历些有趣的事情，所以如果你对一件事情的成与败、一件东西得与失，都能做到坦然处之，或许你就不会再畏惧失败，当我们不再愿意为一件事情投入热情的时候，其实我们已经习惯了为自己的懒惰找到一个借口，你必须要相信你做的事情是最正确的事情，你必须要有一种敢于突破自我的激情，否则你注定只能做出平庸而普通的产品。如果我们不能比别人做得更好，那么就努力和别人做得不同;如果我们可以和别人做得不同，那么就努力比别人做得更好，即使普通如你我一般的人，我们依然可以选择像天才一样疯狂。 &emsp;&emsp;在《模仿游戏》里，艾伦的“初恋”克里斯托弗告诉他，有时候正是人们以为的无用之人，成就了无人感想之事。同样地，在劝说琼参与到解密工作中时，他同样对琼说出了这句话，或许是因为琼因为迟到而无法参加测试时，她说的一句漫不经心的话“你凭什么认为我自己不可以解决呢”，让图灵想到了自己，所以他破例让迟到的琼参加测试，虽然图灵是一个同性恋，可他和琼两个人的感情依然让人动容，即使两个人都不是完美的彼此，即使他们按照各自不同的生活方式生活，可他们同样能按照各自不同的方式去爱对方，在这种情形下，世俗中理解的爱是否会显得平淡无奇？图灵的死亡，在我看来是一个国家甚至整个世界的巨大损失，从伽利略、布鲁诺再到图灵，在这个世界上人类自以为是地创造了各种“教条”，并以此来伤害这些本应该在历史中绽放异彩的天才们，图灵提出的“图灵测试”是人工智能领域的一个重要概念，而计算机领域最高的奖项以他的名字定义，甚至英国女王都曾经公开为其恢复名誉，所以同样都是活着，为什么我们不能给自己一种新的选择？ &emsp;&emsp;或许你我的努力不会为人们所歌颂，或许你我的坚持不会为人们所理解，可我们来到这个世界，就是为了给这个世界留下我们的印记，不然我们来这里做什么呢？因为你要相信，你学过的每一样东西，你遭受过的每一次苦难，都会在你一生中的某个时刻派上用场。其实你我的生命都很短暂，我们没有多少时间值得去浪费。像诗人一样睿智，去了解我们的生活；像天才一样疯狂，去掌控我们的生活。","tags":[{"name":"黑客","slug":"黑客","permalink":"http://qinyuanpei.github.io/tags/黑客/"},{"name":"画家","slug":"画家","permalink":"http://qinyuanpei.github.io/tags/画家/"},{"name":"诗人","slug":"诗人","permalink":"http://qinyuanpei.github.io/tags/诗人/"}]},{"title":"你了解爱的艺术吗？","date":"2016-09-24T22:42:44.000Z","path":"posts/2275646954/","text":"&emsp;&emsp;或许我不是一个懂得如何去爱人的人，我时常陷入一种自我否定的焦虑当中，当我发觉自己喜欢上一个人的时候，从某种意义上它会让我身上的缺点被无情地放大，我并不畏惧在喜欢的人面前暴露这些缺点，因为这就是真实的我，因此我从来不喜欢去塑造别人，让别人成为我心目中期待的样子，可是我会忍不住去塑造我自己，尤其是在和别人相处的过程中，发现我身上的缺点或者问题的时候，我习惯了对自我严格，虽然我知道这个过程注定痛苦，可是你能告诉我，爱到底是什么吗？如果爱不足以让我们改变，我们喜欢的究竟是一个怎样的自己、怎样的别人？ &emsp;&emsp;弗洛姆这本《爱的艺术》是我自己为自己挑选的一本书，在我买了Kindle以后，我将我的时间安排在看书和学习上，因为我的确很喜欢读书，而我这种理性的性格有时候难免让人讨厌，所以读书特别是选择去读人文类书籍，从某种意义上来说是我在刻意地稀释这种理性思维造成的影响，《黑客与画家》里告诉我们一件事情，聪明人不被周围人喜欢是因为他们比周围人聪明，当谈恋爱越发地被人们改造成一种套路，我们对爱的定义或许会越来越模糊，可是爱作为一种大自然间普遍存在的情感，我坚信它是一种相当原始而简单的事情。 &emsp;&emsp;弗洛姆认为，爱情是对人类生存问题的回答，人们在这个世界上逐渐意识到生不由己、意识到死的必然、意识到孤独和与世隔绝、意识到面对社会和自然的威力时的无能为力，所以，所有生活在不同文化和时代里的人，都面临着一个同一个问题，即：如何克服这种孤独感。古人说“古来圣贤皆寂寞，唯有饮者留其名”，其实何止是古来圣贤，我们生活在这个地球上的所有人，从出生到死亡都不可避免地被一种孤独感包围者，曾经和别人 讨论过这个问题，我对人情颇为淡漠，因为我觉得除了能够真正将彼此联系起来的两个人，在这个世界上你永远无法找到真正能让你灵魂皈依的地方，这种感觉并非是由血缘或者金钱这样的关系来维系，一个人的孤独与一群人的孤独，在整个宇宙间看起来，其实没有什么不同。 &emsp;&emsp;爱的确是一门艺术，可对我们每个人而言，它像是某种缥缈甚至是难以揣测的情绪，你不能用一种非常理性的眼光来审视和定义它的存在，弗洛姆说：“不是拥有财物的人是富裕的，而是给予他人东西的人才是富裕者”，可现实是并非你不顾一切地对一个人好，就能赢得一份让你感动的爱情，所以在经历过挫折以后，我不再考虑一味地索取或者付出，我喜欢将这个过程叫做分享，人们在分享的过程中认识彼此、丰富彼此、提高彼此的生命感，这是我认为在爱情中我们需要去挖掘的一种潜质，如果一个人没有生命力，就不会有创造爱情的能力，所以当我们试图爱一个人之前，我们首先要学会爱我们自己，而弗洛伊德将这种人的自我欣赏叫做“自恋”，除了爱情自身积极性的因素以外，爱情具有所有爱的形式所共有的因素，如：关心、责任心、尊重和理解。 &emsp;&emsp;爱情不是自私地占有对方或者是放弃除对方以外人的更为广泛意义上的博爱，“爱情是自由之子，永远不会是控制的产物”。或许我们穷极一生来认识自己、认识别人，可我们最终还是不认识自己、不认识别人，可我们无法阻止这种深入了解人的灵魂的秘密、了解人的核心，即“自我”的愿望将继续存在。毫无疑问，德尔斐的人箴言“认识你自己”表达了我们认识自己和他人的愿望。白昼和黑夜表面看起来是敌人，但它们却都是为了一个目标，因为相爱就是为了完成共同的事情。而从广义的爱的定义来看，中国古代先哲孟子的“老吾老以及人之老，幼吾幼以及人之幼”就很好的表达了这种观点，弗洛姆说：“一切爱的形式都以博爱为基础，我指的博爱就是对所有的人都有一种责任感，关心、尊重和了解他人，即愿意提高其他人的生活情趣”。以前以为爱是自私地占有一个人，是对除对方以外的人表现得漠不关心，可后来逐渐发现，我们对自己的爱远远超过别人，这或许不能叫做爱吧！ &emsp;&emsp;我们来到这个世界上，更本质的意义在于我们希望认识些有趣的人，做些有趣的事情而已，这意味着我们常常试图在这个世界上留下自己的印记，我们习惯了在朋友圈里晒美食、晒旅游、晒自拍等等约定俗成的处事方法，亦如我们生来就渴望被人理解、被人喜欢一样，而这一切更本质的原因，我们现在称为“刷存在感”，恰恰迎合了这个观点，我们想要在这个世界上留下我们的印记，即使这些方式方法看起来并不是我们最初喜欢的样子，弗洛姆将在这个观点理解为“超越自己”的追求，这一追求属于人的最基本要求，即“人对自己的纯生物作用不满，他不能忍受自己仅仅是被扔进这一世界的小卒。他一定要感到自己是创造者，是能超越处于被创造者消极地位的生命。满足这一要求有许多可能性，最自然和最基本的途径就是母亲对自己创造物的关怀和爱”。所以，我们渴望被人喜欢、被人理解都是因为我们希望生来独特、生来不同，而这一切都源于父母对爱的一种创造力。 &emsp;&emsp;我们常常表现出，一种试图要要证明比别人过得更好的心态，仿佛在朋友圈或者微博这种社交平台上，我们能找到更多的自豪感，可我同样知道，这个世界上最大的社交网站Facebook，背后却是由一个有社交障碍的人创造出来的，我们都渴望让别人了解自己、认识自己，这不同于社交场合里那种客套的场面话，对此，弗洛姆认为，人与人之间可以通过讲述这种方式来打破人与生俱来的这种孤独感，“讲述自己的生活，叙述自己的希望和恐惧，谈出自己幼稚的或者不成熟的梦想，以及找到面对世界的共同利益——所有这一切都是克服人与人之间隔离的途径，甚至表露自己的愤怒和仇恨，毫无顾忌地交心也都被看作是亲密的表现”，我们对爱的终极理解其实应该是，我们通过爱一个人，进而爱全人类，爱一切生命，我们从自我的生命的本质出发去爱对方，并且去体验对方的本质，爱情是意志的行为，是人作的一项把全部生命交付对方的决定。 &emsp;&emsp;圣经中“爱他人如同爱己”的说法，说明了对自己的完整性和独特性的尊重，爱自己，理解自己同尊重、爱和谅解别人是不可分割的，爱我同爱他人是紧密相连的。中世纪德意志神秘主义哲学家和神学家，爱克哈特有一句关于自爱的格言：“你若爱己，那就会爱所有的人如爱己。你若对一个人的爱少于爱己，如果你不是爱所有的人如同爱己，如果你不是在一个人身上爱所有的人——因为这个人就是上帝和人。一个既爱自己又爱他人如同爱己的人就是这样的人，一个值得这样评价的人”。我们来到世界上学会与人相处、学会如何去爱一个人，其实是在寻找一种探索生活所需要的信仰，因为生存或许会非常容易，可是学会生活或许会非常困难，我们努力提高生活质量，源于我们对自己和伴侣的一种爱，希望让彼此变得更好。 &emsp;&emsp;或许对弗洛姆本人而言，这本《爱的艺术》更像是 他对自我的一种内省，因为他的爱情基本上在持续地遭遇着失败，他曾经和四个不同的女人结过婚，所以他在这本书里提出的大量观点都来源自他自己的感情经历，他早期研究过弗洛伊德的相关理论，而事实上，因为对爱的无能为力让他真正找到了爱的能力，我们在年轻的时候总会遇到一个非常喜欢，可我们却无法给她想要的生活的女孩子，或许我们都需要用一生去领悟爱的真正含义吧，就像弗洛姆这本书是建立在将理论和实践结合起来的基础上的，我不认为我此刻已经读懂了这本书，可是它对我的确非常重要，我总要学着去爱别人，让自己变得更好！","tags":[{"name":"读书","slug":"读书","permalink":"http://qinyuanpei.github.io/tags/读书/"},{"name":"爱情","slug":"爱情","permalink":"http://qinyuanpei.github.io/tags/爱情/"},{"name":"Kindle","slug":"Kindle","permalink":"http://qinyuanpei.github.io/tags/Kindle/"}]},{"title":"一个关于概率的问题的思考","date":"2016-09-24T20:06:45.000Z","path":"posts/3247186509/","text":"&emsp;&emsp;最近需要给公司内部编写一个随机生成人员名单的小工具，在解决这个问题的过程中，我认识到这是一个概率相关的问题，即使在过去我曾经设计过类似转盘抽奖这样的应用程序，可我并不认为我真正搞清楚了这个问题，所以想在这篇文章中说说我对概率问题的相关思考。首先，我们来考虑这个问题的背景，我们需要定期在内部举行英语交流活动，可是大家的英语水差异悬殊，所以如果按照常规的思路来解决这个问题，即认为每个人被选中的概率是相等的话，实际上对英语不好的人是显得不公平的。其次，作为一个内部活动它需要的是营造一种氛围，让每个人参与到其中，所以它要求英语好的人有一个相对高的优先级，这样能够方便在活动开始前“破冰”，可是同时它需要让英语不好的人能够参与其中，所以这个问题该如何解决呢？这就是我们今天想要讨论的话题！ 今天吃什么？&emsp;&emsp;虽然我的确是一个对穿衣吃饭没有太多追求的人，可是作为这尘世间芸芸众生里最为普通的一个人，我们每天不可避免地会遇到这个问题。如同哲学家会从“认识你自己”这样一个基本命题发散出无数哲学问题一样，“今天吃什么”在某种意义上可能是比哲学问题还要重要的问题，尤其是对一个喜欢美食的吃货来讲，“今天吃什么”可能是整个世界里优先级最高的事情。 &emsp;&emsp;好了，我们从这个问题出发想要说明什么呢？通常我们解决这个问题最简单粗暴的方式是，罗列出附近所有的餐馆然后从中随机选择一家，现在主流的地图类APP基本上都有这样的功能，在每个餐馆被选中的概率相同的情况下，这种方案是没有什么问题的。可是我们都知道，人类作为这个世界上最复杂的一种动物，怎么会甘心让这个问题如此的简单呢？因为我们在选择的时候存在一个优先级的问题，例如我今天想吃红烧肉而明天想吃水煮鱼，显然因为个体偏好的差异每个餐馆被选中的概率是不相同的，因此在这种情况下，经典的概率理论是无法满足我们的要求的，那么此时该如何解决这个问题呢？ &emsp;&emsp;考虑到个人偏好对餐馆是否被选中的影响比较明显，因此实际上不同的餐馆拥有不同的优先级，这里我们假定有A、B、C三家餐馆，以你的个人喜好作为优先级评价标准，其优先级分别为2、3、5，则根据概率知识可知，P(A)=0.2、P(B)=0.3、P(C)=0.5。我们这里采用一种累加的思路来处理，令P(A)=P(A)=0.2、P(B)=P(A)+P(B)=0.5、P(C)=P(B)+P(C)=1，此时我们将P(A)、P(B)、P(C)三个概率值标注在数轴上，根据几何概型的相关理论，我们很容易地可以知道，0~0.2范围内可以表示餐馆A被选中的概率、0.2~0.5可以表示餐馆B被选中的概率，0.5~1可以表示餐馆C被选中的概率，此时我们可以借助各种编程语言提供的随机数功能来生成0~1间的随机数，然后根据随机数落在哪个区间内来处理结果。 &emsp;&emsp;我认为这个方案是比较不错的一种思路，在数学里有一种思想称为归一化，我们这里是将概率值从离散状态变为连续状态，而计算机更擅长我们生成一定范围内的随机数，所以这个方案为我们解决这类问题找到了一个不错的契合点，联想到转盘游戏其实是将0~1范围内的数字转换为0~360度范围内的角度，这一切就显得更加有趣啦！ 概率与累积概率&emsp;&emsp;在解决了“今天吃什么？”这样一个终极命题后，下面我们来从理论上对这个问题进行解释。第一个问题，什么是概率呢？根据百科全书中的定义，概率是概率论中的一个基本概念，它是度量随机事件发生的可能性的一个量，通常使用0~1间的实数来表示一个随机事件发生的可能性的大小，当其值越接近0时表示该随机事件越不可能发生，当其值月接近1时表示该随机事件越有可能发生。经典的古典概型理论指出，如果一个实验满足同时下列两个条件，则这样的实验就是古典实验： 实验只且只有有限个基本结果 每个基本结果出现的可能性相同 &emsp;&emsp;此时，对古典实验中的事件A，其概率定义为：P(A)=m/n，其中m为事件A包含的基本结果的数目，n为该实验中所有可能出现的基本结果的数目，这种概率定义的方法称为概率的古典定义。人们在重复实验的基础上进一步提出，在一定条件下，重复做n次重复实验，虽然实验次数的增加，如果某个事件的频率逐渐稳定在某一个数值p附近，则认为数值p即为事件A在该条件下发生的概率。这是建立在统计基础上的概率定义。显然我们发现这里存在问题，即古典概型是建立在所有事件发生的可能性相同这样一个基本假设的基础上的，于此同时我们可以注意到，概率是客观的而频率则依赖经验。对于概率甚至数学，人们一度认为它们都是严格的科学，对这种观点，我想引用庞加莱的一段话： 概率仅仅是我们无知程度的度量，据定义，我们不晓得其定律的现象，都是偶然现象。 &emsp;&emsp;好了，下面我们来关注一个新的概念，即累积分布函数(CDF，Cumulative Distribution Function)，它能够完整描述一个实数随机变量X的概率分布，是概率密度函数(pdf，probability density function)的积分。其数学定义是F(X)=P(X&lt;=x)，表示随机变量小于或者等于某个数值的概率。为什么我们需要连续的随机变量呢？因为计算机产生的随机数通常都是指某个范围内的随机变量，而通常意义上的古典概型实际上是一种离散分布的数学模型，显然这两者间需要某种形式上的转换，所以我们需要累积分布函数，并且对连续函数而言，所有小于或者等于某个数值x的概率都可以认为，它等于数值x处的概率，因为我们能够保证累积分布函数严格递增，印象中诸如正态分布、均匀分布、泊松分布都是可以采用这种思路来处理的。好啦，更多理论层面的内容大家有兴趣的话可以自己去探索，这里我们想在这种理论的基础上设计一个基本的抽奖系统。 一个抽奖系统的设计&emsp;&emsp;首先，我们必须指出计算机产生的随机数都是伪随机数，因此我们无法编写出100%随机的程序，而且事实上这种“随机”程度对我们来讲应该是完全足够了，所以在排除了这个因素的影响以后，我们基本上不能再为我们的应用程序寻找任何的借口，在这里我认为重要的一点是，我们能够有一个在理论和实践上都相对可行的方案，我们这里选择以一个简单的抽奖系统的设计为例来探讨这个问题。 随机概率公平吗？&emsp;&emsp;抽奖系统最重要的是什么呢？是公平合理，那么怎样保证每次抽奖对所有用户来讲都是公平的呢？我认为首先要能够指定一个公平合理的规则，因为规则就如同人世间的法律正义、就如同璀璨夜空中的星辰宇宙一样，当它被确定下来以后就会一种永恒的真理。我们现在来考虑这样一个概率问题，假设我们有A、B、C、D四种不同的物品，它们各自被选中的概率分别为10%、20%、30%和40%，我们应该如何解决这个问题呢？通常可以想到的一种方案是，因为这四种物品被选中的概率之和为100%，因此我们将0~100范围内的数划分为[1,11)、[11,31)、[31,61)、[61,101)，我们注意到这四个区间都是左闭右开的，因此每个区间的长度和概率完全对应，此时我们产生一个(0,101)间的随机数，然后根据随机数落在那个区间内来判断抽取物品的结果，这种方法称为随机概率，我们来看看它是如何实现的： 1234567891011121314151617static void Main(string[] args)&#123; List&lt;Prize&gt; prizes = new List&lt;Prize&gt;() &#123; new Prize(\"奖品A\",0.1d,1,11), new Prize(\"奖品B\",0.2d,11,31), new Prize(\"奖品C\",0.3d,31,61), new Prize(\"奖品D\",0.4d,61,101) &#125;; var seed = Guid.NewGuid().GetHashCode(); Random random = new Random(seed); int rand = random.Next(1, 101); var prize = prizes.Where(p =&gt; rand &gt;= p.RangeStart &amp;&amp; rand &lt; p.RangeEnd).FirstOrDefault(); Console.WriteLine(\"随机选取的物品为:\" + prize.ID); &#125; &emsp;&emsp;这段代码是非常简单的，可我想要问的一个问题是，我们这样的做法到底对不对呢。面对一个概率学的问题，如果要检验我们的算法是否正确，一个最简单的方式是判断其是否符合我们的预期，因为从概率的定义中我们已经可以了解到，概率是一种数学定义中的概念，我们可以通过大量重复试验的客观性来证明概率的确是存在的，并且我们可以合理地解释它为什么这样，可是这样到底对不对，我相信没有人能够给出确定的答案。现在我们来借助计算机通过大量的重复实验来证明我们的方法是否正确，根据频率和概率的关系，我们知道频率应该会在概率的某一个范围内上下波动，但是它整体上会越来越接近于概率。下面的表格给出了我在这个问题上的试验结果： 10次 1000次 1000000次 物品A 0.2 0.109 0.10066 物品B 0.4 0.199 0.19977 物品C 0.3 0.311 0.300071 物品D 0.1 0.381 0.399499 &emsp;&emsp;这里因为博主在尝试做1亿次重复试验时电脑运行时间非常漫长，就像在电影《模仿游戏》中艾伦.图灵制作的计算机器在破解德国加密设备“恩格尼玛”时，常常需要长达数月的运算周期一样，这种类比可能不是非常恰当，因为现代计算机的硬件水平是图灵所处的二战时期难以企及的，可是我们忽然发现一个非常沮丧的事实，我们在这里处理1亿次左右的循环，依然需要一段我们感觉上非常“漫长”的时间，而根据电影中的情节，图灵制作的计算机器需要完成159亿次的运算来尝试各种可能的组合，所以此时此刻我们是应该向这些推动人类进步的杰出人物诚恳地致敬，因为我们今天的一切都是来自这些人在当时看似疯狂的举动，或许人们曾将他们视为疯子而我更喜欢将其视为天才。 &emsp;&emsp;结果的确如我们所预期的那样，这里每组试验都是3次平行试验后的平均值，可以看到随着重复次数的增加，试验结果更加趋向我们理论上设计的概率值，因此这种情况下我们认为这个设计是合理的，即这个算法是公平的。可是这个世界让人头疼的一点是，我们每个人都理所当然地认为，只要是别人能得到而我们自己得不到地，就一定是有内幕、是不公平地，可是这个世界本来就是不公平的啊，谁掌握更多的社会资源、谁掌握绝对的话语权，“正义”的天平就会向谁倾斜，我们能做的无非是让自己变得更好，努力避免陷入某种被动的局面。 &emsp;&emsp;好了，言归正传，现在我们会发现一个问题，这种方案在奖品种类非常多的情况下，调整概率会是一件非常困难的事情，这就像工程师不喜欢产品经理和游戏策划，其真实原因并非是工程师无法实现特定需求，而是在整个建筑完成规划和设计以后，频繁的需求变更让一座伟大的建筑变成了临时的脚手架，你必须认识到这是工程师经过创作以后的某种产出，你可以不在乎这些无人问津的代码，可是我作为工程师我一定要比任何人都要在乎啊。 &emsp;&emsp;可是一个新的问题是，你永远无法为用户提供一种通用的解决方案，一个简单的抽奖在引入各种“自定义”规则以后，就注定不会再成为一个简单的抽奖，因为揣测一个人会说什么，对我这样一个不喜欢说话的人来说简直是种灾难，同样地，用户让计算机来做什么就应该明确地告诉计算机，而不是让工程师用各种各样的if-else来揣测用户想要做什么，我们常常说“优雅接口、肮脏实现”，在某种意义上就是指这种东西在永远浪费工程师的时间，用户愚蠢、用户懒惰，可是他们居然可以凌驾于工程师之上，这是对这个世界最大的恶意。好了，我们现在来动手解决新的问题，当用户需要在抽奖的时候对各种条件进行筛选同时还要考虑优先级和公平性这样一个问题吧！ 让一切可复用&emsp;&emsp;首先我们来考虑，如何设计一个可以复用的抽奖系统，在这个问题中我们关注两点，第一，这个抽奖系统可以支持不同类型的“奖品”；第二，这个抽奖系统可以支持不同类型的“抽取”方式。因为在这个问题中，按照某种优先级随机抽取人员或者物品其实应该是一类问题，而抽取我们都知道应该有可放回抽取和不可放回抽取两种，所以我们可以考虑通过泛型和接口来实现这样的需求。我们在这里定义一个IRankable接口，所有的“奖品”都要实现该接口，其定义如下： 1234interface IRankable&#123; int GetRank();&#125; 我们可以发现该接口中只有一个GetRank()方法，这是因为我们这里的概率算法的基础是权重，所以我们只要为不同类型的“奖品”建立其相应的权重模型，就可以实现对不同类型奖品的支持。现在我们需要编写一个随机生成“奖品”的随机生成器，我们应该可以想到通过接口来约束泛型的思路，所以下面我们来实现一个随机生成器RandomGenerator。 &emsp;&emsp;首先我们可以想到的一点是，因为这里的泛型类型T需要实现IRankable接口，因此我们可以通过IRankable接口中定义的GetRank()方法来获取不同奖品的权重，在此基础上我们对奖品按照权重进行分组，则我们可以计算出每种权重在整个奖品权重中占到的百分比，我们以此作为每种权重奖品的概率，利用累积概率的思想可以非常容易地获得各种权重奖品对应的概率范围。其代码实现如下： 12345678910111213141516171819202122232425262728/// &lt;summary&gt;/// 计算概率/// &lt;/summary&gt;private void CalculateProbability(IEnumerable&lt;T&gt; source)&#123; this.m_groups = source.GroupBy(e =&gt; e.GetRank()); //计算总权重 var totalRank = 0; m_source.ToList().ForEach((item) =&gt; &#123; totalRank += item.GetRank(); &#125;); //计算每个权重对应的概率 m_probs = new Dictionary&lt;int, double&gt;(); foreach (IGrouping&lt;int, T&gt; group in m_groups) &#123; var p = (double)(group.Key * group.Count() / (double)totalRank); m_probs.Add(group.Key, p); &#125; //计算每个权重对应的累积概率(递增） var totalProb = 0d; m_totalProbs = new Dictionary&lt;int, double&gt;(); foreach (KeyValuePair&lt;int, double&gt; kv in m_probs) &#123; totalProb += kv.Value; m_totalProbs.Add(kv.Key, totalProb); &#125;&#125; &emsp;&emsp;好了，现在我们就获得了不同权重物品所对应的累积概率，即其概率范围，因此我们可以利用随机生成[0,1)范围内的随机数，然后判断随机数所在哪个概率范围内，我们就可以知道要对哪个权重分组中的奖品进行抽取，而对每个权重分组来说，因为其权重都是一样的，所以这里抽取试验可以认为是符合随机概率的，我们只需要从该分组中随机选取一个奖品返回就可以啦。那么这里该如何查找概率范围内，我们这里选择经典的“二分查找”算法： 1234567891011121314/// &lt;summary&gt;/// 返回概率所在的区间索引/// &lt;/summary&gt;private int GetProbablityRange(Dictionary&lt;int, double&gt; totalProbs, int begin, int end, double value)&#123; if (begin &gt;= end) return begin; int mid = (begin + end) / 2; if (totalProbs.ElementAt(mid).Value &gt;= value) return GetProbablityRange(totalProbs, begin, mid, value); else return GetProbablityRange(totalProbs, mid + 1, end, value);&#125; &emsp;&emsp;那么好了，现在我们该怎么从这些奖品中随机抽取一个奖品呢，我们这里提供了随机生成1个奖品和随机生成指定数目个奖品的方法重载，我们以前者为例来看看它的实现过程: 1234567891011121314151617181920212223242526272829/// &lt;summary&gt;/// 随机抽取一个奖品/// &lt;/summary&gt;public T Generate()&#123; //初始化随机数 var seed = Guid.NewGuid().GetHashCode(); var random = new Random(seed); //生成0到1间的随机数 double rand = random.NextDouble(); T result = default(T); //计算随机数落在哪个区间内 int index = GetProbablityRange(m_totalProbs, 0, m_totalProbs.Count - 1, rand); switch (m_option) &#123; case GenerateOption.CanReplace: result = GenerateCanReplace(index, random); break; case GenerateOption.NoReplace: result = GetnerateNoReplace(index, random); break; &#125; return result;&#125; &emsp;&emsp;在这里我设计了两种不同的抽取方式，即可放回抽取和不可放回抽取，两者的区别在于前者奖品池中奖品的数目保持不变，而后者奖品池中奖品的数目会发生变化，而更本质的区别在于前者奖品概率保持不变，而后者概率会发生变化。后者在每次抽取完以后需要将抽中的奖品从奖品池中取出，重新计算概率后方能进行下一轮抽取，所以这里我们直接给出这两两种抽取方法的代码实现，这里需要考虑的一个问题是，在抽取指定数目个“奖品”的时候我们通常不希望出现重复的元素，前者需要我们判断已抽取的奖品列表中是否存在指定元素，而后者因为抽取的奖品会被取出，所以不需要考虑这种情况的处理。 12345678910111213141516171819202122232425262728293031323334/// &lt;summary&gt;/// 可放回抽取/// &lt;/summary&gt;private T GenerateCanReplace(int index, Random random)&#123; int rank = m_totalProbs.ElementAt(index).Key; var group = m_groups.Where(e =&gt; e.Key == rank).FirstOrDefault(); if (group == null) group = m_groups.ElementAt(random.Next(0, m_groups.Count())); return group.ElementAt(random.Next(0, group.ToList().Count));&#125;/// &lt;summary&gt;/// 不可放回抽取/// &lt;/summary&gt;/// &lt;returns&gt;&lt;/returns&gt;private T GetnerateNoReplace(int index, Random random)&#123; int rank = m_totalProbs.ElementAt(index).Key; var group = m_groups.Where(e =&gt; e.Key == rank).FirstOrDefault(); if (group == null) group = m_groups.ElementAt(random.Next(0, m_groups.Count())); T result = group.ElementAt(random.Next(0, group.ToList().Count)); //从集合中移除当前抽取的元素 var list = m_source.ToList(); list.Remove(result); //更新集合、重新计算概率 m_source = list; CalculateProbability(m_source); return result;&#125; &emsp;&emsp;在此基础上实现指定数目的奖品就会变得非常简单啦，因为我们只需要重复调用这个方法就可以啦，那么现在我们该如何使用这个随机生成器呢？一起来看一段示例代码： 123456789101112131415161718192021222324252627282930//模拟优先级和员工级别对随机数的影响List&lt;Contract&gt; contracts = new List&lt;Contract&gt;();contracts.Add(new Contract() &#123; Name = \"People0\", Level = \"Senior\", Priority = 1 &#125;);contracts.Add(new Contract() &#123; Name = \"People1\", Level = \"Senior\", Priority = 1 &#125;);contracts.Add(new Contract() &#123; Name = \"People2\", Level = \"SSE\", Priority = 10 &#125;);contracts.Add(new Contract() &#123; Name = \"People3\", Level = \"SSE\", Priority = 1 &#125;);contracts.Add(new Contract() &#123; Name = \"People4\", Level = \"SSE\", Priority = 1 &#125;);contracts.Add(new Contract() &#123; Name = \"People5\", Level = \"SE\", Priority = 1 &#125;);contracts.Add(new Contract() &#123; Name = \"People6\", Level = \"SE\", Priority = 1 &#125;);contracts.Add(new Contract() &#123; Name = \"People7\", Level = \"SE\", Priority = 1 &#125;);contracts.Add(new Contract() &#123; Name = \"People8\", Level = \"SE\", Priority = 1 &#125;);contracts.Add(new Contract() &#123; Name = \"People9\", Level = \"SE\", Priority = 1 &#125;);contracts.Add(new Contract() &#123; Name = \"People10\", Level = \"Senior\", Priority = 1 &#125;);contracts.Add(new Contract() &#123; Name = \"People11\", Level = \"Senior\", Priority = 1 &#125;);contracts.Add(new Contract() &#123; Name = \"People12\", Level = \"SSE\", Priority = 1 &#125;);contracts.Add(new Contract() &#123; Name = \"People13\", Level = \"SSE\", Priority = 1 &#125;);contracts.Add(new Contract() &#123; Name = \"People14\", Level = \"SSE\", Priority = 1 &#125;);contracts.Add(new Contract() &#123; Name = \"People15\", Level = \"SE\", Priority = 1 &#125;);contracts.Add(new Contract() &#123; Name = \"People16\", Level = \"SE\", Priority = 1 &#125;);contracts.Add(new Contract() &#123; Name = \"People17\", Level = \"SE\", Priority = 1 &#125;);contracts.Add(new Contract() &#123; Name = \"People18\", Level = \"SE\", Priority = 1 &#125;);contracts.Add(new Contract() &#123; Name = \"People19\", Level = \"SE\", Priority = 1 &#125;);RandomGenerator&lt;Contract&gt; generator = new RandomGenerator&lt;Contract&gt;(contracts,GenerateOption.NoReplace);var list = generator.Generate(10);foreach (var contract in list)&#123; Console.WriteLine(contract.Name);&#125;&#125; 在这里Contract实现了IRankable接口，每个Contract的权重由Level和Priority两个属性来计算，示例中我们一次从集合中随机抽取了10个Contract，而我们的算法能够保证它们都是不重复的，这个程序可以满足各种各样的抽取规则，比如按照Contract的口语、职位等不同的维度进行概率模型的建立即可，只要它实现了IRankable接口就可以使用这篇文章中的方法来随机抽取，这其实是一个业余时间的小项目啦，可我还是想让自己认真地考虑下这个问题，所以我花时间写了这篇文章，我对它的期望并没有太高，我喜欢将这些想法写下来而已。 小结&emsp;&emsp;或许有些时候我们对一个事情的态度，对事情最终的走向起不了决定性的作用，尤其是在我们没有掌握话语权的时候。可我在考虑这个方案的时候，是明显地意识到程序永远无法满足人类的脑洞的需要，所以当我们在做一件事情的时候，就应该有意识地让自己想到它可能会有扩展性上的需求，我认为这是我们在做项目开发过程中需要去关注的一个点，如何让你的代码具备扩展性和可维护性，虽然有时候你想得太多会造成过度设计，可是如果你在项目前期做出了一个糟糕的规划，到了后期遭遇项目需求变更的时候就会非常痛苦，可不幸的是我在最近同时遭遇了这两种情况，或许这就是我想要强迫自己写完这篇文章的原因吧，这篇文章足足花了我两周的时间，我的拖延症啊什么时候能好啊！","tags":[{"name":"概率","slug":"概率","permalink":"http://qinyuanpei.github.io/tags/概率/"},{"name":"数学","slug":"数学","permalink":"http://qinyuanpei.github.io/tags/数学/"},{"name":"算法","slug":"算法","permalink":"http://qinyuanpei.github.io/tags/算法/"}]},{"title":"一见钟情，无疾而终","date":"2016-09-10T19:29:57.000Z","path":"posts/21112647/","text":"&emsp;&emsp;昨天下午，当她从公司办理完离职手续的时候，她在内部聊天工具上告诉我：“师父，我在公司的离职手续都办理完了，我要走了”。在那一瞬间，我突然非常平静地走过去对她说：“那就走吧”。我不知道她是不是想让我在她离开之前做些什么，或许这完全就是我的一厢情愿，因为她在此之前就明确地告诉我，她不喜欢我，所以这注定是一个悲伤的故事。一个月前，当她的同学从公司离职的时候，她就告诉我或许某一天她就离开这里了，当时我说我会想她的，而当她真正要离开的时候，我甚至都想不明白自己为什么会如此平静。下班路上同事Kent若有所思的告诉我，在我这个年龄“一见钟情”这种满足初恋情结的机会会越来越少，与其在感情的创伤中持续失落不如努力去争取一段新的开始。我惊诧于他突然间发现我隐藏在心底的秘密，我更加纠结于我丧失了喜欢一个人的能力。 &emsp;&emsp;我像是忽然间发现我在感情上的天赋基本为负值似的，从我开始喜欢她开始，在这个过程中我感觉自己非常自卑，甚至当我真正站在她面前的时候，我常常会变得非常笨拙以至于完全不知道要说什么，我和她说我在她面前的时候有点儿“怕”她，她回复给我一个笑脸说：你可是我师父啊。你知道吗？当一个男生接受女生“成为朋友”这种现实的时候，从某种意义上来讲，他是将对她的喜欢以一种新的方式重新输出，就像她不在公司里的时候，她愿意委托我帮她处理某些事情，这对我而言是非常开心的一个时刻，因为你永远都期待着，她在有事情的时候能够第一个想到你，即使她曾经拒绝过你两次，即使她明确告诉你她不喜欢你，我曾经告诉过自己，喜欢是占有而爱是克制，至少曾经有很多很多的瞬间，我们两个人因为坦露心声而变得非常开心，这是我最让我怀念的瞬间。 &emsp;&emsp;我承认我喜欢她是明显的“套路”感的，而我恰恰不是一个演技派，所以当我发现我在她面前变得笨拙的时候，我意识到我的情绪随时都可能因为她的一举一动而受到影响。我曾经因为她和某个男生一起而生她的闷气，可讽刺的是她告诉我在她心目中我比这个男生更受欢迎。同样地，这是一个悲剧的开始：你人挺好的，可我觉得我们不适合，我们还是继续做朋友吧！男人在年轻的时候，最难以接受而不得不接受的一个现实是，你非常喜欢一个人，可你此时此刻完全没有能力给她想要的生活，就像古古说她可能再遇不到我这样对她好的人，可她始终觉得我们两个人是没有未来的，而这一次，我忽然发现这一切是如此的相似，虽然我清楚地知道她们是完全不同的两个人，当她们同时对我说出“你会找到真正适合你的那个人”这句话的时候，我已无心分辨这句话的真假，我只知道我会陷入无休止的纠结，就像一个死循环导致的精神分裂。 &emsp;&emsp;我是一个双子座男生，虽然我不是特别相信星座这种东西，可是通过知乎上的相关问题，我意识到双重人格可能是每一个双子座的终身宿命。同事说我走路的时候身体前倾、双手呈合拢状态，我承认这是因为我受到阿什顿.库彻主演的乔布斯同名传记电影的影响，在某种程度上我是在刻意模仿他的动作，所以当时我戏诩地回答道：因为我是风一样的男子啊。可事实是，无论是她还是我，我们都像风一样彼此走进各自的生命历程，然后又像风一样遁迹于无形，可是这一切真实存在过不是吗？她说我无法控制情绪生闷气的时候显得挺逗比的，所以从那个时候开始，我决定学会管理情绪。可我时常对自己产生怀疑， 比如我怀疑我是不是一个不懂得聊天的人，比如我怀疑我是不是自从古古离开我以后就失去了爱人的能力，比如我怀疑是不是太专注于技术而忽略了更多技术以外的东西等等，事实上这些问题确实存在，当你喜欢上一个人以后，你会发现你更加你身上的缺点会在瞬间被方大，大概这是我在她面前自卑的原因吧！ &emsp;&emsp;所以双子座内心深处像是上帝打开了一扇新窗户，它是天使与魔鬼的结合。而更多的时候，我都被内心深处的两个灵魂左右者，我时常温柔、时常暴戾，就像阴晴不定的天气一样，我虽然讨厌这种严重分裂的性格，因为它常常让我在小事情上举棋不定，而一个成熟的男人是要学会当机立断的，可我同样知道，这是真实的我，不管它是好是坏，当你学会接受这一切的时候，你的灵魂和你的身体是完全同步的，所以这是我为什么讨厌虚伪的原因，因为它像藏在套子里的一个人你永远都不知道它哪一句话是真的。当你发现一个双子座男生对你忽冷忽热的时候，如果你信任他就让他自生自灭，当他安静下来像个孩子的时候，你会发现他的快乐和忧愁就像风一样转瞬即逝，所以我说：“我是风一样的男子”。而当他对你失去关注和热情的时候，他会使用最直接的话语告诉你他的真实想法，而这一切在我这里从来发生过，我希望所有被我这种阴晴不定的性格不经意间伤害过的朋友都能够原谅我，我从来都不是一个坏人，只是我的心里一直有两个人在打架。 &emsp;&emsp;当我此时此刻写这篇博客的时候，我常常问自己，我还喜欢她吗？我确认我依然喜欢她，尤其是当我知道，她年龄比我大1岁以及她拥有硕士学位，这样两个事实以后，我更多的纠结和痛苦是来自来自我的否定，我们常常说爱情一半靠缘分一半靠争取，可当你真正试图走进一个人的生活的时候，你是否认真地考虑过两个人的未来，因为我不想重蹈覆辙。喜欢一个人并没有错，关键是你如何让两个人的世界巧妙地融合为一个世界，我时常自卑因为我对未来还没有确定。我喜欢过的人永远都会在我心底占据一片地方，因为我有严重的依赖性和怀旧心理，我可以去经常去的地方吃同样的东西，我可以和经常遇见的人说同样的话，对我而言，忠诚度和稳定性比新鲜感更为重要。或许我在生活和情感上的的确确存在弱点，很多时候我主观意识薄弱，对待事物的态度随意而温和，这在女生心目中可能会变成没有主见吧，其实在这些小事情上我一直都不怎么上心的，或许我需要改变吧！ &emsp;&emsp;昨天晚上，不知道为什么突然特别难过，或许是因为被同事说中心事，或许是因为想到我喜欢过的女孩而心存不甘，或许是因为憎恶现在这个状态的自己……总而言之，有那么一瞬间我感到我的心像是被挖去了一块，原来喜欢一个人可以让我如此难过，想到种种过往我以为自己会泣不成声，结果我声音哽咽着眼睛却是干的，或许我们最喜欢使用的那个“破涕为笑”的表情最能形容我当时的心境，我想了很久，一个人跑出去散步，当风轻轻地划过我的脸庞的时候，当秋天的寒意让我猝不及防的时候，我忽然觉得，当这个世界越发地充满“恶意”的时候，你更需要一个坚强地理由去生活，她们都教会我很多，和这个相比，悲伤和痛苦都显得微不足道，我想努力学好英语、我想努力练习写字、我想努力培养兴趣、我想努力克服恐惧，我是一个骄傲的人，在技术上是在生活上更应该是，如果我不能像编程一样掌控世界，我愿意在这纷繁的世界里不忘初心，喜欢和爱这种美好的情感，是不该让悲伤来消化的奢侈品。对未来的期望是让我变得优秀，如果在感情问题上做不了演技派，那我只好选择本色出演，真诚比套路更重要。 &emsp;&emsp;下午坐公交回来的时候，看着窗外像风一样飞驰的风景，我的思绪越飘越远，我不知道我想要表达什么，在那一刻我突然很想给她写一首诗，当别的女孩儿嫉妒我对她如宠溺一般的耐心时，我常常告诉她们，我曾经有一个不笨的徒弟，即使各种羡慕嫉妒恨，可我想说，这是我的心自己选择的啊，我不过是遵从它的意志，让这一切变得温暖美好起来： 你像一阵风/我伸开手抓到的只有/花落后的芬芳我离你/时而很近/时而很远像天上的云/舒卷成蝶我不想去采摘它啊月亮静待着它怒放我愿意守护它一刻即使它一直当月亮是太阳 2016年9月10日 Payne","tags":[{"name":"感悟","slug":"感悟","permalink":"http://qinyuanpei.github.io/tags/感悟/"},{"name":"成长","slug":"成长","permalink":"http://qinyuanpei.github.io/tags/成长/"},{"name":"爱情","slug":"爱情","permalink":"http://qinyuanpei.github.io/tags/爱情/"}]},{"title":"浅析WPF中MVVM模式下命令与委托的关系","date":"2016-07-21T14:27:07.000Z","path":"posts/569337285/","text":"&emsp;&emsp;各位朋友大家好，我是Payne，欢迎大家关注我的博客，我的博客地址是http://qinyuanpei.com。最近因为项目上的原因开始接触WPF，或许这样一个在现在来讲显得过时的东西，我猜大家不会有兴趣去了解，可是你不会明白对某些保守的项目来讲，安全性比先进性更为重要，所以当你发现银行这类机构还在使用各种“复古”的软件系统的时候，你应该相信这类东西的确有它们存在的意义。与此同时，你会更加深刻地明白一个道理：技术是否先进性和其流行程度本身并无直接联系。由此我们可以推论出：一项不流行的技术不一定是因为它本身技术不先进，或许仅仅是因为它无法满足商业化的需求而已。我这里的确是在说WPF,MVVM思想最早由WPF提出，然而其发扬光大却是因为前端领域近年来比较热的AngularJS和Vue.js，我们这里表达的一个观点是：很多你以为非常新潮的概念，或许仅仅是被人们重新赋予了新的名字，当你理清这一切的来龙去脉以后，你会发现这一切并没有什么不同。这符合我一贯的主张：去发现问题的实质、不要被框架束缚、通过共性来消除差异，所以在今天这篇文章里，我想说说WPF中MVVM模式下命令与委托的关系。 什么是MVVM?&emsp;&emsp;既然提及MVVM，那么我们就无可避免的需要知道什么是MVVM。我们在本文开篇已经提到，MVVM这个概念最早由微软提出，具体来讲是由微软架构师John Gossman提出的。我个人更喜欢通过将MVC、MVP和MVVM这三者横向对比的方式来加强理解，因为这从某种意义上来讲，这是一个逐步改进和演化的过程。我们常常谈及软件的三层架构，我们常常对MVC耳濡目染以致将其神化，可事实上它们是某种在思想上无限接近的理念而已。 MVC模式示意图 &emsp;&emsp;首先，我们从最简单的MVC开始说起，作为最常用的软件架构之一，我们可以从上面的图示中看到，MVC其实是非常简单的一个概念，它由模型(Model)、视图(View)和控制器(Controller)三部分组成，建立在一个单向流动的通信基础上，即View通知Controller响应用户请求，Controller在接到View的通知后会更新Model内的数据，然后Model会将新的数据反馈给View。我们发现这个设计可以使软件工程中的关注点分离，我们注意到通过MVC模式，我们实现了视图和模型的分离，通过控制器这个胶水层让两者间接联系起来，所以MVC的优点是让各个模块更好的协作。那么，它的缺点是什么呢？显然，视图和控制器是高度耦合的，因为控制器中无可避免地要访问视图内的元素，所以控制器注定无法在这尘世间独善其身。要知道最早的MVC架构是基于观察者模式实现的，即当Model发生变化时会同时通知View和Controller，所以我们很快就可以认识到：我们从古至今的所有努力，都是为了让视图和模型彼此分离，我们在这条路上越走越远，幸运的是一直都不忘初心。 MVP模式示意图 &emsp;&emsp;接下来，我们为了彻底地让视图和模型分离，我们发明了新的软件架构：MVP。虽然从感性的认识上来讲，它是将Controller改名为Presenter，然而从理性的认识上来讲，它在让视图和模型分离这件事情上做得更为决绝果断。通过图示我们可以发现，视图和模型不再发生直接联系，它们都通过Presenter相互联系，而且各个部分间的通信都变成了双向流动。我们可以很快意识到，现在全新的控制器即Presenter会变得越来越“重”，因为所有的逻辑都在这里，而视图会变得越来越“轻”，它不再需要主动去获取模型提供的数据，它将被动地接拥抱变化，因为现在在视图里基本上没有任何业务逻辑。现在我们可以预见，人类会在隔绝视图和模型这件事情上乘胜追击，人们会尝试让Controller/Presenter/ViewModel变得越来越臃肿，我想说的是，求它们在得知这一切真相时的心理阴影面积，我们试图让每一个模块各司其职、通力协作，结果脏活累活儿都交给了Controller/Presenter/ViewModel，我想说这件事情做的真是漂亮。 MVVM模式示意图 &emsp;&emsp;历史总是如此的相似，人类在作死的道路上匍匐前进，继续发扬改名的优良传统，这一次是Presenter被改名为ViewModel，在命名这件事情上，我认为程序员都是有某种强迫症因素在里面的，所以当你发现一个事物以一个新的名字出现在你的视野中的时候，通常它会有两种不同的结局，第一，陈酒换新瓶，我们贩卖的不是酒是情怀；第二，看今天的你我怎样重复昨天的故事，我这张旧船票还能否登上你的客船。幸运的是，MVVM相对MVP的确发生了些许改变，一个重要的特性是双向绑定，View的变化将自动反映在ViewModel中，而显然ViewModel是一个为View打造的Model，它可以容纳更多的普通的Model，因此从某种意义上来说，ViewModel依然作为连接View和Model的桥梁而出现，它是对View的一种抽象，而抽象有两层含义，即数据(Property)和行为(Command)，一旦你明白了这一点，ViewModel无非是一个特殊而普通的类而已，特殊是因为它需要实现INotifyPropertyChanged接口，普通是因为它继承了面向对象编程(OOP)的基本思想。 更像MVC的MVVM&emsp;&emsp;到现在为止，我们基本上理解了MVC、MVP和MVVM这三者间的联系和区别，可是这样真的就是最好的结果吗？我们首先来思考一个问题，即什么样的代码应该写在控制器里。比如我们在对项目进行分层的时候，到底应该让控制器负责哪些任务？我们可以让Controller处理单独的路由，同样可以让Controller参与视图逻辑，甚至我们在编写Model的时候，我们可以有两种不同的选择，第一，编写一个简单的数据聚合实体，具体逻辑都交给控制器来处理，我们将这种方式称为贫血模型；第二，编写一个持有行为的数据聚合实体，控制器在业务逻辑中调用这些方法，我们将这种方式称为充血模型。所以，在这里我们纠结的地方，其实是选择让控制器更“重”还是让模型更“重”，我曾经接触过1年左右的Android开发，我认为Android工程是一个相对符合MVC架构的设计，可是我们难免会发现，作为控制器的Activity中的代码非常臃肿，因为我们在这里需要和视图、模型关联起来，所以综合现有的这些软件架构思想，我们发现模型和视图相对来讲都是可以复用的，可是作为连接这两者的Controller/Presenter/ViewModel是非常臃肿而且难以复用的，所以我怀疑我们是否是在真正的使用MVVM。 &emsp;&emsp;我不知道MVVM架构正确的使用方法是什么样的，因为这是我第一次接触到这样一个新的概念，就如同很多年前，我在学校图书馆里看到的一本讲Web开发的书中描写的那样：当我们不了解MVC的时候，我们理所当然地认为通过文件夹将项目划分为Model、View、Controller，这样好像就是MVC啦。可是事实真的是这样吗？以我目前公司项目的情况而已，我认为它更像是使用了双向绑定的MVC，因为你经常可以在ViewModel中看到，某个属性的Get访问器中各种被if-else折磨的“脏”代码，而在ViewModel中我基本上看不到Model的身影，并且因为使用了Binding的概念严重弱化了ViewModel作为类的基本属性，因此它没有构造函数、没有初始化，我们可以在Get访问器中看到各种硬编码，因为视图上的需求经常变动，所以当整个项目结束的时候，我本人是非常不愿意去看ViewModel这部分的代码的，因为项目上要求避免写Code-Behind代码，所以大量的事件被Command和UIEventToCommand代替，这样让ViewModel变得更“重”了。原本我们希望的是让这三者各司其职，结果现在脏活累活儿全部变成了ViewModel一个人的。虽然双向绑定可以避免去写大量赋值语句，可是我知道ViewModel内心深处会表示：宝宝心里苦。 &emsp;&emsp;如果说WPF对技术圈最大的贡献，我认为这个贡献不在双向绑定，而是它真正意义上实现了设计和编程分离，我们必须承认设计和编程都是一项创造性活动，前者趋向感性，而后者趋向理想，在没有实现这两者分离的时候，程序员需要花费大量时间去还原设计师的设计，可是对程序员来讲，一段程序有没有界面设计在某些场合下是完全不重要的，在没有界面设计的情况下，我们可以通过单元测试来测试代码的可靠程度，相反地在有了界面设计以后我们反而不容易做到这一点，所以你问我WPF对技术圈最大的贡献是什么，我会回答它解放了程序员，可以让理性思维去做理性思维更适合的事情。我不太喜欢声明式编程，这里是指WPF中XAML这种继承自XML的标记语言，因为Visual Studio对XAML没有提供调试的支持，所以当你发现视图显示出现问题的时候，你很难分清楚是前台视图绑定出现错误还是后台ViewModel出现错误，只要你输入符合XML规范的内容程序都会编译通过而非引发异常，因为它是用反射所以性能问题广为人所诟病，其次ViewModel中通知前台属性发生变化时需要使用OnPropertyChanged，该方法需要传入一个字符串类型的值，通常是指属性的名称，可是如果你定义了一个字符串类型的属性，当你在这里传入这个属性的时候，因为它是字符串类型所以不会引发编译错误，可是我觉得这个东西还是比较坑。 委托与命令&emsp;&emsp;好了，现在我想说说WPF中的命令和委托，事实上在我计划写这篇文章前，我对这里无比好奇，可当我发现这东西的实质以后，我忽然觉得花费如此大的篇幅来讲解这样一个概念，这是不是会显得特别无聊。我们的项目上使用的是一个叫做MVVM light的框架，当然我们没有使用它的全部功能，公司的前辈们非常猥琐地从这个开源项目中挑了些源代码出来，这里我不想提及关于这个框架本身地相关细节，因为我认为理解问题的实质比学会一个框架更加重要。首先，WPF为每一个控件都提供了一个Command的依赖属性，因为任何实现了ICommand接口的类都可以通过绑定的方式和前台关联起来，我们这里对比下命令和路由事件的区别可以发现，路由事件必须写在Code-Behind代码中，而命令可以写在ViewModel里，所以直观上来讲命令更加自由灵活。下面我们以一个简单的例子来剖析这两者间的关系。 &emsp;&emsp;我们知道使用Command需要实现ICommand接口，所以实现起来是相对容易的，我们这里继续沿用MVVM light中的RelayCommand这个名字：1234567891011121314151617181920212223242526272829303132333435public class RelayCommand : ICommand&#123; private readonly Action&lt;object&gt; m_execute; private readonly Predicate&lt;object&gt; m_canExecute; public RelayCommand(Action&lt;object&gt; execute) &#123; this.m_execute = execute; &#125; public RelayCommand(Action&lt;object&gt; execute, Predicate&lt;object&gt; canExecute) &#123; this.m_execute = execute; this.m_canExecute = canExecute; &#125; public bool CanExecute(object parameter) &#123; if (m_canExecute == null) return true; return m_canExecute(parameter); &#125; public event EventHandler CanExecuteChanged &#123; add &#123; CommandManager.RequerySuggested += value; &#125; remove &#123; CommandManager.RequerySuggested -= value; &#125; &#125; public void Execute(object parameter) &#123; this.m_execute(parameter); &#125;&#125; 我们可以看到这里有两个重要的方法，Execute和CanExecute，前者是一个void类型的方法，后者是一个bool类型的方法。当我们需要判断控件是否应该执行某一个过程的时候，CanExecute这个方法就可以帮助我们完成判断，而Execute方法显然是执行某一个过程的方法，可以注意到通过委托我们让调用者更加自由和灵活地传入一个方法，这是我喜欢这种设计的一个地方，因为我的一位同事就对普通的路由事件表示无法理解。 &emsp;&emsp;这里需要说明的是CanExecuteChanged这个事件，这个和INotifyPropertyChanged接口中的PropertyChanged成员类似，是在当CanExecute发生变化的时候通知视图的，我对这里的理解是CanExecute本身就具备对某一个过程是否应该被执行的支持，可是遗憾的是在，在我参与的项目中，人们更喜欢声明大量的布尔类型变量来处理这里的相关逻辑，因此无论是对Property还是Command而言，在ViewModel里都是看起来非常丑陋的代码实现。 &emsp;&emsp;好了，现在对我们而言，这是一个非常愉快的旅程，因为在完成对RelayCommand的定义以后，我们绑定命令和定义命令的过程是非常简单的。除此以外，WPF提供了一个RoutedCommand类，该类实现了ICommand接口，我怀疑MVVM light中的EventToCommand正是通过这种思路实现了路由事件到命令的转换，因为只有RoutedCommand具备访问UI事件的能力，这里我们仅仅提出问题，进一步的思考和验证我们可以留到以后去做。下面我们来看看如何声明和绑定命令： 12345678910public RelayCommand ClickCommand&#123; get &#123; return new RelayCommand((arg)=&gt; &#123; MessageBox.Show(\"Click\"); &#125;); &#125;&#125; 显然这个ClickCommand将作为一个属性出现在ViewModel中，我选择了一个我最喜欢用的方法，或许这样看起来非常低端。可是在调试界面的过程中，它要比断点调试更为直接和直观。当我们的ViewModel中出现这样的只读属性的时候，直接在Get访问器中定义它的返回值似乎是最直接有效的方案，可问题是Get访问器应该是非常“轻”的，因为大量业务逻辑的渗透，现在连这里都不能保留其纯粹性了吗？这让我表示非常郁闷啊。 123456789&lt;Window x:Class=\"WPFLearning.Window1\" xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\" Title=\"Window\" Height=\"300\" Width=\"300\"&gt; &lt;Grid&gt; &lt;Button Content=\"Button\" HorizontalAlignment=\"Center\" VerticalAlignment=\"Center\" Command=\"&#123;Binding ClickCommand &#125;\"/&gt; &lt;/Grid&gt;&lt;/Window&gt; 现在你可以发现，委托和命令结合得非常好，当你发现这一切如此美妙的时候，回归本质或许是我们最喜欢的事情，就像纯粹的你我一样，在这个世界上，我们彼此装点着各自生命里美好的风景，执著而勇敢、温暖而明媚，那些周而复始的日子里，总能听到梦想开花的声音。 小结&emsp;&emsp;在这篇文章里我们讨论了MVC、MVP、MVVM各自架构变迁的前因后果，由此我们知道了软件设计中，一个典型的设计目标是让视图和模型分离，可我们同样发现，带着这个目标去设计软件的时候，我们基本鲜有更换视图的时候，虽然从理论上来讲，所有的业务逻辑都是在ViewModel中，视图和模型应该是可以进行更换的，可是你告诉我，有谁会为同一个软件制作不同的界面呢？难道我们还能期望通过一个静态工厂，来为不同的平台返回不同的视图，然后理论上只要适配正确的控制器就可以实现软件对不同平台的“自适应”，可是软件开发领域发展至今，最有可能提供完整跨平台方案的Web技术目前都无法满足这个需求，所以我们是否应该去怀疑这个设计的正确性呢？同样的，以Java的SSH三大框架为代表的“配置文件”流派，认为应该将数据库的相关信息写在配置文件里，这样可以满足我们随时切换到不同数据库产品上的需要，可是你告诉我，这样的应用场景多吗？所以，技术本身的设计并没有问题，我们需要思考的是，是否应该被框架和架构束缚，说到底我们是为了设计出更棒的软件产品，以此为目标，其实框架和架构更应该衍生为一种哲学意义上的思想，我们想让每一行代码都充满智慧的光芒，它骄傲却不孤独，因为总有人理解它、懂它。","tags":[{"name":"MVVM","slug":"MVVM","permalink":"http://qinyuanpei.github.io/tags/MVVM/"},{"name":"委托","slug":"委托","permalink":"http://qinyuanpei.github.io/tags/委托/"},{"name":"命令","slug":"命令","permalink":"http://qinyuanpei.github.io/tags/命令/"}]},{"title":"在Unity3D中使用uGUI实现3D旋转特效","date":"2016-07-10T14:29:33.000Z","path":"posts/1150143610/","text":"&emsp;&emsp;各位朋友大家好，欢迎大家关注我的博客，我是Payne，我的博客地址是http://qinyuanpei.com。最近一位朋友问我，如何在Unity引擎中实现类似《英雄联盟》中选择皮肤时的3D滚动视图效果，虽然我非常不喜欢这个游戏，可是大学四年在宿舍里被周围同学们耳濡目染，对这个游戏中常见英雄的口头禅还是颇为熟悉的，曾经在周围同学的“硝烟”和“噪杂”中熬夜编程，此时此刻想起来大概是最能让我怀念和骄傲的记忆了。剑圣说“你的剑就是我的剑”，伊泽瑞尔说“是时候表演真正的技术了”，杰斯说“为了更美好的明天而战”……或许曾经的某一瞬间，我们曾经有过类似的让你我疯狂着迷的人生信条，可是不管怎样，我希望我们可以将这些永远地铭刻在心里，如同心中栽种下一棵红莲，在黑夜中静静地等待开放，这样当此去经年亦或时过境迁的时候，我们不会说是时光抹去了你我年轻的棱角，因为我相信真正的棱角会因为磨砺而变得更加明亮，绝对不会因为此刻的苟且就变的麻木甚至迷茫。好了，喝完我这碗心灵鸡汤，下面我们来一起学习如何在Unity3D中使用uGUI实现3D滚动视图效果。 #需求分析&emsp;&emsp;首先，我们先来对这个需求进行分析，从这篇文章的题目我们获得的一个关键信息是，希望通过某种方式实现3D滚动特效。因此我们首先要解决的一个问题是，我们应该采用2D方式来实现还是采用3D方式来实现这种界面效果。我们假定这里希望实现的效果如下图所示，我们可以注意到从这张图片的设计初衷来看，它更像是一种介绍产品特性的文案设计，我们这里仅仅是想通过这张图告诉大家，我们需要实现一个什么样的效果。软件开发过程中最大的成本在我看来主要来自沟通。因为事实上对普通用户而言技术并不重要，重要的是能否实现用户想要的功能，可是大部分情形是用户并不知道自己想要什么，除非你将实际的产品放到用户眼前甚至手中。好了，在对需求有了一个基本的印象以后，我们来思考如何实现这个需求。 &emsp;&emsp;具体来讲，我们有两种思路： 其一是采用真实的3D来制作，即我们通过一个圆柱体或者是多棱柱将图片”粘贴”在不同的面上，通过对圆柱体或者多棱柱进行旋转，然后以真实的3D的形式来呈现给用户。 其二是采用伪3D来制作，即我们通过在2D平面内对图片的层次进行合理化调整实现伪3D效果，配合插值、缩放等技巧来实现2D平面上的旋转，然后给用户一种视觉上的3D效果。 需求设定 #核心原理&emsp;&emsp;在这里我们选择采用伪3D来制作，为什么选择这种方案呢？因为它简单啊，哈哈。好了，我们现在将实际的需求进行抽象，我们会发现什么呢？我们注意到这本质上是一个曲线问题，我们可以将每个图片的中心用平滑的曲线连接起来，然后我们就得到了一条抛物线或者是圆锥曲线或者是贝塞尔曲线，在这里我们将其理解为什么样的曲线并不重要，因为这最终影响到的是曲线的平滑度问题，即细节上的调整。沿着这个思路，我们就意识到，这是一个根据曲线平均分布坐标点的过程，假设我们这里5张图片，并且曲线在中间位置可以找到一条垂直的对称轴，那么我们只需要将这5个点在水平方向上平均分布即可，事实上根据人类视觉的特点，这个距离应该是越来越小的，就像我们看到的一排并列的树木，越远的地方它们的间距会越来越小，而事实上它们的间距是一样的，根据这个特性我们可以表现出这种视觉上的纵深的感觉，在实际项目中它取决于美术设定和策划设定，我们这里就从最简单的情况开始分析。 &emsp;&emsp;好了，在解决了精灵放置的这个问题以后，我们接下来要解决的是什么呢？答案是精灵的层级，因为层级能够帮助我们营造一种视觉上的层次感和立体感，比如在跑酷游戏中我们常常使用视差滚动这种技术来表现3D效果，以及传统的斜45度瓦片地图来实现2.5D效果都是使用2D来模拟3D效果的经典案例。所以在这里除了确定每个精灵的放置位置以外，我们还有一个问题，如何对这些精灵进行排序，所幸的是在uGUI中我们可以通过SetSiblingIndex方法来设置一个精灵的深度，当每次通过按钮切换精灵的时候，我们都需要对所有精灵重新计算坐标和深度，而为了更好的视觉表现力，我们可以在切换的时候做一个简单的位移动画，至此我们就可以开始动手实现功能啦。 #具体实现&emsp;&emsp;首先我们来搭建一个基本的场景，我们这里将一切浮华褪尽，我们可以看到在场景中有两个按钮，它们可以让我们当前选中的卡片，而界面底部的标签会显示我们当前选择的角色名称。虽然在这里采用触屏滑动的效果更好，可我们这里主要的目的是为了说明如何实现我们的思路，当引入这部分功能的设计以后，会增加大家在整体理解上的难度，所以我们这里以快速实现功能为主。注意到场景中的卡片此时都是相当“任性”地放置在界面上，这是因为我们稍后会采用算法计算每个卡片的实际位置，所以在这里完全可以忽略其“美观性”。 场景展示 &emsp;&emsp;这里，我们设定场景的大小为800x460，那么在这种情况下，我们可以按照下面图中所示的曲线轨迹来构造一条曲线，考虑到椭圆方程比贝塞尔曲线更加简单易用，所以我们这里选择椭圆方程来作为场景中这些卡片排列的曲线方程。 曲线方程 &emsp;&emsp;此时以屏幕中心为原点构建平面直角坐标系，则这个椭圆是一个以长轴2A=400、短轴2B=640、中心在(0,320)上的椭圆。根据这个原理，我们可以将其代码实现分为三个步骤来实现。首先，我们将场景中的所有卡片存储在GameObject数组中，这里我们这里规定卡片的数目必须为奇数，然后我们从左到右依次计算每个卡片的位置和深度，这样就可以让卡片按照我们期望的方式进行排列啦。下面一起来看代码如何实现： 123456789101112//初始化精灵数组int childCount = transform.childCount;//计算两侧精灵数目halfSize = (childCount-1)/2;//初始化精灵sprites = new GameObject[childCount];for(int i=0;i&lt;childCount;i++)&#123; sprites[i] = transform.GetChild(i).gameObject; SetPosition(i); SetDeepin(i);&#125; 这里sprites显然是一个GameObject[],因为卡片的数目为奇数个，所以halfSize是指中间位置卡片的索引，这里需要两个辅助方法，SetPosition和SetDeepin，从名字我们就知道这两个方法分别是设置卡片位置和设置卡片深度。当我们提到代码注释的时候，好多人以代码自注释为理解逃避注释，孰不知这建立在命名规范的基础上，如果你连这点基本的要求都做不到，我建议你还是多写点注释、少写点代码。好了，这两个方法的实现细节如下： 1234567891011121314151617181920212223/// &lt;summary&gt;/// 设置精灵位置/// &lt;/summary&gt;private void SetPosition(int index)&#123; //计算第index个精灵的角度 float angle = 0.0f; if (index &lt; halfSize) &#123; angle = startAngle - (halfSize - index) * DeltaAngle; &#125; else if (index &gt; halfSize) &#123; angle = startAngle + (index - halfSize) * DeltaAngle; &#125; else &#123; angle = startAngle; &#125; //计算第index个精灵的坐标 float x = A* Mathf.Cos((angle/180) * Mathf.PI) + Center.x; float y = B* Mathf.Sin((angle/180) * Mathf.PI) + Center.y; Vector3 v3 = Camera.main.WorldToScreenPoint(new Vector3(x,y,0)); v3 = Camera.main.ScreenToWorldPoint(v3); Vector2 v2 = new Vector2(v3.x,v3.y); sprites[index].GetComponent&lt;RectTransform&gt;().anchoredPosition = v2;&#125; 可以注意到，在这里我们根据精灵索引index和两侧精灵数目halfSize的关系，按照DeltaAngle这个增量来计算每个精灵实际的角度，在此基础上结合椭圆的参数方程，我们可以非常容易地计算出每个精灵实际的位置，这样就可以保证精灵中心都在椭圆曲线上。好了，接下来我们会遇到一个新的问题，这些精灵的层级应该是从中间位置向两边依次递减的，所以为了解决这个问题，我们还需要对每个精灵的层级进行计算，这部分代码的实现细节如下： 12345678910111213141516/// &lt;summary&gt;/// 设置精灵深度/// &lt;/summary&gt;private void SetDeepin(int index)&#123; //计算精灵深度 int deepin = 0; if(index&lt;halfSize)&#123; deepin = index; &#125;else if(index&gt;halfSize)&#123; deepin = sprites.Length-(1+index); &#125;else&#123; deepin = halfSize; &#125; sprites[index].GetComponent&lt;RectTransform&gt;().SetSiblingIndex(deepin);&#125; 事实上，我在这里并不清楚SetSiblingIndex这个方法的真正作用:)，可是它的确能够实现我们想要的功能。有时候在维护一个古老的项目的时候，可能你会在代码中看到各种有趣的注释，而这些注释中有相当一些都充满了一种“形而上学”的味道在里面，我们不知道这个世界为什么会是这样，可是看起来它们都运行地非常良好。或许这就是这个世界的奇妙之处，无论我们是否想要尝试打破这些规则，这个世界上总是有些我们难以理解的东西存在，可是存在即合理，不是吗？理性思维的缺陷在于想要为一切问题找到一个答案，所以这次苏格拉没有底，我们就感性一次又何妨呢，这个问题就让它没有答案吧！ &emsp;&emsp;现在，显然我们需要解决一个新的问题，就像上帝在我们关上一扇门的同时，会为我们开启一扇窗口。理论上任何问题都可以通过引入一个中间层来解决，而引入中间层的同时毫无疑问地引入了一个新的问题。在这里我们已经完成了让所有精灵按照椭圆曲线进行排布以及精灵的层级关系这两个问题，可是我们这是一个静态的过程啊，我们需要的是让它能够滚动起来，所以怎么解决这个问题呢？我们可以注意到的一点是，精灵的这种“滚动”效果，实际上是将数组中的第一个元素sprites[0]或者最后一个元素sprites[sprites.Length-1]，依次和数组中的第i个元素进行交换。比如精灵整体向右侧“滚动”，我们只需要从第一个元素开始依次和最后一个元素进行交换就可以啦，所以这里的实现实际上是： 12345678910111213141516171819/// &lt;summary&gt;/// 向后翻页/// &lt;/summary&gt;public void OnNext()&#123; int length = sprites.Length; for(int i=0;i&lt;length;i++) &#123; GameObject temp = sprites[i]; sprites[i] = sprites[length-1]; sprites[length-1] = temp; &#125; for(int i=0;i&lt;length;i++) &#123; SetPosition(i); SetDeepin(i); &#125;&#125; 我们在对数组内的元素重新组织后，需要重新计算每个精灵的位置和深度。我这里在思考的一个问题是：精灵的位置和深度实际上是确定的，所以我们可以考虑将它们存储起来“复用”，这样可以减少每次的重复计算。其实，代码的优化和重构是一个需要时间来酝酿的过程，没有人能够在写代码的时候，就可以意识到代码中的瑕疵，而这种发现问题的眼光通常需要长时间的培养，这是我们之所以提倡不要过早优化的原因，除非你能够快速地找到代码中的优化点。好了，现在采用类似的思路，我们可以实现向前翻页的逻辑啦，这里的代码非常简单不再赘述。 &emsp;&emsp;好了，现在我们可以看看到目前为止我们实现了一个怎样的功能吧！ 效果展示 其实这篇文章我还想继续再往下写的，可是因为我比较懒一直拖着不写，以及接下来相当多的内容都是和界面相关的东西，所以我决定这篇文章就暂时写到这里，目前这个方案可以实现一个简单的“3D”滚动的效果，按照这个思路，接下来我们要做的事情是让滚动更加平滑以及支持鼠标或者触屏操作，毕竟这个需求的出发点是来自一个游戏，所以我们可以考虑在“滚动”的时候增加插值特性，与此同时，为了让它更加具有“3D”的感觉，可以在设置精灵层级的时候为不同的精灵设置不同的缩放比例，这样会更加符合美术中的透视关系，效果应该会更好吧！我认识的一位朋友使用uGUI中原生控件ScrollRect实现了类似的功能，感觉她还是非常厉害的啊，果然我不再从事Unity开发以后，我在这块的技术完全跟不上整个技术圈的节奏啊。 #小结&emsp;&emsp;本文介绍了一种基于曲线方程来构建伪3D效果的思路，主要借助椭圆的参数方程来计算精灵位置，使其实现按照椭圆曲线进行排布的效果，在此基础上配合层级调整、插值、缩放等技巧，在一定程度上可以实现2D平面内的伪3D旋转效果。因为博主身患拖延症晚期，所以这篇文章在拖延了很久以后，终于成功的成为了一个没有填完的坑，不过我相信掌握原理比获取代码更为重要，所以这篇文章更多的是希望能给大家提供相关思路，博主在这篇文章中没有实现的功能，各位读者有兴趣的话可以考虑自行实现，写完这篇文章表示心好累，好了，就这样吧,各位晚安！","tags":[{"name":"Unity3D","slug":"Unity3D","permalink":"http://qinyuanpei.github.io/tags/Unity3D/"},{"name":"游戏开发","slug":"游戏开发","permalink":"http://qinyuanpei.github.io/tags/游戏开发/"},{"name":"uGUI","slug":"uGUI","permalink":"http://qinyuanpei.github.io/tags/uGUI/"}]},{"title":"Unity3D游戏开发之在uGUI中使用不规则精灵制作按钮","date":"2016-07-08T21:58:39.000Z","path":"posts/1190622881/","text":"&emsp;&emsp;各位朋友大家好，欢迎关注我的博客，我的博客地址是http://www.qinyuanpei.com。最近因为受到工作上业务因素影响，所以博主在Unity引擎上的研究有所停滞。虽然目前的工作内容和Unity3D没有直接的关联，可是我觉得工程师应该有这样一种情怀，即工作和兴趣是完全不同的两个概念。编程对我而言，首先是一种兴趣，其次是一份工作。所以我宁愿在每天下班以后继续研究自己感兴趣的东西，而非为了取悦这个世界、为了加班而加班。最近广电总局让整个游戏行业都坐立不安了，因为其新发布的一系列规定，让中国的独立游戏开发者怨声载道。可是我们更应该看到积极的一面是，无数的小游戏公司会在最近数月内大量消失，或许对中国野蛮生长的游戏行业这是一次“形式”上的整顿，可对我们开发者来说，在这个过程中努力提升自我、巩固基础永远比追求时髦、流行的技术或者框架有意义的多，因为热闹的从来都是昙花一现般的璀璨，而永恒的永远都是历久弥新的真理。好了，闲言少叙，今天我们的话题是在uGUI中使用不规则精灵制作按钮。 从用户体验说起&emsp;&emsp;我们都知道在现代应用程序设计中，用户体验(UX)和用户界面(UI)是两个非常重要的内容。为什么用户体验(UX)和用户界面(UI)会显得如此重要呢？这是因为从普通用户的角度来讲，用户界面(UI)是其接触到一个产品时最先看到的最直观的东西，而在这个过程中产生的直观感受就是用户体验(UX)，所以说到底这是一个产品给用户的“第一印象”。 UX和UI &emsp;&emsp;最近百度UE总监刘超在IXDC峰会上的演讲引起了大家的关注，抛开百度在人才选拔机制中存在的问题以及刘超本人在设计领域是否具备专业能力这两个问题，这件事情真正让大家吐槽的是什么呢？答案是用户体验。虽然IXDC并非国际级别的大型会议，但是我相信大家组织这样的活动，其本意是为了探讨交互、设计领域内的新方法和新思维，因为随着互联网行业的发展，交互和设计这个领域越来越被人们所关注，所以在这样一个场合下，当与会嘉宾都在试图向人们输出干货的时候，刘超以一个非常糟糕的“用户体验”来给大家讲什么是用户体验，这件事情起源自刘超的一个个人行为，结果牵一发而动全身，最终升级为百度继“魏则西事件”以后的又一次公关危机。 什么叫设计 &emsp;&emsp;我到底想说什么呢？我说的本质上就是用户体验的问题，在这个事件中，刘超穿着上的不得体(短裤搭配拖鞋?)、PPT制作的粗制滥造(校招时所用修改)、演讲过程的敷衍糊弄(说相声、猜谜语)等因素，让刘超在与会者心目中的地位瞬间滑落到冰点，进而引发人们对百度在交互设计领域内的能力的怀疑，联想到百度最近这些年内出现的问题，这件事情难免会被人作为指责百度这家企业价值观问题，我想这是这个事情为什么会让大家如此关注的一个原因吧。 WTF! &emsp;&emsp;那么，我们说这些到底和今天的主题有什么关系呢？我想说这当然有关系啊，因为我们提出的这个问题就是一个用户体验的问题。我们知道游戏行业对美术资源高度依赖，不管是2D游戏还是3D游戏，一个项目组中前期主要的工作量其实都在美术这边，虽然不同的游戏引擎、GUI框架都为我们提供了标准的控件样式，然而在这样一个注重多样性的时代，默认样式、系统字体都会让人觉得这个产品缺乏新意，因此这种要求体现在游戏项目中就变成了，我们使用大量的图片资源来解决界面和字体的问题。 &emsp;&emsp;例如，我们通常使用BMFont来制作位图字体，这是为了同时满足字体的多样性和资源的容量这两个要求。再比如我们在使用cocos2d-x和Unity3D引擎开发游戏的时候，我们将大量的时间花费在了UI的制作上，这一切的一切从本质上来讲都是为了提升产品的童虎体验。这样我们就会遇到一个问题，UI中的按钮默认情况下都是规则的矩形，而实际上美术提供的素材常常是不规则的，因此如果继续使用以矩形为标准的这套机制，在实际使用中可能出现“用户点击在不该响应的区域结果程序响应了用户操作”这样的问题，为了解决这个问题，提升这一点点细微的用户体验，我们需要花费时间和精力来了解下面这些内容。 两种不同的方案&emsp;&emsp;目前，关于这个问题如何，解决通过搜索引擎我们能找到两种不同的方案： 多边形碰撞器: 该方法是指给精灵(Sprite)添加一个多边形碰撞器(Rolygon Collider)组件，利用该组件来标记精灵的边界，这样通过比较鼠标位置和边界可以判断点击是否发生在精灵内部。这种方法的详细说明可以参考宣雨松的这篇文章：UGUI研究院之不规则按钮的响应区域（十四） 精灵像素检测: 该方法是指通过读取精灵(Sprite)在某一点的像素值(RGBA)，如果该点的像素值中的Alpha&lt;0.5则表示该点处是透明的，即用户点击的位置在精灵边界以外，否则用户点击的位置在精灵边界内部。这种方法的详细说明可以参考这里 多边形碰撞器&emsp;&emsp;多边形碰撞器这种方案从本质上来讲，其核心思路是验证某一点是否在任意多边形内部，因为在这里RolygonCollider2D组件的作用体现在：第一，它可以在编辑器下进行可视化编辑对用户友好；第二，它可以在帮助我们标记精灵边界的同时保留顶点信息。所以在这里RolygonCollider2D组件相当于为我们提供任意多边形的顶点信息，而接下来我们要做是将鼠标位置转化为屏幕坐标，这样我们就获得了某一点的坐标。整体思路看起来是没有问题的，但我个人以及网友AwayMe都认为宣雨松这个算法存在问题，具体的理由如下： 1、uGUI中的元素采用的是以屏幕中心为原点(0,0)的平面直角坐标系，而普通屏幕坐标采用的是以左下角为原点(0,0)的平面直角坐标系，所以多边形顶点数组和鼠标位置不在一个坐标系内，使用AABBB这样的碰撞检测算法存在问题。 2、RolygonCollider2D中的points属性即多边形顶点数组存储的是相对于UI元素的相对坐标，在进行计算的时候应该统一转化为绝对坐标，这个过程在宣雨松的代码中有所涉及，但我认为对UI元素来讲，应该使用transform.GetComponent().position而非transform.position，因为transform.position最初是给3D物体使用的，而实际上这里是存在误差的。 3、我怀疑宣雨松提供的这个ContainsPoint方法的正确性，因为按照我的理解修改这个方法以后，发现界面响应的情况和实际情况是有所出入的，如下图所示，在整个区域内该方法都返回false。为了排除因为我的方法而对结果产生的影响，我使用宣雨松的代码进行了测试，结论是这个方法不管进行坐标系的转换与否，它在整个区域内的返回值都是false，因此我认为这个方法是错误的，虽然从理解算法的角度来看，它应该是根据线性差值来判断点在多边形中每条边的哪一侧的。 响应区域说明 &emsp;&emsp;在评论中网友AwayMe指出可以使用多边形碰撞器的OverlapPoint方法来判断一个点是否在多边形内部，可是经过我测试，这种方式和宣雨松提供的方法有着类似地问题，无论是否对坐标系进行转换，这个方法都返回false，响应区域与上图完全一致。 &emsp;&emsp;所以不管网络上有没有高质量的内容，一个核心的问题是你能否从中找到答案。如果你可以直接找到解决方案这可能是最好的结局；如果找不到直接的解决方案，却能够有所启发并独立解决问题，这是我们希望看到的结果。可是有时候人们并不这样想啊，人们想得到的是可以运行的代码而非解决问题的思路，因为可能人们并不想解决这个问题。 &emsp;&emsp;好了，经过知乎上相关答案我找到了这篇文章，文章中提到了判断一个点是否在任意多边形内部的两种方法，分别为Corssing Number和Winding Number。这两种方法在理论层面的相关细节请大家自行阅读这篇文章，我们这里选择的是前者，其基本思想是计算从该点引出的射线与多边形边界橡胶的次数，当其为奇数时表示该点在多边形内部，当其为偶数时表示在多边形外部。这里有一个有意思的事情是宣雨松选择的方法应该是著名的Ray-Crossing算法，可是为什么在这里会出现这样的问题呢？ &emsp;&emsp;孰是孰非，一切都交给实践来证明吧！下面是我根据文章中提供的算法改写的一段C#代码：123456789101112131415161718192021222324252627282930313233bool ContainsPoint2(Vector2[] polyPoints,Vector2 p)&#123; //统计射线和多边形交叉次数 int cn = 0; //遍历多边形顶点数组中的每条边 for(int i=0; i&lt;polyPoints.Length-1; i++) &#123; //正常情况下这一步骤可以忽略这里是为了统一坐标系 polyPoints [i].x += transform.GetComponent&lt;RectTransform&gt; ().position.x; polyPoints [i].y += transform.GetComponent&lt;RectTransform&gt; ().position.y; //从当前位置发射向上向下两条射线 if(((polyPoints [i].y &lt;= p.y) &amp;&amp; (polyPoints [i + 1].y &gt; p.y)) || ((polyPoints [i].y &gt; p.y) &amp;&amp; (polyPoints [i + 1].y &lt;= p.y))) &#123; //compute the actual edge-ray intersect x-coordinate float vt = (float)(p.y - polyPoints [i].y) / (polyPoints [i + 1].y - polyPoints [i].y); //p.x &lt; intersect if(p.x &lt; polyPoints [i].x + vt * (polyPoints [i + 1].x - polyPoints [i].x)) ++cn; &#125; &#125; //实际测试发现cn为0的情况即为宣雨松算法中存在的问题 //所以在这里进行屏蔽直接返回false这样就可以让透明区域不再响应 if(cn == 0) return false; //返回true表示在多边形外部否则表示在多边形内部 return cn % 2 == 0;&#125; 这段代码说实话我理解的不是很透彻，而且令人费解的是实际结论和算法结论完全相反，因为按照我现在这样的设计，当cn为偶数时返回为true，此时应该表示该点再多边形外部啊，可是事实上我测试这段代码的时候，它居然是可以正常工作的，即当该方法返回true的时候我的点击确实是在多边形内部，所以这是一段可以正常工作同时让我感到费解的代码，而且当我屏蔽了cn为0的这种情况以后，现在它已经可以完美的工作了 正五边形精灵 同样的，我们这里使用一张正五边形的精灵图片，然后编写下面的代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/* * 基于多边形碰撞器实现的不规则按钮 * 作者：PayneQin * 日期：2016年7月9日 */using UnityEngine;using System.Collections;using UnityEngine.UI;using UnityEngine.EventSystems;public class UnregularButtonWithCollider : MonoBehaviour,IPointerClickHandler&#123; /// &lt;summary&gt; /// 多边形碰撞器 /// &lt;/summary&gt; PolygonCollider2D polygonCollider; void Start() &#123; //获取多边形碰撞器 polygonCollider = transform.GetComponent&lt;PolygonCollider2D&gt;(); &#125; public void OnPointerClick(PointerEventData eventData) &#123; //对2D屏幕坐标系进行转换 Vector2 local; local.x = eventData.position.x - (float)Screen.width / 2.0f; local.y = eventData.position.y - (float)Screen.height / 2.0f; if(ContainsPoint(polygonCollider.points,local)) &#123; Debug.Log (\"这是一个正五边形!\"); &#125; &#125; /// &lt;summary&gt; /// 判断指定点是否在给定的任意多边形内 /// &lt;/summary&gt; bool ContainsPoint(Vector2[] polyPoints,Vector2 p) &#123; //统计射线和多边形交叉次数 int cn = 0; //遍历多边形顶点数组中的每条边 for(int i=0; i&lt;polyPoints.Length-1; i++) &#123; //正常情况下这一步骤可以忽略这里是为了统一坐标系 polyPoints [i].x += transform.GetComponent&lt;RectTransform&gt; ().position.x; polyPoints [i].y += transform.GetComponent&lt;RectTransform&gt; ().position.y; //从当前位置发射向上向下两条射线 if(((polyPoints [i].y &lt;= p.y) &amp;&amp; (polyPoints [i + 1].y &gt; p.y)) || ((polyPoints [i].y &gt; p.y) &amp;&amp; (polyPoints [i + 1].y &lt;= p.y))) &#123; //compute the actual edge-ray intersect x-coordinate float vt = (float)(p.y - polyPoints [i].y) / (polyPoints [i + 1].y - polyPoints [i].y); //p.x &lt; intersect if(p.x &lt; polyPoints [i].x + vt * (polyPoints [i + 1].x - polyPoints [i].x)) ++cn; &#125; &#125; //实际测试发现cn为0的情况即为宣雨松算法中存在的问题 //所以在这里进行屏蔽直接返回false这样就可以让透明区域不再响应 if(cn == 0) return false; //返回true表示在多边形外部否则表示在多边形内部 return cn % 2 == 0; &#125;&#125; 我们可以发现现在它可以正常工作啦！我们必须意识到的一点是，这个方法的空间复杂度为O(n-1)，所以随着多边形顶点数目的增加，这个方法的执行效率会越来越低，如果对不规则精灵的边界没有十分苛刻的要求的话，我的建议是我们使用多边形碰撞器标记出一个相对模糊的边界即可，因为现在我们这个方法主要依靠数学计算，没有涉及到摄像机相关计算，所以宣雨松博客中有朋友指出他的方法仅仅适用于Canvas的模式为Screen-Space Camera这种情况，而我目前这个方法对除了World Space以外都是可以使用的，我最大的疑虑来自对鼠标位置进行转化的时候是否应该使用Screen.width和Screen.height，因为我担心可能会出现屏幕适配这种需求。 演示效果1 精灵像素检测&emsp;&emsp;精灵像素检测这个方案的灵感来自Image组件，我们在MonoDevelop或者Visual Studio中通过”转到定义”这个功能可以获得Image组件的内部细节。我们发现uGUI在处理控件是否被点击的时候，主要是根据IsRaycastLocationValid这个方法的返回值来进行判断的，而这个方法用到的基本原理则是判断指定点对应像素的RGBA数值中的Alpha是否大于某个指定临界值。例如，我们知道半透明通常是指Alpha=0.5，而对一个.png格式的图片来说半透明甚至完全透明的区域理论上不应该被响应的，所以根据这个原理我们只需要设定一个透明度的临界值然后对当前鼠标位置对应的像素进行判断就可以了，因此这种方法叫做精灵像素检测。 &emsp;&emsp;下面我们来一起看这段uGUI的代码，这段代码通过MonoDevelop或者Visual Studio的”转到定义”功能可以找到，这里我做了简单的注释帮助大家理解代码：123456789101112131415161718192021222324252627282930313233343536373839public virtual bool IsRaycastLocationValid(Vector2 screenPoint, Camera eventCamera)&#123; //当透明度&gt;=1.0时，表示点击在可响应区域返回true if(this.m_EventAlphaThreshold &gt;= 1f)&#123; return true; &#125; //当没有指定精灵时为什么要返回true? Sprite overrideSprite = this.overrideSprite; if(overrideSprite == null)&#123; return true; &#125; //坐标系转换 Vector2 local; RectTransformUtility.ScreenPointToLocalPointInRectangle(base.rectTransform, screenPoint, eventCamera, ref local); Rect pixelAdjustedRect = base.GetPixelAdjustedRect (); local.x += base.rectTransform.get_pivot ().x * pixelAdjustedRect.get_width (); local.y += base.rectTransform.get_pivot ().y * pixelAdjustedRect.get_height (); local = this.MapCoordinate(local, pixelAdjustedRect); Rect textureRect = overrideSprite.get_textureRect (); Vector2 vector = new Vector2(local.x / textureRect.get_width (), local.y / textureRect.get_height ()); //计算屏幕坐标对应的UV坐标 float num = Mathf.Lerp(textureRect.get_x (), textureRect.get_xMax (), vector.x) / (float)overrideSprite.get_texture().get_width(); float num2 = Mathf.Lerp(textureRect.get_y (), textureRect.get_yMax (), vector.y) / (float)overrideSprite.get_texture().get_height(); bool result; //核心方法：像素检测 try&#123; result = (overrideSprite.get_texture().GetPixelBilinear(num, num2).a &gt;= this.m_EventAlphaThreshold); &#125;catch(UnityException ex)&#123; Debug.LogError(\"Using clickAlphaThreshold lower than 1 on Image whose sprite texture cannot be read. \" + ex.Message + \" Also make sure to disable sprite packing for this sprite.\", this); result = true; &#125; //返回结果 return result;&#125; 从这段代码中我们可以看出，这个方法核心在第31行代码，即传入一个UV坐标返回一个RGBA数值并将其和临界值相比较。可是在此之前，我们看到在引入uGUI及其专属组件RectTransform以后，现在Unity中的坐标系转换变得更加复杂了，我个人看到这部分代码是相当凌乱的，或许我应该找时间补习下矩阵变换了吧。所以现在我们就有思路啦，我们有两种方式，第一种基于这个思路重新定制一个Image组件;第二种直接修改Image组件的eventAlphaThreshold属性。考虑到坐标系转换这里非常复杂，显然第二种方式更容易接受，为什么这里可以直接修改eventAlphaThreshold属性呢，因为它在Image组件内部和代码中的m_EventAlphaThreshold相关联，这就是这篇文章的完整解释啦！ 圆形精灵图片 &emsp;&emsp;好了，现在我们来一个简单的测试，我们这里准备一张圆形的精灵图片(如上图)，然后编写下面的代码：1234567891011121314151617181920212223242526272829303132333435363738/* * 基于精灵像素检测实现的不规则按钮 * 作者：PayneQin * 日期：2016年7月9日 */using UnityEngine;using System.Collections;using UnityEngine.UI;using UnityEngine.EventSystems;public class UnregularButtonWithPixel : MonoBehaviour,IPointerClickHandler&#123; /// &lt;summary&gt; /// Image组件 /// &lt;/summary&gt; private Image image; /// &lt;summary&gt; /// 透明度临界值 /// &lt;/summary&gt; [Range(0.0f,0.5f)] public float Alpha; public void Start() &#123; //获取Image组件 image = transform.GetComponent&lt;Image&gt;(); //设定透明度临界值 image.eventAlphaThreshold = Alpha; &#125; public void OnPointerClick(PointerEventData eventData) &#123; Debug.Log(\"这是一个圆形!\"); &#125;&#125; 这里我为了让大家在学(复)习(制)的时候更容易理解，我在Click事件的响应上，使用的是实现IPointerClickHandler接口这种方法，希望通过动态绑定这种方式添加事件响应的可以自己解决，我是不会为了满足你们的好(懒)奇(惰)而奉献出我的EventTriggerListener的代码的。好了，现在我们要做的就是为需要响应点击的不规则精灵附加该脚本，这样就可以解决不规则精灵响应的问题了。这种方法使用起来非常简单，需要注意的是：图片的类型必须是Advance且保证可读可写。因为我们在脚本中访问了像素，而简单伴随着的代价就是我们无法使用图集、该图片在内存中会复制一份，所以在项目性能上允许的情况下这种方法还是可以考虑使用的。 演示效果2 小结&emsp;&emsp;本文通过对网络上两种比较通用的不规则按钮制作方案进行对比和研究，解决了基于多边形碰撞器实现不规则按钮这个过程中存在的问题，剖析了基于精灵像素检测实现不规则按钮 这个过程的内部原理，从易用性角度来讲，后者要优于前者，而这种方法的缺陷主要来自于它对图片类型的限制以及允许像素可读写这两个方面，它必须是Advance类型，所以普通的Texture或者Sprite拥有的特性在这里它都无法享受，比如我们无法为其做颜色渐变这类Tween动画、无法使用精灵特有的图集特性等等，于此同时它必须允许像素可读写，因此在实际使用中它会在内存中复制一份，在执行效率上可能会受到影响。而从技术性角度来讲，我个人更推推崇前者，因为在这个过程中我们学到了新的知识，明白了如何利用一个算法来解决实际的问题，而且它不会限制我们对精灵的使用，所有精灵拥有的特性在这里我们都可以使用，无非是在寻找算法、解决问题的过程中我们耗费了大量精力，可是这是值得的啊，不是吗？这就是我们做这件事情的意义所在。从昨天开始研究这两个问题到今天写完整篇文章，整个人是非常疲惫的，欢迎大家继续关注我的博客，今天的内容就是这样啦，谢谢大家！","tags":[{"name":"Unity3D","slug":"Unity3D","permalink":"http://qinyuanpei.github.io/tags/Unity3D/"},{"name":"游戏开发","slug":"游戏开发","permalink":"http://qinyuanpei.github.io/tags/游戏开发/"},{"name":"uGUI","slug":"uGUI","permalink":"http://qinyuanpei.github.io/tags/uGUI/"}]},{"title":"使用C#开发HTTP服务器系列之更简单的实现方式","date":"2016-06-11T15:01:35.000Z","path":"posts/3603924376/","text":"&emsp;&emsp;各位朋友大家好，我是秦元培，欢迎大家关注我的博客，我的博客地址是http://qinyuanpei.com。到目前为止，我已经发布了3篇HTTP服务器开发的系列文章。对我个人而言，我非常享受这个从无到有的过程，或许我现在写的这个Web服务器有各种不完美的因素，可是当有一天我需要一个轻量级的服务器的时候，我在无形中是不是比别人多了一种选择呢？我们常常提到“不要重复造轮子”，可事实上这并不能成为我们“不造轮子”的理由，虽然我们有各种各样的服务器软件、有各种各样的服务端框架可以供我们选择，可是在动手写这个系列文章前，我对Web服务器的印象无非是因为我是用LAWP(Linux + Apache + MySQL + PHP)搭建过Wordpress博客而已。虽然在对动态页面(如.aspx、.jsp、.php等)的处理上，可能会和静态页面有所不同，但是我庆幸我了解了这个过程以及它的内部原理，这种跨语言、跨平台的设计思路是任何框架或者标准都无法告诉我的。或许有人会问我，为什么不在最开始的时候就选择更简单的实现方法，那么在这篇文章中你将会找到答案。 从原理说起&emsp;&emsp;我们知道HTTP服务器其实是一个“服务端循环监听客户端请求然后响应客户端请求”的请求/响应模型，在这个模型中请求通常是由浏览器来发起的，而服务端负责响应客户端的请求。这是我们通常意义上的认识，可是当我们了解到HTTP协议的实质以后就会明白，不管是客户端还是服务端，从本质上来讲都是Socket通信，只要我们能够发送符合HTTP协议规范的报文就可以啦。 &emsp;&emsp;所以我们立刻就能够想到无论是Unity引擎中的WWW还是.NET平台下的WebClient，它们之所以能够向服务器发起请求，无一例外地是它们都遵循了HTTP协议的规范。从这个角度来讲，人类社会存在各种各样的问题，本质上都是存在游离于规范以外的不公平的现象。还记得我们在这个系列中提到的请求报文和响应报文的结构是什么样的吗？此时此刻我们发自内心地向创造HTTP协议的先驱们致敬，因为这个协议我们构建起了连接人与人的社交网络，可是同样因为这个协议我们和人越来越远、和手机越来越近。 &emsp;&emsp;HTTP协议是一种无状态的应用层协议，这个无状态该怎么理解呢？我这里想借助聊天机器人这个实例来解释这个问题，我们都知道聊天机器人是一种问答型的程序，程序每次都可以根据提问者的问题给出，一个从人类角度来看完全合理的答案。然而从目前我了解到的聊天机器人的技术现状来看，具备自然语言理解的机器人程序基本没有，所以在这样的大背景下，机器人程序实际上是没有上下文理解的能力的。 &emsp;&emsp;好了，现在我们回到HTTP协议，首先聊天机器人的问答模式是不是和HTTP协议中的请求/响应模式非常相似呢？其次，我们在设计HTTP服务器的时候，每次在向客户端返回响应报文以后，我们就关闭了Socket连接，这意味着每次的请求和响应完全都是独立的，那么这样是不是就和聊天机器人不能理解上下文非常相似了呢？所以综合下来，我们理解的无状态其实就是说HTTP请求和响应完全独立，即在客户端中不会存储服务端的响应，在服务端中同样不会存储客户端的请求。 &emsp;&emsp;这样难免引发一个问题，如果我需要在不同请求和响应中保持状态该怎么做呢？这个在不同的服务器软件中有不同的技术实现，这里我们说一种最通用的Cookie。Cookie是存储在客户端中的一个数据，在发起下一轮请求时这个参数会被加入到参数列表中然后传递给服务器，服务器会对客户端传递的参数进行验证，以此来判断本轮请求和上轮请求间是否存在上下文联系。 两种不同的实现&emsp;&emsp;到目前为止我们了解的HTTP服务器开发，实际上由两部分组成，即Socket通信和请求-响应模型。基于这两点考虑，我们这里提供两种快速实现Web服务器的具体思路，这是在我们理解了HTTP协议实质以后，从原理出发想到的解决方案，为什么我不建议在刚开始就学习这些东西呢？因为我觉得学习有时候其实就是一个不断开阔视野和思路的过程吧。好了，下面我们来说说这两种不同实现方式的具体思路吧！ 基于TcpListener/TcpClienr改进Socket&emsp;&emsp;如果说使用Socket从头开始编写HTTP服务器是一个“刀耕火种”时代的缩影，那么使用TcpListener/TcpClient则是让我们开始进入“青铜铸犁”的农耕时代。和Sokcet相比，TcpListener/TcpClient是.NET对Socket的进一步封装，在这个体系下，TcpListener负责监听和接收传入的连接请求，在该类中仅需要传入一个网络终端信息就可以完成服务端的初始化，而无需设置网络通信协议等细节性的内容。调用Start方法后即可以开始监听，这里我们使用AcceptTcpClient方法来阻塞进程直到接受到一个客户端请求为止，该方法将返回一个TcpClient对象，我们可以借助它完成和客户端的通信。下面我们来一起看基本的代码实现：123456789101112131415161718192021222324252627282930public void Start()&#123; if(isRunning) return; //创建TcpListener serverListener = new TcpListener(IPAddress.Parse(ServerIP), ServerPort); //开始监听 serverListener.Start(10); isRunning = true; //输出服务器状态 Console.WriteLine(\"Sever is running at http://&#123;0&#125;:&#123;1&#125;/.\", ServerIP, ServerPort); while(isRunning) &#123; //获取客户端连接 TcpClient acceptClient = serverListener.AcceptTcpClient(); //获取请求报文 NetworkStream netstream = acceptClient.GetStream(); //解析请求报文 byte[] bytes = new byte[1024]; int length = netstream.Read(bytes, 0, bytes.Length); string requestString = Encoding.UTF8.GetString(bytes, 0, length); //以下为响应报文(略) &#125;&#125; 我个人感觉这种形式和原生的Socket在实现上区别不是非常大，按照这种思路继续往下设计，我的HttpRequest和HttpResponse可能都需要进行改进，因为在我的设计中，我是在尽可能地隐藏Socket通信的细节，因为我不想让使用者觉察到他这是在使用Socket进行通信，这里细心的朋友可能会发现，这里的TcpListener/TcpClient都保留了常见的Socket用法如同步通信和异步通信的支持等，所以在使用cpListener/TcpClient其实没有必要纠结它的这套流程，如果你喜欢继续使用Socket通信的经验和方法就可以了。这里我们仅提供一种延伸思路。具体的代码实现大家顺着这个思路继续下去就好啦。 基于HttpListener实现请求-响应模型&emsp;&emsp;下面我们再来说说基于HttpListener实现请求-响应模型，它和改进Socket不同，它对我们编写一个Web服务器的意义主要体现在它提供了一个非常规范的接口，类似我这里的HttpResponse和HttpRequest以及OnPost、OnGet等接口这些设计。这个让我不喜欢的一点是它在设置服务器IP地址和端口的时候非常别扭，其思路和我的设计是非常相似的，下面我们来一起看代码： 1234567891011121314151617181920212223242526272829303132public void Listen()&#123; if(!HttpListener.IsSupported) throw new InvalidOperationException( \"请确保使用WindowsXP以上版本的Windows!\"); //初始化Http监听器 listener = new HttpListener(); //初始化服务器URL string[] prefixes = new string[] &#123; address &#125;; foreach(string prefix in prefixes) &#123; listener.Prefixes.Add(prefix); &#125; //开启服务器 listener.Start(); //监听服务器 while(isActive) &#123; HttpListenerContext context = listener.GetContext(); HttpListenerRequest request = context.Request; HttpListenerResponse response = context.Response; if(request.HttpMethod == \"GET\")&#123; OnGetRequest(request, response); &#125;else&#123; OnPostRequest(request, response); &#125; &#125;&#125; 好了，现在这个东西就非常简单了，因为我们只需要继承HttpServerBase这个类然后重写相关方法就可以了，而请求报文和响应报文中的相关属性都在HttpListenerRequest和HttpListenerResponse这两个类中封装好了，我们直接使用就好了。在没有写这个系列文章前，可能我会对这种方案充满好奇，可是当我了解到这一切的实质以后，我反而更加喜欢使用我设计的HTTP服务器了，因为这些东西在我看来区别真的可以忽略。 One More Thing&emsp;&emsp;关于今天本文中提到的两种方案，我都是作为HTTP服务器开发延伸出来的内容来写出来给大家看,所以这块儿内容我都是点到为止不打算给出完整的实现，如果有兴趣的朋友可以顺着我这个思路区继续改进。这个系列文章中的示例代码主要来自我的项目HttpServer，大家到我的GIthub上去了解更多细节。到目前为止我觉得HTTP服务器快发这块儿我能写的内容都基本上写完了，因为是一边写代码一边写博客，所以有时候博客中如果有写得不好或者写的不明白的地方，希望大家能够谅解，同时希望大家在博客中给我积极留言，下一篇我想简单写一下RESTful API的相关问题，写完这一篇整个系列就结束了，我还是想说写文章真的很累啊，希望大家继续支持，下期见。","tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://qinyuanpei.github.io/tags/HTTP/"},{"name":"服务器","slug":"服务器","permalink":"http://qinyuanpei.github.io/tags/服务器/"},{"name":"C#","slug":"C","permalink":"http://qinyuanpei.github.io/tags/C/"}]},{"title":"使用C#开发HTTP服务器系列之构建RESTful API","date":"2016-06-11T15:01:35.000Z","path":"posts/3637847962/","text":"&emsp;&emsp;各位朋友大家好，我是秦元培，欢迎大家关注我的博客，我的博客地址是http://qinyuanpei.com。到目前为止，“使用C#开发HTTP服务器”这个系列系列文章目前已经接近尾声了，虽然我们在服务器功能的完整性(如支持并发、缓存、异步、Htts等)上没有再继续深入下去，可是我们现在已经具备了一个基本的服务器框架啦，所以更多深层次的问题就需要大家根据自己的需要来扩展了，因为写博客更多的是一种“记录-输出-反馈”的一个过程，所以我更希望大家在看完我的博客后能对我有所反馈，因为抄博客上的代码实在是太无聊啦！好了，保持愉悦的心情我们下面来引出今天的话题：构建RESTful API。RESTful API，这个概念或许你曾经听说过，可能它和我们所熟悉的各种Web息息相关，甚至在某种意义上来讲它并不是一种新的技术，而这一切的一切归根到底都是在问一个问题，即网站真的是Web的唯一形态吗？ 什么是RESTful API&emsp;&emsp;什么是RESTful API?首先，REST即REpresentational State Transfer，通常被翻译为“表述性状态传输”或者“表述性状态转移”，它最早出自Roy Fielding的《Archltectural Styles and the Design of Network-based Software Arcltechures》这篇论文，作者曾经参与HTTP协议和Apache Web Server的设计，所以REST实际上是一个和HTTP协议联系非常紧密的一种设计思想。而从这个题目中我们可以找到三个关键词： 架构样式——(Archltectural Styles) 软件架构——(Software Arcltechures) 网络为基础——(Network-based) 所以从我个人角度来理解REST，我更倾向于将REST理解为一种以网络为基础的设计风格，因此REST从本质上来讲解决的是如何正确地使用Web标准的问题。 &emsp;&emsp;以国内为例，当Google的Chrome浏览器选择以Chormium这种形式开源以后，国内厂商纷纷表示跟进以双核为主要特点进行了新一轮的互联网入口争夺战，虽然从技术角度来讲这让Chorme浏览器更加流行，可我们更应该注意到不同的厂商纷纷建立起自己的护城河，以牺牲Web的统一性和标准性来满足其商业竞争的需要，所以我们看到了即使在HTML5定稿以后，在不同浏览器对HTML5的支持区别依然非常大。微信带动了大量可以在朋友圈内流传的“H5”媒介，可是这个东西从来就不是HTML5，而微信内置的QQ浏览器内核更是以各种不兼容让开发者为此殚精竭虑，所以你问我REST是什么的时候，我会回答它是一种风格上统一的Web API，而根据百科中的描述REST通常被这样定义： REST是一组架构约束条件和原则，而满足这些约束条件和原则的应用程序就是RESTful。 REST的目标是构建可扩展的Web Service，它是一种更简单的SOAP协议以及以WSDL为基础的WebService的替代。 REST采用的是HTTP协议并通过HTTP中的GET、POST、PUT、DELETE等动词收发数据。 REST希望通过HTTP来完成对数据的元操作，即传统的CRUD(Create、Read、Update、Delete)分别对应GET、POST、PUT、DELETE，这样就统一了数据操作的接口，实现在不同平台上提供一套相同的服务。 REST是一种面向服务的、分布式的API设计风格。 从WebService看REST&emsp;&emsp;在这里我们提到了SOAP、WSDL、RPC等概念，这是因为从某种意义上来讲，REST是这些概念的一种延伸。以我们熟悉的WebService为例，当我们需要从网络上获取天气预报信息时，我们可以采取两种思路，第一种是通过抓包分析相关天气预报网站来获取信息，第二种是通过调用互联网上提供的WebService来获得信息。虽然这两种方法在技术上具有相似性和可行性，可是我觉得对开发者来讲，除了技术层面的突破以外在道德层面的坚守更为重要，我们说”人无德不立，国无德不兴”正是如此，所以我们这里强烈推荐第二种思路。WebService能够让我们像调用一个方法一样获取信息，那么对我们来讲WebService到底是什么呢？ &emsp;&emsp;WebService首先是一种服务，它不需要客户端提供额外的软件支持，只要客户端支持HTTP协议和XML这样两个特性就可以了。而对WebService自身来讲，它本身就是一种自我描述型的设计，所以服务端和客户端可以通过它来了解响应和请求的内容及格式，因为XML是一种平台无关、语言无关的文档结构，所以WebService是一种可以跨平台的Web API。WebService能够让客户端像调用本地代码一样调用服务端代码，所以WebService是一种分布式计算的Web应用程序组件。我们对WebService下了如此多的定义，其实核心是什么呢？核心是WebService是一种基于HTTP协议和XML的Web API。 &emsp;&emsp;好了，现在我们再来说说什么是SOAP和WSDL。事实上，这些概念听起来都非常地学术，可是我保证这对我们理解REST会有所帮助。首先，SOAP即简单访问对象协议(Simple Object Access Protocol)，听起来感觉非常高大上吗？然而这是一个“唯一没有发明任何新技术的技术”。因为它是一个访问Web服务的协议，如同HTTP协议定义了访问Web的协议一样，SOAP在HTTP协议的基础上，采用XML定义了消息协议，所以SOAP本质上是使用XML进行通信的HTTP协议，这样听起来是不是非常熟悉啦，因为我们熟悉的AJAX同样是采用XML进行通信，所不同的是AJAX是运行在浏览器中的且其主要目的是实现页面的无刷新更新。需要说明的是，虽然SOAP的基础HTTP协议是基于TCP/IP协议的，可是SOAP是具有穿透防火墙的能力的，对此有兴趣的朋友可以自行了解，我们这里因为篇幅有限所以就不做详细说明啦！ &emsp;&emsp;接下来，WSDL即Web服务描述语言(Web Service Description Language)，我对它的理解是提供了一个WebService的文档，因为从定义可以看出，它是一个基于XML的用于描述Web服务以及如何访问Web服务的语言，Web服务提供者通过它可以告知使用者当前Web服务访问的规范和说明，而Web使用者通过它可以在满足平台无关性和语言无关性的情况下快速进行开发，所以综合下来看，WebService和REST都能为我们提供类似地服务需求，关于两者或者说REST能为我们带来哪些不一样的体验，我们将在本文的第二部分说明。 从WCF看REST&emsp;&emsp;我觉得对技术而言，我们每个人都应该试图去发现技术背后真正美的东西，就像我们在了解了WebService，并发现它和REST从本质上来讲都是一个东西的时候，这个时候我们应该直接去了解REST给我们带来了哪些不一样的东西。可是事实上因为开发者使用的平台和语言的多样性，让开发者再这个过程中不得不去对平台或者语言造成依赖，而当每个厂商都试图建立一套自己的标准或者框架的时候，它对开发者造成的这种依赖感就越发地强烈。虽然我目前的工作是做.NET开发，可是事实上我最喜欢的只有微软的C#语言而已。这里我们简单介绍下WCF，WCF即Windows Communication Foundation是由微软发展的一组数据通信的应用程序开发接口，它是.NET框架的一部分，从.NET Framework 3.0开始引入，其设计目标是整合不同进程的通信、不同系统间的通信、C/S架构通信等等通信目标，所以对.NET开发者而言它是一个“全家桶”般的存在，我们到底需要“小而美”还是“大而全”，这是一个问题。 &emsp;&emsp;回到我们关注本身，WCF整合了Web服务、.NET Remoting、消息队列和Enterprise Services的功能并将其整合在Visual Studio中，显然对我们而言，我们关注的核心依然在Web服务。首先，我们要明确的是WebService这个是行业标准，即WebService规范，这是一个和平台、和语言无关的标准，而微软的ASP.NET WebService是ASP.NET框架的组成部分，我不喜欢ASP.NET的一个原因就是我们常常认为网站是Web技术的核心而Web服务不是，更离谱的是我们认为开发一个Web服务器或者一个WebService一定要采用XXX框架，虽然使用Web框架、写业务代码都是技术能力的一种体现，可是不求甚解真的无法让我安心。那么WCF呢？其实WCF本质上是将ASP.NET WebService和微软的相关技术如Enterprise Services(COM+)、.NET Remoting、MSMQ消息队列等进行了整合，为什么要整合在一起呢？因为从宏观上来讲，跨进程、跨机器、跨网络都属于通信的范畴，所以我们现在回过头来看，这些东西玩来玩去有什么稀奇，归根到底还不是HTTP协议啊，我们追求新的技术并没有错，错误的是我们将希望寄托在技术本身，而不是我们自己。 让REST理解起来简单点&emsp;&emsp;我们从最初接触到REST的云里雾里，到翻来覆去地讲述WebService，其实我的目的只有一个，那就是告诉大家，Web技术发展到今天，从本质上来将变化并没有太大，可是为什么我们会看到前端领域每隔一段时间就会有新的框架产生呢？回答这个问题非常简单，所有的框架的提出都是因为某种业务的背景需要，而所有的业务无一不是因为人类增加了其复杂性，所以当你下来看待这一切的时候，你发现从WebService到REST其实变化都是非常细微的东西，与其在新技术里疲于奔命不如静下心来学习好HTML、CSS和JavaScript，虽然JavaScript是一个垃圾的语言，可是有时候它会让我们这些后端程序开发者都懵逼呢，哈哈，所以现在是时候给REST一个简单的定义： REST是一种使用URL来定位资源，使用HTTP请求描述操作的Web服务规范。 REST的约束条件和原则&emsp;&emsp;我们说REST本质上是Web服务的一种规范，一种思想，所以单独来说REST是没有意义的，这意味着，如果我们要深入了解REST，就需要了解它的约束条件和原则，下面我们就来说说这个问题。 资源(Resources)&emsp;&emsp;在REST中资源是整个架构或者说整个网络处理的核心，那么什么是资源呢？在我们传统的观念中，资源是指服务器上的一个文件，而在REST里资源则是指一个URL。URL即统一资源定位，而我们都知道通过URL可以访问互联网上的资源，所以在REST里这种对资源的指向性更加强烈，并且在这里资源的范畴会被无限放大而并非局限在文件本身，例如： 123http://api.qc.com/v1/feed 表示获取某人的最新Feedhttp://api.qc.com/v1/friends 表示获取某人的好友列表http://api.qc.com/v1/profile 表示获取某人的详细信息 由此我们注意到REST在形式上更加趋向API设计，而我们获取的资源则通过一定的形式进行统一而规范化的表达，因此REST实现了让不同的平台共享一套API这样的愿望，这是一件非常美好的事情，这个世界上的技术阵营举不胜数，而它们为了各自的利益建立一套封闭、臃肿的体系框架，很多时候当我们不需要这样的“全家桶”并且希望“跨平台”的时候，REST将会是一个不错的选择。 表现形式(Representational)&emsp;&emsp;在REST中表现形式作为我们对资源请求的一个结果的呈现，通过对HTTP协议的学习我们已经知道，服务器会给客户端返回什么形式的信息，这一点取决于服务器响应报文中相关头部字段，而对REST来讲，它通常会采用XML或者JSON来告诉请求者请求的结果，因为JSON相比XML所含的冗余信息较少，所以目前更加倾向于或者说流行使用JSON作为请求结果的表现形式。 ##状态变化(State Transfer)&emsp;&emsp;虽然我们一再强调HTTP协议是无状态，这主要体现在HTTP请求与请求、HTTP响应与响应的上下文无关性上。在REST中，我们所说状态变化更多是指HTTP中的GET、POST、DELETE等动词实现。具体来讲，虽然这一点我们在前面有所提及我们来看下面的简单示例： 12345GET http://someurl/tasks 表示获取全部的tasksPOST http://someurl/tasks 表示创建一个新的taskGET http://someurl/tasks/&#123;id&#125; 表示获取一个指定id的taskPET http://someurl/tasks/&#123;id&#125; 表示更新一个指定id的taskDELETE http://someurl/tasks/&#123;id&#125; 表示删除一个指定id的task 除此之外，我们注意到REST基于HTTP协议，所以HTTP协议中的状态码对它来讲同样适用，例如最常用的200表示成功、500表示服务器内部错误、404表示无法找到请求资源等等。 如何构建REST风格的API&emsp;&emsp;如何构建REST风格的API?这是这篇文章的最后一个问题，相信大家在阅读这篇文章的时候会感到疲惫吧，我想说写作者的疲惫不一定会比阅读者的疲惫要轻，现在到了这篇文章里最难的部分啦，这可比我们花费大量篇幅来讲什么是REST要更有意义，这是真正的说起来容易做起来难，在正式开始实践以前，我们首先提出下面的最佳实践： URLRoot采用下面这样的结构： 12http://example.com/api/v1/http://api.example.com/v1/ API版本可以放在URL或者HTTP的Header里 URL使用名词而非动词： 12http://example.com/api/v1/getProducts 这是一个糟糕的设计GET http://example.com/api/v1/products 这是一个优雅的设计 保证方法时安全的不会对资源状态有所改变。例如： 1GET http://example.com/api/v1/deleteProduct?id=1 这是一个危险的信号 资源的地址推荐使用嵌套结构 1GET http://example.com/api/v1/friends/10375923/profile 使用正确的HTTP状态码表示访问状态 返回含义明确的结果(这是我为什么推荐使用JSON的理由) &emsp;&emsp;好了，这篇文章我目前能够理解并输出给大家的只有这些啦，关于具体在Web开发中我们如何去实现RESTful API，这个我觉得并没有一个固定的方法吧，而且我现在编写的这个服务器只支持Get和Post两种类型，如果要实现一个完整的RESTful API架构，还需要很长的时间去探索，这篇文章写得我的确有些疲惫，所以有不周的地方希望大家谅解，后续更新关注我的项目HttpServer就好啦，谢谢大家！","tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://qinyuanpei.github.io/tags/HTTP/"},{"name":"服务器","slug":"服务器","permalink":"http://qinyuanpei.github.io/tags/服务器/"},{"name":"C#","slug":"C","permalink":"http://qinyuanpei.github.io/tags/C/"}]},{"title":"使用C#开发HTTP服务器系列之静态页面","date":"2016-06-11T15:01:35.000Z","path":"posts/3695777215/","text":"&emsp;&emsp;各位朋友大家好，我是秦元培，欢迎大家关注我的博客，我的博客地址是http://qinyuanpei.com。在这个系列文章的第一篇中，我们着重认识和了解了HTTP协议，并在此基础上实现了一个可交互的Web服务器，即当客户端访问该服务器的时候，服务器能够返回并输出一个简单的“Hello World”。现在这个服务器看起来非常简陋，为此我们需要在这个基础上继续开展工作。今天我们希望为这个服务器增加主页支持，即当我们访问这个服务器的时候，它可以向我们展示一个定制化的服务器主页。通常情况下网站的主页被定义为index.html，而在动态网站技术中它可以被定义为index.php。了解这些将有助于帮助我们认识Web技术的实质，为了方便我们这里的研究，我们以最简单的静态页面为例。 大意失荆州&emsp;&emsp;首先我们可以认识到的一点是，网站主页是一个网站默认展示给访问者的页面，所以对服务器而言，它需要知道两件事情，第一客户端当前请求的这个页面是不是主页，第二服务端应该返回什么内容给客户端。对这两个问题，我们在目前设计的这个Web服务器中都可以找到答案的。因为HTTP协议中默认的请求方法是GET，所以根据HttpRequest的实例我们可以非常容易的知道，当前请求的方法类型以及请求地址。我们来看一个简单的客户端请求报文：1234567GET / HTTP/1.1Accept: text/html, application/xhtml+xml, image/jxr, */*Accept-Language: zh-Hans-CN,zh-Hans;q=0.5User-Agent: Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Safari/537.36 Edge/13.10586Accept-Encoding: gzip, deflateHost: localhost:4040Connection: Keep-Alive 我们在这里可以非常清晰地看到，客户端当前发出的请求是GET类型，而其请求的地址是”/“，这表示请求页面为主页，而实际上我们将Host字段和这个地址组合起来，就能得到一个完整的地址，这正是我们在HTML结构中编写超链接的时候使用相对地址的原因。好了，在明白了这样两件事情具体的运作机理以后，下面我们来继续编写相关逻辑来实现如何向访问者展示一个网站主页。12345678910111213141516171819202122232425public override void OnGet(HttpRequest request)&#123; //判断请求类型和请求页面 if(request.Method == \"GET\" &amp;&amp; request.URL == \"/\") &#123; //构造响应报文 HttpResponse response; //判断主页文件是否存在，如存在则读取主页文件否则返回404 if(!File.Exists(ServerRoot + \"index.html\"))&#123; response = new HttpResponse(\"&lt;html&gt;&lt;body&gt;&lt;h1&gt;404 - Not Found&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;\", Encoding.UTF8); response.StatusCode = \"404\"; response.Content_Type = \"text/html\"; response.Server = \"ExampleServer\"; &#125;else&#123; response = new HttpResponse(File.ReadAllBytes(ServerRoot + \"index.html\"), Encoding.UTF8); response.StatusCode = \"200\"; response.Content_Type = \"text/html\"; response.Server = \"ExampleServer\"; &#125; //发送响应 ProcessResponse(request.Handler, response); &#125;&#125; 可以注意到在这里我们首先根据请求方法和请求地址来判断当前客户端是否在请求主页页面，然后我们判断在服务器目录下是否存在index.html文件，如果该文件存在就读取文件并返回给客户端，否则我们将返回给客户端一个404的状态，熟悉Web开发的朋友应该会知道这个状态码表示的是无法找到请求资源，类似地我们还可以想到的状态码有200、501等等，通常来讲，这些状态码的定义是这样的： 1XX：指示信息-表示请求已接收，继续处理。 2XX：成功-表示请求已被成功接受、理解和处理。 3XX: 重定向-表示完成请求需要更进一步的操作。 4XX：客户端错误-表示请求错误或者无法实现。 5XX：服务端错误-表示服务器未提供正确的响应。 具体来讲，常见的状态代码描述如下： 状态码 状态描述 200 OK 客户端请求成功 400 Bad Request 客户端请求错误且不能被服务器所理解 401 Unauthorized 请求未经授权需要使用WWW-Authenticate报头域 403 Forbidden 服务器收到请求但拒绝提供服务 404 Not Found 请求资源不存在 500 Internal Server Error 服务器发生不可预期的错误 503 Server Unavailable 服务器当前不能处理客户端的请求 为了简化需求，我们这里假设服务器目录下只有一个主页文件index.html，实际上像IIS、Apache等大型的服务器软件都是支持多个主页文件的，而且同时支持静态页面和动态页面，所以这里就涉及到一个优先级的问题，无论是在Apache还是IIS中我们可以找到对主页优先级设置的选项。所谓优先级，其实就是对这些主页文件重要性的一种排序，在实际设计的过程中，会优先读取优先级较高的主页文件，如该文件不存在则退而求其次，以此类推。在读取主页文件的时候，我们需要注意的一点是编码类型，因为无论是客户端还是服务端在其各自的头部信息里都声明了它可以接受的编码类型，所以服务器端在响应请求的时候应该注意和客户端保持一致，这样可以避免“鸡同鸭讲”问题的发生，进而提高沟通效率。我们这里在说技术，可是人何尝不是这样啊，我感觉我们生活和工作中90%的时间都被用来沟通了，可是这恰恰说明了沟通的重要性啊。好了，下面我们来测试下我们编写的主页： 一个失败的尝试 龙潜在渊&emsp;&emsp;咦？这个页面显示的结果怎么和我们期望的不一样啊，看起来这是一个因为样式丢失而引发的错误啊，不仅如此我们发现页面中的图片同样丢失了。首先我们检查下静态页面是否有问题，这个怎么可能嘛？因为这是博主采用Hexo生成的静态页面，所以排除页面本身的问题后，我们不得不开始重新思考我们的设计。我们静下心来思考这样一个问题：在浏览器加载一个页面的过程中难道只有静态页面和服务器发生交互吗？这显然不是啊，因为傻子都知道一个网页最起码有HTML、CSS和JavaScript三部分组成，所以我们决定在Chrome中仔细看看浏览器在加载网页的过程中都发生了什么。按下”F12”打开开发者工具对网页进行监听： 浏览器的小秘密 &emsp;&emsp;WTF！感觉在这里懵逼了是不是？你没有想到服务器在这里会响应如此多的请求吧？所以我们自作聪明地认为只要响应静态页面的请求就好了，这完全就是在作死啊！这里我的理解是这样的，对页面来讲服务器在读取它以后会返回给客户端，所以对客户端而言这部分响应是完全可见的，而页面中关联的CSS样式和JavaScript脚本则可能是通过浏览器缓存下载到本地，然后再根据相对路径引用并应用到整个页面中来的，而为了区分这些不同类型的资源，我们需要在响应报文中的Content-Type字段中指明内容的类型，所以现在我们就清楚了，首先在请求页面的时候存在大量关联资源，这些资源必须通过响应报文反馈给客户端，其次这些资源由不同的类型具体体现在响应报文的Content-Type字段中。因此，我们在第一段代码的基础上进行修改和完善，最终编写出了下面的代码：12345678910111213141516171819202122232425262728293031323334public override void OnGet(HttpRequest request)&#123; if(request.Method == \"GET\") &#123; ///获取客户端请求地址 ///链接形式1:\"http://localhost:4050/assets/styles/style.css\"表示访问指定文件资源， ///此时读取服务器目录下的/assets/styles/style.css文件。 ///链接形式2:\"http://localhost:4050/assets/styles/\"表示访问指定页面资源， ///此时读取服务器目录下的/assets/styles/style.index文件。 //当文件不存在时应返回404状态码 string requestURL = request.URL; requestURL = requestURL.Replace(\"/\", @\"\\\").Replace(\"\\\\..\", \"\"); //判断地址中是否存在扩展名 string extension = Path.GetExtension(requestURL); //根据有无扩展名按照两种不同链接进行处 string requestFile = string.Empty; if(extension != \"\")&#123; requestFile = ServerRoot + requestURL; &#125;else&#123; requestFile = ServerRoot + requestURL + \"index.html\"; &#125; //构造HTTP响应 HttpResponse response = ResponseWithFile(requestFile); //发送响应 ProcessResponse(request.Handler, response); &#125;&#125; 注意到我在代码中写了两种不同形式的链接的分析： 链接形式1:”http://localhost:4050/assets/styles/style.css&quot;表示访问指定文件资源，此时读取服务器目录下的/assets/styles/style.css文件。 链接形式2:”http://localhost:4050/assets/styles/&quot;表示访问指定页面资源，此时读取服务器目录下的/assets/styles/style.index文件。 &emsp;&emsp;首先我们判断这两种形式是根据扩展名来判断的，这样我们可以获得一个指向目标文件的地址requestFile。这里提供一个辅助方法ResponseWithFile，这是一个从文件中构造响应报文的方法，其返回类型是一个HttpResponse，当文件不存在时将返回给客户端404的错误代码，我们一起来看它具体如何实现： 12345678910111213141516171819202122232425262728293031/// &lt;summary&gt;/// 使用文件来提供HTTP响应/// &lt;/summary&gt;/// &lt;param name=\"fileName\"&gt;文件名&lt;/param&gt;private HttpResponse ResponseWithFile(string fileName)&#123; //准备HTTP响应报文 HttpResponse response; //获取文件扩展名以判断内容类型 string extension = Path.GetExtension(fileName); //获取当前内容类型 string contentType = GetContentType(extension); //如果文件不存在则返回404否则读取文件内容 if(!File.Exists(fileName))&#123; response = new HttpResponse(\"&lt;html&gt;&lt;body&gt;&lt;h1&gt;404 - Not Found&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;\", Encoding.UTF8); response.StatusCode = \"404\"; response.Content_Type = \"text/html\"; response.Server = \"ExampleServer\"; &#125;else&#123; response = new HttpResponse(File.ReadAllBytes(fileName), Encoding.UTF8); response.StatusCode = \"200\"; response.Content_Type = contentType; response.Server = \"ExampleServer\"; &#125; /返回数据 return response;&#125; 同样的，因为在响应报文中我们需要指明资源的类型，所以这里使用一个叫做GetContentType的辅助方法，该方法定义如下，这里仅仅选择了常见的Content-Type类型来实现，有兴趣的朋友可以自行了解更多的内容并在此基础上进行扩展：1234567891011121314151617181920212223242526272829303132333435363738394041424344/// &lt;summary&gt;/// 根据文件扩展名获取内容类型/// &lt;/summary&gt;/// &lt;param name=\"extension\"&gt;文件扩展名&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;protected string GetContentType(string extension)&#123; string reval = string.Empty; if(string.IsNullOrEmpty(extension)) return null; switch(extension) &#123; case \".htm\": reval = \"text/html\"; break; case \".html\": reval = \"text/html\"; break; case \".txt\": reval = \"text/plain\"; break; case \".css\": reval = \"text/css\"; break; case \".png\": reval = \"image/png\"; break; case \".gif\": reval = \"image/gif\"; break; case \".jpg\": reval = \"image/jpg\"; break; case \".jpeg\": reval = \"image/jgeg\"; break; case \".zip\": reval = \"application/zip\"; break; &#125; return reval;&#125; 风雨过后终见彩虹&emsp;&emsp;好啦，到目前为止，关于静态Web服务器的编写我们基本上告一段落啦！其实这篇文章写的不是特别顺利，因为我几乎是在不断否认自我的情况下，一边调试一边写这篇文章的。整篇文章总结下来其实就两个点，第一，Web服务器在加载一个页面的时候会发起无数个请求报文，除了页面相关的请求报文以外大部分都是和资源相关的请求，所以HTML页面的优化实际上就是从资源加载这个地方入手的。第二，不同的资源有不同的类型，具体表现在响应报文的Content-Type字段上，构造正确的Content-Type能让客户端了解到这是一个什么资源。好了，现在我们可以气定神闲的验证我们的劳动成果啦，这里我以我本地的Hexo生成的静态博客为例演示我的Web服务器，假设我的博客是存放在”D:\\Hexo\\public”这个路径下，所以我可以直接在Web服务器中设置我的服务器目录：123ExampleServer server = new ExampleServer(\"127.0.0.1\",4050);server.SetServerRoot(\"D:\\\\Hexo\\\\public\");server.Start(); 现在打开浏览器就可以看到： Web服务器运行效果 如此激动人心的时候，让我们踏歌长行、梦想永续，下期见！","tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://qinyuanpei.github.io/tags/HTTP/"},{"name":"服务器","slug":"服务器","permalink":"http://qinyuanpei.github.io/tags/服务器/"},{"name":"C#","slug":"C","permalink":"http://qinyuanpei.github.io/tags/C/"}]},{"title":"使用C#开发HTTP服务器系列之实现Get和Post","date":"2016-06-11T15:01:35.000Z","path":"posts/1700650235/","text":"&emsp;&emsp;各位朋友大家好，我是秦元培，欢迎大家关注我的博客，我的博客地址是http://qinyuanpei.com。在我们这个Web服务器有了一个基本的门面以后，我们是时候来用它做点实际的事情了。还记得我们最早提到HTTP协议的用途是什么吗？它叫超文本传输协议啊，所以我们必须考虑让我们的服务器能够接收到客户端传来的数据。因为我们目前完成了大部分的工作，所以对数据传输这个问题我们这里选择以最简单的GET和POST为例来实现，这样我们今天的重点就落实在Get和Post的实现这个问题上来。而从原理上来讲，无论Get方式请求还是Post方式请求，我们都可以在请求报文中获得其请求参数，不同的是前者出现在请求行中，而后者出现在消息体中。例如我们传递的两个参数num1和num2对应的数值分别是12和24，那么在具体的请求报文中我们都能找到类似“num1=12&amp;num2=24”这样的字符结构，所以只要针对这个字符结构进行解析，就可以获得客户端传递给服务器的参数啦。 实现Get请求&emsp;&emsp;首先我们来实现Get请求，Get是HTTP协议中默认的请求类型，我们平时访问网页、请求资源实际上都是通过Get方式实现的。Get方式请求需要通过类似“?id=001&amp;option=10”这样的形式附加在URL上，因此Get方式对浏览器来说是透明的，即用户可以通过浏览器地址栏知道，这个过程中传递了哪些参数以及这些参数的值分别是什么。而由于浏览器的限制，我们通过这种方式请求的时候能够传递的参数数目和长度都是有限的，而且当参数中存在中文数值的时候还需要对其进行编码。Get方式请求相对简单，我们下面来看看它的请求报文： 12345678GET /?num1=23&amp;num2=12 HTTP/1.1Accept: text/html, application/xhtml+xml, image/jxr, */*Accept-Language: zh-Hans-CN,zh-Hans;q=0.5User-Agent: Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Safari/537.36 Edge/13.10586Accept-Encoding: gzip, deflateHost: localhost:4040Connection: Keep-AliveCookie: _ga=GA1.1.1181222800.1463541781 此时我们可以注意到在请求报文第一行，即请求行中出现了“/?num1=23&amp;num2=12”这样的字样，这就是客户端传递给服务器的参数，我们很容易想到只需要将这个字段串中的“键”和“值”都解析出来，服务器就可以对这些数据进行处理然后返回给客户端了。所以下面我们通过这样的方式来实现，我们为HtttpRequest类增加了一个Parms属性，它是一个键和值均为字符串类型的字典，我们使用这个字典来存储和管理客户端传递来的参数。 123//获取请求参数if(this.Method == \"GET\" &amp;&amp; this.URL.Contains('?')) this.Params = GetRequestParams(lines[0].Split(' ')[1].Split('?')[1]); 显然我们首先需要判断请求类型是否为GET以及请求中是否带有参数，其方法是判断请求地址中是否含有“?”字符。这里的lines是指将报文信息按行分割以后的数组，显然请求地址在第一行，所以我们根据“?”分割该行数据以后就可以得到“num1=23&amp;num2=12”这样的结果，这里我们使用一个方法GetRequestParms来返回参数字典，这样作做是为了复用方法，因为在处理Post请求的时候我们会继续使用这个方法。该方法定义如下：1234567891011121314151617181920212223242526272829 /// &lt;summary&gt;/// 从内容中解析请求参数并返回一个字典/// &lt;/summary&gt;/// &lt;param name=\"content\"&gt;使用&amp;连接的参数字符串&lt;/param&gt;/// &lt;returns&gt;如果存在参数则返回参数否则返回null&lt;/returns&gt;protected Dictionary&lt;string, string&gt; GetRequestParams(string content)&#123; //防御编程 if(string.IsNullOrEmpty(content)) return null; //按照&amp;对字符进行分割 string[] reval = content.Split('&amp;'); if(reval.Length &lt;= 0) return null; //将结果添加至字典 Dictionary&lt;string, string&gt; dict = new Dictionary&lt;string, string&gt;(); foreach(string val in reval) &#123; string[] kv = val.Split('='); if(kv.Length &lt;= 1) dict.Add(kv[0], \"\"); dict.Add(kv[0],kv[1]); &#125; //返回字典 return dict;&#125; 实现Post请求&emsp;&emsp;Post请求相对Get请求比较安全，因为它克服了Get请求参数长度的限制问题，而且由于它的参数是存放在消息体中的，所以在传递参数的时候对用户而言是不可见的，我们平时接触到的网站登录都是这种类型，而复杂点的网站会通过验证码、Cookie等形式来避免爬虫程序模拟登录，在Web开发中Post请求可以由一个表单发起，可以由爬虫程序如HttpWebRequest、WebClient等发起，下面我们重点来分析它的请求报文： 12345678910POST / HTTP/1.1Accept: text/html, application/xhtml+xml, image/jxr, */*Accept-Language: zh-Hans-CN,zh-Hans;q=0.5User-Agent: Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Safari/537.36 Edge/13.10586Accept-Encoding: gzip, deflateHost: localhost:4040Connection: Keep-AliveCookie: _ga=GA1.1.1181222800.1463541781num1=23&amp;num2=12 我们可以注意到此时请求行的请求方法变成了POST，而在报文结尾增加了一行内容，我们称其为“消息体”，这是一个可选的内容，请注意它前面有一个空行。所以，当我们处理一个Posst请求的时候，通过最后一行就可以解析出客户端传递过来的参数，和Get请求相同，我们这里继续使用GetRequestParams来完成解析。 12if(this.Method == \"POST\") this.Params = GetRequestParams(lines[lines.Length-1]); 实例&emsp;&emsp;现在我们来完成一个简单地实例，服务器自然由我们这里设计的这个服务器来完成咯，而客户端则由Unity来完成因为Unity有简单的WWW可以使用。首先来编写服务端，这个继承HttpServer就好了，我们主要来写这里的方法：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using HttpServerLib;using System.IO;namespace HttpServer&#123; public class ExampleServer : HttpServerLib.HttpServer &#123; /// &lt;summary&gt; /// 构造函数 /// &lt;/summary&gt; /// &lt;param name=\"ipAddress\"&gt;IP地址&lt;/param&gt; /// &lt;param name=\"port\"&gt;端口号&lt;/param&gt; public ExampleServer(string ipAddress, int port) : base(ipAddress, port) &#123; &#125; public override void OnPost(HttpRequest request) &#123; //获取客户端传递的参数 int num1 = int.Parse(request.Params[\"num1\"]); int num2 = int.Parse(request.Params[\"num2\"]); //设置返回信息 string content = string.Format(\"这是通过Post方式返回的数据:num1=&#123;0&#125;,num2=&#123;1&#125;\",num1,num2); //构造响应报文 HttpResponse response = new HttpResponse(content, Encoding.UTF8); response.StatusCode = \"200\"; response.Content_Type = \"text/html; charset=UTF-8\"; response.Server = \"ExampleServer\"; //发送响应 ProcessResponse(request.Handler, response); &#125; public override void OnGet(HttpRequest request) &#123; //获取客户端传递的参数 int num1 = int.Parse(request.Params[\"num1\"]); int num2 = int.Parse(request.Params[\"num2\"]); //设置返回信息 string content = string.Format(\"这是通过Get方式返回的数据:num1=&#123;0&#125;,num2=&#123;1&#125;\",num1,num2); //构造响应报文 HttpResponse response = new HttpResponse(content, Encoding.UTF8); response.StatusCode = \"200\"; response.Content_Type = \"text/html; charset=UTF-8\"; response.Server = \"ExampleServer\"; //发送响应 ProcessResponse(request.Handler, response); &#125; &#125;&#125; 因为这里需要对Get和Post进行响应，所以我们这里对OnGet和OnPost两个方法进行了重写，这里的处理方式非常简单，按照一定格式返回数据即可。下面我们来说说Unity作为客户端这边要做的工作。WWW是Unity3D中提供的一个简单的HTTP协议的封装类，它和.NET平台下的WebClient、HttpWebRequest/HttpWebResponse类似，都可以处理常见的HTTP请求如Get和Post这两种请求方式。 WWW的优势主要是简单易用和支持协程，尤其是Unity3D中的协程（Coroutine）这个特性，如果能够得到良好的使用，常常能够起到事倍功半的效果。因为WWW强调的是以HTTP短链接为主的易用性，所以相应地在超时、Cookie等HTTP头部字段支持的完整性上无法和WebClient、HttpWebRequest/HttpWebRespons相提并论，当我们需要更复杂的HTTP协议支持的时候，选择在WebClient、HttpWebRequest/HttpWebResponse上进行深度定制将会是一个不错的选择。我们这里需要的是发起一个简单的HTTP请求，所以使用WWW完全可以满足我们的要求，首先我们来看在Unity3D中如何发起一个Get请求，这里给出一个简单的代码示例：1234567//采用GET方式请求数据IEnumerator Get()&#123; WWW www = new WWW (\"http://127.0.0.1:4040/?num1=12&amp;num2=23\"); yield return www; Debug.Log(www.text);&#125; 现在我们是需要使用StartCoroutine调用这个方法就可以啦！同样地，对于Post请求，我们这里采用一个WWWForm来封装参数，而在网页开发中我们通常都是借助表单来向服务器传递参数的，这里给出同样简单的代码示例：12345678910//采用POST方式请求数据IEnumerator Post()&#123; WWWForm form = new WWWForm (); form.AddField (\"num1\", 12); form.AddField (\"num2\", 23); WWW www = new WWW (\"http://127.0.0.1:4040/\", form); yield return www; Debug.Log (www.text);&#125; 而运行这个实例，我们可以得到下面的结果： 测试结果 都是谁告诉你做服务器开发一定要用Java的啊，现在我们可以写出自己的服务器了，本篇结束，下期见！","tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://qinyuanpei.github.io/tags/HTTP/"},{"name":"服务器","slug":"服务器","permalink":"http://qinyuanpei.github.io/tags/服务器/"},{"name":"C#","slug":"C","permalink":"http://qinyuanpei.github.io/tags/C/"}]},{"title":"使用C#开发HTTP服务器系列之Hello World","date":"2016-06-11T12:38:03.000Z","path":"posts/3040357134/","text":"&emsp;&emsp;各位朋友大家好，我是秦元培，欢迎大家关注我的博客。从今天起，我将开始撰写一组关于HTTP服务器开发的系列文章。我为什么会有这样的想法呢？因为人们对Web技术存在误解，认为网站开发是Web技术的全部。其实在今天这样一个时代，Web技术可谓是无处不在，无论是传统软件开发还是移动应用开发都离不开Web技术，所以在我的认识中，任何使用了HTTP协议实现数据交互都可以认为是Web技术的一种体现，而且当我们提及服务器开发的时候，我们常常提及Java或者PHP。可是这些重要吗？不，在我看来服务器开发和语言无关，和IIS、Tomcat、Apache、Ngnix等等我们熟知的服务器软件无关。Web技术可以像一个网站一样通过浏览器来访问，同样可以像一个服务一样通过程序来调用，所以在接下来的时间里，我将和大家一起见证如何使用C#开发一个基本的HTTP服务器，希望通过这些能够让大家更好的认识Web技术。 至繁至简的HTTP&emsp;&emsp;我们对HTTP协议最直观的认识应该是来自浏览器，因为在互联网时代我们都是通过浏览器这个入口来接触互联网的，而到了移动互联网时代我们开始思考新的互联网入口。在这个过程中我们有创新的模式不断涌现出来，同样有并购、捆绑、垄断等形式的恶性竞争此起彼伏，所谓“痛并快乐着”。我想说的是，HTTP是一个简单与复杂并存的东西，那么什么是HTTP呢？我们在浏览器中输入URL的时候，早已任性地连“http”和“www”都省略了吧，所以我相信HTTP对人们来说依然是一个陌生的东西。 &emsp;&emsp;HTTP是超文本传输协议(HyperText Transfer Protocol)的简称，它建立在C/S架构的应用层协议，熟悉这部分内容的朋友应该清楚，TCP/IP协议是协议层的内容，它定义了计算机间通信的基础协议，我们熟悉的HTTP、FTP、Telnet等协议都是建立在TCP/IP协议基础上的。在HTTP协议中，客户端负责发起一个Request，该Request中含有请求方法、URL、协议版本等信息，服务端在接受到该Request后会返回一个Response，该Response中含有状态码、响应内容等信息，这一模型称为请求/响应模型。HTTP协议迄今为止发展出3个版本： 0.9版本：已过时。该版本仅支持GET一种请求方法，不支持请求头。因为不支持POST方法，所以客户端无法向服务器传递太多信息。 HTTP/1.0版本：这是第一个在通讯中指定版本号的HTTP协议版本，至今依然被广泛采用，特别是在代理服务器中。 HTTP/1.1版本：目前采用的版本。持久连接被默认采用，并能很好地配合代理服务器工作。相对1.0版本，该版本在缓存处理、带宽优化及网络连接地使用、错误通知地管理、消息在网络中的发送等方面都有显著的区别。 &emsp;&emsp;HTTP协议通信的核心是HTTP报文，根据报文发送者的不同，我们将其分为请求报文和响应报文。其中，由客户端发出的HTTP报文称为请求报文，由服务端发出的报文称为响应报文。下面我们来着重了解和认识这两种不同的报文： 请求报文：请求报文通常由浏览器来发起，当我们访问一个网页或者请求一个资源的时候都会产生请求报文。请求报文通常由HTTP请求行、请求头、消息体(可选)三部分组成，服务端在接收到请求报文后根据请求报文请求返回数据给客户端，所以我们通常讲的服务端开发实际上是指在服务端接收到信息以后处理的这个阶段。下面是一个基本的请求报文示例： 1234567891011/* HTTP请求行 */GET / HTTP/1.1/* 请求头部 */Accept: text/html, application/xhtml+xml, image/jxr, */*Accept-Encoding: gzip, deflateAccept-Language: zh-Hans-CN, zh-Hans; q=0.5Connection: Keep-AliveHost: localhost:4000User-Agent: Mozilla/5.0 (Windows NT 10.0; Trident/7.0; rv:11.0) like Gecko/* 消息体 */ 响应报文：响应报文是指在服务端接收并处理了客户端的请求信息以后，服务端发送给客户端的HTTP报文，服务端开发的重要工作就是处理来自客户端的请求，所以这是我们开发一个HTTP服务器的核心工作。和请求报文类似，响应报文由HTTP状态行、响应头、消息体(可选)三部分组成。例如我们通常熟悉的200和404分别表示连接正常和无法访问资源这两种响应状态。下面是一个基本的响应报文示例： 12345678910/* HTTP状态行 */HTTP/1.1 200 OK/* 响应头部 */Content-Type: text/html;charset=utf-8Connection: keep-aliveServer: Microsoft-IIS/7.0Date: Sun, 12 Jun 2016 11:00:42 GMTX-Powered-By: Hexo/* 消息体 */ &emsp;&emsp;这里需要说明的是，实际的请求报文和响应报文会因为服务端设计的不同，和这里的报文示例略有不同，报文中头部信息参数种类比较多，我不打算在这里详细解释每个参数的含义，我们只需要对报文格式有一个基本的认识即可，想了解这些内容的朋友可以阅读这里。在请求报文中我们注意到第一行，即HTTP请求行指明当前请求的方法。所以下面我们来说说HTTP协议的基本请求方法。常见的方法有GET、POST、HEAD、DELETE、OPTIONS、TRACE、CONNECT，我们这里选取最常用的两种方式，即GET和PSOT来讲解： GET：最为常见的一种请示方式。当客户端从服务器读取文档或者通过一个链接来访问页面的时候，都是采用GET方式来请求的。GET请求的一个显著标志是其请求参数附加在URL后，例如”/index.jsp?id=100&amp;option=bind”这种形式即为GET方式请求。GET方式对用户而言，传递参数过程是透明的，因为用户可以通过浏览器地址栏直接看到参数，所以这种方式更适合用来设计API，即在不需要验证身份或者对安全性要求不高的场合，需要注意的是GET方式请求对参数长度由一定限制。 POST：POST克服了GET方式对参数长度存在限制的缺点，以键-值形式将参数封装在HTTP请求中，所以从理论上讲它对参数长度没有限制(实际上会因为浏览器和操作系统的限制而大打折扣)，而且对用户来讲参数传递过程是不可见的，所以它是一种相对安全的参数传递方式。通常用户登录都会采取这种方式，我们在编写爬虫的时候遇到需要登录的情况通常都需要使用POST方式进行模拟登录。 #Socket与HTTP的紧密联系&emsp;&emsp;到目前为止，我们基本上搞清楚了HTTP是如何运作的，这恰恰符合普通人对技术的认知水平，或许在普通人看起来非常简单的东西，对技术人员来讲永远都是复杂而深奥的，所以从这个角度来讲，我觉的我们更应该向技术人员致敬，因为是技术人员让这些经过其简化以后的复杂流程以一种产品的形态走进了你我的生活，感谢有技术和技术人员的存在，让我们这个世界更加美好。好了，现在我们来思考这样一个问题，Socket和HTTP有一种怎样的关联？这是因为我们目前所有对HTTP的理解都是一种形而上学上的理解，它现在仅仅是一种协议，可是协议离真正的应用很遥远不是吗？所以我们需要考虑如何去实现这样一种协议。我们注意到HTTP是建立在TCP/IP协议上的，所以HTTP的协议应该考虑用TCP/IP协议的实现来实现，考虑到Socket是TCP/IP协议的一种实现，所以我们非常容易地想到应该用Socket来构建一个HTTP服务器，由此我们找到了Socket和HTTP的紧密联系。 &emsp;&emsp;在找到Socket和HTTP的紧密联系以后，我们现在就可以开始着手来设计一个HTTP服务器了。我们的思路是这样的，首先我们在服务端创建一个Socket来负责监听客户端连接。每次客户端发出请求后，我们根据请问报文来判断客户端的请求类型，然后根据不同的请求类型进行相应的处理，这样我们就设计了一个基本的HTTP服务器。 从头开始设计HTTP服务器&emsp;&emsp;好了，现在我们要开始从头设计一个HTTP服务器了，在此之前，我们首先来为整个项目设计下面的基本约束。我一直非常好奇为什么有的开发者会如此强烈地依赖框架。尤其是在Web开发领域，MVC和MVVM基本上是耳熟能详到烂俗的词汇。我个人更加认同这是一种思想。什么是思想呢？思想是你知道其绝妙处而绝口不提，却在潜移默化中心领神会的运行它。可事实上是什么样呢？无数开发者被框架所禁锢，因为我们缺少了犯错的机会。所以我在这里不想再提及Java、PHP、.NET在Web开发领域里那些广为人知的框架，因为我认为忘掉这些框架可以帮助我们更好的理解框架，下面我就来用我的这种方法告诉大家什么叫做MVC？ &emsp;&emsp;什么叫做MVC？我们都知道MVC由模型、视图、控制器三部分组成，可是它们的实质是什么呢？我想这个问题可能没有人想过，因为我们的时间都浪费在配置XML文档节点上。(我说的就是Java里的配置狂魔) &emsp;&emsp;首先，模型是什么呢？模型对程序员而言可以是一个实体类，亦可以是一张数据表，而这两种认知仅仅是因为我们看待问题的角度不同而已，为了让这两种认知模型统一，我们想到了ORM、想到了根据数据表生成实体类、想到了在实体类中使用各种语法糖，而这些在我看来非常无聊的东西，竟然可以让我们不厌其烦地制造出各种框架，对程序员而言我还是喜欢理解为实体类。 &emsp;&emsp;其次，视图是什么呢？视图在我看来是一个函数，它返回的是一个HTML结构的文本，而它的参数是一个模型，一个经过我们实例化以后的对象，所以控制器所做的工作无非是从数据库中获取数据，然后将其转化为实体对象，再传递给视图进行绑定而已。这样听起来，我们对MVC的理解是不是就清晰了？而现在前端领域兴起的Vue.js和React，从本质上来讲是在纠结控制器的这部分工作该有前端来完成还是该有后端来完成而已。 &emsp;&emsp;MVC中有一个路由的概念，这个概念我们可以和HTTP中请求行来对应起来，我们知道发出一个HTTP请求的时候，我们能够从请求报文中获得请求方法、请求地址、请求参数等一系列信息，服务器正是根据这些信息来处理客户端请求的。那么，路由到底是什么呢？路由就是这里的请求地址，它可以是实际的文件目录、可以是虚拟化的Web API、可以是项目中的文件目录，而一切的一切都在于我们如何定义路由，例如我们定义的路由是”http://www.zhihu.com/people/vczh“，从某种意义上来讲，它和”http://www.zhihu.com/people/?id=vczh“是一样的，因为服务器总是能够一眼看出这些语法糖的区别。 &emsp;&emsp;虽然我在竭尽全力地避免形成对框架的依赖，可是在设计一个项目的时候，我们依然需要做些宏观上的规划，我设计的一个原则就是简单、轻量，我不喜欢重度产品，我喜欢小而美的东西，就像我喜欢C#这门语言而不喜欢ASP.NET一样，因为我喜欢Nancy这个名字挺起来文艺而使用起来简单、开心的东西。我不会像某语言一样丧心病狂地使用接口和抽象类的，在我这里整体设计是非常简单的： IServer.cs：定义服务器接口，该接口定义了OnGet()、OnPost()、OnDefault()、OnListFiles()四个方法，分别用来响应GET请求、响应POST请求、响应默认请求、列取目录，我们这里的服务器类HttpServer需要实现该接口。 Request.cs：封装来自客户端的请求报文继承自BaseHeader。 Response.cs：封装来自服务端的响应报文继承自BaseHeader。 BaseHeader.cs: 封装通用头部和实体头部。 HttpServer.cs: HTTP服务器基类需实现IServer接口。 &emsp;&emsp;因为我这里希望实现的是一种全局上由我来控制，细节上由你来决定的面向开发者的设计思路，这和通常的面向大众的产品思路是完全不同的。例如委托或者事件的一个重要意义就是，它可以让程序按照设计者的思路来运行，同时满足使用着在细节上的控制权。所以，在写完这个项目以后，我们就可以无需再关注客户端和服务端如何通信这些细节，而将更多的精力放在服务器接收到了什么、如何处理、怎样返回这样的问题上来，这和框架希望我们将精力放在业务上的初衷是一样的，可是事实上关注业务对开发者来讲是趋害的，对公司来讲则是趋利的。当你发现你因为熟悉了业务而逐渐沦落为框架填充者的时候，你有足够的理由来唤起内心想要控制一切的欲望。世界很大、人生很短，这本来就是一个矛盾的存在，当我们习惯在框架中填充代码的时候，你是否会想到人生本来没有这样的一个框架？ &emsp;&emsp;好了，现在我们来开始编写这个Web服务器中通信的基础部分。首先我们需要创建一个服务端Socket来监听客户端的请求。如果你熟悉Socket开发，你将期望看到下面这样的代码： 12345678910111213141516171819202122232425/// &lt;summary&gt;/// 开启服务器/// &lt;/summary&gt;public void Start()&#123; if(isRunning) return; //创建服务端Socket serverSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); serverSocket.Bind(new IPEndPoint(IPAddress.Parse(ServerIP), ServerPort)); serverSocket.Listen(10); isRunning = true; //输出服务器状态 Console.WriteLine(\"Sever is running at http://&#123;0&#125;:&#123;1&#125;/.\", ServerIP, ServerPort); //连接客户端 while(isRunning) &#123; Socket clientSocket = serverSocket.Accept(); Thread requestThread = new Thread(() =&gt;&#123; ProcessRequest(clientSocket);&#125;); requestThread.Start(); &#125;&#125; 这里我们使用isRunning来表示服务器是否运行，显然当服务器处在运行状态时，它应该返回。我们这里使用ServerIP和ServerPort分别表示服务端IP和端口，创建服务端Socket这里就不再赘述了，因为这是非常简单而基础的东西。当服务器处在运行状态时我们接受一个客户端请求，并使用一个独立的线程来处理请求，客户端请求的处理我们这里提供了一个叫做ProcessRequest的方法，它具体都做了什么工作呢？我们继续往下看： 123456789101112131415161718/// &lt;summary&gt;/// 处理客户端请求/// &lt;/summary&gt;/// &lt;param name=\"handler\"&gt;客户端Socket&lt;/param&gt;private void ProcessRequest(Socket handler)&#123; //构造请求报文 HttpRequest request = new HttpRequest(handler); //根据请求类型进行处理 if(request.Method == \"GET\")&#123; OnGet(request); &#125;else if(request.Method == \"POST\")&#123; OnPost(request); &#125;else&#123; OnDefault(); &#125;&#125; 接下来我们可以注意到我们这里根据客户端Soket构造了一个请求报文，其实就是在请求报文的构造函数中通过解析客户端发来的消息，然后将其和我们这里定义的HttpRequest类对应起来。我们这里可以看到，根据请求方法的不同，我们这里分别采用OnGet、OnPost和OnDefault三个方法进行处理，而这些是定义在IServer接口中并在HttpServer类中声明为虚方法。严格来讲，这里应该有更多的请求方法类型，可是因为我这里写系列文章的关系，我想目前暂时就实现Get和Post两种方法，所以这里大家如果感兴趣的话可以做更深层次的研究。所以，现在我们就明白了，因为这些方法都被声明为虚方法，所以我们只需要HttpServer类的子类中重写这些方法就可以了嘛，这好像离我最初的设想越来越近了呢。关于请求报文的构造，大家可以到http://github.com/qinyuanpei/HttpServer/中来了解，实际的工作就是解析字符串而已，这些微小的工作实在不值得在这里单独来讲。 &emsp;&emsp;我们今天的正事儿是什么呢？是Hello World啊，所以我们需要想办法让这个服务器给我们返回点什么啊，接下来我们继承HttpServer类来写一个具体的类MyServer，和期望的一样，我们仅仅需要重写相关方法就可以写一个基本的Web服务器，需要注意的是子类需要继承父类的构造函数。我们一起来看代码： 123456789101112131415161718192021222324252627using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using System.IO;namespace HttpServerLib&#123; public class MyServer : HttpServer &#123; public MyServer(string ipAddress, int port) : base(ipAddress, port) &#123; &#125; public override void OnGet(HttpRequest request) &#123; HttpResponse response = new HttpResponse(\"&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello World&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;\", Encoding.UTF8); response.StatusCode = \"200\"; response.Server = \"A Simple HTTP Server\"; response.Content_Type = \"text/html\"; ProcessResponse(request.Handler, response); &#125; &#125;&#125; 可以注意到我们这里构造了一个HttpResponse，这是我这里定义的HTTP响应报文，我们这里响应的内容是一段简单的HTML采用UTF-8编码。在构造完HttpResponse以后我们设定了它的相关状态，熟悉Web开发的朋友应该可以想到这是抓包工具抓包时得到的服务端报文信息，最近博主最喜欢的某个妹子写真集网站开始反爬虫了，因此博主以前写的Python脚本现在执行会被告知403，这是一个禁止访问的状态码。解决方案其实非常简单地，将HTTP请求伪装成一个“浏览器”即可，思路就是在HTTP请求报文中增加相关字段，这样就可以“骗”过服务器，当然更深层次的“欺骗”就是Cookie和Session级别的伪装了，这个话题我们有时间再说。这里我们设定状态码为200，这是一个正常的请求，其次ContentType等字段可以自行阅读HTTP协议中头部字段的相关资料，最后我们通过ProcessResponse这个方法来处理响应，其内部是一个使用Socket发送消息的基本实现，详细的设计细节大家可以看项目代码。 &emsp;&emsp;现在让我们怀着无比激动的心情运行我们的服务器，此时服务器运行情况是： 服务器运行情况 这样是不是有一种恍若隔世的感觉啊，每次打开Hexo的时候看到它自带的本地服务器，感觉非常高大上啊，结果万万没想到有朝一日你就自己实现了它，这叫做“长大以后我就成了你吗”？哈哈，现在是见证奇迹的时刻： 浏览器运行情况 浏览器怀着对未来无限的憧憬，自豪地写下“Hello World”，正如很多年前诗人北岛在绝望中写下的《相信未来》一样，或许生活中眼前都是苟且，可是只要心中有诗和远方，我们就永远不会迷茫。好了，至此这个系列第一篇Hello World终于写完了，简直如释重负啊，第一篇需要理解和学习的东西实在太多了，本来打算在文章后附一份详细的HTTP头部字段说明，可是因为这些概念实在太枯燥，而使用Markdown编写表格时表格内容过多是写作者的无尽痛苦。关于这个问题，大家可以从这里找到答案。下期再见！","tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://qinyuanpei.github.io/tags/HTTP/"},{"name":"服务器","slug":"服务器","permalink":"http://qinyuanpei.github.io/tags/服务器/"},{"name":"C#","slug":"C","permalink":"http://qinyuanpei.github.io/tags/C/"}]},{"title":"扫描二维码在移动设备上浏览响应式页面","date":"2016-05-01T10:58:18.000Z","path":"posts/2158696176/","text":"&emsp;&emsp;最近想尝试对一个Ghost博客主题进行移植，因为对一个后端程序员来说，进行前端方面的工作实在是个不小的挑战，而我对CSS更是有种与生俱来的恐惧感，所以我是非常喜欢Bootstrap和Materilize这种对后端程序员友好的前端框架。现在前端技术如火如荼，而前端技术作为最有可能实现跨平台技术的技术形态，相对原生技术有着更为灵活的适应性和扩展性，因此以响应式设计为代表的Web技术，能够让Web页面在不同尺寸屏幕上都有着相近的体验，因为目前软件开发基本都是在计算机设备上来完成的，这样我们在制作Web页面的时候就需要在不同的设备上进行调试，如果每次都将Web页面部署到远程服务器上，这样将浪费大量的时间而且容易将测试阶段的问题暴露给用户，因此本文将采用一种扫描二维码的方式来实现在移动设备上浏览响应式页面。 #工作原理&emsp;&emsp;因为我们这里是在测试阶段在不同的移动设备上浏览响应式页面，所以这些Web页面实际上是部署在本地服务器上的，因此这个问题的实质就是如何让移动设备访问本地服务器，这个问题无论从原理上还是实现上来讲都不复杂，只要保证运行本地服务器的计算机和移动设备在同一个局域网内就可以了，考虑到移动设备的便携性，采用无线局域网的方式对移动设备更为友好。我们知道Windows系统，从Windows7版本以后就可以支持虚拟热点的创建，因此可以说是近水楼台啦！在这种情况下，理论上我们可以直接使用运行本地服务器的计算机的IP来访问本地服务器，可是因为不同的服务器软件配置不同以及不同的计算机设置不同等等外部性的因素，在实际操作的过程中依然存在各种问题，下面我们就来针对实际操作中需要注意和解决的问题，来说说具体的实现过程。 #实现过程&emsp;&emsp;考虑到实际操作中的配置项目主要由计算机设置和服务器设置两部分组成，因此我们这里对这两部分各自进行详细说明。 ##计算机设置 热点的创建 1、创建一个名称为QRPager-WIFI的无线网络，其密码为888888881netsh wlan set hostednetwork ssid=QRPager-WIFI key=88888888 2、开启网络热点确保其它设备可以访问这个热点1netsh wlan start hostednetwork 3、关闭网络热点1netsh wlan stop hostednetwork 防火墙设置 &emsp;&emsp;防火墙设置非常简单，因为关闭防火墙就好啦，这样可以保证其它设备能够正常访问本地服务器，在测试完页面后应该立即开启防火墙，这个世界可谓是充满了诱惑，有诱惑的地方就有危险，所以当我们通过互联网获取知识的同时，更为重要的一点是学会如何去甄别信息的真伪，魏则西事件让我们每一个人都感到痛心，可我们必须认识到，即使百度在你我的口诛笔伐中宣告破产，对这个世界的影响永远都是杯水车薪，所以无论是杀毒软件还是防火墙，任何形式的东西都不能代替你保护自我的意识，就像在地震、火灾这类破坏性灾难中，学会自救互救比等待公共救援更为有效。 ##服务器设置 IIS设置 &emsp;&emsp;IIS设置起来非常简单，只要在网站“绑定”设置中设置本地服务器所在计算机的IP地址即可，这样做的目的是保证服务器可以使用除了127.0.0.1和localhost以外地址来访问，因为我们在手机上访问本地服务器的时候，需要指定本地服务器所在计算机的IP。 Apache设置 &emsp;&emsp;Apache设置相对Geek，因为我们都知道它需要去编辑httpd.conf这个文件来开启或者关闭特定功能。但在这里它并不会显得复杂，因为和IIS一样，我们要进行的修改是让Apache可以通过除localhost以外的地址进行访问。在该文件中找到下列片段：1234567891011121314151617181920212223242526272829303132&lt;Directory \"D:/Program Files/WAMP/www/\"&gt; # # Possible values for the Options directive are \"None\", \"All\", # or any combination of: # Indexes Includes FollowSymLinks SymLinksifOwnerMatch ExecCGI MultiViews # # Note that \"MultiViews\" must be named *explicitly* --- \"Options All\" # doesn't give it to you. # # The Options directive is both complicated and important. Please see # http://httpd.apache.org/docs/2.2/mod/core.html#options # for more information. # Options Indexes FollowSymLinks # # AllowOverride controls what directives may be placed in .htaccess files. # It can be \"All\", \"None\", or any combination of the keywords: # Options FileInfo AuthConfig Limit # AllowOverride all # # Controls who can get stuff from this server. ## onlineoffline tag - don't remove Order Deny,Allow Allow from all #将这里由\"Deny from all\"修改为\"Allow from all\" Allow from 127.0.0.1&lt;/Directory&gt; 将第29行代码由”Deny from all”修改为”Allow from all”即可，这样就可以给其它设备访问本地服务器的权限，至此，这个问题得以成功解决。 #总结&emsp;&emsp;这篇文章无论从需求还是实现上来讲都是非常简单的，我之所以想写这篇文章，更多的是希望帮助大家克服这些“非技术性”的问题，因为有时候阻碍我们的可能并非问题本身，而是因为一个微不足道的部分，就像我们无法使用Google并非是因为Google使用起来有多么的困难，而是因为一道技术含量非常低的防火墙，在开发中除了我们使用的编程语言，任何开发工具、部署工具都可能出现这种问题，所以除了技术本身以外，关注这些“非技术性”因素同样是非常重要的一件事情。在这个设计中，有一个问题，即用户连接到无线网络是一个手动去完成的行为，换言之在扫描二维码前用户必须首先连接到无线网络。这样让我感觉显得不够优雅，我一直在思考有没有一种方法可以通过扫描二维码，直接建立移动设备到本地服务器的连接，可是二维码保存的是普通的文本信息，除非我能够通过二维码去调用Android系统中的Intent，否则这个过程是没有办法实现自动化的，一个更好的想法是在PC端生成二维码图片，在手机端通过编写二维码应用来实现两者间的Socket通信，而通信的细节如IP地址、端口号等则可以通过二维码来进行加密和解密。","tags":[{"name":"二维码","slug":"二维码","permalink":"http://qinyuanpei.github.io/tags/二维码/"},{"name":"响应式","slug":"响应式","permalink":"http://qinyuanpei.github.io/tags/响应式/"},{"name":"Web","slug":"Web","permalink":"http://qinyuanpei.github.io/tags/Web/"}]},{"title":"使用Mono打造轻量级的.NET程序运行时","date":"2016-03-25T12:47:58.000Z","path":"posts/907824546/","text":"&emsp;&emsp;在使用Mono让.NET程序跨平台运行这篇文章中，我们已经对Mono以及.NET程序的运行机制有了初步的理解。今天我想来谈谈”使用Mono打造轻量级的.NET运行时”这样一个话题。为什么我会有这样一种想法呢？因为Mono和.NET都可以执行IL代码，所以我用Mono来作为.NET程序的运行时是一个顺理成章的想法。由于.NET程序需要.NET Framework提供运行支持，所以当目标设备没有安装.NET Framework或者.NET Framework版本不对的时候，我们的程序都无法顺利运行。强迫用户安装.NET框架无疑会影响用户体验，在Windows XP尚未停止服务前，国内软件厂商为了兼容这些用户，通常会选择C++这类语言来编写原生应用，这就造成了国内.NET技术长期不被重视的现状。 #考虑.NET版本的兼容&emsp;&emsp;在考虑使用Mono来作为.NET应用程序的运行时前，首先我们来考虑.NET版本的兼容问题。假设我们使用.NET Framework 3.5版本生成了一个应用程序，那么这个应用程序将在安装了.NET Framework v3.5的计算机上运行，如果目标计算机上没有安装.NET Framework v3.5，这个应用程序将无法正常运行。这个时候，我们可以有两种解决方案：第一种，强迫用户安装.NET Framework v3.5，无论是将该框架集成到安装包中，还是在安装软件的时候自动从网上下载安装，显然这种方式都会影响用户的使用体验让用户对应用程序的印象大打折扣；第二种，尝试让应用程序和.NET版本兼容。我们知道Android程序有一个最低API版本的设置，这样能够保证应用程序在不低于该API版本的设备上运行。这里我们选择这种思路，在.NET程序中，我们可以通过应用程序配置文件中的supportedRuntime节点来指定应用程序运行的.NET Framework版本。例如下面的配置文件能够保证应用程序在.NET Framework v2.0到v3.5间的版本上运行。12345678&lt;?xml version=\"1.0\"?&gt;&lt;configuration&gt; &lt;startup&gt; &lt;supportedRuntime version=\"v2.0.50727\"/&gt; &lt;supportedRuntime version=\"v3.0\"/&gt; &lt;supportedRuntime version=\"v3.5\"/&gt; &lt;/startup&gt;&lt;/configuration&gt; 虽然说这样能够保证应用程序的兼容性，可是你这个应用程序的命运却是掌握在.NET Framework手里的，如果用户的计算机上没有安装.NET Framework我们一样还是没辙儿，那么怎么办呢？我们来搭建Mono运行时。 #Mono运行时的搭建&emsp;&emsp;我们在前面说过，Mono主要由三部分组成，即C#编译器(mcs.exe)、Mono运行时(mono.exe)和基础类库。因为我们这里是为了让编写的.NET应用程序运行在Mono运行时中，所以我们这里需要的是Mono运行时(mono.exe)和基础类库。我们建立如下的目录结构： Mono运行时目录结构 下面来说说这些目录各自的结构和功能： bin目录：放置Mono运行时的目录，主要放置mono.exe、mono-2.0.dll、libgio-2.0-0.dll、libglib-2.0-0.dll、libgthread-2.0-0.dll共5个文件。 lib目录：放置Mono依赖库的目录，主要放置.NET库目录(此处以4.0为例)、Gac库目录。其中Gac库目录下的Accessibility、Mono.Posix、System、System.Drawing、System.Windows.Forms共5个子目录是我们开发WindowsForm需要使用到的依赖库。 etc目录：放置我们编写的程序及其相关文件，主程序的文件名为Main.exe。 &emsp;&emsp;好了，现在我们就具备了一个非常轻量级的.NET程序运行环境(其实整个环境的大小在40M左右)，注意以上文件都可以在安装Mono在其安装目录内找到。根据博主目前了解到的资料来看，通过Mono运行时来运行文件主要有命令行和一种被称为Mono Embedding的方案。特别地，第二种方案可以直接将运行时嵌入到程序内，我们熟悉的Unity3D引擎就是将整个脚本的运行时嵌入到了C++程序中，但是这种方式比较复杂，暂时博主还没有弄清楚它的内部机制，所以我们这里选择第一种方案。可是它要用命令行啊，迫使普通用户来使用命令行工具是件痛苦的事情，就像我们常常被Git搞得晕头转向一样。那么，我们就用程序来模拟命令行好了！什么？用程序来模拟命令行？这个用C#来写简直不能更简单了好吗？请注意我们这里是不能使用.NET Framework里的功能的，因为它就是一个引导程序嘛，如果引导程序都需要依赖.NET，那我们这个程序怎么搞啊。 &emsp;&emsp;好嘛，那就写C++原生应用吧，它是无需任何依赖的。而在C++中模拟命令行主要有WinExec、ShellExecute和CreateProcess三种方法，关于这三种方法的异同大家可以自行了解，这里我们选择最简单的WinExec。代码如下：123456789#include &lt;Windows.h&gt;int main(int agrc,char *args[])&#123; /* 执行命令 */ WinExec(\"bin\\\\mono.exe etc\\\\Main.exe\",SW_NORMAL); return 0;&#125; 我们将编译好的程序命名为Launcher.exe，放置我们前面定义的Mono运行时目录结构的根目录下，这个文件将作为启动文件暴露给用户，当用户点击这个程序后就可以打开主文件Main.exe。好了，现在我们来验证下我们的想法： 运行在Mono运行时下的程序 作为对比，我们给出正常情况下程序的运行截图： 运行在.NET框架下的程序 这样我们现在这个程序就基本实现了脱离.NET框架运行，为什么说是基本呢？因为.NET中的基础类库是作为.NET框架中的一部分存在的，即它并非是CLR的内容。所以我们现在使用到的大部分的基础类库都是Mono重新实现的版本，如果我们使用的某一个库在Mono中没有相应的实现，那么我们就需要自己想办法来解决依赖问题了。现在这个方案每次运行的时候都会闪出命令行窗口，虽然不影响使用，但对一个追求完美的人来说就是瑕疵啦，怎么解决呢？答案就是Mono Embedding。 #小结&emsp;&emsp;本文通过Mono实现了一个轻量级的.NET程序运行环境，从某种程度上来说，它间接地实现了.NET程序脱离.NET Framework运行。这个方案目前看起来存在的主要问题是库依赖的问题，我们现在这个环境有将近40M左右的体积，这是因为我们将常用的库都放在了lib目录中，可是在实际运行中，这些库并非完全都会用到，因此如何根据程序来生成合适的lib目录，是解决运行时环境体积的有效方法。如果靠手动来解决这个问题，这显得困难重重，因为在平时微软将这些库都给我们了，它就在我们的计算机上，所以我们从来没有关注过这个问题。现在当我们面对这个问题的时候，反射可能是种不错的想法，但这种想法的验证就要等到以后啦！","tags":[{"name":".NET","slug":"NET","permalink":"http://qinyuanpei.github.io/tags/NET/"},{"name":"Mono","slug":"Mono","permalink":"http://qinyuanpei.github.io/tags/Mono/"},{"name":"跨平台","slug":"跨平台","permalink":"http://qinyuanpei.github.io/tags/跨平台/"}]},{"title":"使用Mono让.NET程序跨平台运行","date":"2016-03-06T12:20:09.000Z","path":"posts/1836680899/","text":"&emsp;&emsp;众所周知，Unity3D引擎凭借着强大的跨平台能力而备受开发者的青睐，在跨平台应用开发渐渐成为主流的今天，具备跨平台开发能力对程序员来说就显得特别重要。传统的针对不同平台进行开发的方式常常让开发者顾此失彼，难以保证应用程序在不同的平台都有着相同的、出色的体验，这种情况下寻找到一种跨平台开发的方式将会为解决这个问题找到一种思路。从目前的开发环境来看，Web应该是最有可能成为跨平台开发的神兵利器，可是长期以来Web开发中前端和后端都有各自不同的工作流，虽然现在出现了前端和后端逐渐融合的趋势，可在博主看来想让Web开发变得像传统开发这样简单还需要一定的过渡期。 #从Mono到Xamarin&emsp;&emsp;对Unity3D来说，Mono是实现它跨平台的核心技术。Mono是一个旨在使得.NET在Linux上运行的开源项目。它通过内置的C#语言编译器、CLR运行时和各种类库，可以使.NET应用程序运行在Windows、Linux、FreeBSD等不同的平台上。而在商业领域，Xamarin则实现了用C#编写Android和iOS应用的伟大创举。Windows10发布的时候，微软提出了通用应用UWP的设想，在这种设想下开发者可以直接在最新的Visual Studio中使用C#编写跨平台应用。最近微软收购了Xamarin，这一举措能够保证Xamarin这样的商业项目可以和微软的产品融合地更好。虽然在传统Web开发中Java和PHP目前占据主要优势，可是虽然云计算技术的流行，服务器成本的降低或许会让C#这样优秀的语言更加成熟。我一直坚信技术没有好坏的区别，一切技术问题的核心是人，所以接下来，我们打算追随着跨平台开发的先驱——Java，最早提出的“一次编写、到处运行”的伟大思想来探索C#程序跨平台的可能性。 #Mono跨平台的原理&emsp;&emsp;在提到Mono跨平台的时候，我们首先需要引入公共语言基础(Common Language Infrastructure，CLI)这个概念，CLI是一套ECMA定义的标准，它定义了一个和语言无关的跨体系结构的运行环境，这使得开发者可以用规范定义内各种高级语言来开发软件，并且无需修正即可让软件运行在不同的计算机体系结构上。因此我们可以说跨平台的原理是因为我们定义了这样一个和语言无关的跨体系结构的运行环境规范，只要符合这个规范的应用程序都可以运行在不同的计算机体系结构上，即实现了跨平台。针对这个标准，微软实现了公共语言运行时（Common Language Runtime，CLR)，因此CLR是CLI的一个实现。我们熟悉的.NET框架就是一个在CLR基础上采用系统虚拟机的编程平台，它为我们提供了支持多种编程语言如C#、VB.NET、C++、Python等。我们编写的C#程序首先会被C#编译器编译为公共中间语言即CIL或者是MSIL(微软中间语言)，然后再由CLR转换为操作系统的原生代码（Native Code）。 &emsp;&emsp;好了，现在我们来回答最开始的问题：Mono为什么能够跨平台。我们回顾.NET程序运行机制可以发现实现.NET跨平台其实需要这三个关键：编译器、CLR和基础类库。在.NET下我们编写一个最简单的“Hello World”都需要mscorlib.dll这个动态链接库，因为.NET框架已经为我们提供了这些，因为在我们的计算机上安装着.NET框架，这是我们编写的应用程序能够在Windows下运行的原因。再回头来看Mono，首先Mono和CLR一样，都是CLI这一标准的实现，所以我们可以理解为Mono实现了和微软提供给我们的类似的东西，因为微软的.NET框架属于商业化闭源产品，所以Mono除了在实现CLR和编译器的同时实现了大量的基础库，而且在某种程度上Mono实现的版本与相同时期.NET的版本有一定的差距，这点使用Unity3D开发游戏的朋友应该深有感触吧！这就决定了我们在将应用程序移植到目标平台时能否实现在目标平台上和当前平台上是否能够具有相同的体验。因为公共中间语言即CIL能够运行在所有实现了CLI标准的环境中，而CLI标准则是和具体的平台或者说CPU无关的，因此只要Mono运行时能够保证CIL的运行，就可以实现应用程序的跨平台。我们可以通过下面这张图来总结下这部分内容： #开发第一个跨平台程序&emsp;&emsp;下面我们来尝试开发第一个跨平台程序，我们使用Visual Studio或者MonoDevelop编写一个简单的控制台应用程序，为了减少这个程序对平台特性的依赖，我们这里选择System这个命名空间来实现最为基础的Hello World，这意味着我们的应用程序没有使用任何除mscorlib.dll以外的库：123456789101112using System;namespace MonoApplication&#123; class MainClass &#123; public static void Main(string[] args) &#123; Console.WriteLine(\"Hello World!\"); &#125; &#125;&#125; &emsp;&emsp;因为我们的计算机安装了.NET框架，所以我们编写的这个程序会被C#编译器编译为公共中间语言CIL,然后再由CLR转换为Native Code。通常情况下公共中间语言(CIL)会被存储到.il文件中，可是在这里我们在编译的时候好像并没有看到这个文件的生成啊，这是因为这里生成的可执行文件(.exe)本质上是公共中间语言(CIL)形态的可执行文件。这一点我们可以通过ildasm这个工具来验证，该工具可以帮助我们查看IL代码，通常它位于C:\\Program Files\\Microsoft SDKs\\Windows\\v7.0A\\bin这个位置。下面是通过这个工具获得的IL代码：1234567891011.method public hidebysig static void Main(string[] args) cil managed&#123; .entrypoint // 代码大小 13 (0xd) .maxstack 8 IL_0000: nop IL_0001: ldstr \"Hello World!\" IL_0006: call void [mscorlib]System.Console::WriteLine(string) IL_000b: nop IL_000c: ret&#125; // end of method MainClass::Main &emsp;&emsp;可以看到这段代码和我们编写的程序中的Main方法完全对应，关于这段代码的含义，大家可以通过搜索引擎来了解IL代码的语法。因为我们这里想要说明的是，这里生成的可执行文件(.exe)从本质上来讲并非是一个可执行文件。因为它能否执行完全是取决于CPU的，这和我们直接用C++编写的应用程序不同，我们知道不同的编译器如Windows下的VC++和Linux下的GCC都是和硬件紧密相连的，所以我们编译的程序能够在各自的平台直接运行，即CPU是认识这些程序的。可是在.NET这里就不一样了，因为我们通过C#编译器即csc.exe编译出来的文件，其实是一个看起来像可执行文件，实际上却是一个和平台无关、和CPU无关的IL文件。 &emsp;&emsp;那么我们就会感到迷茫了啊，平时我们编译完C#程序双击就可以打开啊，哈哈，现在隆重请出.NET程序的家长公共语言运行时(CLR)。公共语言运行时实际上是程序运行的监管者，程序运行的情况完全由运行时来决定。我们双击这个文件的时候，公共语言运行时会将其加载到内存中，然后由即时编译器(JIT)来识别IL文件，然后由CPU去完成相应的操作。 &emsp;&emsp;所以我们可以这样理解.NET程序跨平台，因为IL文件是一个和平台无关、和CPU无关的、跨平台的文件结构，所以我们只需要在不同的平台上实现这样一个公共语言运行时(CLR)就可以实现在不同的平台上运行同一个程序。但这个过程中，需要有一个C#编译器负责将C#代码转换为IL代码，然后需要有一个公共语言运行时(CLR)来解析IL代码。与此同时，我们在.NET框架下使用了大量的基础类库，这些类库在Windows以外的平台是没有的，所以除了C#编译器和公共语言运行时以外，我们还需要基础类库。现在大家是不是对Mono有了更清楚的认识了呢？没错，Mono所做的事情其实就是我们在讨论的这些事情。这里博主想说说即时编译(JIT)和静态编译(AOT)，这两种编译方式我们可以按照”解释型”和”编译型”来理解,为什么Unity3D在iOS平台上做热更新的时候会出现问题呢？这是因为iOS平台考虑到安全性禁止使用JIT即时编译，所以像C#这种需要编译的语言在这里就无计可施了。 &emsp;&emsp;好了，既然我们有Mono这样的工具能够帮助我们实现跨平台开发。那么我们现在就来考虑将这个程序移植到Linux平台，这里以Linux Deepin为例，我们按照C#程序编译的过程来完成这个移植过程： 1、将C#程序编译为IL文件：在.NET下我们使用csc.exe这个程序来完成编译，在Mono下我们使用mcs.exe这个程序来完成编译，这个程序在安装完Mono以后在其安装目录内可以找到。我们在命令行下输入命令： 1mcs D:\\项目管理\\CSharp\\MonoApplication\\MonoApplication\\Main.cs 2、这样将生成Main.exe这样一个IL文件，现在我们需要一个运行时来解析它，在.NET下我们使用CLR来完成这个步骤，在Mono下我们使用mono.exe这个文件来完成这个步骤。我们在命令行下输入下列命令： 1mono D:\\项目管理\\CSharp\\MonoApplication\\MonoApplication\\Main.exe 在Mono中运行.NET程序 我们可以看到命令行下输出了我们期望的Hello World，这意味着我们编写的程序现在运行在Mono中了，实际上在Windows下由Mono提供的C#编译器mcs.exe编译的IL文件双击是可以直接运行的，因为我们的计算机上安装了CLR，它作为.NET的一部分内置在我们的计算机中。由此我们会发现一个问题，我们这里的跨平台实际上是编译器、运行时和基础类库这三部分的跨平台，这意味着我们在Linux下运行.NET程序是需要Mono提供支持的。因为在这里我无法在Linux离线安装Mono，所以Linux下运行.NET程序的验证需要等博主以后有时间再来更新啦！可是我们可以想象到，通过C#编译器编译得到的可执行文件在Linux下是无法正常运行的，因为通常情况下Windows程序在Linux下运行是需要虚拟机环境或者Wine这样的软件来支持的，显然让这样一个Windows程序运行在Linux环境下是因为我们在Linux下安装了Mono。 #谈谈Mono跨平台以后&emsp;&emsp;好了，到现在为止我们基本理清了Mono跨平台的原理。我们知道微软的技术体系在发展过程中因为某些历史遗留问题，.NET程序在不同的Windows版本中的兼容性有时候会出现问题，虽然微软宣布Windows XP停止维护，我们编写Windows应用程序的时候可以忽略对Windows XP版本的支持，可是因为国内用户不喜欢在线更新补丁的这种普遍现状，所以假如让用户在安装程序的时候先去安装.NET框架一定会降低用户体验，其次.NET框架会增加应用程序安装包的大小，所以我们需要一种能够让我们开发的.NET应用程序在脱离微软的这套技术体系时，同时能够安全、稳定的运行，所以我们这里考虑借助Mono让.NET程序脱离.NET框架运行。 &emsp;&emsp;首先，我们来说说.NET程序为什么能够脱离.NET框架运行，我们注意到Mono提供了一个Mono运行时，所以我们可以借助这样一个运行时来运行编译器生成的IL代码。我们继续以Hello World为例，我们在使用Mono编译出IL代码以后需要使用Mono运行时来解析IL代码，所以假如我们可以编写一个程序来调用Mono运行时就可以解决这个问题。在这个问题中，其实精简应用程序安装包的大小从本质上来讲就是解决基础类库的依赖问题，因为Mono实现了.NET框架中大部分的基础类库，所以移植.NET应用程序的关键是基础类库的移植，比如WinForm在Linux下的解决方案是GTK，这些细节在考虑跨平台的时候都是非常重要的问题。 #小结&emsp;&emsp;本文从Mono跨平台的原理说起，探讨了.NET应用程序跨平台的可能性和具体实现。跨平台是一个涉及到非常多内容的话题，我个人理解的跨平台是要编写跨平台的代码，这意味着我们在编写程序的时候需要考虑减少对平台特性的移植，比如说Linq是一个非常棒的特性，可是这个特性离开了Windows、离开了.NET就没有办法得到保证，所以如果要让使用了Linq的应用程序跨平台就会是一件非常麻烦的事情！在不同的平台间保持相同的体验很难，就像我们编写的Web程序在不同的浏览器间都有着不一样的表现，所以跨平台这个问题我们就抱着学习的态度来研究吧！","tags":[{"name":".NET","slug":"NET","permalink":"http://qinyuanpei.github.io/tags/NET/"},{"name":"Mono","slug":"Mono","permalink":"http://qinyuanpei.github.io/tags/Mono/"},{"name":"跨平台","slug":"跨平台","permalink":"http://qinyuanpei.github.io/tags/跨平台/"}]},{"title":"在Unity3D中基于订阅者模式实现事件机制","date":"2016-01-15T12:30:41.000Z","path":"posts/632291273/","text":"&emsp;&emsp;各位朋友，大家好，欢迎大家关注我的博客，我是秦元培，我的博客地址是http://qinyuanpei.com。今天博主想和大家分享的是在Unity3D中基于订阅者模式实现消息传递机制，我们知道Unity3D中默认提供了一种消息传递机制SendMessage，虽然SendMessage使用起来的确非常简单，可是它的这种简单是建立在付出一定的代价的基础上的。经常有朋友提及不同的模块间如何进行通信的问题，可能答案最终会落到单例模式、委托和事件机制这些关键词上，在这种情况下本文所探讨的内容可能会帮助你找到最终的答案。 #从生活中得到的启示&emsp;&emsp;我们知道通过在Unity3D中通过GetComponent就可以获得某个模块的实例，进而引用这个实例完成相关任务的调用。可是显然这种方法，就像我们随身带着现金去和不同的人进行交易，每次交易的时候都需要我们考虑现金的支入和支出问题，从安全性和耦合度两个方面进行考虑，这种方法在面对复杂的系统设计的时候，非常容易造成模块间的相互依赖，即会增加不同模块间的耦合度。为了解决这个问题，大家开始考虑单例模式，因为单例模式能够保证在全局内有一个唯一的实例，所以这种方式可以有效地降低模块间的直接引用。单例模式就像是我们在银行内办理了一个唯一的账户，这样我们在交易的时候只需要通过这个账户来进行控制资金的流向就可以了。单例模式确保了各个模块间的独立性，可是单例模式更多的是一种主动行为，即我们在需要的时候主动去调用这个模块，单例模式存在的问题是无法解决被调用方的反馈问题，除非被调用方主动地去调用调用方的模块实例。说到这里我们好像看到了一种新的模式，这就是我们下面要提到的事件机制。 #订阅者模式和事件机制&emsp;&emsp;首先这里要提到一种称为“订阅者模式”的设计模式，这种设计模式在《大话设计模式》这本书中称为“观察者模式”或者“发布-订阅（Publish/Subscribe）模式”，我们这里暂且叫做“订阅者模式”吧！该模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个对象在状态发生变化时会通知所有观察者对象，使它们能够自动更新自己。针对这个模式，我们可以考虑事件机制的实现，事件机制可以理解为在一个事件中心（Subject）保存有对所有事件（Observer）的引用，事件中心负责对这些事件进行分发，这样每个事件就可以通过回调函数的方式进行更新，这样就实现了一个事件机制。下面给出基本的代码实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109using System;using System.Collections;using System.Collections.Generic;using UnityEngine;namespace UniEventDispatcher&#123; /// &lt;summary&gt; /// 定义事件分发委托 /// &lt;/summary&gt; public delegate void OnNotification(Notification notific); /// &lt;summary&gt; ///通知中心 /// &lt;/summary&gt; public class NotificationCenter &#123; /// &lt;summary&gt; /// 通知中心单例 /// &lt;/summary&gt; private static NotificationCenter instance=null; public static NotificationCenter Get() &#123; if(instance == null)&#123; instance = new NotificationCenter(); return instance; &#125; return instance; &#125; /// &lt;summary&gt; /// 存储事件的字典 /// &lt;/summary&gt; private Dictionary&lt;string,OnNotification&gt; eventListeners = new Dictionary&lt;string, OnNotification&gt;(); /// &lt;summary&gt; /// 注册事件 /// &lt;/summary&gt; /// &lt;param name=\"eventKey\"&gt;事件Key&lt;/param&gt; /// &lt;param name=\"eventListener\"&gt;事件监听器&lt;/param&gt; public void AddEventListener(string eventKey,OnNotification eventListener) &#123; if(!eventListeners.ContainsKey(eventKey))&#123; eventListeners.Add(eventKey,eventListener); &#125; &#125; /// &lt;summary&gt; /// 移除事件 /// &lt;/summary&gt; /// &lt;param name=\"eventKey\"&gt;事件Key&lt;/param&gt; public void RemoveEventListener(string eventKey) &#123; if(!eventListeners.ContainsKey(eventKey)) return; eventListeners[eventKey] =null; eventListeners.Remove(eventKey); &#125; /// &lt;summary&gt; /// 分发事件 /// &lt;/summary&gt; /// &lt;param name=\"eventKey\"&gt;事件Key&lt;/param&gt; /// &lt;param name=\"notific\"&gt;通知&lt;/param&gt; public void DispatchEvent(string eventKey,Notification notific) &#123; if (!eventListeners.ContainsKey(eventKey)) return; eventListeners[eventKey](notific); &#125; /// &lt;summary&gt; /// 分发事件 /// &lt;/summary&gt; /// &lt;param name=\"eventKey\"&gt;事件Key&lt;/param&gt; /// &lt;param name=\"sender\"&gt;发送者&lt;/param&gt; /// &lt;param name=\"param\"&gt;通知内容&lt;/param&gt; public void DispatchEvent(string eventKey, GameObject sender, object param) &#123; if(!eventListeners.ContainsKey(eventKey)) return; eventListeners[eventKey](new Notification(sender,param)); &#125; /// &lt;summary&gt; /// 分发事件 /// &lt;/summary&gt; /// &lt;param name=\"eventKey\"&gt;事件Key&lt;/param&gt; /// &lt;param name=\"param\"&gt;通知内容&lt;/param&gt; public void DispatchEvent(string eventKey,object param) &#123; if(!eventListeners.ContainsKey(eventKey)) return; eventListeners[eventKey](new Notification(param)); &#125; /// &lt;summary&gt; /// 是否存在指定事件的监听器 /// &lt;/summary&gt; public Boolean HasEventListener(string eventKey) &#123; return eventListeners.ContainsKey(eventKey); &#125; &#125;&#125; &emsp;&emsp;注意到在这个“通知中心”中，我们首先实现了单例模式，这样我们可以通过Get方法来获取该“通知中心”的唯一实例，其次这里利用一个字典来存储对所有事件的引用，这样保证外部可以通过AddEventListener和RemoveEventListener这两个方法来进行事件的添加和移除，对于添加的事件引用我们可以通过DispatchEvent方法来分发一个事件，事件的回调函数采用委托来实现，注意到这个委托需要一个Notification类型，对该类型简单定义如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950using System;using UnityEngine;namespace UniEventDispatcher&#123; public class Notification &#123; /// &lt;summary&gt; /// 通知发送者 /// &lt;/summary&gt; public GameObject sender; /// &lt;summary&gt; /// 通知内容 /// 备注：在发送消息时需要装箱、解析消息时需要拆箱 /// 所以这是一个糟糕的设计，需要注意。 /// &lt;/summary&gt; public object param; /// &lt;summary&gt; /// 构造函数 /// &lt;/summary&gt; /// &lt;param name=\"sender\"&gt;通知发送者&lt;/param&gt; /// &lt;param name=\"param\"&gt;通知内容&lt;/param&gt; public Notification(GameObject sender, object param) &#123; this.sender = sender; this.param = param; &#125; /// &lt;summary&gt; /// 构造函数 /// &lt;/summary&gt; /// &lt;param name=\"param\"&gt;&lt;/param&gt; public Notification(object param) &#123; this.sender = null; this.param = param; &#125; /// &lt;summary&gt; /// 实现ToString方法 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public override string ToString() &#123; return string.Format(\"sender=&#123;0&#125;,param=&#123;1&#125;\", this.sender, this.param); &#125; &#125;&#125; &emsp;&emsp;对Notification的定义需要提供发送者和发送内容，这样可以保证所有的通知都按照这样的格式进行定义，如果有Socket开发经验的朋友可能会联想到通讯协议的定义，这里是比较相似啦，哈哈！ #使用事件机制的一个示例&emsp;&emsp;这里以一个简单的示例来验证事件机制的可行性，我们在场景中有一个球体，默认这个球体的颜色为白色，通过调整界面中的RGB数值，可以改变球体的颜色，在这个示例中UI是事件发送者，负责UI中Slider控件的数值发生变化时向球体发送消息，传递的数据类型是Color类型；球体为事件接收者，负责注册事件及接收到消息后的处理。因为代码较为简单，所以这里写在一个脚本中：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758using UnityEngine;using UnityEngine.UI;using System.Collections;using UniEventDispatcher;public class Example : MonoBehaviour &#123; /// &lt;summary&gt; /// R数值的Slider /// &lt;/summary&gt; private Slider sliderR; /// &lt;summary&gt; /// G数值的Slider /// &lt;/summary&gt; private Slider sliderG; /// &lt;summary&gt; /// B数值的Slider /// &lt;/summary&gt; private Slider sliderB; void Start () &#123; //在接收者中注册事件及其回调方法 NotificationCenter.Get().AddEventListener(\"ChangeColor\", ChangeColor); //在发送者中分发事件，这里以UI逻辑为例 sliderR = GameObject.Find(\"Canvas/SliderR\").GetComponent&lt;Slider&gt;(); sliderG = GameObject.Find(\"Canvas/SliderG\").GetComponent&lt;Slider&gt;(); sliderB = GameObject.Find(\"Canvas/SliderB\").GetComponent&lt;Slider&gt;(); //注册UI事件 sliderR.onValueChanged.AddListener(OnValueChanged); sliderG.onValueChanged.AddListener(OnValueChanged); sliderB.onValueChanged.AddListener(OnValueChanged); &#125; public void OnValueChanged(float value) &#123; //获得RGB数值 float r = sliderR.value; float g = sliderG.value; float b = sliderB.value; //分发事件,注意和接收者协议一致 NotificationCenter.Get().DispatchEvent(\"ChangeColor\", new Color(r, g, b)); &#125; /// &lt;summary&gt; /// 改变物体材质颜色 /// &lt;/summary&gt; /// &lt;param name=\"notific\"&gt;&lt;/param&gt; public void ChangeColor(Notification notific) &#123; Debug.Log(notific.ToString()); //设置颜色 renderer.material.color = (Color)notific.param; &#125;&#125; 该示例运行效果如下： 事件机制的简单示例 #小结&emsp;&emsp;虽然目前这个事件机制在实现和使用上没有什么问题，可是从扩展性和可优化性上来考虑，这个设计目前存在以下问题： 字符型的键名使用起来方便，可是对通知者和接收者由1个以上的人力来维护的时候双方需要通过沟通来确定键名，可以考虑使用GameObject或者Transform来替代现在的键名设计，可是这种设计带来的新问题是会增加不同模块间的GameObject或者Transform的相互引用。 通知者和接收者在传递参数和接受参数的时候需要分别进行装箱和拆箱，所以这并非一个优秀的设计，同时需要双方保证传递的参数类型一致。解决方法是针对不同的类型对通知中心进行派生或者考虑对通知中心提供泛型约束，这样做的目的是使Notification中的通知内容变成具体的类型，这样就可以解决目前需要进行装箱和拆箱而带来的性能问题。","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://qinyuanpei.github.io/tags/设计模式/"},{"name":"消息","slug":"消息","permalink":"http://qinyuanpei.github.io/tags/消息/"},{"name":"事件","slug":"事件","permalink":"http://qinyuanpei.github.io/tags/事件/"}]},{"title":"扩展Unity3D编辑器的脚本模板","date":"2016-01-08T13:58:44.000Z","path":"posts/3653662258/","text":"&emsp;&emsp;最近在学习Shader时感觉Shader语言参数众多、语法诡异，如果每次都从头开始写Shader一定是一件痛苦的事情。如果可以在本地定义好一组标准的Shader模板，这样当我们需要实现某些效果类似的Shader时，就可以在这个Shader模板的基础上进行修改。因为Shader文件是一个文本文件，所以我们可以非常容易地创建这样一个模板，在这个模板中我们可以进一步完善相关的参数注释，这样就不用每次写Shader的时候都需要查文档了，从这个角度出发，就进入了这篇文章的正题：扩展Unity3D编辑器的脚本模板。 #按图索骥，模板在哪里？&emsp;&emsp;Unity3D默认的脚本模版位于/Editor/Data/Resources/ScriptTemplates/目录下，注意该目录相对Unity3D的安装目录而言，在这个目录中我们可以找到Unity3D中脚本模板的某些蛛丝马迹，首先，脚本模板是一个简单的文本文件，这个文本文件中预先填充了内容，我们在编辑器中创建模脚本或者Shader的时候实际上是读取这些文件然后在写入项目中的指定路径的。其次，这些模板文件中#SCRIPTNAME#或者#NAME#这样的标记，当我们在编辑器中创建文件的时候，这个标记会被替换成指定的文件名。比如Unity3D中继承自MonoBehaviour的脚本，有一个非常重要的特性是文件名必须和类名保持一致，这固然是Unity3D引擎的一个设定，可是在这里亦可以找到一个可以称得上理由的理由。我们注意到这些模板的文件名中都有一个独一无二的数字，比如C#脚本的模板中的数字是81、Shader模板中的数字是83，这些数字是什么呢，博主这里将其称为来自星星的黑科技。 #来自星星的黑科技&emsp;&emsp;作为一个经常捣鼓Unity3D编辑器的人，如果说你不知道MenuItem、EditorWindow、ScriptableWizard这些黑科技，那么说明你不是一个喜欢折腾和探索的人。从Unity3D的API文档中，我们知道MenuItem的原型为：1MenuItem(string itemName,bool isValidateFunction,int priority) 我知道我们通常使用MenuItem常常使用的是它的第一个参数，即定义一个菜单项的名称，我们可以使用”/“这样的分隔符来表示菜单的层级，MenuItem需要配合一个静态方法来使用，可以理解为当我们点击当前定义的菜单后就会去执行静态方法中的代码，因此MenuItem常常可以帮助我们做些编辑器扩展开发的工作。好了，第二个参数作为一个验证的标志，如果该标志为true，意味着我们定义的静态方法是一个验证方法在执行静态方法前会首先对方法进行验证，这个我们暂且不管，因为今天我们这个来自星星的黑科技主要和第三个参数有关，第三个参数表示一个优先级，它表示菜单项在菜单栏中的展示顺序，优先级大的菜单项会展示在优先级小的菜单项下面，由此我们就明白了了模板文件名中的类似81、83这样的数字的真实含义，注意到模板文件的排列顺序和编辑器中的菜单项顺序是一样的，我们做一个尝试，编写下面的代码：1234567891011121314151617181920212223[MenuItem(\"Assets/Create/Lua Scripts\", false, 85)]static void CreateLuaScripts()&#123; &#125;[MenuItem(\"Assets/Create/固定功能着色器\", false, 86)]static void CreateFixedFunctionShader()&#123; &#125;[MenuItem(\"Assets/Create/表面着色器\", false, 87)]static void CreateSurfaceShader()&#123; &#125;[MenuItem(\"Assets/Create/可编程着色器\", false, 88)]static void CreateVertexAndFragmentShader()&#123; &#125; 注意到我们按照已知的优先级继续写了四个方法，现在我们在编辑器中可以发现默认的菜单栏发生了变化： 我们可以看到我们编写的这四个菜单都生效了，虽然它们暂时什么都做不了，但顺着这个方向去探索，我们是可以实现最初的梦想的。现在我们来思考如何根据模板来创建文件，这个对我们来说简直太简单了，通过StreamReader来读取模板，然后再用StreamWriter来生成文件就可以了。可是这样创建的文件的文件名是固定的，在创建文件的时候我们没法修改，而且即使修改了文件内定义的名字并不会改变啊。所以我们需要一个更好的解决方案。Unity3D提供了一个UnityEditor.ProjectWindowCallback的命名空间，在这个空间中提供了一个称为EndNameEditAction的类，我们只需要继承这个类就可以完成这个任务。这个类需要重写Action的方法，我们知道创建一个文件的完整步骤是创建文件然后使其高亮显示，因此这部分代码实现如下：1234567891011121314151617181920212223242526272829303132333435363738394041/// &lt;summary&gt;/// 定义一个创建资源的Action类并实现其Action方法/// &lt;/summary&gt;class CreateAssetAction : EndNameEditAction&#123; public override void Action(int instanceId, string pathName, string resourceFile) &#123; //创建资源 Object obj = CreateAssetFormTemplate(pathName, resourceFile); //高亮显示该资源 ProjectWindowUtil.ShowCreatedAsset(obj); &#125; internal static Object CreateAssetFormTemplate(string pathName, string resourceFile) &#123; //获取要创建资源的绝对路径 string fullName = Path.GetFullPath(pathName); //读取本地模版文件 StreamReader reader = new StreamReader(resourceFile); string content = reader.ReadToEnd(); reader.Close(); //获取资源的文件名 string fileName = Path.GetFileNameWithoutExtension(pathName); //替换默认的文件名 content = content.Replace(\"#NAME\", fileName); //写入新文件 StreamWriter writer = new StreamWriter(fullName, false, System.Text.Encoding.UTF8); writer.Write(content); writer.Close(); //刷新本地资源 AssetDatabase.ImportAsset(pathName); AssetDatabase.Refresh(); return AssetDatabase.LoadAssetAtPath(pathName, typeof(Object)); &#125;&#125; 这部分代码相对来说比较简单，就是读取本地模板文件然后生成新文件，在生成新文件的时候会将#NAME替换成实际的文件名，这样我们就完成了文件资源的创建。现在的问题是如何在创建文件的时候获取实际的路径，这部分代码实现如下：123456789101112131415161718192021private static string GetSelectedPath()&#123; //默认路径为Assets string selectedPath = \"Assets\"; //获取选中的资源 Object[] selection = Selection.GetFiltered(typeof(Object), SelectionMode.Assets); //遍历选中的资源以返回路径 foreach (Object obj in selection) &#123; selectedPath = AssetDatabase.GetAssetPath(obj); if (!string.IsNullOrEmpty(selectedPath) &amp;&amp; File.Exists(selectedPath)) &#123; selectedPath = Path.GetDirectoryName(selectedPath); break; &#125; &#125; return selectedPath;&#125; 现在解决了创建资源的问题，我们接下来只要调用ProjectWindowUtil的StartNameEditingIfProjectWindowExists方法即可，该方法需要传入一个继承自EndNameEditAction的类的实例、目标文件路径和模板文件的路径。例如要创建一个Lua脚本可以这样实现：12345678[MenuItem(\"Assets/Create/Lua Scripts\", false, 85)]static void CreateLuaScripts()&#123; ProjectWindowUtil.StartNameEditingIfProjectWindowExists(0, ScriptableObject.CreateInstance&lt;CreateAssetAction&gt;(), GetSelectedPath() + \"/NewLuaScript.lua\", null, \"Assets/Editor/Template/85-Lua-NewLuaScript.lua.txt\");&#125; #小结&emsp;&emsp;现在有了这个黑科技以后，我们可以创建更多的模板来扩展编辑器的功能，比如对Shader而言，我们可以创建些基础性的Shader模板，然后每次需要写Shader的时候直接从模板库中选择一个功能类似的Shader然后在此基础上进行修改，这样比从头开始写一个新的Shader应该会轻松不少，这段时间学习Shader，感觉进程缓慢离图形学高手遥遥无期，行了，这篇博客就是这样了。","tags":[{"name":"Unity3D","slug":"Unity3D","permalink":"http://qinyuanpei.github.io/tags/Unity3D/"},{"name":"编辑器","slug":"编辑器","permalink":"http://qinyuanpei.github.io/tags/编辑器/"},{"name":"模板","slug":"模板","permalink":"http://qinyuanpei.github.io/tags/模板/"}]},{"title":"《Cg Programming in Unity》读书笔记","date":"2015-12-25T12:29:20.000Z","path":"posts/1670305415/","text":"&emsp;&emsp;最近开始着手Shader语言的学习，因为Unity3D没有提供类似虚幻四引擎的材质编辑器功能，所以当在Unity3D中碰到需要提供引擎默认材质以外的效果的时候，就需要我们来编写Shader以实现各种特效，本文主要是结合《Cg Programming in Unity》这本书和浅墨博客中关于Shader的这部分内容来学习和整理，目的是帮助博主快速掌握Shader语言。 #Unity3D中的Shader概述&emsp;&emsp;为Unity3D编写Sahder代码相对OpenGL和DirectX要简单。Unity3D没有刻意地区分Cg语言和HLSL语言，因为这两者是非常相似的，这意味着使用HLSL编写的代码可以直接在Cg中使用，更为深入地探索HLSL和Cg的渊源你会戏剧性地发现Cg是Microsoft和NVIDIA联手推出并试图从硬件和软件上和GLSL相抗衡的一种产物。 &emsp;&emsp;其中Cg是Nvidia提供的一种Shader编写语言，HLSL是DirectX提供的一种Shader编写语言，这意味着大部分的Cg代码同样可以被HLSL支持。Unity3D中使用的Shader编写语言是ShaderLab，其本质是对Cg进行了封装，因此在Unity3D中编写Shader本质上在给DirectX或者OpenGL写Shader，因为我猜测在引擎内部存在HLSL和GLSL的相互转换使得Unity3D能够在不同的平台都有较好的图形表现。 &emsp;&emsp;Unity3D中Shader程序的编写可以参考这里。我们知道计算机图形学的中渲染管线一般可以分为两种类型，即固定功能渲染管线和可编程渲染管线。因此从这个角度来看，Unity3D中主要有三种着色器，即固定功能着色器（Fixed Function Shader）、表面着色器（Surface Shader）和 顶点着色器&amp;片段着色器 （Vertex Shader &amp; Fragment Shader）。 #Unity3D中Shader的基本结构&emsp;&emsp;首先，Unity3D中Shader的基本结构是：12345678910111213141516Shader &#123; //------【属性】------// Properties &#123; &#125; //------【子着色器】------// SubShaders &#123; &#125; //------【回滚】------// Fallback&#125; 对这个结构我们的理解是，Shader代码首先是一些属性定义，用来指定这段代码将有哪些输入。接下来是一个或者多个的子着色器，在实际运行中，哪一个子着色器被使用是由运行的平台所决定的。子着色器是代码的主体，每一个子着色器中包含一个或者多个的Pass。在计算着色时，平台先选择最优先可以使用的着色器，然后依次运行其中的Pass，然后得到输出的结果。最后指定一个Fallback，用来处理所有SubShader都不能运行的情况称为回滚。下面来分别介绍Shader基本结构中的各个部分： ##Shader中的PropertiesProperties是由多条标签组成的Shader属性定义，这些属性能够在Unity3D中的编辑器中显示出来，以此来确定这段Shader代码由哪些输入。常见的标签定义有：1name(\"display name\", Range(min, max)) = number 定义一个在编辑器中可通过滑动条修改的浮点数属性1name(\"display name\", Color) = (number,number,number,number) 定义一个在编辑器中可通过拾色器来设置RGBA的颜色值属性1name(\"display name\", 2D) = \"name\" &#123;options &#125; 定义一个在编辑器中可编辑的2D纹理属性，其中options可选表示即纹理自动生成纹理坐标时的模式，通常是ObjectLinear、EyeLinear、SphereMap、 CubeReflect、CubeNormal其中之一。1name(\"display name\", Rect) = \"name\"&#123; options &#125; 定义一个在编辑器中可编辑的非二次方2D纹理属性1name(\"display name\", Cube) = \"name\"&#123; options &#125; 定义一个在编辑器中可编辑的立方贴图纹理属性 1name(\"display name\", Float) = number 定义一个在编辑器中可通过输入框修改的浮点数值属性1name(\"display name\", Vector) =(number,number,number,number) 定义一个在编辑器中可通过输入框修改的Vector4属性 ##Shader中的SubShader&emsp;&emsp;SubShader，即子着色器。子着色器是代码的主体，每一个子着色器中包含一个或者多个的Pass。在计算着色时，平台先选择最优先可以使用的着色器，然后依次运行其中的Pass，然后得到输出的结果。子着色器的基本结构是：1234567891011Subshader&#123; //------【Tags标签】------// Tags&#123;&#125; //------【Pass通道】------// Pass &#123; &#125;&#125; ####Tags标签在这里子着色器使用Tags标签来告诉渲染引擎期望何时和如何渲染对象，其语法是：1Tags &#123; \"TagName1\" = \"Value1\" \"TagName2\" = \"Value2\" &#125; 即采用一个键值对来表示标签的名称及其对应的值，通常由三种标签可以在这里使用：1\"Queue\" = \"Transparent\" 表示决定渲染次序的队列标签，其取值定义如下： Background在所有队列渲染之前被渲染，如天空盒等。 Geometry默认渲染大部分的对象，如不透明的几何体等。 Transparent在所有队列渲染之后被渲染采用由后到前的次序，如玻璃、粒子效果等。 Overlay主要实现叠加效果的渲染，如镜头光晕等。 1Tags &#123; \"Queue\" = \"Geometry+1\" &#125; 表示自定义中间渲染队列，当默认的渲染队列不能满足要求时可选用当前渲染队列。在Unity实现中每一个队列都被一个整数的索引值所代表。Background为1000、Geometry为2000、Transparent为3000、Overlay为4000. 1Tags &#123; \"IgnoreProjector\" =\"True\" &#125; 表示忽略投影标签，其值为True表示忽略投影反之表示受投影影响。 ####Pass通道Pass通道块控制被渲染的对象的几何体。其结构定义如下：123456789Pass &#123; //------【名称与标签】------// [Name and Tags] //------【渲染设置】------// [RenderSetup] //------【纹理设置】------// [TextureSetup] &#125; #####名称与标签在通道中可以定义其名称和任意数目的标签，通过使用tags来告诉渲染引擎在什么时候该如何渲染他们所期望的效果，其语法和Tags标签完全相同，即采用键值对来定义标签的名称和其对应的值。常用的标签有：1Tags &#123; \"LightMode\" = \"Always\" &#125; 表示一个光照模式标签，该标签的取值可以是： Always总是渲染。没有运用光照。 ForwardBase用于正向渲染,环境光、方向光和顶点光等 ForwardAdd用于正向渲染，用于设定附加的像素光，每个光照对应一个pass PrepassBase用于延迟光照，渲染法线/镜面光。 PrepassFinal用于延迟光照，通过结合纹理，光照和自发光渲染最终颜色 Vertex用于顶点光照渲染，当物体没有光照映射时，应用所有的顶点光照 VertexLMRGBM用于顶点光照渲染，当物体有光照映射的时候使用顶点光照渲染。在平台上光照映射是RGBM 编码 VertexLM用于顶点光照渲染，当物体有光照映射的时候使用顶点光照渲染。在平台上光照映射是double-LDR 编码（移动平台，及老式台式CPU） ShadowCaster使物体投射阴影。 ShadowCollector为正向渲染对象的路径，将对象的阴影收集到屏幕空间缓冲区中。 #####渲染设置渲染设置设定显示硬件的各种状态，常用的命令如下：123456789101112131415161718192021222324Material &#123; Diffuse Color(R,G,B,A) //漫反射颜色构成，即对象的基本颜色。 Ambient Color(R,G,B,A) //环境色颜色构成，即当对象被RenderSettings中设定的环境色所照射时对象所表现的颜色。 Specular Color(R,G,B,A) //对象反射高光的颜色。 //(R,G,B,A)四个分量分别代表红绿蓝和Alpha，取值为0到1之间。 Shininess Number //加亮时的光泽度，在0和1之间。 Emission Color //自发光颜色，即当不被任何光照所照到时对象的颜色。 //(R,G,B,A)四个分量分别代表红绿蓝和Alpha，取值为0到1之间。 //【备注】对象上的完整光照颜色最终是： //FinalColor = Ambient * RenderSettings ambientsetting + //(Light Color * Diffuse + Light Color *Specular) + Emission&#125; 定义一个使用顶点光照管线的材质1Lighting On | Off 开启或关闭顶点光照1Cull Back | Front | Off 设置多边形剔除模式1ZTest (Less | Greater | LEqual | GEqual |Equal | NotEqual | Always) 设置深度测试模式1ZWrite On | Off 设置深度写模式1Fog &#123; Fog Block &#125; 设置雾参数1AlphaTest (Less | Greater | LEqual | GEqual| Equal | NotEqual | Always) CutoffValue 开启alpha测试1Blend SourceBlendMode | DestBlendMode 设置alpha混合模式 1Color Color value 设置当顶点光照关闭时所使用的颜色1ColorMask RGB | A | 0 | any combination of R, G, B, A 设置颜色写遮罩。设置为0将关闭所有颜色通道的渲染1Offset OffsetFactor , OffsetUnits 设置深度偏移1SeparateSpecular On | Off 开启或关闭顶点光照相关的平行高光颜色1ColorMaterial AmbientAndDiffuse | Emission 当计算顶点光照时使用每顶点的颜色 #####纹理设置纹理设置的作用是在完成渲染设定后指定一定数目的纹理及其混合模式：1SetTexture [texture property]&#123; [Combineoptions] &#125; ##Shader中的FallbackFallback就像switch-case结构中的default，其作用是定义当处理所有SubShader都不能运行时采取的一个补救方案，这个主要是为了解决不同的显卡对Shader支持的差异问题。 #Unity3D中Shader的语法Unity3D中Shader的语法主要针对Cg代码而言，Cg代码是可编程着色器和表面着色器中的核心内容，Cg代码从CGPROGRAM开始到ENDCG结束 #Unity3D中的三种着色器","tags":[{"name":"Shader","slug":"Shader","permalink":"http://qinyuanpei.github.io/tags/Shader/"},{"name":"CG","slug":"CG","permalink":"http://qinyuanpei.github.io/tags/CG/"},{"name":"Unity","slug":"Unity","permalink":"http://qinyuanpei.github.io/tags/Unity/"}]},{"title":"EasyAR尝鲜系列教程之视频播放功能的实现","date":"2015-12-09T08:40:22.000Z","path":"posts/316230277/","text":"&emsp;&emsp;各位朋友大家好，欢迎大家关注我的博客，我是秦元培，我的博客地址是http://qinyuanpei.com。到现在为止，我们对EasyAR中的ImageTarget基本上可以说是驾轻就熟了，因此我们这个系列教程可以说是接近尾声了。博主第一次接触AR这个概念是在大学时候读到一本讲解计算机图形视觉的书籍里，相对VR技术目前华而不实的市场现状，AR技术从实用性和成熟度都能得到较好的保证。可是大家都清楚这些技术背后都是建立在复杂而高深的图形学算法的基础上的，如果想学习AR技术请回归计算机图形学的本源，这就和学习游戏技术要追寻可编程渲染管线是一样的，所以这个系列完全是博主个人的兴趣使然，希望了解这个技术的可以进行更加深入的探索。这次我们来说说VideoTarget如何实现吧！ #EasyAR中对视频的支持&emsp;&emsp;目前EasyAR对视频的支持主要是通过VideoPlayerBehaviour这个类，这个类继承自一个基类VideoPlayerBaseBehaviour。我们可以将其理解为一个视频播放器组件，只要我们将这个组件添加到一个GameObject上，然后简单填写下参数就可以了。可是这个组件博主在32位操作系统下并没有看到实际的效果，虽然说都到了2015年了64位操作系统相对来说更为普及了，可是我觉得支持不支持32位操作系统更多的体现的是一家公司做产品的态度。既然暂时没有办法看到这里的具体效果，我们本着学习的态度对这个组件有所了解就是了。下面是这个组件的一张截图： VideoPlayerBehaviour组件截图 从图中我们可以看到这个组件相关参数的设置，这里选取的视频资源是StreamingAssets目录下的video.mp4这个文件，视频资源的Stroge同样支持App、Assets、Absolute这三种类型，和图片资源的Stroge是一样的，关于这三种类型的资源路径的问题，我这里不想再重复说了，这个看看文档就知道了。其次会涉及到视频播放方式和视频缩放的相关参数，这些基本上没什么理解上的难度，大家对照着文档反复尝试就知道各自的用途了。博主这里不太理解EasyAR为什么不采用MovieTexture或者Unity3D中针对视频播放提供的相关插件，因为VideoTarget本质上就是把三维模型换成了可以播放的视频而已，所以大家在前面文章的基础上创建一个ImageTarget然后再其下面放置一个附加了VideoPlayerBehaviour的的子物体就可以了。官方的示例项目中提供了两种方式的VideoTarget创建方式，即手动创建和动态创建。手动创建即我们这里提到的这种方式，而动态创建则是由程序在运行时期间创建。这两种方式本质上没有什么不同，需要注意的是VideoPlayerBehaviour有一个EnableAutoPlay的选项，该选项被选中后会启用自动播放，即当识别图被识别后自动播放视频、识别图未被识别则暂停播放视频。如果这个选项没有被选中，我们需要在ITargetEventHandle接口中动手来实现。 #增强ImageTarget&emsp;&emsp;这个增强ImageTarget是指在ImageTarget的基础上融入VideoPlayerBehaviour的功能，因为按照官方的示例来考虑，这两部分功能是独立的，博主希望让大家在制作识别图的时候完全忘记区别ImageTarget和VideoTarget，这样我们可以更为专注地制作识别图，因为视频组件就只是设置参数这一件事情，完全可以一次性搞定，所以我们首先来定义一个VideoTargetBaseBehaviour类，一起来看代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161using UnityEngine;using System.Collections;using EasyAR;public class VideoTargetBaseBehaviour : ImageTargetBehaviour,ITargetEventHandler&#123; /// &lt;summary&gt; /// 视频播放模块 /// &lt;/summary&gt; private VideoPlayerBehaviour videoPlayer; /// &lt;summary&gt; /// 视频文件路径 /// &lt;/summary&gt; public string VideoPath; /// &lt;summary&gt; /// 是否自动播放视频 /// &lt;/summary&gt; public bool VideoEnableAutoPlay = true; /// &lt;summary&gt; /// 是否允许视频循环 /// &lt;/summary&gt; public bool VideoEnableLoop = true; /// &lt;summary&gt; /// 视频类型 /// &lt;/summary&gt; public VideoPlayer.VideoType VideoType = VideoPlayer.VideoType.TransparentSideBySide; /// &lt;summary&gt; /// 视频资源类型 /// &lt;/summary&gt; public StorageType VideoStorage = StorageType.Assets; /// &lt;summary&gt; /// 视频是否加载 /// &lt;/summary&gt; private bool isVideoLoaded; protected override void Start() &#123; //在Start方法中加载视频、隐藏模型 base.Start(); LoadVideo(); HideObjects(transform); &#125; /// &lt;summary&gt; /// 加载视频 /// &lt;/summary&gt; private void LoadVideo() &#123; //创建子物体VideoObject并为其添加视频组件 GameObject VideoObject = new GameObject(\"VideoObject\"); videoPlayer = VideoObject.AddComponent&lt;VideoPlayerBehaviour&gt;(); VideoObject.transform.SetParent(transform); VideoObject.transform.localPosition = Vector3.zero; VideoObject.transform.localRotation = Quaternion.identity; VideoObject.transform.localScale = Vector3.one; //设置视频组件相关参数 videoPlayer.Storage = VideoStorage; videoPlayer.Path = VideoPath; videoPlayer.EnableAutoPlay = VideoEnableAutoPlay; videoPlayer.EnableLoop = VideoEnableLoop; videoPlayer.Type = VideoType; videoPlayer.VideoReadyEvent+=videoPlayer_VideoReadyEvent; videoPlayer.VideoReachEndEvent+=videoPlayer_VideoReachEndEvent; videoPlayer.VideoErrorEvent+=videoPlayer_VideoErrorEvent; videoPlayer.Open(); videoPlayer.Play(); &#125; #region 视频组件相关事件定义 public virtual void videoPlayer_VideoErrorEvent(object sender, System.EventArgs e) &#123; &#125; public virtual void videoPlayer_VideoReachEndEvent(object sender, System.EventArgs e) &#123; &#125; public virtual void videoPlayer_VideoReadyEvent(object sender, System.EventArgs e) &#123; &#125; #endregion /// &lt;summary&gt; /// 隐藏模型的方法 /// &lt;/summary&gt; /// &lt;param name=\"trans\"&gt;要隐藏的Transform&lt;/param&gt; void HideObjects(Transform trans) &#123; for (int i = 0; i &lt; trans.childCount; ++i) HideObjects(trans.GetChild(i)); if (transform != trans) gameObject.SetActive(false); &#125; /// &lt;summary&gt; /// 显示模型的方法 /// &lt;/summary&gt; /// &lt;param name=\"trans\"&gt;要显示的Transform&lt;/param&gt; public void ShowObjects(Transform trans) &#123; for (int i = 0; i &lt; trans.childCount; ++i) ShowObjects(trans.GetChild(i)); if (transform != trans) gameObject.SetActive(true); &#125; /// &lt;summary&gt; /// 实现ITargetEventHandler接口中的OnTargetFound方法 /// &lt;/summary&gt; /// &lt;param name=\"target\"&gt;识别目标&lt;/param&gt; void ITargetEventHandler.OnTargetFound(Target target) &#123; if (videoPlayer) videoPlayer.Play(); ShowObjects(transform); &#125; /// &lt;summary&gt; /// 实现ITargetEventHandler接口中的OnTargetLost方法 /// &lt;/summary&gt; /// &lt;param name=\"target\"&gt;识别目标&lt;/param&gt; void ITargetEventHandler.OnTargetLost(Target target) &#123; if (videoPlayer) videoPlayer.Pause(); HideObjects(transform); &#125; /// &lt;summary&gt; /// 实现ITargetEventHandler接口中的OnTargetLoad方法 /// &lt;/summary&gt; /// &lt;param name=\"target\"&gt;识别目标&lt;/param&gt; void ITargetEventHandler.OnTargetLoad(Target target, bool status) &#123; &#125; /// &lt;summary&gt; /// 实现ITargetEventHandler接口中的OnTargetUnload方法 /// &lt;/summary&gt; /// &lt;param name=\"target\"&gt;识别目标&lt;/param&gt; void ITargetEventHandler.OnTargetUnload(Target target, bool status) &#123; &#125;&#125; 在这段代码中博主采用了动态创建视频组件的方法，这样我们在制作VideoTarget的时候只需要按照以下步骤即可： 在Assets/EasyAR/Prefabs目录下找到EasyAR这个预制体，添加EasyARConfig组件，然后填写KEY。具体请参考系列教程第三篇EasyAR尝鲜系列教程之ImageTarget千呼万唤始出来。 在Assets/EasyAR/Prefabs目录中找到ImageTarget这个预制体，然后使用VideoTargetBaseBehaviour组件替换默认的ImageTargetBehaviour组件。下面是博主这里的参数配置截图 我制作的VideoTarget 这里博主继续选择idback这张图片，这种方法是博主喜欢的方法，大家可以按照个人喜欢的方式来实现，总而言之万变不离其宗，只需要掌握它的原理就好了。在文章中已经提到过这个组件在32位操作系统下无法正常工作，所以这篇文章就不给大家展示相关的截图了，本文暂时先写到这里等有时间测试成功了再来更新这篇文章。如果像博主这样对Unity3D比较熟悉的朋友，可以考虑使用MovieTexture或者其它的方式来替代官方目前的这个方案，好了，这篇文章就是这样了，希望大家喜欢!","tags":[{"name":"Unity3D","slug":"Unity3D","permalink":"http://qinyuanpei.github.io/tags/Unity3D/"},{"name":"增强现实","slug":"增强现实","permalink":"http://qinyuanpei.github.io/tags/增强现实/"},{"name":"EasyAR","slug":"EasyAR","permalink":"http://qinyuanpei.github.io/tags/EasyAR/"}]},{"title":"EasyAR尝鲜系列教程之ImageTarget千呼万唤始出来","date":"2015-12-09T08:39:54.000Z","path":"posts/3736599391/","text":"&emsp;&emsp;各位朋友大家好，欢迎大家关注我的博客，我是秦元培，我的博客地址是http://qinyuanpei.com。最近EasyAR终于迎来了一次重大的版本更新：v1.10，真可谓是“千呼万唤始出来”啊，所以在官方文档和示例项目基本完善的情况下，博主决定将EasyAR尝鲜系列教程继续下去。本次教程主要以官方新发布的Unity示例项目为基础来进行讲解，关注Androis/iOS原生应用开发的朋友请自行针对官方示例项目进行研究。好了，今天主要的内容是通过EasyAR SDK来自行构建一个ImageTarget的实例，采用Unity3D 4.6.4版本进行开发。 #EasyAR SDK的结构&emsp;&emsp;将EasyAR SDK导入Unity3D后会在项目的Assets根目录下生成EasyAR和Plugins两个文件夹。其中EasyAR文件夹中提供了开发AR应用相关的标准接口、材质、Shader和Prefab，Plugins文件夹中提供了针对各个平台的插件。好了，下面我们来介绍EasyAR SDK中提供的标准接口： ARBuilder: 该类提供了EasyAR初始化的相关方法，我们在编写EasyAR配置类的时候会用到这个类，这是一个可以直接使用的类。 ImageTargetBehaviour: 该类是一个抽象类，我们需要对其进行override，可以将这个类理解为ImageTarget生命周期相关的一个类，在实际使用中需要配合ITargetEventHandle这个接口来使用。 VideoPlayerBaseBehaviour: 该类是一个组件，我们可以使用这个组件来播放视频。其原理和ImageTarget类似，所不同的地方是ImageTarget在识别成功后会显示一个模型，而这里则是使用一个隐藏的物体来播放视频，VideoPlayerBaseBehaviour负责控制视频的播放、暂停等工作。 ITargetEventHandle: 这是一个接口，通过该接口可以捕捉到识别过程中的OnTargetFound、OnTargetLost、OnTargetLoad和OnTargetUnload四个事件，对于一个基本的AR应用来说，我们通常需要关注的是OnTargetFound、OnTargetLost这两个方法。 #构建第一个ImageTarget项目&emsp;&emsp;好了，在了解了EasyAR中常用的标准接口以后，我们下面来着手构建第一个ImageTarget项目，和我们第一次接触EasyAR不同，这次我们会编写些简单地代码，打开场景填入应用程序密钥(Key)然后运行它，这种方式在这里会显得略LOW。 ##EasyAR的初始化&emsp;&emsp;首先我们在Assets/EasyAR/Prefabs目录下找到EasyAR这个预制体，然后将其拖放到场景中，这样我们就创建了基本的EasyAR应用场景，接下来我们要做的事情就是在这个场景中填入各种各样的识别物。为了让EasyAR正常工作，我们首先要编写一个初始化EasyAR的脚本： 123456789101112131415161718192021222324using UnityEngine;using System.Collections;using EasyAR;public class EasyARConfig : MonoBehaviour &#123; /// &lt;summary&gt; /// 应用程序密钥 /// &lt;/summary&gt; [TextArea(1,10)] public string Key; public void Awake() &#123; //检查KEY是否存在 if(string.IsNullOrEmpty(Key)) Debug.Log(\"请先输入应用程序密钥\"); //初始化EasyAR ARBuilder.Instance.InitializeEasyAR(Key); ARBuilder.Instance.EasyBuild(); &#125; &#125; 我确信这个类简单到彻底，它需要开发者在编辑器中填入KEY然后再Awake方法中完成对EasyAR的初始化，就是这样简单，我们这里将这个脚本附加到EasyAR这个物体上去，这样我们就完成了引擎的初始化工作，下面我们就可以专注于AR内容的产生了。 ##制作一个ImageTarget&emsp;&emsp;接下来我们在Assets/EasyAR/Prefabs目录中找到ImageTarget这个预制体，将其拖放到场景中，确保它在摄像机的视野范围内。我们注意到默认情况下它附加了一个ImageTargetBehaviour脚本，我们在前面已经说过，这个类是一个抽象类，抽象类通常是不做任何事情的，因此我们需要继承这个类来编写一个具体类，我们将这个具体类命名为CustomImageTargetBehaviour。下面给出它的代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374using UnityEngine;using System.Collections;using EasyAR;public class CustomImageTargetBehaviour :ImageTargetBehaviour,ITargetEventHandler&#123; protected override void Start() &#123; //在Start方法中隐藏模型 base.Start(); HideObjects(transform); &#125; /// &lt;summary&gt; /// 隐藏模型的方法 /// &lt;/summary&gt; /// &lt;param name=\"trans\"&gt;要隐藏的Transform&lt;/param&gt; void HideObjects(Transform trans) &#123; for (int i = 0; i &lt; trans.childCount; ++i) HideObjects(trans.GetChild(i)); if (transform != trans) gameObject.SetActive(false); &#125; /// &lt;summary&gt; /// 显示模型的方法 /// &lt;/summary&gt; /// &lt;param name=\"trans\"&gt;要显示的Transform&lt;/param&gt; void ShowObjects(Transform trans) &#123; for (int i = 0; i &lt; trans.childCount; ++i) ShowObjects(trans.GetChild(i)); if (transform != trans) gameObject.SetActive(true); &#125; /// &lt;summary&gt; /// 实现ITargetEventHandler接口中的OnTargetFound方法 /// &lt;/summary&gt; /// &lt;param name=\"target\"&gt;识别目标&lt;/param&gt; void ITargetEventHandler.OnTargetFound(Target target) &#123; ShowObjects(transform); &#125; /// &lt;summary&gt; /// 实现ITargetEventHandler接口中的OnTargetLost方法 /// &lt;/summary&gt; /// &lt;param name=\"target\"&gt;识别目标&lt;/param&gt; void ITargetEventHandler.OnTargetLost(Target target) &#123; HideObjects(transform); &#125; /// &lt;summary&gt; /// 实现ITargetEventHandler接口中的OnTargetLoad方法 /// &lt;/summary&gt; /// &lt;param name=\"target\"&gt;识别目标&lt;/param&gt; void ITargetEventHandler.OnTargetLoad(Target target, bool status) &#123; &#125; /// &lt;summary&gt; /// 实现ITargetEventHandler接口中的OnTargetUnload方法 /// &lt;/summary&gt; /// &lt;param name=\"target\"&gt;识别目标&lt;/param&gt; void ITargetEventHandler.OnTargetUnload(Target target, bool status) &#123; &#125;&#125; 可以注意到在这个类中我们主要做了两件事情：第一，定义了隐藏和显示识别模型的方法HideObjects和ShowObjects，其作用是在没有识别到Target的时候隐藏物体，在识别到Target的时候显示物体；第二，实现了ITargetEventHandler接口并在OnTargetFound和OnTargetLost两个方法中实现我们第一步希望达到的目的。至此，我们完成了一个基本的AR识别组件，我们下面所有的AR识别物体都是通过这个组件来工作的，所以我们从场景中的ImageTarget物体上移除默认的ImageTargetBehaviour脚本然后为其添加我们定义的CustomImageTargetBehaviour脚本。 &emsp;&emsp;编写完脚本以后我们就可以着手制作识别图和Marker了，EasyAR最让人喜欢的一点就是你可以按照自己的意愿来制作识别图和Marker。虽然Vuforia在识别效果上比EasyAR更好点，可是对程序员来说选择一个透明的产品方案比面对着黑箱子进行调试要明智得多。EasyAR中的识别图相对来说比较简单，因为我们只需要选择一张图片然后为其创建一个材质，再将这个材质附加到ImageTarget物体上就可以了。此外还会涉及到某些参数的设置，我们下面会提到。好了，我们继续选择官方示例中的idback这张图片来作为我们的识别图，因为身份证每个人都有可以随时用来进行测试，而一般的图片则需要打印出来制成硬质卡片来使用。我们在Assets目录中创建一个StreamingAssets目录，将官方示例中targets.json和idbcak.jpg两个文件拷贝过来。创建材质就不再说了，这是Unity3D中非常非常基础的内容。我们将创建好的材质附加到ImageTarget物体上以后，可能在场景中并不会看到对应的识别图，这是因为我们没有为其配置参数。具体的参数配置如下图： ImageTarget参数配置 具体这些参数的定义请大家自己去看文档，因为我这里说得再明白如果大家不看等于我没有说。好了，下面我们来创建Marker，这个就比较简单了，我们直接找一个模型缩放到合适的大小然后拖拽到ImageTarget这个物体下面就可以了。如图是博主参照官方示例制作的两个识别图及其Marker： 两个ImageTarget及其对应Maker ##走向成功的关键步骤1、在EasyAR物体的EasyARConfig组件中填入从官网申请的KEY。2、在BuildSetting中填写KEY对应的AppID。3、安装SDK中附带的VC++2015运行库。4、如要编译Android版本，请确保安装Java环境和Android SDK更多的问题请自行到官方文档中对照寻找解决办法。 #截图展示","tags":[{"name":"增强现实","slug":"增强现实","permalink":"http://qinyuanpei.github.io/tags/增强现实/"},{"name":"AR","slug":"AR","permalink":"http://qinyuanpei.github.io/tags/AR/"},{"name":"EasyAR","slug":"EasyAR","permalink":"http://qinyuanpei.github.io/tags/EasyAR/"}]},{"title":"C#中的扩展方法学习总结","date":"2015-12-05T12:01:02.000Z","path":"posts/305484621/","text":"&emsp;&emsp;各位朋友大家好，我是秦元培，欢迎大家关注我的博客。最近偶然接触到了C#中的扩展方法，觉得这个语法特性是一个不错的特性，因此决定在这里系统地对C#中的扩展方法相关内容进行下总结和整理，因为博主觉得学习这件事情本身就是一个积累的过程，所以博主有时候会对现在的线上培训和视频教程这种“在线教育”感到反感。试想《射雕英雄传》中江南七怪远赴大漠传授郭靖武艺苦历十八载，何以难及全真教丹阳子马钰传授内功两年的积累？这里固然有郭靖愚笨木讷的天性和江南七怪武功低微的因素，可是在博主看来更重要的是强调了一个积累。想郭靖一生受益自全真教的玄门内功终成一代“为国为民”的侠之大者，则我辈需更加努力方可在这世间行走奔波。 #什么是扩展方法？&emsp;&emsp;扩展方法从字面上理解是指扩展的方法，而对应到面向对象编程这个格局中则是指为一个类提供的扩展方法。按照我们通常的理解，我们首先需要获得某个类的源代码，然后在这个类代码中增加成员方法，这样就可以达到为一个类提供扩展方法的目的。可是不幸地是，这种方法在没有源代码的情况下就无法奏效了，而且我们人为地去改变源代码有可能会破坏整个代码的稳定性。那么有没有一种方法能在不改变源代码的前提下为某个类提供扩展方法呢？这就是我们今天要说的扩展方法，所以我们可以将扩展方法理解为在不改变源代码的前提下向外部提供扩展方法的一种方式。C#中的扩展方法实现起来是相对来说比较简单的，例如我们做在Unity3D游戏开发的时候，可能会用到DOTween这个插件。这个插件是iTween的作者重新编写一个动画插件，效率上比iTween有较大的提升。更为重要的一点是，它采用扩展方法这种实现方式，使得我们在调用这些API接口的时候难以感觉到我们是在使用一个插件，更像是在使用Unity3D的原生函数，所以当我们使用DOTween + uGUI 这样的组合的时候，内心会感到无比的舒畅，一切都像是水到渠成一般。 #扩展方法有哪些特点？&emsp;&emsp;扩展方法在实现上和普通的面向对象编程是一样的，换句话说，我们只需要定义一个类，然后在里面添加并实现相应的方法即可。但是这里需要注意的地方有三点，第一，实现扩展方法的类必须是静态类且类的名称和实现扩展方法的类无关；第二、实现扩展方法的类方法必须是静态方法；第三、实现扩展方法的类方法的第一个参数必须是使用this关键字指明要实现扩展方法的类。例如，我们知道将一个合法字符串类型转换为整型，可以使用int.parse()方法，假如我们希望为string类型扩展一个ToInt方法应该怎么办呢？我们一起来看下面的这段代码： 12345678910111213141516/// &lt;summary&gt;/// 1、定义一个静态类/// 2、静态类的名称和要实现扩展方法的具体类无关/// &lt;/summary&gt;public static class SomeClass&#123; /// &lt;summary&gt; /// 3、实现一个具体的静态方法 /// &lt;/summary&gt; /// &lt;param name=\"str\"&gt;4、第一个参数必须使用this关键字指定要使用扩展方法的类型&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static int ToInt(this string str) &#123; return int.Parse(str); &#125;&#125; 需要注意的是C#支持扩展方法是从.NET3.5版本开始，所以在编写扩展方法的时候请确保你的.NET版本是否满足这一要求。提到版本问题，有很多朋友尤其是从Unity5.0以后开始学习Unity3D的朋友，常常会在我的博客中留言提到我的代码无法在新环境下运行等等类似地问题，我觉得这个世界上更新速度最快的当属IT技术了，大家使用新版本没有问题，可是有时候因为技术发展中的历史遗留问题例如Python2.7和Python3、Unity4.X和Unity5.X，这个时候可能出现版本不兼容的问题，这个时候如果网络上的资源没有及时更新，建议大家还是及时查看官方的最新文档，因为在博主看来网络上的书籍或者相关文章都是用来参考的，古话说：尽信书不如无书，只有客观、冷静地判断知识的正确与否，我们方能学到真正有用的知识。 &emsp;&emsp;好了，现在我们编写完这个扩展方法以后，就可以像下面这样使用扩展方法了： 12string str = \"1234\";int val = str.ToInt(); 这个示例向大家展示了如何编写一个无参数的扩展方法，那么当我们需要在扩展方法中传入参数的时候该怎么做呢？我们只需要在第一个参数后继续加入参数的声明就好了。例如我们在Unity3D中常常需要给一个3D物体设置坐标，通常我们可以通过下面的代码来实现：1transform.position = new Vector3(1,1,1); 这个代码到目前为止是比较简洁的，可是我们知道在Unity3D中除了position属性以外还有localPosition属性，如果我们的代码中再涉及坐标计算的话，我相信这个代码一定会变得非常的长。更有甚者，有时候我们只想改变三维坐标中的一个维度，可是我们必须给transform.position一个三维坐标，毫无意外地此时的代码会变得更长。为了解决这个问题，我们可以扩展出三个方法SetPositionX、SetPositionY、SetPositionZ来分别为x、y、z三个坐标分量进行赋值，我们继续在SomeClass这个类中添加方法：1234567891011121314151617181920212223242526272829/// &lt;summary&gt;/// 设置Tranform的X坐标/// &lt;/summary&gt;/// &lt;param name=\"tran\"&gt;当前Transform&lt;/param&gt;/// &lt;param name=\"x\"&gt;X坐标&lt;/param&gt;public static void SetPositionX(this Transform tran, float x)&#123; tran.position = new Vector3(x, tran.position.y, tran.position.z);&#125;/// &lt;summary&gt;/// 设置Tranform的Y坐标/// &lt;/summary&gt;/// &lt;param name=\"tran\"&gt;当前Transform&lt;/param&gt;/// &lt;param name=\"x\"&gt;Y坐标&lt;/param&gt;public static void SetPositionY(this Transform tran, float y)&#123; tran.position = new Vector3(tran.position.x, y, tran.position.z);&#125;/// &lt;summary&gt;/// 设置Tranform的Z坐标/// &lt;/summary&gt;/// &lt;param name=\"tran\"&gt;当前Transform&lt;/param&gt;/// &lt;param name=\"x\"&gt;Z坐标&lt;/param&gt;public static void SetPositionZ(this Transform tran, float z)&#123; tran.position = new Vector3(tran.position.x, tran.position.y, z);&#125; 同样的，我们现在可以直接为一个三维物体的坐标进行赋值：123transform.SetPositionX(1.0f);transform.SetPositionY(1.0f);transform.SetPositionZ(1.0f); #使用扩展方法的利弊&emsp;&emsp;扩展方法使用起来得心应手，所以我们这里来讨论下使用扩展方法的利弊。好处当然是自由而任性地使用扩展方法对类进行扩展，而且扩展方法在Visual Studio中的智能提示会以蓝色向下箭头进行标识。扩展方法的坏处则是要看设计扩展方法的人能否较好的驾驭这个特性啦，其实所有的技术都是一样的，我常常在游戏群里听到人鄙视Unity3D引擎，以UnReal Engine4为游戏引擎世界里的泰山北斗，我承认UE4的画面效果好，可是能真正用好这个引擎的人有多少呢？扩展方法在使用的时候应该遵守就近原则，即是在最小的范围内使用扩展方法，对具体类而非抽象类实现扩展方法。我们使用扩展方法无非是因为它在逻辑层需要这样的功能，所以我们没有必要去改变抽象层的逻辑，因为这样会“污染”整个代码。举一个简单的例子，我们知道.NET中的基类是object，如果我们对这个类进行扩展，毫无疑问它会影响所有继承自object的类，这样就会造成“污染”，显然是不可取的。 #小结 在C#中实现扩展方法的类必须是静态类且类的名称和实现扩展方法的类无关 实现扩展方法的类方法必须是静态方法 实现扩展方法的类方法的第一个参数必须是使用this关键字指明要实现扩展方法的类 实现扩展方法应遵守就近原则，在最小的范围内使用扩展方法以避免造成“污染”","tags":[{"name":"CSharp","slug":"CSharp","permalink":"http://qinyuanpei.github.io/tags/CSharp/"},{"name":"扩展方法","slug":"扩展方法","permalink":"http://qinyuanpei.github.io/tags/扩展方法/"},{"name":"Unity3D","slug":"Unity3D","permalink":"http://qinyuanpei.github.io/tags/Unity3D/"}]},{"title":"青黄未接的2015","date":"2015-12-01T19:24:18.000Z","path":"posts/1394521917/","text":"&emsp;&emsp;匆匆时光总是把我们这些过客留在感慨和叹息中，而它却如风之旅人一般渐行远去。转眼这大半年的时间里，每天我都在努力让时间发挥它的意义，可是有时候这种努力却像枷锁一样让我有些莫名的压抑。从毕业那天起，我就决定这辈子不会再靠我的本科专业生活，因为它从来没有和我的内心发生过强烈的共鸣，所以当我毕业以后就意味着我再没有回头的路可以走。曾经因为怯懦而将自己封闭在这座小城市，其结果就是我在我人生中的第一家公司的项目在拖延和等待中慢慢地死亡。 &emsp;&emsp;从刚进公司时的踌躇满志到此时此刻心灰意冷，大概就像冬日里的懒洋洋的太阳，一个季节的凋落需要的可能只是一片枯萎的叶子而已。我每天都坚持早起，因为我不想被这种安逸到近似麻木的生活拔去梦想的翅膀，虽然我在乎的事情没有人懂、更没有人在乎，可我就是不愿做一只温水中的青蛙，因为当危险临近的时候更加不会有人来救我。每天穿梭在来来往往的人群中、听着年轻的男男女女们讨论被生活剥夺去的纷纷扰扰，我曾经为了让自己和别人不同而努力过，此时此刻却要为了和别人一样而满腹忧愁。我不甘心让我的生活变成电视连续剧，一切都在编剧和观众的期望之中。我想要一个独特的故事，虽然狗血可它却是我在这世界上来过的真实写照。 &emsp;&emsp;古语说：父母在，不远游，游必有方。我固然不愿意离开年迈的父母，我固然不愿意离开生养我的土地，可是对我来说这一切都没有可以选择的余地，每次看到回家看到父母不停地辛劳，我意识到他们渐渐地老了，他们的身体不再像以前那般硬朗，他们的头发一天比一天白，我不愿意他们再为我辛劳下去，留在这座小城市里除了可以经常看到他们以外，对我而言并不会有更好的理由。虽然在这座小城市里我可以勉强混得下去，可对我付出过的精力和时间来说，它更像是一种灵魂上的亵渎。我还要照顾她、和她在一起生活，看看此时此刻的我有什么资格这样说呢？我身边的同龄人有的人已经买好了房子、有的人已经在准备结婚成家，可我什么都没有啊，我没有资格让每天的日子都这样平淡而安稳地过下去，大概这就是我一直在纠结的原因吧！ &emsp;&emsp;将近七个月的时间，可对我来说真正为第一家公司工作的时间只有三个月。我自问每天都在认真的做事情，可是因为领导层和整个公司的问题现在这个项目变成这个样子，我真的感到失望而寒心。时光一过不再有，这过去的大半年时间就让它过去吧，在接下来的2016年里，我希望我可以更加勇敢、更加努力，我要更好地把握我的人生，我要变得更加成熟，我要做最初的、最好的自己！2016，加油！","tags":[{"name":"生活","slug":"生活","permalink":"http://qinyuanpei.github.io/tags/生活/"},{"name":"感悟","slug":"感悟","permalink":"http://qinyuanpei.github.io/tags/感悟/"},{"name":"成长","slug":"成长","permalink":"http://qinyuanpei.github.io/tags/成长/"}]},{"title":"Unity3D游戏开发之C++插件接入","date":"2015-11-21T14:47:26.000Z","path":"posts/2527231326/","text":"&emsp;&emsp;各位朋友大家好，我是秦元培，欢迎大家关注我的博客，我的博客地址是http://qinyuanpei.com。虽然Unity3D引擎依靠强大的跨平台能力睥睨高手林立的游戏引擎世界，我们在使用Unity3D游戏引擎的时候基本上不会去接触底层的东西，可是有时候面对某些奇葩的要求的时候，我们就不得不考虑使用C++这样的语言来为其编写相关的插件。你如果问我是什么样的奇葩要求，比如接入蓝牙手柄来控制游戏、接入类似街机的设备来控制游戏、接入同一个游戏到两个不同的设备上并响应不同的控制……诸如此类的种种问题，可能目前在Unity3D引擎中找不到解决方案，这个时候写C++插件就变成了一种刚性需求，这就是我们今天要来一起探讨的问题。 &emsp;&emsp;Unity3D主要使用C#进行开发，所以为Unity3D编写插件本质上就是让C#调用C++代码。目前主要有C++ CLR和C++ Native两种实现方法，其中C++ CLR可以理解为运行在.Net CLR即公共语言运行库上的C++代码，这种代码是托管的C++代码，目前并没有被C++标准承认，因为它更像是C++和C#两种语言的混合代码，这种代码的优势是可以像普通的.NET库一样被C#调用，考虑到Unity3D建立在和.Net类似的Mono上，因此这种方式应该是我们的最佳实践方案；C++ Native则是指传统的C++ 动态链接库，通过DllImport在C#中进行包装后在C#中进行调用，相对地这种方式调用的是非托管的C++代码，这种方式相信接触过Windows开发的朋友应该不会感到陌生啦，它是一种更为普遍的方法，例如我们要接入苹果官方SDK的时候，需要对Object C的代码进行封装后交给C#去调用，而这里使用的方法就是DllImport了。 &emsp;&emsp;好了，下面我们来看看两种方式各自是如何实现的吧！这里博主使用的开发环境是Windows 8.1 32bit 和 Visual Studio 2012，Unity3D的版本为4.6版本。 #C++ CLR ##创建一个C++ CLR类库项目&emsp;&emsp;首先我们按照下图中的步骤创建一个C++ CLR项目： 截图是件讨厌的事情，虽然懒惰的人们都喜欢 请注意.Net版本问题，重要的事情说三遍，不认真看这里的人出现问题就不要到我这里来评论了，我最讨厌连文章都没有看明白就来和你纠缠不清的人，谢谢。创建好项目后请打开项目属性窗口设置【公共语言运行时支持】节点的值为【安全 MSIL 公共语言运行时支持(/clr:safe)】好了，下面我们找到CLR4Unity.h文件，添加ExampleClass声明： 123456789101112131415161718192021222324252627282930313233343536373839404142434445/// &lt;summary&gt;/// 一个简单的托管C++示例类/// &lt;/summary&gt;public ref class ExampleClass&#123; public: /// &lt;summary&gt; /// 产生一个介于min和max之间的整型随机数 /// &lt;returns&gt;整型随机数&lt;/returns&gt; /// &lt;param name=\"min\"&gt;最小值&lt;/param&gt; /// &lt;param name=\"max\"&gt;最大值&lt;/param&gt; /// &lt;/summary&gt; static int Random(int min,int max) &#123; //注意在托管的C++中使用gcnew来代替new //我承认C++写CLR代码略显奇葩像是C++和C#语法的混合 return (gcnew System::Random)-&gt;Next(min,max); &#125; /// &lt;summary&gt; /// 计算一个整数的平方 /// &lt;returns&gt;整型数值&lt;/returns&gt; /// &lt;param name=\"a\"&gt;需要平方的数值&lt;/param&gt; /// &lt;/summary&gt; static int Square(int a) &#123; return a * a; &#125; /// &lt;summary&gt; /// 返回两个数中的最大值 /// &lt;returns&gt;整型数值&lt;/returns&gt; /// &lt;param name=\"a\"&gt;参数1&lt;/param&gt; /// &lt;param name=\"b\"&gt;参数2&lt;/param&gt; /// &lt;/summary&gt; static int Max(int a,int b) &#123; if(a&lt;=b)&#123; return b; &#125;else&#123; return a; &#125; &#125;&#125;; 显然我们这里定义了三个简单的方法，注意到第一个方法Random依赖于System.Rnadom类，而在托管的C++中是使用gcnew来代替new这个关键字的，所以请尽情感受C#和C++的混搭语法风格吧！这样我们就可以编译得到CLR4Unity.dll这个类库，将这个文件复制到Unity3D项目中的Plugins目录下下，然后将其加入项目引用列表。如果你以为引用就是：1using CLR4Unity; 呵呵，我严重怀疑你对.Net的熟悉程度。你没有添加对CLR4Unity.dll的引用，你到底在using什么啊？ 先添加引用然后using 如果你对.NET熟悉到足以无视这里的一切，请闭上眼接着往下看，哈哈！ ##在C#中添加引用及方法调用&emsp;&emsp;接下来我们在Unity3D中创建一个脚本PluginTest.cs，然后在OnGUI方法增加下列代码。可是你要以为这些代码就应该写在OnGUI方法中，抱歉请你先去了解MonoBehaviour这个类。什么？添加了这些代码报错？没有using的请自行面壁：1234567//调用C++ CLR中的方法if(GUILayout.Button(\"调用C++ CLR中的方法\", GUILayout.Height (30))) &#123; Debug.Log(\"调用C++ CLR中的方法Random(0,10):\" + ExampleClass.Random(0,10)); Debug.Log(\"调用C++ CLR中的方法Max(5,10):\" + ExampleClass.Max(5,10)); Debug.Log(\"调用C++ CLR中的方法Square(5):\" + ExampleClass.Square(5));&#125; #C++ Native ##创建一个C++动态链接库项目&emsp;&emsp;首先我们按照下图中的步骤来创建一个C++ Win32项目： 不要问我从哪里来 我的故乡在远方 好了，接下来我们找到Native4Unity.cpp写入下列代码： 123456789101112131415161718192021222324252627282930313233343536373839404142// Native4Unity.cpp : 定义 DLL 应用程序的导出函数。//#include \"stdafx.h\"//为了使用rand()函数引入C++标准库#include \"stdlib.h\"/// &lt;summary&gt;/// 产生一个介于min和max之间的整型随机数/// &lt;returns&gt;整型随机数&lt;/returns&gt;/// &lt;param name=\"min\"&gt;最小值&lt;/param&gt;/// &lt;param name=\"max\"&gt;最大值&lt;/param&gt;/// &lt;/summary&gt;extern \"C\" __declspec(dllexport) int Random(int min,int max)&#123; return rand() % (max - min + 1) + min;&#125;/// &lt;summary&gt;/// 返回两个数中的最大值/// &lt;returns&gt;整型数值&lt;/returns&gt;/// &lt;param name=\"a\"&gt;参数1&lt;/param&gt;/// &lt;param name=\"b\"&gt;参数2&lt;/param&gt;/// &lt;/summary&gt;extern \"C\" __declspec(dllexport) int Max(int a ,int b)&#123; if(a&lt;=b)&#123; return b; &#125;else&#123; return a; &#125;&#125;/// &lt;summary&gt;/// 计算一个整数的平方/// &lt;returns&gt;整型数值&lt;/returns&gt;/// &lt;param name=\"a\"&gt;需要平方的数值&lt;/param&gt;/// &lt;/summary&gt;extern \"C\" __declspec(dllexport) int Square(int a)&#123; return a * a;&#125; 和C++ CLR类似，我们使用标准的C++语言来实现同样的功能。注意到rand()这个函数是C++标准库里的内容，所以我们在文件开头增加了对stdlib.h这个头文件的引用。这里需要注意的一点是：所有希望使用DllImport引入C#的C++方法都应该在方法声明中增加__declspec(dllexport)关键字，除非它在.def文件中对这些方法进行显示声明。关于.def文件的相关定义大家可以到MSDN上检索，这些都是属于C++编译器的内容，这里不再详细说了。 ##在C#中使用DllImport封装方法 &emsp;&emsp;将编译好的Native4Unity.dll复制到Plugins目录中后，下面我们要做的事情就是在C#里对这些方法进行封装或者说是声明： 12345678[DllImport(\"Native4Unity\")]private extern static int Random(int min, int max);[DllImport(\"Native4Unity\")]private extern static int Max(int a, int b);[DllImport(\"Native4Unity\")]private extern static int Square(int a); 然后就是简单地调用啦： 1234567//调用C++ Native中的方法if(GUILayout.Button(\"调用C++ Native中的方法\", GUILayout.Height (30))) &#123; Debug.Log(\"调用C++ Native中的方法Random(0,10):\" + Random(0, 10)); Debug.Log(\"调用C++ Native的方法Max(5,10):\" + Max(5, 10)); Debug.Log(\"调用C++ Native中的方法Square(5):\" + Square(5));&#125; 最终程序的运行效果如图： 这个结果来之不易请大家珍惜","tags":[{"name":"Unity3D","slug":"Unity3D","permalink":"http://qinyuanpei.github.io/tags/Unity3D/"},{"name":"C++","slug":"C","permalink":"http://qinyuanpei.github.io/tags/C/"},{"name":"插件","slug":"插件","permalink":"http://qinyuanpei.github.io/tags/插件/"}]},{"title":"在Hexo中为文章自动添加版权信息声明模块","date":"2015-11-15T13:12:22.000Z","path":"posts/2950334112/","text":"&emsp;&emsp;各位朋友，大家好，欢迎大家关注我的博客，我是秦元培，我的博客地址是http://qinyuanpei.com。今天想和大家说说博客文章版权这件事情。每当提到版权的时候，我知道大家内心深处都是对此不以为然的，因为国内版权意识薄弱，所以版权在我们的眼中就变成了这样一件可有可无的东西，可是事实真的是这样的吗？首先我们必须承认一件事情，即你从互联网上获得的知识都是有价值的，即使这些知识的创造者并未因此而获得利益。相对其它的行业，因为程序员这个职业本身需要其通过不断地学习新知识来适应新变化，因此程序员这个群体更喜欢在互联网上分享知识和经验，而这些知识的受众面窄、技术门槛高则决定了程序员们无法像普通的博客作者一样有更多的机会来获得收入。大部分的程序员都是从分享知识、记录学习和技术交流这样的角度来撰写博客的。那么这样就会造成一个问题，在国内版权意识薄弱和技术博客变现困难的双重夹缝中，博客作者该如何寻求新的突破呢？ #一、为什么要说博客文章版权这件事儿&emsp;&emsp;首先，我们为什么要说博客文章版权这件事情呢？因为博客是文字创造的产物，是知识共享的一种形式。当我们无视版权的时候，这意味着知识是没有价值的，创造是无关痛痒的，脑力劳动和创意活动的价值在现实中被无情地扼杀。当你引用一个人的观点却不加以注明的时候，当你盗用一个人的创意却不给予报酬的时候，试问谁还会愿意为这个社会贡献创意和想法呢？引用许锡良的观点，尊重版权更深层次的含义在于对人权的尊重： 从人权的角度看，人与动物的区别在于知识与思想，因此，人类最根本的财富也应该是知识与思想上的财富，一切社会财富都来源于知识与思想，这是从自然界获得生活资料，以及改造社会的根本。没有知识与思想的人类将与动物世界没有什么区别。尊重人权，首先就要学会尊重人的劳动成果，特别是创造性劳动成果，只有人，才能创造出来的知识产权与发明专利。尊重人权，首先就要学会尊重一个人的思想与创意。只有人，才能创造出来的知识产权与发明专利。因为每个人都是一个独立的个体，每个人头脑里的想法都是独一无二的，无人能替代的。在没有说出来，或者写出来之前，也无人能盗取的，这种思想就是个人独有，就是只属于个人的专利。 &emsp;&emsp;我常常遇到在博客评论中和我直接要源代码的人，我不明白从什么时候起对知识的分享变成了某些人懒惰的借口。我选择将我知道的某个分享出来，当然我同样有权利可以选择沉默。你不能因为习惯了做伸手党就认为我应该理所当然地把源代码给你，这是对我的不尊重。我写博客的目的在于和别人交流技术、互相学习，如果你根本没有看懂我博客写了什么，只是希望可以找到可以“抄”来就能用的代码。抱歉!这违背了我的初衷我更没有道理要将源代码分享给你,况且如果我的代码都清清楚楚（命名规范、注释清晰）地写在博客里，如果这样的代码你都不能看懂，就算把完整的工程分享给你又有什么用呢？我本来不情愿论坛来转载我的文章，因为论坛盖楼的这种互动模式实在难以产生较为良好的互动效果，可是人家来诚心诚意地询问你的态度，如此拒绝难免有点却之不恭吧！当然最让人讨厌的是网络爬虫和网站编辑，这种让人讨厌是因为它”简单粗暴”，完全不考虑博客作者的感受，文章的原始链接被删除、文章的作者署名被删除。或许大家都觉得一个署名、一个原始链接都是无足轻重的东西，可是在我看来这恰恰是体现责任的地方。作者的责任在于对文章的真实性和客观性负责，转发者的责任在于帮助读者找到作者当他们之间需要某种交流的时候，这就是我为什么强调署名和原始链接的理由！ #二、谈谈如何保护博客文章版权&emsp;&emsp;在保护博客文章版权这个问题上，我们可以采取的方式固然很多，但是这件事情的根本原因在于人们普遍不重视知识产权的保护，所以我们这里提到的这些方式都是外家功夫，真正要根除这等沉疴痼疾需要人们不断提升自我、勤修内功。 第一种方式，我们称为通过技术方式提醒，比如通过编写JavaScript脚本，实现当对方复制你的博客内容的时候，程序可以自动在这段复制的内容中增加署名和连接。当然我们可以通过修改文章的模板来在文章中加入版权信息，这个我们留到最后会说，因为实际上这个是我们今天要重点研究的内容，博主是个程序员，我们当然要用技术的方式来实现了，前面的这些大家看完心里有个数就是了，哈哈！ 第二种方式，我们称为增加文章内链的方式，就是在文章中尽可能地使用指向这个博客的连接，这样可以保证在文章转载后为博客带来一定的反向访客。 第三种方式，在图片上增加水印，这样读者在看到图片的时候就可以很容易地找到原始出处，可是如果你不能保证拥有所引用的图片得版权，建议不要轻易地使用这种方式。 第四种方式，逐渐形成个性化的写作风格，这样当读者读到这些文字的时候，可以通过文章的风格知道文章的作者和出处。 第五种方式，努力提高自己博客的文章质量，让更多的读者从中受益，形成有独立风格的博客品牌。一个博客有了高质量的内容和品牌，那么在搜索引擎中的权重就会很高，网民通过搜索引擎进行查找的时候，博客原文都会排在第一位。 博主之所以要使用http://qinyuanpei.com这个独立博客的原因正是基于这个原因。博主目前采用的知识共享许可是署名(BY)-非商业性使用(NC)-相同方式共享(SA)，请各位在转载文章的时候注意保留作者署名和文章出处，谢谢！ #三、保护博客文章版权，独立博客在行动&emsp;&emsp;我的博客是采用Hexo这个博客系统来搭建的，说到底程序员是天生爱折腾的命吧，都有对掌控事物的欲望，不喜欢受到条件制约。CSDN的博客虽然还不错，可是“限制因素 + 服务器奔溃”这样的强效组合实在让我很难有继续坚持下去的动力，所以果断就自己搭了博客买了域名，老老实实地开始管理起独立博客。好了，废话少说，放码过来，我们下面来看看怎么在Hexo中的文章中增加一个展示版权信息的模块，这里以Jacman主题为例，我们首先定位到该主题文件夹下的\\layout_partial\\post\\article.ejs文件： 123456789101112131415161718192021222324&lt;div id=\"main\" class=\"&lt;%= item.layout %&gt;\" itemscope itemprop=\"blogPost\"&gt; &lt;% if (page.layout=='photo' &amp;&amp; item.photos &amp;&amp; item.photos.length)&#123; %&gt; &lt;%- partial('gallery') %&gt; &lt;% &#125; %&gt; &lt;article itemprop=\"articleBody\"&gt; &lt;%- partial('header') %&gt; &lt;div class=\"article-content\"&gt; &lt;% if( table&amp;&amp;(item.toc !== false) &amp;&amp; theme.toc.article)&#123; %&gt; &lt;div id=\"toc\" class=\"toc-article\"&gt; &lt;strong class=\"toc-title\"&gt;&lt;%= __('contents') %&gt;&lt;/strong&gt; &lt;% if(item.list_number == false) &#123;%&gt; &lt;%- toc(item.content,&#123;list_number:false&#125;) %&gt; &lt;% &#125;else&#123; %&gt; &lt;%- toc(item.content) %&gt; &lt;% &#125; %&gt; &lt;/div&gt; &lt;% &#125; %&gt; &lt;%- item.content %&gt; &lt;/div&gt; &lt;%- partial('footer') %&gt; &lt;/article&gt; &lt;%- partial('pagination') %&gt; &lt;%- partial('comment') %&gt;&lt;/div&gt; 我们可以注意到文章的内容是在&lt;%- item.content %&gt;这个标签里，因此我们如果要在文章中增加内容，只需要在&lt;%- item.content %&gt;的后面引入一个ejs模板文件即可，所以我们接下在article.ejs的同级目录下创建一个declare.ejs文件： 1&lt;pre&gt;&lt;code&gt;&lt;b&gt; 版权声明&lt;/b&gt;:本文由&lt;b&gt;&lt;a href=\"&lt;%= config.root %&gt;about\" target=\"_blank\" title=\"&lt;%= config.author %&gt;\"&gt;&lt;%= config.author %&gt;&lt;/a&gt;&lt;/b&gt;创作和发表,采用&lt;b&gt;署名(BY)&lt;/b&gt;-&lt;b&gt;非商业性使用(NC)&lt;/b&gt;-&lt;b&gt;相同方式共享(SA)&lt;/b&gt;国际许可协议进行许可,转载请注明作者及出处,本文作者为&lt;b&gt;&lt;a href=\"&lt;%= config.root %&gt;about\" target=\"_blank\" title=\"&lt;%= config.author %&gt;\"&gt;&lt;%= config.author %&gt;&lt;/a&gt;&lt;/b&gt;,本文标题为&lt;b&gt;&lt;a href=\"&lt;%- config.root %&gt;&lt;%- item.path %&gt;\" target=\"_blank\" title=\"&lt;%= item.title %&gt;\"&gt;&lt;%= item.title %&gt;&lt;/a&gt;&lt;/b&gt;,本文链接为&lt;b&gt;&lt;a href=\"&lt;%- config.root %&gt;&lt;%- item.path %&gt;\" target=\"_blank\" title=\"&lt;%= item.title %&gt;\"&gt;&lt;%- config.url %&gt;/&lt;%- item.path %&gt;&lt;/a&gt;&lt;/b&gt;.&lt;/code&gt;&lt;/pre&gt; 大家可以看到这里就是一段HTML代码，因为我们要引入的这个模板和article.ejs在同一个页面中，所以我们可以直接在这里调用item这个变量，而item这个变量里是封装了当前文章的标题和链接的，因此我们可以顺利成章的构造这样一段HTML代码，因为博主不会写CSS样式，所以使用了一个默认的代码样式来完成这个工作，如果大家懂CSS，请自行发挥你的创意将它做得更好。好了，下面我们要做的工作就是将这个模版引用到article.ejs文件中，类似地我们可以使用&lt;%- partial(‘footer’) %&gt;这样的结构来引入这个模板，这里给出完整的article.ejs文件内容： 123456789101112131415161718192021222324252627282930313233&lt;div id=\"main\" class=\"&lt;%= item.layout %&gt;\" itemscope itemprop=\"blogPost\"&gt; &lt;% if (page.layout=='photo' &amp;&amp; item.photos &amp;&amp; item.photos.length)&#123; %&gt; &lt;%- partial('gallery') %&gt; &lt;% &#125; %&gt; &lt;article itemprop=\"articleBody\"&gt; &lt;%- partial('header') %&gt; &lt;div class=\"article-content\"&gt; &lt;% if(theme.show_declare) &#123; %&gt; &lt;%- partial('declare') %&gt; &lt;% &#125; %&gt; &lt;% if( table&amp;&amp;(item.toc !== false) &amp;&amp; theme.toc.article)&#123; %&gt; &lt;div id=\"toc\" class=\"toc-article\"&gt; &lt;strong class=\"toc-title\"&gt;&lt;%= __('contents') %&gt;&lt;/strong&gt; &lt;% if(item.list_number == false) &#123;%&gt; &lt;%- toc(item.content,&#123;list_number:false&#125;) %&gt; &lt;% &#125;else&#123; %&gt; &lt;%- toc(item.content) %&gt; &lt;% &#125; %&gt; &lt;/div&gt; &lt;% &#125; %&gt; &lt;%- item.content %&gt; &lt;% if(theme.show_declare) &#123; %&gt; &lt;%- partial('declare') %&gt; &lt;% &#125; %&gt; &lt;/div&gt; &lt;%- partial('footer') %&gt; &lt;/article&gt; &lt;%- partial('pagination') %&gt; &lt;%- partial('comment') %&gt;&lt;/div&gt; 这里博主在文章的开头和结尾处插入了这个模板，同时在主题文件夹中设置了一个是否显示版权声明的开关变量，这样我们就可以在主题中设置是否开启版权声明模块了。好啦，相信你在看到这边文章的时候你已经看到了它的版权声明了，这就是我们今天的内容啦，谢谢大家！","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://qinyuanpei.github.io/tags/Hexo/"},{"name":"版权","slug":"版权","permalink":"http://qinyuanpei.github.io/tags/版权/"},{"name":"知识共享","slug":"知识共享","permalink":"http://qinyuanpei.github.io/tags/知识共享/"}]},{"title":"解析OBJ模型并将其加载到Unity3D场景中","date":"2015-11-15T13:07:57.000Z","path":"posts/1124152964/","text":"&emsp;&emsp;各位朋友，大家好，欢迎大家关注我的博客，我是秦元培，我的博客地址是http://qinyuanpei.com。今天想和大家交流的是解析obj模型并将其加载到Unity3D场景中，虽然我们知道Unity3D是可以直接导入OBJ模型的，可是有时候我们并不能保证我们目标客户知道如何使用Unity3D的这套制作流程，可能对方最终提供给我们的就是一个模型文件而已，所以这个在这里做这个尝试想想还是蛮有趣的呢，既然如此，我们就选择在所有3D模型格式中最为简单的OBJ模型来一起探讨这个问题吧！ #关于OBJ模型&emsp;&emsp;OBJ格式是一种3D模型文件格式，是由Alias|Wavefront公司为3D建模和动画软件 “Advanced Visualizer”开发的一种标准，适合用于3D软件模型之间的互相转换。和FBX、Max这种内部私有格式不同，OBJ模型文件是一种文本文件，我们可以直接使用记事本等软件打开进行编辑和查看，因此我们这里选择OBJ模型主要是基于它开放和标准这两个特点。需要说明的是，OBJ文件是一种3D模型文件，它主要支持多边形模型（三个点以上的面）。OBJ模型支持法线和贴图坐标，可是因为它本身并不记录动画、材质特性、贴图路径、动力学及粒子等信息，所以我们在游戏开发中基本看不到这种模型格式的，所以我们这里做下简单研究就好。 #OBJ模型解读&emsp;&emsp;因为OBJ模型文件是一个文本文件，所以我们可以使用记事本等软件打开它来对它的文件结构进行下了解。首先OBJ文件没有头文件，如果你曾经尝试解析过mp3文件的ID3v1/ID3v2标签就应该知道它是根据mp3文件的开头或者末尾的若干字节来判断这些标签信息的，而在OBJ文件中是没有类似这样的头文件的。OBJ文件是由一行行由关键字、空格和文本字符组成的文本文件，通过关键字我们就可以知道这一行的文本表示的是什么数据。例如：1# Blender v2.76 (sub 0) OBJ File: '' #关键字表示一个注释行，通过这个注释信息我们可以知道这个OBJ模型是由Blender2.76版本导出的。再比如：1mtllib liumengli.mtl mtllib关键字则表示当前模型对应的材质库(.mtl)文件名称，每个OBJ模型文件都会有这样一个对应和它同名的.mtl文件，在这个文件中记录了材质相关的信息，稍后我们说到材质的时候会详细说说这个文件的格式，因为它和OBJ文件一样是一个文件文件。再比如：1usemtl Material__33 usemtl关键字则表示从当前行到下一个usemtl关键字所在行间的全部网格结构都使用其对应的材质，通过这个材质名称我们可以在.obj文件对应的.mtl文件中找到它的材质定义，这个我们在讲到材质部分的时候会详细说。 &emsp;&emsp;好了，目前我们要做的工作室解析.obj文件然后创建网格进而可以使其显示在Unity3D场景中，在这里我们要重点关注的关键字有： v即Vertex，表示一个顶点的局部坐标系中的坐标，通常有三个分量，因为这里讨论的是三角面。例如： 1v 1.5202 14.9252 -1.1004 vn即Vertex Normal，表示法线，注意到这些向量都是单位向量，所以我们可以认为三维软件在导出模型的时候已经做好了相关的标准化工作。 1vn 0.8361 -0.0976 0.5399 vt即Vertex Texture，表示纹理坐标，就是我们熟悉的UV坐标啦，显然UV是个2D坐标，有两个分量。 1vt -0.5623 0.4822 1.0000 f即face，这是一个真正描述面的关键字，通常它后面有三个索引结构，每个索引结构由顶点索引、法线索引和纹理坐标索引三部分构成。例如： 1f 256/303/637 257/304/638 258/305/639 以上这些关键字对我们解析.obj文件来说已经完全足够了，如果大家想对这些细节有更为深入的了解，可以参考这里这里。 #OBJ模型的读取&emsp;&emsp;OBJ模型的读取涉及到网格部分的读取和材质部分的读取两个部分，其中网格部分的读取难点在于当模型存在多个材质的时候，需要将模型分为若干个子物体，然后分别为这些子物体添加材质。可是不幸的是到目前为止，博主并没有找到一种行之有效的方法来对这些网格进行分类，所以这里我们假定模型是一个整体且共享同一种材质和一张贴图。如果大家找到了更好的解决方案，请记得告诉我，再次谢谢大家！ ##网格部分&emsp;&emsp;在网格读取这部分，因为我们已经假设所有的面构成一个物体，因此我们可以先将OBJ文件内的文本按照换行符来进行分割，然后再按照关键字去判断每一行的数据类型并进行相应的处理就可以了。读取OBJ模型的基本流程是： 读取顶点、法线、UV以及三角面 将三角面合并为四边面 根据索引重新计算顶点、法线、UV数组 ###读取顶点、法线、UV以及三角面&emsp;&emsp;首先我们来看第一步的代码实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/// &lt;summary&gt;/// 从一个文本化后的.obj文件中加载模型/// &lt;/summary&gt;public ObjMesh LoadFromObj(string objText)&#123; if(objText.Length &lt;= 0) return null; //v这一行前面是两个空格后面是一个空格 objText=objText.Replace(\" \", \" \"); //将文本化后的obj文件内容按行分割 string[] allLines = objText.Split('\\n'); foreach(string line in allLines) &#123; //将每一行按空格分割 string[] chars = line.Split(' '); //根据第一个字符来判断数据的类型 switch(chars[0]) &#123; case \"v\": //处理顶点 this.vertexArrayList.Add(new Vector3( ConvertToFloat(chars[1]), ConvertToFloat(chars[2]), ConvertToFloat(chars[3])) ); break; case \"vn\": //处理法线 this.normalArrayList.Add(new Vector3( ConvertToFloat(chars[1]), ConvertToFloat(chars[2]), ConvertToFloat(chars[3])) ); break; case \"vt\": //处理UV this.uvArrayList.Add(new Vector3( ConvertToFloat(chars[1]), ConvertToFloat(chars[2])) ); break; case \"f\": //处理面 GetTriangleList(chars); break; &#125; &#125; 在这段代码中，我们首先将文本化的.obj文件按照换行符分割成字符串数组allLines，然后再对每一行按照空格分隔成字符串数组chars，这样我们就可以通过该数组的第一个元素chars[0]来判断当前行中的数据类型。这样我们将每一行的文本读取完后，所有的数据都被存储到了其相对应的列表中。其中，vertexArrayList存储顶点信息、normalArrayList存储法线信息、uvArrayList存储UV坐标。至此，我们完成第一部分中的顶点、法线和UV的读取。 &emsp;&emsp;这里可以注意到我们在开始对文本化的.obj文件的内容有1次替换操作，这是因为在3dsMax中导出的.obj文件关键字v这一行中v后面的第一处空格位置是有2个空格，而我们在处理的时候是按照空格来分割每一行的内容的，这样chars[1]就会变成一个空字符串，显然这不符合我们的初衷，所以这里就需要对字符串进行这样一个操作，希望大家在解析的过程中注意，好吧，我承认我想吐槽3dsMax了，我不明白同一家公司的3dsMax和Maya为什么不能互相转换，我不明白3dsMax导出.obj文件的时候要做这样奇葩的设定，我更不明白为什么有开源、免费、轻巧的Blender都不去用非要每次都去安装容量动辄上G的盗版软件和不知道会不会变成下一个GhostXXXX的注册机，我更加不能容忍的是封闭的FBX格式和用起来就如同自虐的FBX SDK。 &emsp;&emsp;好了，吐槽结束，我们接下来来看看三角面是如何读取的。三角面的读取定义在GetTriangleList()方法中，因此三角面的读取实际上首先需要将每一行文本按照空格进行分割，然后再将每一个元素按照/分割，这样就可以依次得到顶点索引、法线索引和UV索引。在某些情况下法线索引可能不存在，所以在处理的过程中需要对其进行处理。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/// &lt;summary&gt;/// 获取面列表./// &lt;/summary&gt;/// &lt;param name=\"chars\"&gt;Chars.&lt;/param&gt;private void GetTriangleList(string[] chars)&#123; List&lt;Vector3&gt; indexVectorList = new List&lt;Vector3&gt;(); List&lt;Vector3&gt; triangleList = new List&lt;Vector3&gt;(); for(int i = 1; i &lt; chars.Length;++i ) &#123; //将每一行按照空格分割后从第一个元素开始 //按照/继续分割可依次获得顶点索引、法线索引和UV索引 string[] indexs = chars[i].Split('/'); Vector3 indexVector = new Vector3(0, 0); //顶点索引 indexVector.x = ConvertToInt(indexs[0]); //法线索引 if(indexs.Length &gt; 1)&#123; if(indexs[1] != \"\") indexVector.y = ConvertToInt(indexs[1]); &#125; //UV索引 if(indexs.Length &gt; 2)&#123; if(indexs[2] != \"\") indexVector.z = ConvertToInt(indexs[2]); &#125; //将索引向量加入列表中 indexVectorList.Add(indexVector); &#125; //这里需要研究研究 for(int j = 1; j &lt; indexVectorList.Count - 1; ++j) &#123; //按照0,1,2这样的方式来组成面 triangleList.Add(indexVectorList[0]); triangleList.Add(indexVectorList[j]); triangleList.Add(indexVectorList[j + 1]); &#125; //添加到索引列表 foreach(Vector3 item in triangleList) &#123; faceVertexNormalUV.Add(item); &#125;&#125; 在这里，我们首先使用一个索引向量列表indexVectorList存储每一行的索引向量。这里的索引向量是指由顶点索引、法线索引和UV索引分别构成Vector3的三个分量，这样做的好处是我们可以节省重新去定义数据机构的时间。好了，我们把所有的索引向量读取完后，按照0、1、2这样的方式组成三角面，这里可能是.obj文件本身定义的一种方式，我们暂且按照这样的方式来处理。最后，全部的三角面会被读取到faceVertexNormalUV列表中，它表示的是每个三角面的顶点、法线和UV的索引向量，是一个List类型的变量。 ###将三角面合并为四边面&emsp;&emsp;现在我们读取到的是三角面，接下来我们需要将它们合并成四边面，合并的原理是判断它们是否在同一个面上。如果两个点的顶点索引相同则表明它们是同一个点，如果两个点的法线索引相同则表明它们在同一个面上。好了，我们来看定义的一个方法Combine():123456789101112131415161718192021222324252627282930313233343536373839/// &lt;summary&gt;/// 合并三角面/// &lt;/summary&gt;private void Combine()&#123; //使用一个字典来存储要合并的索引信息 Dictionary&lt;int, ArrayList&gt; toCambineList = new Dictionary&lt;int,ArrayList&gt;(); for(int i = 0; i &lt; faceVertexNormalUV.Count; i++) &#123; if(faceVertexNormalUV[i] != Vector3.zero) &#123; //相同索引的列表 ArrayList SameIndexList = new ArrayList(); SameIndexList.Add(i); for(int j = 0; j &lt; faceVertexNormalUV.Count; j++) &#123; if(faceVertexNormalUV[j]!=Vector3.zero) &#123; if(i != j) &#123; //如果顶点索引和法线索引相同，说明它们在一个面上 Vector3 iTemp = (Vector3)faceVertexNormalUV[i]; Vector3 jTemp = (Vector3)faceVertexNormalUV[j]; if(iTemp.x == jTemp.x &amp;&amp; iTemp.y == jTemp.y) &#123; //将索引相同索引列表然后将其重置为零向量 //PS:这是个危险的地方，如果某个索引信息为Vector3.Zero //就会被忽略过去，可是貌似到目前为止没有发现为Vector3.Zero的情况 SameIndexList.Add(j); faceVertexNormalUV[j]=Vector3.zero; &#125; &#125; &#125; &#125; //用一个索引来作为字典的键名，这样它可以代替对应列表内所有索引 toCambineList.Add(i, SameIndexList); &#125; &#125; &#125; 在这里我们使用了一个字典来存储合并后的四边面，这个字典的键名为这一组三角面共同的索引，因为大家都是用同一个索引，因此它可以代替那些被合并的三角面的索引，这样合并以后的四边面列表中元素的个数就是实际的网格中的面数个数，因为如果采用三角面的话，这个面数会比现在的面数还要多，这意味着这样会带来更多的性能上的消耗。这里可能不大好理解，大家可以将博主这里的表达方式换成自己能够理解的方式。佛曰不可说，遇到这种博主自己都说不明白的地方，博主就只能请大家多多担待了。好了，接下来要做的是重新计算顶点、法线和UV数组。可能大家会比较疑惑，这部分内容我们在第一步不是就已经读取出来了嘛，怎么这里又要重新计算了呢？哈哈，且听我慢慢道来！ ###根据索引重新计算顶点、法线、UV数组&emsp;&emsp;虽然我们在第一步就读取到了这些坐标数据，可是当我们合并三角面以后，就会出现大量的无用的点，为什么无用呢，因为它被合并到四边面里了，这样我们原来读取的这些坐标数据就变得不适用了。那怎么办呢？在第三步中我们合并四边面的时候已经用一个字典保存了合并后的索引信息，这就相当于我们已经知道哪些是合并前的索引，哪些是合并后的索引，这个时候我们只要根据索引重新为数组赋值即可：123456789101112131415161718192021222324252627282930313233343536373839//初始化各个数组this.VertexArray = new Vector3[toCambineList.Count];this.UVArray = new Vector2[toCambineList.Count];this.NormalArray = new Vector3[toCambineList.Count];this.TriangleArray = new int[faceVertexNormalUV.Count];//定义遍历字典的计数器int count = 0;//遍历词典foreach(KeyValuePair&lt;int,ArrayList&gt; IndexTtem in toCambineList)&#123; //根据索引给面数组赋值 foreach(int item in IndexTtem.Value) &#123; TriangleArray[item] = count; &#125; //当前的顶点、UV、法线索引信息 Vector3 VectorTemp = (Vector3)faceVertexNormalUV[IndexTtem.Key]; //给顶点数组赋值 VertexArray[count] = (Vector3)vertexArrayList[(int)VectorTemp.x - 1]; //给UV数组赋值 if(uvArrayList.Count &gt; 0) &#123; Vector3 tVec =(Vector3)uvArrayList[(int)VectorTemp.y - 1]; UVArray[count] = new Vector2(tVec.x, tVec.y); &#125; //给法线数组赋值 if(normalArrayList.Count &gt; 0) &#123; NormalArray[count] = (Vector3)normalArrayList[(int)VectorTemp.z - 1]; &#125; count++; &#125; 这样我们就读取到了合并后的坐标信息，通过顶点、法线、UV、面等信息我们现在就可以生成网格了。这部分我们暂且不着急，因为这基本上属于最后整合到Unity3D中步骤了。好了，为了方便大家理解，我已经完整的项目上传到Github，大家可以通过这里了解完整的项目。 ##材质部分&emsp;&emsp;材质这块儿的解析主要集中在.mtl文件中，和.obj文件类似，它同样是一个文本文件、同样采用关键字、空格、文本字符这样的结构来表示数据，因此我们可以借鉴.obj文件的读取。例如：1newmtl Material newmtl关键字表示从当前行到下一个newmtl关键字所在行间都表示该关键字所对应的材质，这里的Material即表示材质的名称，它和.obj文件中的usemtl关键字相对应，因此我们给模型添加材质的过程本质上是从.obj文件中读取网格，然后找到其对应的材质名称，然后在.mtl文件中找到对应的材质定义，并根据定义来生成材质。目前已知的关键字有：1Ka 0.5880 0.5880 0.5880 Ka关键字表示环境反射的RGB数值。 1Kd 0.640000 0.640000 0.640000 Kd关键字表示漫反射的RGB数值。 1Ks 0.500000 0.500000 0.500000 Ks关键字表示镜面反射的RGB数值。 1map_Ka E:\\学习资料\\Unity3D技术\\Unity3D素材\\柳梦璃\\Texture\\1df2eaa0.dds map_Ka关键字表示环境反射的纹理贴图，注意到这里使用的是绝对路径，显然我们在读取模型的时候不会将贴图放在这样一个固定的路径，因此我们这里初步的想法读取贴图的文件名而非贴图的完整路径，考虑到我们在Unity3D中一般使用PNG格式的贴图，因此这里需要对路径进行处理。 1map_Kd E:\\学习资料\\Unity3D技术\\Unity3D素材\\柳梦璃\\Texture\\1df2eaa0.dds map_Kd关键字表示漫反射的纹理贴图，和环境反射的纹理贴图是类似地，这里就不再说了。此外还有其它的关键字，初步可以推断出的结论是它和3dsMax中材质编辑器里的定义特别地相似，感兴趣的朋友可以进一步去研究。可是现在就有一个新的问题了，怎样将这些参数和Unity3D里的材质关联起来呢？我们知道Unity3D里的材质是是由着色器和贴图两部分组成的，博主对Shader并不是很熟悉，因此这里确实有些说不清楚了。博主感觉对OBJ文件来说，其实使用Diffuse就完全足够了，所以这里对材质部分的研究我们点到为止，不打算做代码上的实现。如果不考虑这些参数的话，我们要做的就是通过WWW或者Resource将贴图加载进来，然后赋值给我们通过代码创建的Shader即可。而对于.obj文件来说，无论是通过Resource、WWW或者是IO流，只要我们拿到了这个文件中的内容就可以使用本文中的方式加载进来，因为我们假定的是读取只有一种材质的模型。有朋友可能要问，那如果有多种材质怎么办呢？答案是在.mtl问价中获取到所有贴图的名称，然后再到程序指定的路径去读取贴图，分别为其创建不同的材质，可是这些材质要怎么附加到它对应的物体上呢？这个目前博主没有找到解决的方法，所以此事暂且作罢吧！ #在Unity3D中加载obj模型&emsp;&emsp;下面我们以一个简单的例子来展示今天研究的成果，我们将从.obj文件中读取出一个简单的模型并将其加载到场景中。好了，我们一起来看代码：123456789101112131415161718192021222324if(!File.Exists(\"D:\\\\cube.obj\")) Debug.Log(\"请确认obj模型文件是否存在!\");StreamReader reader = new StreamReader(\"D:\\\\cube.obj\",Encoding.Default);string content = reader.ReadToEnd();reader.Close();ObjMesh objInstace = new ObjMesh();objInstace = objInstace.LoadFromObj(content); Mesh mesh = new Mesh();mesh.vertices = objInstace.VertexArray;mesh.triangles = objInstace.TriangleArray;if(objInstace.UVArray.Length &gt; 0) mesh.uv = objInstace.UVArray;if(objInstace.NormalArray.Length&gt;0) mesh.normals = objInstace.NormalArray;mesh.RecalculateBounds(); GameObject go = new GameObject();MeshFilter meshFilter = go.AddComponent&lt;MeshFilter&gt;();meshFilter.mesh = mesh; MeshRenderer meshRenderer = go.AddComponent&lt;MeshRenderer&gt;(); 这里没有处理材质，所以读取出来就是这个样子的，哈哈！ 最终效果，这是一个悲伤的故事 材质大家可以尝试用代码去创建一个材质，然后在给一张贴图，这个玩玩就好，哈哈！好了，今天的内容就是这样子了，希望大家喜欢，为了写这篇文章我都怀疑我是不是有拖延症啊！","tags":[{"name":"Unity3D","slug":"Unity3D","permalink":"http://qinyuanpei.github.io/tags/Unity3D/"},{"name":"OBJ","slug":"OBJ","permalink":"http://qinyuanpei.github.io/tags/OBJ/"},{"name":"格式","slug":"格式","permalink":"http://qinyuanpei.github.io/tags/格式/"}]},{"title":"Unity3D游戏开发之分页效果在uGUI中的实现","date":"2015-11-10T20:46:35.000Z","path":"posts/166983157/","text":"&emsp;&emsp;各位朋友大家好，我是秦元培，欢迎大家关注我的博客，我的博客地址是http://qinyuanpei.com。今天想和大家分享的是uGUI中分页效果的实现，我们知道相对NGUI来说uGUI在功能覆盖上来讲，它并没有像NGUI那样提供较为丰富和炫酷的组件，可是因为uGUI有着较好的扩展性，因此我们可以通过编写脚本来扩展它的功能。虽然在移动开发时代以开发速度论成败，可是这并不是我们“不求甚解”的正当理由。每次看到NGUI各种”丰富”的组件在脑海中打转的时候，每次看到编译项目时弹出各种Warming的时候，我内心是如此地期望有这样一个简单高效的UI系统啊，直到有一天我遇上了uGUI。 &emsp;&emsp;好了，博主这里并没有想要表达厚此薄彼的观点啦，博主真正想要表达的是我们在开发中应该摒弃“唯语言论”、“唯平台论”的狭隘观点，努力去掌握和语言无关、平台无关的“通用型技能”。这样，当我们面对全新的任务的时候我们可以更快地适应新的环境。言归正传，我们这里来接着说uGUI中的分页，分页通常是指将内容分散到不同的页面上来显示的一种手段，这种手段我们在传统的Web开发中可以经常看到。到了移动互联网以后分页被我们更为熟知的“下拉更新”所替代，这种方式我们就更为熟悉啦。好了，我们回到分页，为什么要要分页呢？这里有两个关键点：第一，内容在一页内无法展示完全；第二，对内容的数量无法进行估计。 &emsp;&emsp;例如，我们在uGUI中可以使用ScrollRect组件 + GridLayout组件 + Mask组件实现一个滚动列表，具体的案例可以参考这里。这里我们可以注意到一件事情就是这个滚动列表，它可以滚动的范围是由Mask组件来决定的，因此这个滚动列表是无法无限滚动的，虽然我们知道在游戏设计中不会出现这种无限滚动的列表，可是我们这里是为了探讨这个问题，所以我们假设这个情况是允许发生的。那么面对这个问题，我们有什么好的解决方案呢？博主尝试过一种思路，即借鉴Android中的ListView控件，这个控件的特点是可以对列表中的项目进行回收。相信说到这里，大家都明白我想做什么了吧，大概的思路就是制作一个高度大于屏幕高度的列表，然后让所有的列表项在这个列表中循环显示。可是新的问题就来了，第一，频繁地生成和销毁物体是Unity3D大忌。虽然我们可以缓存池来解决这个问题，可是因为博主并没有具体这样实践过，所以这里目前是存疑的。第二，GridLayout这个组件内的元素排序是根据子元素添加的顺序来决定的，因此每次列表更新以后都需要将所有的子元素更新一遍。曾经因为这样需求和策划发生过争执，最终妥协的一个结果就是采用分页来解决这个问题。分页首先解决了无限滚动的需求，因为它是一种“以不变应万变”的策略，不论列表内元素有多少它都可以显示出来。其次，在分页的过程是将数据模板化的过程，它改变是界面的外观和行为，UI结构是相对稳定的，这样可以避免频繁地生成和销毁物体。 &emsp;&emsp;下面我们以一个简单的案例来探讨分页效果在uGUI中的实现，首先我们使用GridLayoutGroup来制作一个简单的网格布局，请用心感受下图中萌萌哒十二生肖： 请不要伤害一个程序员的艺术细胞，虽然我知道它比较难看 这里我们不再对这个布局的制作方法进行详细的说明，因为我们今天的重点不在这里。我们注意到这里有12个元素，当我们每次对页面进行切换的时候，实际上这12个元素是基本不会发生变化的，真正变化的是这些元素的外观（如这里的精灵图片和名称）以及其对应的UI事件，在这个案例中我们利用匿名函数实现了一个简单的Click事件的监听。好了，前面我们说到分页的一个目的是可以解决列表内元素数目不确定的问题，因此我们这里利用一个12生肖的数组来随机生成元素数目不同的列表，代码实现如下：12345678910111213141516171819202122232425262728293031323334353637383940/// &lt;summary&gt; /// 初始化元素 /// &lt;/summary&gt; private void InitItems() &#123; //准备一个存储着12生肖信息的数组 GridItem[] items = new GridItem[] &#123; new GridItem(\"鼠\",\"Mouse\"), new GridItem(\"牛\",\"Ox\"), new GridItem(\"虎\",\"Tiger\"), new GridItem(\"兔\",\"Rabbit\"), new GridItem(\"龙\",\"Dragon\"), new GridItem(\"蛇\",\"Snake\"), new GridItem(\"马\",\"Horse\"), new GridItem(\"羊\",\"Goat\"), new GridItem(\"猴\",\"Monkey\"), new GridItem(\"鸡\",\"Rooster\"), new GridItem(\"狗\",\"Dog\"), new GridItem(\"猪\",\"Pig\") &#125;; //利用12生肖数组来随机生成列表 m_ItemsList = new List&lt;GridItem&gt;(); for(int i = 0; i &lt; Random.Range(1,1000); i++) &#123; m_ItemsList.Add(items[Random.Range(0,items.Length)]); &#125; //计算元素总个数 m_ItemsCount = m_ItemsList.Count; //计算总页数 m_PageCount = (m_ItemsCount % 12) == 0 ? m_ItemsCount / 12 : (m_ItemsCount / 12) + 1; BindPage(m_PageIndex); //更新界面页数 m_PanelText.text = string.Format(\"&#123;0&#125;/&#123;1&#125;\", m_PageIndex.ToString(), m_PageCount.ToString()); &#125; 在这段代码中，m_ItemList表示我们要展示的元素列表，m_ItemsCount表示元素列表中元素的个数，m_PageCount表示这些元素可以分成的总页数，m_PageIndex表示页数的索引默认从1开始。其中GridItem是一个简单的类，它有ItemName和ItemSprite两个属性，这里不再具体说明了。好了，现在我们来思考如何将这些元素和UI对应起来，因为列表中元素的数目不确定，因此我们可以分成两种情况来讨论： 页面总数为1，即m_PageCount=1，此时列表内的元素个数的范围是1~12，因此我们可以利用循环判断哪些元素是要展示的？哪些元素是不需要的？因为如果此时列表内的元素为10，则意味着前面10个元素是要展示给用户，而剩下的2个元素是不需要的。在这里我们简单地使用SetActive来让这些元素隐藏起来。 页面总数大于1，即m_PageCount&gt;1，此时前面的m_PageCount-1个页面都是显示完全的，它相当于元素总个数中被12整除的部分。而第m_PageCount个页面此时的情况和页数总数为1的情况类似，我们可以采取和页面总数为1类似的方法来处理。 &emsp;&emsp;好了，下面我们来看这部分代码的具体实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/// &lt;summary&gt;/// 绑定指定索引处的页面元素/// &lt;/summary&gt;/// &lt;param name=\"index\"&gt;页面索引&lt;/param&gt;private void BindPage(int index)&#123; //列表处理 if(m_ItemsList == null || m_ItemsCount &lt;= 0) return; //索引处理 if(index &lt; 0 || index &gt; m_ItemsCount) return; //按照元素个数可以分为1页和1页以上两种情况 if(m_PageCount == 1) &#123; int canDisplay = 0; for(int i = 12; i &gt; 0; i--) &#123; if(canDisplay &lt; 12)&#123; BindGridItem(transform.GetChild(canDisplay), m_ItemsList[12 - i]); transform.GetChild(canDisplay).gameObject.SetActive(true); &#125;else&#123; //对超过canDispaly的物体实施隐藏 transform.GetChild(canDisplay).gameObject.SetActive(false); &#125; canDisplay += 1; &#125; &#125;else if(m_PageCount &gt; 1)&#123; //1页以上需要特别处理的是最后1页 //和1页时的情况类似判断最后一页剩下的元素数目 //第1页时显然剩下的为12所以不用处理 if(index == m_PageCount)&#123; int canDisplay = 0; for(int i = 12; i &gt; 0; i--) &#123; //最后一页剩下的元素数目为 m_ItemsCount - 12 * (index-1) if(canDisplay &lt; m_ItemsCount - 12 * (index-1))&#123; BindGridItem(transform.GetChild(canDisplay), m_ItemsList[12 * index-i]); transform.GetChild(canDisplay).gameObject.SetActive(true); &#125;else&#123; //对超过canDispaly的物体实施隐藏 transform.GetChild(canDisplay).gameObject.SetActive(false); &#125; canDisplay += 1; &#125; &#125; else&#123; for(int i = 12; i &gt; 0; i--) &#123; BindGridItem(transform.GetChild(12 - i), m_ItemsList[12 * index - i]); transform.GetChild(12 - i).gameObject.SetActive(true); &#125; &#125; &#125;&#125; 好了，在这里完成BindPage方法的定义以后，我们就可以指定程序显示对应页面的元素，此时上一页和下一页的工作基本上就是改变索引的一个过程了。这部分我们不再说了，大家可以去看最终给出的完整代码，我们这里来看看实际的效果吧！ 简单的分页效果展示 其实这里核心的内容是分页的处理，在处理里只有1页时的元素个数和超过1页的最后1页时我们可以采取两个循环处理的方法，即先从0循环到m_ItemsCount - 12 (index-1))设置要显示的元素，然后再从m_ItemsCount - 12 (index-1))循环到12设置要隐藏的元素，可是这样的方式我不太喜欢，所以在文章中就没有采取这样的方式。这篇文章是根据一个项目当时的经历写的，因为时间过得比较久，所以如果文章中不当之处希望大家指出并批评。现在这个方案感觉还可以在特效上进行改进，因为现在感觉切换的时候画面比较突兀，这一点请大家注意。好了，下面给出完整的代码和场景布局截图。再次强调：请在看懂文章的基础上“抄”代码，每次看到别人问我把XXX脚本挂到场景中不起作用这类的问题，我就觉得整个世界充满了深深地罪恶感。别人愿意分享技术文章，更多的是希望可以和别人交流学习相互促进，如果你只是希望拿到一个随便抄来就能用地代码，抱歉！这违背了我的初衷所以我很难做到！123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249/* * 一个基于uGUI的分页功能的实现 * 作者：秦元培 * 时间：2015年11月11日 * 博客：http://qinyuanpei.com */using UnityEngine;using System.Collections;using System.Collections.Generic;using UnityEngine.UI;public class PaginationPanel : MonoBehaviour&#123; /// &lt;summary&gt; /// 当前页面索引 /// &lt;/summary&gt; private int m_PageIndex = 1; /// &lt;summary&gt; /// 总页数 /// &lt;/summary&gt; private int m_PageCount = 0; /// &lt;summary&gt; /// 元素总个数 /// &lt;/summary&gt; private int m_ItemsCount = 0; /// &lt;summary&gt; /// 元素列表 /// &lt;/summary&gt; private List&lt;GridItem&gt; m_ItemsList; /// &lt;summary&gt; /// 上一页 /// &lt;/summary&gt; private Button m_BtnPrevious; /// &lt;summary&gt; /// 下一页 /// &lt;/summary&gt; private Button m_BtnNext; /// &lt;summary&gt; /// 显示当前页数的标签 /// &lt;/summary&gt; private Text m_PanelText; void Start() &#123; InitGUI(); InitItems(); &#125; /// &lt;summary&gt; /// 初始化GUI /// &lt;/summary&gt; private void InitGUI() &#123; m_BtnNext = GameObject.Find(\"Canvas/Panel/BtnNext\").GetComponent&lt;Button&gt;(); m_BtnPrevious = GameObject.Find(\"Canvas/Panel/BtnPrevious\").GetComponent&lt;Button&gt;(); m_PanelText = GameObject.Find(\"Canvas/Panel/Text\").GetComponent&lt;Text&gt;(); //为上一页和下一页添加事件 m_BtnNext.onClick.AddListener(() =&gt; &#123; Next(); &#125;); m_BtnPrevious.onClick.AddListener(() =&gt; &#123; Previous(); &#125;); &#125; /// &lt;summary&gt; /// 初始化元素 /// &lt;/summary&gt; private void InitItems() &#123; //准备一个存储着12生肖信息的数组 GridItem[] items = new GridItem[] &#123; new GridItem(\"鼠\",\"Mouse\"), new GridItem(\"牛\",\"Ox\"), new GridItem(\"虎\",\"Tiger\"), new GridItem(\"兔\",\"Rabbit\"), new GridItem(\"龙\",\"Dragon\"), new GridItem(\"蛇\",\"Snake\"), new GridItem(\"马\",\"Horse\"), new GridItem(\"羊\",\"Goat\"), new GridItem(\"猴\",\"Monkey\"), new GridItem(\"鸡\",\"Rooster\"), new GridItem(\"狗\",\"Dog\"), new GridItem(\"猪\",\"Pig\") &#125;; //利用12生肖数组来随机生成列表 m_ItemsList = new List&lt;GridItem&gt;(); for(int i = 0; i &lt; Random.Range(1,1000); i++) &#123; m_ItemsList.Add(items[Random.Range(0,items.Length)]); &#125; //计算元素总个数 m_ItemsCount = m_ItemsList.Count; //计算总页数 m_PageCount = (m_ItemsCount % 12) == 0 ? m_ItemsCount / 12 : (m_ItemsCount / 12) + 1; BindPage(m_PageIndex); //更新界面页数 m_PanelText.text = string.Format(\"&#123;0&#125;/&#123;1&#125;\", m_PageIndex.ToString(), m_PageCount.ToString()); &#125; /// &lt;summary&gt; /// 下一页 /// &lt;/summary&gt; public void Next() &#123; if(m_PageCount &lt;= 0) return; //最后一页禁止向后翻页 if(m_PageIndex &gt;= m_PageCount) return; m_PageIndex += 1; if (m_PageIndex &gt;= m_PageCount) m_PageIndex = m_PageCount; BindPage(m_PageIndex); //更新界面页数 m_PanelText.text = string.Format(\"&#123;0&#125;/&#123;1&#125;\", m_PageIndex.ToString(), m_PageCount.ToString()); &#125; /// &lt;summary&gt; /// 上一页 /// &lt;/summary&gt; public void Previous() &#123; if(m_PageCount &lt;= 0) return; //第一页时禁止向前翻页 if(m_PageIndex &lt;= 1) return; m_PageIndex -= 1; if(m_PageIndex &lt; 1) m_PageIndex = 1; BindPage(m_PageIndex); //更新界面页数 m_PanelText.text = string.Format(\"&#123;0&#125;/&#123;1&#125;\", m_PageIndex.ToString(), m_PageCount.ToString()); &#125; /// &lt;summary&gt; /// 绑定指定索引处的页面元素 /// &lt;/summary&gt; /// &lt;param name=\"index\"&gt;页面索引&lt;/param&gt; private void BindPage(int index) &#123; //列表处理 if(m_ItemsList == null || m_ItemsCount &lt;= 0) return; //索引处理 if(index &lt; 0 || index &gt; m_ItemsCount) return; //按照元素个数可以分为1页和1页以上两种情况 if(m_PageCount == 1) &#123; int canDisplay = 0; for(int i = 12; i &gt; 0; i--) &#123; if(canDisplay &lt; 12)&#123; BindGridItem(transform.GetChild(canDisplay), m_ItemsList[12 - i]); transform.GetChild(canDisplay).gameObject.SetActive(true); &#125;else&#123; //对超过canDispaly的物体实施隐藏 transform.GetChild(canDisplay).gameObject.SetActive(false); &#125; canDisplay += 1; &#125; &#125;else if(m_PageCount &gt; 1)&#123; //1页以上需要特别处理的是最后1页 //和1页时的情况类似判断最后一页剩下的元素数目 //第1页时显然剩下的为12所以不用处理 if(index == m_PageCount)&#123; int canDisplay = 0; for(int i = 12; i &gt; 0; i--) &#123; //最后一页剩下的元素数目为 m_ItemsCount - 12 * (index-1) if(canDisplay &lt; m_ItemsCount - 12 * (index-1))&#123; BindGridItem(transform.GetChild(canDisplay), m_ItemsList[12 * index-i]); transform.GetChild(canDisplay). gameObject.SetActive(true); &#125;else&#123; //对超过canDispaly的物体实施隐藏 transform.GetChild(canDisplay). gameObject.SetActive(false); &#125; canDisplay += 1; &#125; &#125; else&#123; for(int i = 12; i &gt; 0; i--) &#123; BindGridItem(transform.GetChild(12 - i), m_ItemsList[12 * index - i]); transform.GetChild(12 - i).gameObject.SetActive(true); &#125; &#125; &#125; &#125; /// &lt;summary&gt; /// 加载一个Sprite /// &lt;/summary&gt; /// &lt;param name=\"assetName\"&gt;资源名称&lt;/param&gt; private Sprite LoadSprite(string assetName) &#123; Texture texture = (Texture)Resources.Load(assetName); Sprite sprite = Sprite.Create((Texture2D)texture, new Rect(0, 0, texture.width, texture.height), new Vector2(0.5f, 0.5f)); return sprite; &#125; /// &lt;summary&gt; /// 将一个GridItem实例绑定到指定的Transform上 /// &lt;/summary&gt; /// &lt;param name=\"trans\"&gt;&lt;/param&gt; /// &lt;param name=\"gridItem\"&gt;&lt;/param&gt; private void BindGridItem(Transform trans,GridItem gridItem) &#123; trans.GetComponent&lt;Image&gt;().sprite = LoadSprite(gridItem.ItemSprite); trans.Find(\"Item/Name\").GetComponent&lt;Text&gt;().text = gridItem.ItemName; trans.GetComponent&lt;Button&gt;().onClick.AddListener(()=&gt; &#123; Debug.Log(\"当前点击的元素名称为:\" + gridItem.ItemName); &#125;); &#125;&#125; 好了，今天的内容就是这样啦，欢迎大家继续关注我的博客，谢谢大家！ 2016年1月10日更新：&emsp;&emsp;经过博客中一位朋友指出，这篇文章中实现BindPage这个方法时可以在代码上再精简些，主要是考虑这个代码中有部分功能是重合的，因此这里对这个方法进行重写，分页从本质上来讲是编写这样一个函数：输入数据集合data、每页显示的元素个数pageSize以及当前页数page，然后返回一个新的数据集合。为了考虑扩展性我们这里编写一个分页的泛型方法，代码实现如下：12345678910111213141516171819202122232425262728293031323334List&lt;T&gt; Pagination(List&lt;T&gt; data,int size,int page)&#123; //要返回的结果 List&lt;T&gt; output = new List&lt;T&gt;(); //计算最大页数 int PageCount = (data.Count % size) == 0 ? (data.Count / size) : (data.Count / size) + 1; //判断输入页数的合法性 if(page &lt; 1 || page &gt; PageCount) return null; //计算第page页第一个元素的索引 int startIndex = (page - 1) * size; //除了尾页所有的页面中元素个数都是size个 if(page &lt; PageCount) &#123; for (int i = 0; i &lt; size; i++) &#123; output.Add(data[startIndex + i]); &#125; &#125; else &#123; for (int i = startIndex; i &lt; data.Count; i++) &#123; output.Add(data[i]); &#125; &#125; return output;&#125; 这里我们只需要考虑传入的页数是不是尾页即可，因为在所有的页面中除了尾页以外都有size个元素，所以我们只需要计算出第page页的第一个元素的索引，然后以此递增即可，而尾页显然是从startIndex到data.Count-1个。现在回过头来看，写个分页函数确实是简单至极，这篇博客显然是小题大做了。","tags":[{"name":"Unity3D","slug":"Unity3D","permalink":"http://qinyuanpei.github.io/tags/Unity3D/"},{"name":"游戏开发","slug":"游戏开发","permalink":"http://qinyuanpei.github.io/tags/游戏开发/"},{"name":"uGUI","slug":"uGUI","permalink":"http://qinyuanpei.github.io/tags/uGUI/"}]},{"title":"EasyAR尝鲜系列教程之自定义Marker的实现","date":"2015-11-03T10:23:14.000Z","path":"posts/1156673678/","text":"&emsp;&emsp;各位朋友大家好，欢迎大家关注我的博客，我是秦元培，我的博客地址是http://qinyuanpei.com。通过本系列第一篇文章，我们初步了解了EasyAR这个增强现实引擎，这次我们来尝试自己定义一个Marker，这样我们就可以用自己喜欢的图片来作为Marker。因为目前EasyAR文档并不完善，所以下面的这些内容可能更多的是我个人的尝试和探索。如果大家对此感兴趣的话继续往下看否则就不要往下看了，因为我担心在官方正式文档出来以后大家可能会骂我啊。好了，对这个话题感兴趣的朋友就请继续往下看吧！ #EasyAR的基本流程&emsp;&emsp;首先我们来看看官方给出的一张EasyAR的基本流程示意图： EasyAR基本流程示意图 在这张流程图，当中作为开发者的我们此刻需要关注的Target这一条线和Frame这条线。前者对应的是如何将普通的图片如.jpg、.png配合JSON文件转化为系统可以识别的Target，后者对应的是我们在识别到Target后要去处理哪些逻辑。在官方文档中我们可以找到这样一段话： 创建相机设备、图像追踪器和增强对象（Create CameraDevice and ImageTracker and Augmenter objects）. 打开相机设备（Open CameraDevice）. 给相机设备附加图像追踪器（Attach ImageTracker to CameraDevice）. 开始执行相机设备和图形追踪器的相关逻辑（Start CameraDevice and ImageTracker）. 获得从图像追踪器增强后的帧画面（New frame using Augmenter from ImageTracker）. 绘制视频和其它的内容（Draw video background and other stuffs）. 这段话基本上就是EasyAR流程示意图的全面解读了，所以我们学习EasyAR可以从这个基本流程来入手，了解这个流程能帮助我们更快地理解API接口，虽然现在官方的API文档依然处在Debug状态下，想到这里简直各种不开心啊！ #创建自定义Marker&emsp;&emsp;在了解了EasyAR的基本流程后，我们就来说说如何在EasyAR中创建自定义Marker吧！相信使用过Vuforia的人都知道要创建一个自定义的Marker需要到开发者后台去创建然后下载资源包，这种方式虽然高效、直接，可是因为没有人为地干预过程，所以我们对AR引擎内部究竟做了怎样的处理基本上是一无所知的，换句话说我们大部分的工作都是在做黑箱测试。到了EasyAR这里，一切就变得特别简单，这一点要给EasyAR点个赞。首先在EasyAR中配置Marker是通过StreamingAssets目录下的dataset.json这个文件来实现的：123456789101112131415&#123; \"images\" : [ &#123; \"image\" : \"mousepad.jpg\", \"name\" : \"mousepad\" &#125;, &#123; \"image\" : \"idback.jpg\", \"name\" : \"idback\", \"size\" : [8.56, 5.4], \"uid\" : \"todo=uid-string\" &#125; ]&#125; 从这个文件中我们可以发现每一张图片都具有某些不同的属性，从目前博主掌握的资料来看，每张图片最重要的两个属性是image和name。其中image是指图片的相对路径，该路径相对于StreamingAssets目录，因为我们做Unity3D游戏开发的时候都知道这个目录下的资源在编译的时候不会被压缩，当导出APK安装包的时候它会被完整的保留到根目录下的assets目录中。同样地，name是指图片的名称即ID，EasyAR正是通过这个ID来和图片资源关联起来的。比如在默认的SDK项目中身份证背面这张图片是和idback这个ID对应的，如图所示，在这里Easy提供了四种存储方案即Assets、App、Absolute、Json。和官方的人交流的时候说可以支持路径和Json字符串两种形式，但是对更加具体的这四种存储方案上的区别和优缺点目前并没有一个确切的说法，所以在这里我们就继续沿用Assets这种存储方案吧！我们可以注意到idback这张图片和mousepad这张图片相比增加了两个属性，即uid和size。size目前基本可以了解为Unity3D中的缩放，因为这个值表示的是在物理空间里的范围大小，单位是米，而我们知道Unity3D里默认的单位就是米，所以这个数值可以暂时理解为Unity3D里的缩放，它对应到下图里的Size，我已经用红色字体标示出来。对于uid这个属性嘛，既然配置文件里都有todo标识出来了，那么我们就姑且认为这是一个暂时没有启用的属性值吧！ 好了，下面我们来具体看看如何创建一个自定义Markder。 首先我们在StreamingAssets目录中添加一张图片ziying.jpg，然后在dataset.json文件中增加该图片的信息。此时ziying.jpg的位置是在StreamingAssets根目录下。如果我们希望把它放在一个自定义的文件夹中，如StreamingAssets/ziying目录下，则需要将ziying的image属性值改为ziying/ziying.jpg，以此类推。 12345678910111213141516171819&#123; \"images\" : [ &#123; \"image\" : \"mousepad.jpg\", \"name\" : \"mousepad\" &#125;, &#123; \"image\" : \"ziying.jpg\", \"name\" : \"ziying\" &#125;, &#123; \"image\" : \"idback.jpg\", \"name\" : \"idback\", \"size\" : [8.56, 5.4], \"uid\" : \"todo=uid-string\" &#125; ]&#125; 在Materials目录下新建一个材质，然后找到ziying.jpg将其作为该材质的纹理贴图。 在场景中找到ImageTargetDataSet-idback节点，修改其附加的SimpleImageTargetBehaviour脚本下的Name属性，将其修改为ziying，同时将第二步创建的材质赋给ImageTargetDataSet-idback节点。此时场景效果如图所示，这意味着我们使用手机摄像头来扫描这张图片就可以看到场景中的这个模型啦！ 自定义Markder效果 好了，现在编译这个项目并部署到手机上可以得到我们期望的结果，哈哈，慕容紫英站在桌面上和我一起玩对一个仙剑迷来说是不是特别有趣呢？ 站在手机上的慕容紫英 #总结&emsp;&emsp;到目前为止，EasyAR官方还没有给出一个完整的API文档，所以我们目前能做的研究依然十分有限，在本文中涉及到的部分没有解决的问题，博主会在官方给出文档后第一时间给予解决，希望大家继续关注我的博客！我们现在使用的都是SDK中现成的脚本，如果我们希望自己来设计脚本来满足自己的要求实现某些定制的功能或者是想用原生代码来减少Unity3D这类游戏引擎带来的性能上的损耗以及实现播放视频的功能等等。这些内容博主在稍后会陆续写出来，好了，今天的内容就是这个样子啦！希望大家喜欢。","tags":[{"name":"Unity3D","slug":"Unity3D","permalink":"http://qinyuanpei.github.io/tags/Unity3D/"},{"name":"增强现实","slug":"增强现实","permalink":"http://qinyuanpei.github.io/tags/增强现实/"},{"name":"AR","slug":"AR","permalink":"http://qinyuanpei.github.io/tags/AR/"}]},{"title":"教你一步步实现一个虚拟摇杆","date":"2015-10-30T09:44:18.000Z","path":"posts/331752533/","text":"&emsp;&emsp;各位朋友，大家好，我是秦元培，欢迎大家关注我的博客，我的博客地址是http://qinyuanpei.com。最近因为项目需要决定尝试自己来实现一个虚拟摇杆，所以在今天的文章中我们的目标是使用uGUI来制作一个可以在移动平台稳定运行的虚拟摇杆(请不要问我为什么不使用NGUI来实现，你说我做个虚拟摇杆有必要在项目里导入那么多的资源嘛23333)。关于使用第三方插件来实现虚拟摇杆，请大家参照我以前写的文章Unity3D游戏开发之使用EasyTouch虚拟摇杆控制人物移动，在这里就不再赘述了。 &emsp;&emsp;虚拟摇杆这种输入方式相信大家在手机游戏平台上已经相当的熟悉了，首先我们来简单了解下虚拟摇杆的设计原理。虚拟摇杆有一张固定的2D贴图(背景层)和一张可拖动的2D贴图(控制层)构成，默认情况下控制层在背景层的中心，我们称这个位置为初始位置，当移动控制层后移动层的位置会发生变化，此时控制层的当前位置和初始位置两点间可以计算出一个2D向量，通过这个向量我们就可以判断虚拟摇杆的移动方向。在经典的八方向摇杆导航中摇杆中可移动方向被分成了上、左上、右上、下、左下、右下、左、右共8个方向。我们知道根据三角函数可以非常容易地计算出这个2D向量的角度并由此判定摇杆是在向着这8个方向中的哪一个方向移动。在今天的文章中，我们不需要考虑这8个方向，因为我们可以向任何一个方向进行移动。 &emsp;&emsp;好了，首先在场景中创建两个Image组件和一个空的游戏体，然后将这两个Image组件拖拽到这个空的游戏体下使它们称为其子节点。这里需要注意的是这两个Image的层级关系。现在我们来编写脚本，这个脚本将被添加到控制层物体上：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161/* * uGUI虚拟摇杆 * 作者：秦元培 * 博客：http://qinyuanpei.com * 时间：2015年10月24日 */using UnityEngine;using System.Collections;using UnityEngine.UI;using UnityEngine.EventSystems;public class JoyStick : MonoBehaviour,IPointerDownHandler, IPointerUpHandler, IDragHandler&#123; /// &lt;summary&gt; /// 摇杆最大半径 /// 以像素为单位 /// &lt;/summary&gt; public float JoyStickRadius = 50; /// &lt;summary&gt; /// 摇杆重置所诉 /// &lt;/summary&gt; public float JoyStickResetSpeed = 5.0f; /// &lt;summary&gt; /// 当前物体的Transform组件 /// &lt;/summary&gt; private RectTransform selfTransform; /// &lt;summary&gt; /// 是否触摸了虚拟摇杆 /// &lt;/summary&gt; private bool isTouched = false; /// &lt;summary&gt; /// 虚拟摇杆的默认位置 /// &lt;/summary&gt; private Vector2 originPosition; /// &lt;summary&gt; /// 虚拟摇杆的移动方向 /// &lt;/summary&gt; private Vector2 touchedAxis; public Vector2 TouchedAxis &#123; get &#123; if(touchedAxis.magnitude &lt; JoyStickRadius) return touchedAxis.normalized / JoyStickRadius; return touchedAxis.normalized; &#125; &#125; /// &lt;summary&gt; /// 定义触摸开始事件委托 /// &lt;/summary&gt; public delegate void JoyStickTouchBegin(Vector2 vec); /// &lt;summary&gt; /// 定义触摸过程事件委托 /// &lt;/summary&gt; /// &lt;param name=\"vec\"&gt;虚拟摇杆的移动方向&lt;/param&gt; public delegate void JoyStickTouchMove(Vector2 vec); /// &lt;summary&gt; /// 定义触摸结束事件委托 /// &lt;/summary&gt; public delegate void JoyStickTouchEnd(); /// &lt;summary&gt; /// 注册触摸开始事件 /// &lt;/summary&gt; public event JoyStickTouchBegin OnJoyStickTouchBegin; /// &lt;summary&gt; /// 注册触摸过程事件 /// &lt;/summary&gt; public event JoyStickTouchMove OnJoyStickTouchMove; /// &lt;summary&gt; /// 注册触摸结束事件 /// &lt;/summary&gt; public event JoyStickTouchEnd OnJoyStickTouchEnd; void Start () &#123; //初始化虚拟摇杆的默认方向 selfTransform = this.GetComponent&lt;RectTransform&gt;(); originPosition = selfTransform.anchoredPosition; &#125; public void OnPointerDown(PointerEventData eventData) &#123; isTouched = true; touchedAxis = GetJoyStickAxis(eventData); if(this.OnJoyStickTouchBegin != null) this.OnJoyStickTouchBegin(TouchedAxis); &#125; public void OnPointerUp(PointerEventData eventData) &#123; isTouched = false; selfTransform.anchoredPosition = originPosition; touchedAxis = Vector2.zero; if(this.OnJoyStickTouchEnd != null) this.OnJoyStickTouchEnd(); &#125; public void OnDrag(PointerEventData eventData) &#123; touchedAxis = GetJoyStickAxis(eventData); if(this.OnJoyStickTouchMove != null) this.OnJoyStickTouchMove(TouchedAxis); &#125; void Update() &#123; //当虚拟摇杆移动到最大半径时摇杆无法拖动 //为了确保被控制物体可以继续移动 //在这里手动触发OnJoyStickTouchMove事件 if(isTouched &amp;&amp; touchedAxis.magnitude&gt;=JoyStickRadius) &#123; if(this.OnJoyStickTouchMove != null) this.OnJoyStickTouchMove(TouchedAxis); &#125; //松开虚拟摇杆后让虚拟摇杆回到默认位置 if(selfTransform.anchoredPosition.magnitude &gt; originPosition.magnitude) selfTransform.anchoredPosition -= TouchedAxis * Time.deltaTime * JoyStickResetSpeed; &#125; /// &lt;summary&gt; /// 返回虚拟摇杆的偏移量 /// &lt;/summary&gt; /// &lt;returns&gt;The joy stick axis.&lt;/returns&gt; /// &lt;param name=\"eventData\"&gt;Event data.&lt;/param&gt; private Vector2 GetJoyStickAxis(PointerEventData eventData) &#123; //获取手指位置的世界坐标 Vector3 worldPosition; if (RectTransformUtility.ScreenPointToWorldPointInRectangle (selfTransform, eventData.position, eventData.pressEventCamera, out worldPosition)) selfTransform.position = worldPosition; //获取摇杆的偏移量 Vector2 touchAxis = selfTransform.anchoredPosition-originPosition; //摇杆偏移量限制 if(touchAxis.magnitude &gt;= JoyStickRadius) &#123; touchAxis = touchAxis.normalized * JoyStickRadius; selfTransform.anchoredPosition = touchAxis; &#125; return touchAxis; &#125;&#125; &emsp;&emsp;在这段脚本中，我们实现了OnPointerDown、OnPointerUp和OnDrag三个uGUI事件接口，然后注册了相关的事件委托，这里借鉴了EasyTouch的设计，可以使得虚拟摇杆的逻辑和角色控制逻辑相互分离。这里的核心方法是GetJoyStickAxis()方法，通过这个方法我们可以获得一个Vector2类型的值，它表示的是未标准化过的虚拟摇杆的偏移量。这里的RectTransformUtility.ScreenPointToWorldPointInRectangle()方法表示将一个屏幕坐标转化为对应RectTransform的世界坐标，RectTransform的anchoredPosition属性表示的是当前元素在场景中的屏幕坐标。我们知道屏幕坐标是以像素为单位的，因此这里使用屏幕坐标可以计算出虚拟摇杆在水平方向和垂直方向上移动了多少个像素，我们以此来作为虚拟摇杆的偏移量衡量指标。TouchedAxis是经过标准化以后的偏移量，我们将把这个值传递到事件委托中以提供给外部来调用。好了，要说的就这些了，没有说到的大家可以看看代码里的注释或者是在博客中给我留言，就是这样啦。 &emsp;&emsp;接下来，我们在场景中添加一个角色模型来测试我们编写的虚拟摇杆，因为在JoyStick中我们已经定义了事件委托，所以在这里就是简单的调用啦。好了，我们一起来看看代码吧！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/* * Joystick3D.cs * 3D模式下的虚拟摇杆测试 * 作者：秦元培 * 博客：http://qinyuanpei.com * 时间：2015年10月30日 */using UnityEngine;using System.Collections;public class JoyStick3D : MonoBehaviour &#123; private JoyStick js; void Start () &#123; js = GameObject.FindObjectOfType&lt;JoyStick&gt; (); js.OnJoyStickTouchBegin += OnJoyStickBegin; js.OnJoyStickTouchMove += OnJoyStickMove; js.OnJoyStickTouchEnd += OnJoyStickEnd; &#125; void OnJoyStickBegin(Vector2 vec) &#123; Debug.Log(\"开始触摸虚拟摇杆\"); &#125; void OnJoyStickMove (Vector2 vec) &#123; Debug.Log(\"正在移动虚拟摇杆\"); //设置角色朝向 Quaternion q = Quaternion.LookRotation (new Vector3 (vec.x, 0, vec.y)); transform.rotation = q; //移动角色并播放奔跑动画 transform.Translate(Vector3.forward * 75f * Time.deltaTime); animation.CrossFade(\"Run\"); &#125; void OnJoyStickEnd () &#123; Debug.Log(\"触摸移动摇杆结束\"); //播放默认待机动画 animation.CrossFade(\"idle\"); &#125; void OnGUI() &#123; GUI.Label(new Rect(30,30,200,30),\"3D模式下的虚拟摇杆测试\"); &#125;&#125; &emsp;&emsp;最终程序的运行效果如下图所示，我们编写的这个虚拟摇杆可以在手机上完美的运行，欢饮大家来一起测试和吐槽！ 2D模式演示 3D模式演示 &emsp;&emsp;好了，今天的内容就是这样啦！欢迎大家继续关注我的博客，希望大家喜欢！","tags":[{"name":"游戏开发","slug":"游戏开发","permalink":"http://qinyuanpei.github.io/tags/游戏开发/"},{"name":"uGUI","slug":"uGUI","permalink":"http://qinyuanpei.github.io/tags/uGUI/"},{"name":"虚拟摇杆","slug":"虚拟摇杆","permalink":"http://qinyuanpei.github.io/tags/虚拟摇杆/"}]},{"title":"EasyAR尝鲜系列教程之Hello EasyAR","date":"2015-10-30T09:44:18.000Z","path":"posts/3120185261/","text":"&emsp;&emsp;各位朋友，大家好，我是秦元培，欢迎大家关注我的博客，我的博客地址是http://qinyuanpei.com。从今天起博主将为大家带来EasyAR尝鲜系列教程，本教程适用的对象是增强现实应用开发者和Unity3D游戏开发者，在阅读本教程前请确保具备增强现实应用开发及Unity3D游戏开发的相关基础知识。在本节及后续内容中，博主将以国产增强现实引擎EasyAR为主要开发平台来带领大家一起走进增强现实应用开发的世界，希望大家能够喜欢！ #什么是增强现实？&emsp;&emsp;为了让更多的人了解增强现实，所以在开始本文教程前，我们首先来了解下什么是增强现实。增强现实(Augmented Reality，简称 AR)，它是一种将真实世界信息和虚拟世界信息进行融合和集成的新技术，这种技术的目标是在屏幕上把虚拟世界和现实世界进行叠加并在此基础上进行互动。增强现实是真实世界和虚拟世界的信息集成，具有实时交互性，是在三维尺度空间中增添定位虚拟物体。增强现实技术可广泛应用到军事、医疗、建筑、教育、工程、影视、娱乐等领域。增强现实是新型的人机交互和三维仿真工具，目前已发挥出了重要的作用，具有巨大的应用潜力。 增强现实概念图 #增强现实应用现状&emsp;&emsp;目前，增强现实在国内尚处在起步阶段。2012年4月Google发布的Google Class是全球唯一一款真正意义上实现增强现实技术的硬件设备。随着移动设备的普及和相关技术的成熟，增强现实开始逐渐地走进人们的生活。如国内首款聚合了目前移动互联最新增强现实技术的智能手机应用《城市镜头》以及中视典数字科技研发的VRP系统等。AR技术在人工智能、CAD、图形仿真、虚拟通讯、遥感、娱乐、模拟训练等许多领域带来了革命性的变化。目前增强现实相关技术主要有开源社区的ARToolkit、面向商业化解决方案的Metaio和Vuforia等。 #国产增强现实引擎EasyAR&emsp;&emsp;EasyAR(Easy Augmented Reality)是视辰信息科技（上海）有限公司的增强现实解决方案系列的子品牌，其含义是希望让增强现实变得简单易实施。EasyAR提供了诸如手机APP互动营销、户外大屏幕互动活动、网络营销互动等形式在内的增强现实互动营销技术和解决方案。著作权归作者所有。EasyAR无需授权、无水印、无识别次数的限制，开放后可免费下载，无需任何费用，是一款完全免费的AR引擎。EasyAR具有强大的跨平台特性可支持Windows、 Mac OS、 Android和iOS等主流平台。从目前的情况来看，EasyAR的SDK是目前市场上同类产品中最为简单易用的，唯一的不足是产品刚发布不久尚未能提供完整的技术文档。 #Hello EasyAR&emsp;&emsp;好了，下面我们以EasyAR提供的Unity3D版本SDK为例来学习EasySDK的使用。在开始前请确保你的计算机上正确安装了以下开发工具或者硬件： Unity3D(必选)：主要的开发环境 JDK相关工具(必选)：编译Android应用所需环境 Android SDK(必选)：编译Android应用所需环境 摄像头(可选)：如使用手机进行调试则不需要 在完成以上准备工作后： 打开EasyAR官网并登录官网，我们将在登陆后创建应用以获得开发所需的密钥以及SDK。如果尚未注册可以在注册后完成这一步骤。 创建应用 点击创建应用，并在这里填入应用的名称和包的名称，此处以“EasyAR测试”和“com.easyar.first”为例，在创建完应用后可以在应用列表中找到当前创建的应用，点击显示可以查看当前应用对应的密钥。 点击“下载EasyAR SDK v1.0.1”完成SDK的下载。 下载SDK 解压下载的SDK压缩包，找到vc_redist目录安装对应平台的VC++运行库。请注意，即使在你的计算机上安装了VC++运行库，这里依然需要安装。Win8及Win8.1请先使用磁盘清理工具清理系统垃圾，否则可能会出现无法安装的问题。建议使用64位操作系统且安装x86和x64的VC++运行库。 找到SDK压缩包内的package/unity目录下的EasyAR.unitypackage文件并将其导入到Unity3D中。 在Unity3D中找到Scenes目录下的easyar场景并打开该场景，然后找到EasyAR节点名称，在右侧属性窗口中填入应用对应的密钥。 填入应用程序密钥 打开BuildSetting-&gt;PlayerSetting在右侧属性窗口中填入应用对应的包名。 填入应用程序包名 SDK默认提供了三张识别图片，我们选择每个人都有的身份证照片作为识别目标，在场景中找到ImageTargetDataSet-idback这个物体，找到它的子节点Cube。这意味着如果我们识别到了身份证照片，那么就会在身份证照片上显示一个Cube。如果大家手头上有自己喜欢的模型，可以将Cube隐藏，然后将模型添加进来，并为其添加VideoPlayerBehaviour.cs脚本。如手头上没有模型，这一步可以忽略。如图是我现在的场景效果： 加入自定义模型后的效果 &emsp;&emsp;好了，现在编译程序，将其导出为APK安装包，这样我们就可以在手机上测试EasyAR的效果啦。假如一切顺利的话，在手机上将会看到这样的画面。下面放点运行情况截图供大家参考： 截图1 截图2 #问题汇总&emsp;&emsp;作为一款国产的增强现实引擎，目前EasyAR的表现我还是比较满意的，虽然在识别的准确度上无法和国外的同类产品相比，但是它的简单易用确实是做得不错。作为一个程序员尝鲜更像是吃螃蟹，目前发现的问题及解决方案有： 编辑器提示DllNotFoundException错误，请安装SDK中对应的VC++运行库。 视频导入失败，Unity3D导入视频需要依赖苹果公司的QuickTime播放器，所以请安装最新版的QuickTime后重试。 在64位计算机上编译的Android应用可以正常运行，在32位计算机上编译的Android应用无法正常运行。具体表现如图 32位计算机下的问题 &emsp;&emsp;好了，作为整个系列的第一篇文章，我们至此对EasyAR有了一个较为直观的印象。在接下来的内容中，我们将对SDK中的内容进行更加深入的了解，因此希望大家继续关注我的博客，谢谢大家！","tags":[{"name":"Unity3D","slug":"Unity3D","permalink":"http://qinyuanpei.github.io/tags/Unity3D/"},{"name":"增强现实","slug":"增强现实","permalink":"http://qinyuanpei.github.io/tags/增强现实/"},{"name":"AR","slug":"AR","permalink":"http://qinyuanpei.github.io/tags/AR/"}]},{"title":"Unity3D游戏开发之Unity3D场景编辑器扩展开发","date":"2015-10-13T12:59:01.000Z","path":"posts/3019914405/","text":"&emsp;&emsp;今天博主想和大家分享的是Unity3D场景编辑器的扩展开发，相关的话题我们在Unity3D游戏开发之编辑器扩展程序开发实例这篇文章中我们已经有所涉及，今天博主想特别针对场景编辑器的扩展开发来进行下深入研究。对于一个场景编辑器来说，它主要的作用是3D场景视图中实时显示、输入反馈和相关信息的更新。在Unity3D中提供了Editor、EditorWindow、GUILayout、EditorGUILayout、GUIUtility、EditorGUIUtility、Handles、Event等来完成这些工作。其中基于EditorWindow的这种扩展方式我们已经研究过了，这种扩展方式拥有自己的独立窗口使用OnGUI方法进行界面的绘制。今天我们想说的是基于Editor的这种扩展方式，这种扩展方式只能针对脚本，从脚本内容在Inspector里的显示布局到变量在Scene视图的可视化编辑，它都可以完全胜任。这里特别想说的是Handles和Event这两个类，这两个类分别提供了3D显示和输入反馈的功能，我们下面就来学习如何使用这些类来扩展Unity3D的场景编辑器。 #创建一个扩展的Transform组件&emsp;&emsp;Transform是Unity3D中一个基本的组件，下面我们来创建一个扩展的Transform组件，该组件可以对游戏体的坐标、旋转、缩放进行重置。首先，我们创建一个ExtendTransform的类，该类继承自Editor类：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899using UnityEngine;using System.Collections;using UnityEditor;[CustomEditor(typeof(Transform),true)]public class ExtendTransform : Editor &#123; /// &lt;summary&gt; /// Position属性 /// &lt;/summary&gt; private SerializedProperty mPos; /// &lt;summary&gt; /// Scale属性 /// &lt;/summary&gt; private SerializedProperty mScale; void OnEnable() &#123; mPos = serializedObject.FindProperty(\"m_LocalPosition\"); mScale = serializedObject.FindProperty(\"m_LocalScale\") ; &#125; /// &lt;summary&gt; /// Inspector相关GUI函数 /// &lt;/summary&gt; public override void OnInspectorGUI() &#123; EditorGUIUtility.labelWidth = 15; //获取最新的可序列化对象 serializedObject.Update(); //绘制物体的坐标、旋转和缩放 DrawPosition(); DrawRotate(); DrawScale(); //更新可序列化对象的属性 serializedObject.ApplyModifiedProperties(); &#125; /// &lt;summary&gt; /// 绘制位置 /// &lt;/summary&gt; private void DrawPosition() &#123; GUILayout.BeginHorizontal(); &#123; bool Reset = GUILayout.Button(\"P\", GUILayout.Width(20f)); EditorGUILayout.LabelField(\"Position\"); EditorGUILayout.PropertyField(mPos.FindPropertyRelative(\"x\")); EditorGUILayout.PropertyField(mPos.FindPropertyRelative(\"y\")); EditorGUILayout.PropertyField(mPos.FindPropertyRelative(\"z\")); if(Reset) mPos.vector3Value = Vector3.zero; &#125; GUILayout.EndHorizontal(); &#125; /// &lt;summary&gt; /// 绘制旋转 /// &lt;/summary&gt; private void DrawRotate() &#123; Vector3 eulerAngles = ((Transform)target).eulerAngles; GUILayout.BeginHorizontal(); &#123; bool Reset = GUILayout.Button(\"R\", GUILayout.Width(20f)); EditorGUILayout.LabelField(\"Rotation\", GUILayout.Width(70f)); EditorGUILayout.LabelField(\"X\", GUILayout.Width(13f)); float angleX=EditorGUILayout.FloatField(eulerAngles.x, GUILayout.Width(56f)); EditorGUILayout.LabelField(\"Y\", GUILayout.Width(13f)); float angleY = EditorGUILayout.FloatField(eulerAngles.y, GUILayout.Width(56f)); EditorGUILayout.LabelField(\"Z\", GUILayout.Width(13f)); float angleZ = EditorGUILayout.FloatField(eulerAngles.z, GUILayout.Width(56f)); ((Transform)target).eulerAngles = new Vector3(angleX, angleY, angleZ); if(Reset) &#123; eulerAngles = Vector3.zero; ((Transform)target).eulerAngles = Vector3.zero; &#125; &#125; GUILayout.EndHorizontal(); &#125; /// &lt;summary&gt; /// 绘制缩放 /// &lt;/summary&gt; private void DrawScale() &#123; GUILayout.BeginHorizontal(); &#123; bool Reset = GUILayout.Button(\"S\", GUILayout.Width(20f)); EditorGUILayout.LabelField(\"Scale\"); EditorGUILayout.PropertyField(mScale.FindPropertyRelative(\"x\")); EditorGUILayout.PropertyField(mScale.FindPropertyRelative(\"y\")); EditorGUILayout.PropertyField(mScale.FindPropertyRelative(\"z\")); if (Reset) mScale.vector3Value = Vector3.one; &#125; GUILayout.EndHorizontal(); &#125;&#125; &emsp;&emsp;首先我们注意到ExtendTransform继承自Editor，这是我们开发这类编辑器扩展的第一个前提。其次我们注意到在该类的声明位置有这样一个标记:1[CustomEditor(typeof(Transform),true)] 该标记表明我们这个编辑器扩展是针对Transform组件进行扩展的，即当物体存在Tranform组件时会在编辑器中响应这个编辑器扩展程序。我们在这个编辑器扩展程序中都做了哪些事情呢？第一，我们实现了OnEnable()方法，该方法相当于一个初始化的方法；第二，我们重写了OnOnInspectorGUI()方法，该方法将覆盖默认的Inspector窗口外观。 扩展后的Transform 好了，现在我们点击场景中默认的相机MainCamera可以发现默认的Transform会变成具有重置功能的扩展型Transform。下面我们来介绍这段程序中较为重要的核心内容： ##Unity3D中的可序列化对象&emsp;&emsp;通常我们所说的序列化是指将一个对象的实例转化为字符串的过程，而在Unity3D中可序列化对象更像是一种智能对象，它可以将脚本中的属性显示在Inspector窗口中，当场景发生变化时这些属性值将自动被更新。例如我们可以定义这样一个简单的脚本：1234567891011121314151617181920212223/// &lt;summary&gt;/// 定义一个可序列化类/// &lt;/summary&gt;[System.Serializable]public class ExampleClass &#123; [SerializeField] public int ID; [SerializeField] public string Name; [SerializeField] public Vector3[] Points; private bool editable = false;&#125;/// &lt;summary&gt;/// 定义一个简单的脚本/// &lt;/summary&gt;public class ExampleScript : MonoBehaviour &#123; public ExampleClass Example;&#125; 此时如果我们给场景中的某个物体附加上该脚本，则我们在Inspector窗口可以看到Example类的实例Example将被序列化到编辑器面板中，同时我们可以注意到私有的editable字段并没有被序列化出来，这是因为在Unity3D中，公有的字段默认支持序列化，私有的字段除非显式的增加[SerializeField]标记，否则都不会被序列化，这一点希望大家注意。好了，那么我们为什么要讲这部分内容呢，这是因为它和我们下面要讲的Editor基类中的属性和方法有着十分密切的关联。 Unity3D中的可序列化对象 ##Editor基类中的属性和方法&emsp;&emsp;Editor基类中有两个重要的属性，即target和serializedObject。target表示当前受检查的物体我们可以通过它获得当前物体；而serializedObject表示当前物体的全部可序列化信息，我们可以通过它获得指定的序列化字段及其数值。Editor基类中重要的方法有： OnInspectorGUI():该方法可对Inspector窗口面板进行扩展或者重写，比如我们可以通过DrawDefaultInspector()方法来绘制默认Inspector窗口面板然后在此基础上使用GUILayout或者EditorGUILayout等辅助类进行自定义的绘制。在这个示例中我们对整个面板进行了重写，值得注意的是为了让Inspector窗口面板正常工作，如果要重绘该窗口请确保对该方法进行覆盖。 OnSceneGUI():该方法可对场景视图进行绘制，在实际的使用中可以配合Handles类和Event类来进行网格编辑、地形绘制或高级Gizmos等方面的工作。在本文的第二个示例中，我们将利用这一特性来编写一个用于NPC寻路的路径节点编辑工具。 ##对第一个示例的总结&emsp;&emsp;在第一个示例中，可以注意到我们使用了FindProperty()方法来获取一个可序列化物体的属性(字段)，然后我们在EditorGUILayout.PropertyField()方法来绘制了各种属性框，这种方式可以实现属性的自动更新。注意到DrawRotate()方法与DrawPositin()及DrawScale()方法在实现方式上略有不同，这是因为Transform组件的Rotation属性是一个Quaternion即四元数的结构，四元数是利用x、y、z、w四个数值来表示物体的三维旋转，这不仅和我们平时习惯的欧拉角相违背而且更为关键的是貌似目前我还没有发现可以直接绘制四元数的API接口，如果有的话希望大家可以告诉我，所以这里我们用了变通的一种方法，即通过Transform的eulerAngles来实现，但是这种方式绘制的属性框大小和EditorGUILayout.PropertyField()方法绘制的属性框大小并不一致，同时我们需要自己去完成属性值的更新。好了，暂时先总结到这里更多的细节大家可以通过代码来了解。 #创建一个NPC寻路节点编辑工具&emsp;&emsp;创建这样一个工具的想法来自我实际的工作体验，当我Unity3D中使用的Tween动画库从iTween变成Dotween后，我在使用Dotween的过程中一直没有找到类似于iTweenPath的路径节点编辑工具。作为一个有节操的程序员，去寻找破解版的Dotween Pro这样的事情我是能不干就不干啦，因为我觉得自己有能力做这样一个类似的小工具，所以在一边准备这篇文章的时候，一边开始设计这样一个路径节点编辑工具。相信经过第一个示例的铺垫和相关知识的储备，大家都了解了这些内容，所以这里直接给出代码啦，因为实在是没有多少内容，嘿嘿：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152using UnityEngine;using System.Collections;using UnityEditor;[CustomEditor(typeof(PatrolNPC))]public class PatrolPathEditor : Editor &#123; /// &lt;summary&gt; /// 寻路节点 /// &lt;/summary&gt; private Vector3[] paths; /// &lt;summary&gt; /// 显示寻路信息的GUI /// &lt;/summary&gt; private GUIStyle style=new GUIStyle(); /// &lt;summary&gt; /// 初始化 /// &lt;/summary&gt; void OnEnable() &#123; //获取当前NPC的寻路路径 paths = ((PatrolNPC)target).Paths; //初始化GUIStyle style.fontStyle = FontStyle.Normal; style.fontSize = 15; &#125; void OnSceneGUI() &#123; //获取当前NPC的寻路路径 paths = ((PatrolNPC)serializedObject.targetObject).Paths; //设置节点的颜色为红色 Handles.color = Color.red; if(paths.Length &lt;= 0 || paths.Length&lt;2) return; //在场景中绘制每一个寻路节点 //可以在场景中编辑节点并将更新至对应的NPC for (int i = 0; i &lt; paths.Length; i++) &#123; paths[i] = Handles.PositionHandle(paths[i], Quaternion.identity); Handles.SphereCap(i, paths[i], Quaternion.identity, 0.25f); Handles.Label(paths[i], \"PathPoint\" + i, style); if (i &lt; paths.Length &amp;&amp; i + 1 &lt; paths.Length) &#123; Handles.DrawLine(paths[i], paths[i + 1]); &#125; &#125; &#125; &#125; &emsp;&emsp;这里的PatrolNPC是一个可寻路NPC类，基本和这篇文章的内容无关，大家只要知道那个Paths字段是一个Vector3[]就好啦，这样当我们在场景中编辑这些路径节点的时候，对应NPC的路径节点信息就会同步发生更新，这样我们就可以随心所欲地规划NPC的移动路径啦，哈哈。好了，今天的内容就是这样啦，写完熬到这个点真心不容易啊，大家晚安，这是这个小工具在场景编辑器中的效果，嘻嘻，感觉还是蛮不错的吧，反正我是很喜欢就对啦！ 路径节点编辑工具演示","tags":[{"name":"Unity3D","slug":"Unity3D","permalink":"http://qinyuanpei.github.io/tags/Unity3D/"},{"name":"编辑器","slug":"编辑器","permalink":"http://qinyuanpei.github.io/tags/编辑器/"},{"name":"扩展","slug":"扩展","permalink":"http://qinyuanpei.github.io/tags/扩展/"}]},{"title":"在Unity3D中加载外部图片的两种方法","date":"2015-10-08T15:03:01.000Z","path":"posts/821259985/","text":"&emsp;&emsp;各位朋友大家好，我是秦元培，欢迎大家关注我的博客。最近在做项目的过程中遇到这样的一个需求：玩家可以在游戏过程中进行实时存档，在存档过程中会保存当前游戏进度，同时会截取当前游戏画面并加载到游戏存档界面中。当下一次进入游戏的时候，将读取本地存档图片并加载到游戏界面中。这在单机游戏中是特别常见的一种功能，这里主要有两个关键点。首先是截取游戏画面，这个问题大家可以在《Unity3D游戏开发之截屏保存精彩瞬间》这篇文章中找到答案。其次是从本地加载图片，因为这里要保证可读可写，因此传统的Resources.Load()方式和AssetBundle方式均无法实现这样的功能。那么怎样从外部加载图片到游戏中，这就是我们今天要讨论的内容啦。好了，这里介绍两种方法来实现这一目的。 #喜闻乐见的WWW方式&emsp;&emsp;喜闻乐见的WWW方式之所以喜闻乐见，这是因为这是我们最为熟悉的一种，我们都知道通过WWW可以从网络上加载文本、图片、音频等形式的内容，那么通过WWW能否加载本地外部（相对于应用程序）资源呢？答案是肯定的，这是因为WWW可以支持http和file两种协议。我们通常接触到的WWW默认都是指http协议，现在我们来说说file协议，该协议可以用来访问本地资源（绝对路径）。例如我们希望加载文件D:\\TestFile\\pic001.png这个文件，则此时对应的C#脚本为： 123456789//请求WWWWWW www = new WWW(\"file://D:\\\\TestFile\\\\pic001.png);yield return www; if(www != null &amp;&amp; string.IsNullOrEmpty(www.error))&#123; //获取Texture Texture texture=www.texture; //更多操作... &#125; 注意到这里出现了yield return结构，这表示这里使用到了协程，因此我们需要付出的代价就是需要在项目中使用StartCoroutine等协程相关的方法来调用这些协程。虽然在Unity3D中使用协程是件简单的事情，可是如果我们随随便便地使用协程而不注意去维护这些协程，那么这些让我们引以为傲的简单代码可能就会变成我们痛苦不堪的无尽深渊。 #亘古不变的传统IO方式&emsp;&emsp;好了，下面我们隆重推出亘古不变的传统IO方式，这种方式相信大家都没有接触过，所以这里将这种方法和大家分享。既然是传统的IO方式，那么无非就是各种IO流的处理啦。好，我们一起来看下面这段代码： 1234567891011121314151617//创建文件读取流FileStream fileStream = new FileStream(screen, FileMode.Open, FileAccess.Read);fileStream.Seek(0, SeekOrigin.Begin);//创建文件长度缓冲区byte[] bytes = new byte[fileStream.Length]; //读取文件fileStream.Read(bytes, 0, (int)fileStream.Length);//释放文件读取流fileStream.Close();fileStream.Dispose();fileStream = null;//创建Textureint width=800;int height=640;Texture2D texture = new Texture2D(width, height);texture.LoadImage(bytes); 可以看到在使用这种方式读取图片文件的时候主要是将图片文件转化为byte[]数组，再利用Texture2D的LoadImage方法转化为Unity3D中的Texture2D。这种方法需要在创建过程中传入图片的大小，在这里我们创建了一张800X640的图片。经过博主的研究发现，这种方式加载外部图片相对于使用WWW加载外部图片效率更高，所以如果大家遇到类似的需求，博主个人推荐大家使用这种方式进行加载。 &emsp;&emsp;到目前为止我们解决了如何从外部加载图片到Unity3D中，现在我们回到最开始的问题，我们从外部读取到这些图片以后需要将它们加载到游戏界面中。比如当我们使用UGUI的时候，UGUI中的Image控件需要一个Sprite来作为它的填充内容，那么此时我们就需要将Texture转化为Sprite.号了，下面我们给出一个简单的例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788using UnityEngine;using System.Collections;using UnityEngine.UI;using System.IO;public class TestLoading : MonoBehaviour &#123; /// &lt;summary&gt; /// Image控件 /// &lt;/summary&gt; private Image image; void Start () &#123; image = this.transform.Find(\"Image\").GetComponent&lt;Image&gt;(); //为不同的按钮绑定不同的事件 this.transform.Find(\"LoadByWWW\").GetComponent&lt;Button&gt;().onClick.AddListener ( delegate()&#123;LoadByWWW();&#125; ); this.transform.Find(\"LoadByIO\").GetComponent&lt;Button&gt;().onClick.AddListener ( delegate()&#123;LoadByIO();&#125; ); &#125; /// &lt;summary&gt; /// 以IO方式进行加载 /// &lt;/summary&gt; private void LoadByIO() &#123; double startTime = (double)Time.time; //创建文件读取流 FileStream fileStream = new FileStream(\"D:\\\\test.jpg\", FileMode.Open, FileAccess.Read); fileStream.Seek(0, SeekOrigin.Begin); //创建文件长度缓冲区 byte[] bytes = new byte[fileStream.Length]; //读取文件 fileStream.Read(bytes, 0, (int)fileStream.Length); //释放文件读取流 fileStream.Close(); fileStream.Dispose(); fileStream = null; //创建Texture int width = 300; int height = 372; Texture2D texture = new Texture2D(width, height); texture.LoadImage(bytes); //创建Sprite Sprite sprite = Sprite.Create(texture, new Rect(0, 0, texture.width, texture.height), new Vector2(0.5f, 0.5f)); image.sprite = sprite; startTime=(double)Time.time-startTime; Debug.Log(\"IO加载用时:\" + startTime); &#125; /// &lt;summary&gt; /// 以WWW方式进行加载 /// &lt;/summary&gt; private void LoadByWWW() &#123; StartCoroutine(Load()); &#125; IEnumerator Load() &#123; double startTime = (double)Time.time; //请求WWW WWW www = new WWW(\"file://D:\\\\test.jpg\"); yield return www; if(www != null &amp;&amp; string.IsNullOrEmpty(www.error)) &#123; //获取Texture Texture2D texture=www.texture; //创建Sprite Sprite sprite = Sprite.Create(texture, new Rect(0, 0, texture.width, texture.height), new Vector2(0.5f, 0.5f)); image.sprite = sprite; startTime = (double)Time.time - startTime; Debug.Log(\"WWW加载用时:\" + startTime); &#125; &#125;&#125; &emsp;&emsp;现在我们运行程序可以发现两种方式均可以让图片加载进来，为了对比两种方式在执行效率上的高低，我们在脚本中加入了相关代码，通过对比可以发现使用IO方式加载一张227k的图片需要的时间为0s，而使用WWW方式加载需要0.0185s，因此传统的IO方式具有更高的效率，建议大家在遇到这类问题时尽可能地使用这种方式。好了，今天的内容就是这样啦，欢迎大家在我的博客中留言、欢迎大家关注和支持我的博客，谢谢大家！ 2016年6月12日更新：&emsp;&emsp;针对有朋友指出WWW加载和传统IO加载方式在效率上的差异，我们这里重新做一个效率测试。","tags":[{"name":"Unity3D","slug":"Unity3D","permalink":"http://qinyuanpei.github.io/tags/Unity3D/"},{"name":"游戏开发","slug":"游戏开发","permalink":"http://qinyuanpei.github.io/tags/游戏开发/"},{"name":"uGUI","slug":"uGUI","permalink":"http://qinyuanpei.github.io/tags/uGUI/"}]},{"title":"做最初的自己","date":"2015-09-30T10:19:26.000Z","path":"posts/786195243/","text":"&emsp;&emsp;在中秋节这样一个万家团圆的日子，我却再度因为工作的问题和家人发生争执。发生争执的原因简单到习以为常，家人喜欢稳定、安逸的生活，而我却喜欢有挑战、梦想的生活。我不知道梦想对一个二十三岁的人是不是一种奢侈品，我只知道当我住在狭小、拥挤的出租房里的时候，我想努力去拥有一个温暖的家，我不想靠着一张嘴去哗众取宠，我不想刻意地迎合和奉承这个世界，我只想靠我平凡而微薄的努力让我的生活一天天地温暖起来。从小我被告诉要做一个正直、善良的人，可是随着我慢慢地长大，在我的耳边总会听到“要去适应这个社会”这样的话，然而最讽刺的是这样的话常常出自同一人的口中。 &emsp;&emsp;虽然我知道当今中国的社会是一个人情社会、关系社会，可我就是不愿意把时间浪费在交际应酬这样的事情上，因为我知道人的这一生的时间是非常宝贵的，从小我就看到身边熟悉的人因为各种各样的原因突然离开这个世界，我们每一个人都会面临死亡，所以当我懒得理会这些无聊的事情的时候，我更希望在我喜欢或者关注的事情上投入精力。每次当家人说我应该应该怎么样的时候，我常常假设自己如果按照这样的规划来度过这一生，那么当我衰老直至死亡的那一刻我心里又会想些什么？我讨厌政治和宗教，因为这是由人类自己为人类制造的精神枷锁，在它们涉足的领域常常伴随各种无可争辩的假象或者谎言，这恰恰是我这样一个正直的本性中极度厌恶的部分。长辈们或多或少地喜欢给我这样的年轻人冠以“愤青”这样的荣誉称号，可我做错了什么呢？我无非就是像《皇帝的新装》里的那个小孩，突然说出了一个大家都习以为常的秘密而已，我们从小到大的成长过程其实就是小孩从见到了就要说出来，变成现在见到了习以为常、看在眼里说在心里。人们常常把这种转变当作成熟，可是事实上人们只是变得更加麻木而已。此时此刻我假装麻木想要摆脱这些掩耳盗铃的秘密，长辈们却再度摆出“社会就是这样，你必须要去适应”这样的架势，大概是嫌弃我假装麻木难以入戏需要变得更加虚伪。 &emsp;&emsp;我天生就是一个不会表演的人，从小时候排练舞蹈学习动作到此时此刻需要我去逢场作戏的各种场合，我不会说除了让人高兴还是高兴的话，我不会让喜怒哀乐像变脸、像翻书一样快。长辈们一直希望我变成一个圆滑世故、胸有城府的人，可我听惯了许嵩的《城府》、《别咬我》、《秋千坠》对这些东西天生排斥，所以在长辈们的世界观里，我就变成了一个冥顽不灵、图样图森破的年轻人。长辈们固然是从自己的经验出发，想让作为年轻人的我走上一条平坦舒适的道路，可是这个世界早已在不知不觉中发生着天翻地覆的变化，长辈们的经验获取可以让你顺利通关人生这场游戏，然而缺少了自我探索的旅程未免显得平凡而无趣。我有幸在小学三年级的时候接触计算机，在初中的时候接触互联网，在高中的时候接触编程，然而在这短短的若干年间互联网行业风起云涌、起起伏伏却并非我们的父辈可以理解和掌握。我走进大学的时候社交网站(SNS)开始兴起，以Facebook、Twitter、人人网、新浪微博、腾讯微博等等为代表的社会化平台迅速地占领了整个互联网行业的制高点。或许和70后、80后相比，我们这一代人在这个变化剧烈的时代显得有点生不逢时，可是机遇和挑战总是并存的，当我们无法和前辈们一起成为时代的弄潮儿的时候，我们只有努力去追赶这个时代忙碌的脚步。短短大学四年，我感受到了互联网每天天翻地覆的变化，从SNS到云计算、移动互联网、大数据、物联网再到互联网金融、O2O，这个行业慢慢地渗透到我们的生活中来。曾经我的长辈认为如果依靠政治力量毁灭了百度，则我们完全可以借由政治力量重新创造出来一个百度，可是同样是由政治力量领导的人民网、同样是由政治力量推到台前的邓亚萍，人民网最终依然在这场搜索引擎大战中以失败告终。我们无法访问国外网站并非是我们拥有世界山最先进的互联网技术，而是我们依靠政治力量用流氓一样的手段在全球一体化的今天实施信息领域的闭关锁国。我一直认为互联网行业是政治干预较为稀疏的一个行业，所以在这个行业当中我不会遭遇那些让我厌恶的政治因素，虽然有人聚集的地方就会有政治产生，但是作为互联网基础要素之一的技术是一个相对纯粹的领域，它依靠最为简单的0和1构成了今天丰富多彩的世界，它讲道理、守规矩让我觉得这个领域简单而纯粹。长辈们不理解我为什么会对计算机有这样独特的情结，因为在普通人眼中它就是一个可以娱乐和办公的机器，然而在我眼中它像是我的一位朋友默默地支持着我去解决各种问题。从我高中的时候起我就认定这个行业将会成为我一辈子的一种寄托，我相信技术可以让我们这个世界变得更加美好，这是我永恒的信仰，所以我不会把政治和宗教当成我一生的信仰。 &emsp;&emsp;大学四年里它每天和我如影随形，让我去思考、去创造、去解决，我喜欢这样的一个过程。长辈们认为大学学习什么样的专业并不重要，因为当你从事实际的工作以后注定要去从头学习新的东西不是吗？可是这样的思路通常适用于那些对未来没有目标、随遇而安的人，显然我并不是这样的人，我一直都清楚地知道自己想要做什么，从始至终这个目标由大到小，但是从未有所改变。我的长辈们对互联网、对计算机技术基本都没有过深入的了解，他们从来不愿意去尝试这些新的东西，却习惯于去指责我做出了这样一个他们并不期望的选择。我是一名程序员，可是我从来没有觉得我的工作低人一等，我每天的付出和老师给学生授课、销售员给顾客售货、银行柜员给消费者办理业务、公务员为人民服务……并没有什么不同，我靠自己掌握的技能去解决工作中的问题，我靠自己掌握的知识去帮助更多的人，我并没有觉得我选择了一条错误的道路，难道在安逸中渐渐迷失了自我会让你从此与众不同？曾经和老师一起做艾依河的毕业设计，当时觉得对整个艾依河了如指掌，然而每天上下班从宝湖经过的时候却突然发现自己的渺小，我是一个普通人，我想做的事情就是努力让自己变得强大去拥有一个温暖的家，能够让因衰老而疲惫的心有个归宿，不至于在满是迷雾的现实中丢失本心，我就想一直这样简单地生活下去，做正直、正确的事情，做一个温暖、善良的人，做最初的自己。","tags":[{"name":"生活","slug":"生活","permalink":"http://qinyuanpei.github.io/tags/生活/"},{"name":"梦想","slug":"梦想","permalink":"http://qinyuanpei.github.io/tags/梦想/"},{"name":"人生","slug":"人生","permalink":"http://qinyuanpei.github.io/tags/人生/"}]},{"title":"Unity3D游戏场景优化系列之批处理","date":"2015-09-07T10:59:13.000Z","path":"posts/927393529/","text":"&emsp;&emsp;各位朋友大家好，我是秦元培，欢迎大家关注我的博客，我的博客地址是http://qinyuanpei.com。最近开始研究Unity3D游戏场景优化，每次提及游戏优化这个话题的时候，我的脑海中都会浮现出《仙剑奇侠传六》这个让四路泰坦都光荣陨落的神奇游戏，作为一个使用Unity3D引擎进行游戏开发的仙剑玩家，我曾经天真的以为，这款使用Unity3D引擎打造的仙剑二十周年献礼之作，会让我对《仙剑奇侠传》这个系列游戏的未来充满更多期待，然而当游戏真正呈现在我眼前的时候，我感受到了在历代仙剑游戏中从未有过的尴尬和失望，我尴尬的是Unity3D这样一个比较强大的游戏引擎硬生生地被北软玩成了这个鬼样子，我失望的是这部游戏除了剧情和跳跳乐以外并没有什么让人看到希望的东西。 仙剑奇侠传六 不到20帧的优化 &emsp;&emsp;我知道我这样说会有一堆仙剑玩家指责我说，仙剑本来就是玩剧情的嘛，所以只要剧情好其它的都可以原谅啦。然而我们每一个人都清楚《仙剑奇侠传》是一个RPG游戏，它不是每隔三年出一次新番的GAL动漫、不是每隔三年更新一次的言情小说、更不是每隔三年播放一次的偶像电影。两年前的今天我可以耐着性子玩通关《仙剑奇侠传五》，但是这一次我真的玩不下去了。当一个游戏因为优化问题而获得《仙剑奇侠传六：泰坦陨落》称号的时候，作为一个玩家我真的不想再为这个游戏洗白什么，虽然我曾经深爱过这个游戏。所以言归正传，作为一个程序员，我们还是来做点程序员该做的事情，那么我们今天说什么呢，我们来说说Unity3D里的批处理！ ###一、什么是批处理？&emsp;&emsp;我们知道Unity3D在屏幕上绘制一个图形本质上调用OpneGL或者DirectX这样的API，因此在这个过程中会产生一定程度上的性能消耗。DrawCall是OpenGL中描述绘制次数的一个量，例如一个基本的OpenGL绘制流程是设置颜色-&gt;绘图方式-&gt;顶点坐标-&gt;绘制-&gt;结束，在绘制的过程中每帧都会重复这个过程，这就是一次DrawCall，所以当游戏中的绘制过程变得复杂的时候，就会带来DrawCall的急剧增加，进而带来游戏的性能问题，反映到游戏表现上就变成了优化问题。那么在Unity3D中采取了什么样的措施来降低DrawCall呢？这就是我们今天要说的批处理，换句话说Unity3D使用了批处理来达到降低DrawCall的目的，批处理希望通过对物体网格的重组来获得更高的绘制效率，试想以下如果将多个物体合并为一个物体，那么在绘制的时候只需要绘制一次就够了，因此从这个角度上来讲这样做肯定是可以降低DrawCall的，更深刻的一种理解是这里体现了一种资源循环调用的思想，接触过Android开发的朋友们一定知道ListView控件可以对其元素进行“缓存”从而提高效率，因为我们可以发现其实ListView是对列表项进行某种程度上的“复用”从而提高了效率，在Unity3D这里同样遵循了这个原理。在Unity3D中进行批处理的一个前提是相同材质的物体可以被合并，如果这些物体使用不同的材质，那么当我们把这些材质对应的纹理打成“图集”以后可以对其进行合并，并且在合并的时候应该是用Renderer.sharedMaterial 而非 Renderer.material以保证材质是可以共享的。关于DrawCall的相关细节大家从这里来了解,博主并未对图形学领域有过深入的研究，因此就不在这里班门弄斧了啊，哈哈！ ###二、Unity3D中批处理的两种方式&emsp;&emsp;在Unity3D中有静态批处理和动态批处理两种方式，下面我们就来分别说说这两种不同的批处理方式！ ####静态批处理&emsp;&emsp;静态批处理其实大家都是知道的。为什么这样说呢？因为我们在使用Unity3D的过程中无形中培养了这样一个习惯，那就是将场景中相对来说“静态”的物体都勾选Static选项，这在Unity3D中称为Static GameObjects，并且因为这一特性和Lightmapping、Navigation、Off-meshLinks、ReflectionProbe、Occluder and Occludee等内容均有着密切的联系，因此说静态批处理大家都是知道的其实一点都为过，和场景优化相关的内容博主会在后续的博客中涉及，希望大家能及时关注我的博客更新。静态批处理允许游戏引擎尽可能多的去降低绘制任意大小的物体所产生的DrawCall，它会占用更多的内存资源和更少的CPU资源，因为它需要额外的内存资源来存储合并后的几何结构，如果在静态批处理之前，如果有几个对象共享相同的几何结构，那么将为每个对象创建一个几何图形，无论是在编辑器还是在运行时。这看起来是个艰难的选择，你需要在内存性能和渲染性能间做出最为正确的选择。在内部，静态批处理是通过将静态对象转换为世界空间，并为它们构建一个大的顶点+索引缓冲区。然后，在同一批中，一系列的“便宜”画调用，一系列的“便宜”，几乎没有任何状态变化之间的。所以在技术上它并不保存“三维的调用”，但它可以节省它们之间的状态变化（这是昂贵的部分）。使用静态批处理非常简单啦，只要勾选物体的Static选项即可！ ####动态批处理&emsp;&emsp;相对静态批处理而言，动态批处理的要求更为严格一些，它要求批处理的动态对象具有一定的顶点，所以动态批处理只适用于包含小于900个顶点属性的网格。如果你的着色器使用顶点位置，法线和单光，然后你可以批处理300个顶点的动态对象；而如果你的着色器使用顶点位置，法线，uv0，UV1和切线，那么只能处理180个顶点的动态对象。接下来最为重要的一点，如果动态对象使用的是不同的材质，那么即使进行了动态批处理从效率上来讲并不会有太大的提升。如果动态对象采用的是多维子材质，那么批处理是无效的。如果动态对象接收实时光影，同样批处理是无效的。下面展示的是一个将多个物体合并为一个物体的脚本示例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748[MenuItem(&quot;ModelTools/将多个物体合并为一个物体&quot;)] static void CombineMeshs2() &#123; //在编辑器下选中的所有物体 object[] objs=Selection.gameObjects; if(objs.Length&lt;=0) return; //网格信息数组 MeshFilter[] meshFilters =new MeshFilter[objs.Length]; //渲染器数组 MeshRenderer[] meshRenderers = new MeshRenderer[objs.Length]; //合并实例数组 CombineInstance[] combines = new CombineInstance[objs.Length]; //材质数组 Material[] mats = new Material[objs.Length]; for (int i = 0; i &lt; objs.Length; i++) &#123; //获取网格信息 meshFilters[i]=((GameObject)objs[i]).GetComponent&lt;MeshFilter&gt;(); //获取渲染器 meshRenderers[i]=((GameObject)objs[i]).GetComponent&lt;MeshRenderer&gt;(); //获取材质 mats[i] = meshRenderers[i].sharedMaterial; //合并实例 combines[i].mesh = meshFilters[i].sharedMesh; combines[i].transform = meshFilters[i].transform.localToWorldMatrix; &#125; //创建新物体 GameObject go = new GameObject(); go.name = &quot;CombinedMesh_&quot; + ((GameObject)objs[0]).name; //设置网格信息 MeshFilter filter = go.transform.GetComponent&lt;MeshFilter&gt;(); if (filter == null) filter = go.AddComponent&lt;MeshFilter&gt;(); filter.sharedMesh = new Mesh(); filter.sharedMesh.CombineMeshes(combines,false); //设置渲染器 MeshRenderer render = go.transform.GetComponent&lt;MeshRenderer&gt;(); if (render == null) render = go.AddComponent&lt;MeshRenderer&gt;(); //设置材质 render.sharedMaterials = mats; &#125; &emsp;&emsp;这段脚本的核心是CombineMeshes()方法，该方法有三个参数，第一个参数是合并实例的数组，第二个参数是是否对子物体的网格进行合并，第三个参数是是否共享材质，如果希望物体共享材质则第三个参数为true，否则为false。在我测试的过程中发现，如果选择了对子物体的网格进行合并，那么每个子物体都不能再使用单独的材质，默认会以第一个材质作为合并后物体的材质，下面演示的是合并前的多个物体和合并后的一个物体的对比： 合并前 合并后 ###三、批处理效率分析&emsp;&emsp;那么批处理对游戏效率提升究竟有怎样的作用呢？我们来看下面几组测试对比： &emsp;&emsp;1、三个不同的物体使用同一种材质，不做静态批处理，不做动态批处理：DrawCall为4、面数为584、顶点数为641 &emsp;&emsp;2、三个不同的物体使用同一种材质，只做静态批处理，不做动态批处理：DrawCall为2、面数为584、顶点数为641 &emsp;&emsp;3、三个不同的物体使用不同的材质，不做静态批处理，不做动态批处理：DrawCall为4、面数为584、顶点数为641 &emsp;&emsp;4、三个不同的物体使用不同的材质，只做静态批处理，不做动态批处理：DrawCall为4、面数为584、顶点数为641 &emsp;&emsp;5、三个不同的物体使用不同的材质，不做静态批处理，只做动态批处理：DrawCall为4、面数为584、顶点数为641 &emsp;&emsp;6、三个不同的物体使用不同的材质，做静态批处理，做动态批处理：DrawCall为4、面数为584、顶点数为641 &emsp;&emsp;7、三个不同的物体使用同一种材质，不做静态批处理，只做动态批处理：：DrawCall为4、面数为584、顶点数为641 &emsp;&emsp;大家可以注意到各组测试结果中，只有第二组的DrawCall降低，这说明只有当不同的物体使用同一种材质时通过批处理可以从一定程度上降低DrawCall，即我们在文章开始提到的尽可能地保证材质共享。昨天下午兴冲冲地将游戏场景里的某些物体进行了动态批处理，但是实际测试的过程中发现DrawCall非常地不稳定，但是在场景中的某些地方DrawCall却可以降得非常低，如果静态批处理和动态批处理都不能对场景产生较好的优化，那么Unity3D游戏场景的优化究竟要从哪里抓起呢？我觉得这是我们每一个人都该用心去探索的地方，毕竟游戏做出来首先要保证能让玩家流畅的玩下去吧，一味的强调引擎、强调画面，却时常忽略引擎使用者的主观能动性，希望把一切问题都交给引擎去解决，这样的思路是错误而落后的，仙剑六的问题完全是用不用心的问题，我常常看到有人在公开场合说仙剑以后要换虚幻三，其实按照北软现在这样的状态，给他们一个虚幻四也不过是然并卵。我在知乎上看到了号称15岁就开发次时代游戏的高中生妹子，做出个能称为DEMO的游戏就觉得自己可以搞引擎了，更有甚者随便用DirectX或者OpenGL封装若干函数就敢说自己会做游戏引擎了，呵呵，你确定你的游戏能在别人的电脑或者手机上运行起来吗？优化的重要性可见一斑。 ###四、小结&emsp;&emsp;好了，通过今天这篇文章，我们可以整理出以下观点：&emsp;&emsp;1、如果不同的物体间共享材质，则可以直接通过静态批处理降低DrawCall&emsp;&emsp;2、动态批处理并不能降低DrawCall、面数和顶点数（我不会告诉你我昨天傻呵呵地合并了好多场景中的模型，结果面数和顶点数并没有降下来，23333）&emsp;&emsp;3、不管是静态批处理还是动态批处理都会影响Culiing，这同样是涉及到场景优化的一个概念，好吧，为了让场景的DrawCall降下来我最近可能要研究好多涉及的优化的内容……&emsp;&emsp;那么今天的内容就是这样子了，希望对大家学习Unity3D有所帮助，欢迎大家和我交流这些问题来相互促进，毕竟这才是我写博客最初的目的嘛，哈哈！","tags":[{"name":"Unity3D","slug":"Unity3D","permalink":"http://qinyuanpei.github.io/tags/Unity3D/"},{"name":"游戏","slug":"游戏","permalink":"http://qinyuanpei.github.io/tags/游戏/"},{"name":"优化","slug":"优化","permalink":"http://qinyuanpei.github.io/tags/优化/"}]},{"title":"Unity3D游戏开发游戏读/存档在Unity3D中的实现","date":"2015-08-20T08:57:10.000Z","path":"posts/887585917/","text":"&emsp;&emsp;大家好，我是秦元培，欢迎大家关注我的博客。近期博客的更新频率基本直降到冰点，因为这段时间实在是忙得没有时间来写博客了。今天想和大家分享的内容是RPG游戏中游戏存档的实现，因为最近在做一个RPG游戏的项目，所以遇到这个问题就随时记录下来，在对知识进行总结的同时可以将这种思路或者想法分享给大家，这是一件快乐而幸运的事情。我讨厌写按部就班的技术教程，因为我觉得学习是一种自我的探索行为，如果一切都告诉你了，探索的过程便会变得没有意义了。 &emsp;&emsp;游戏存档是一种在单机游戏中特别常见的机制，这种机制是你在玩网络游戏的时候无法体验到的，你知道每次玩完一款单机游戏都会把游戏存档保存起来是一种怎样的感觉吗？它就像是一个征战沙场的将军将陪伴自己一生金戈铁马的宝剑静静地收入剑匣，然而每一次打开它的时候都会不由自主的热泪盈眶。人的本性其实就是游戏，我们每一天发生的故事何尝不是一个游戏？有时候让我们怀念的可能并不是游戏本身，而只是搁浅在时光里的那时的我们。好了，游戏存档是我们在游戏世界里雪泥鸿爪，它代表了我们曾经来到过这个世界。以RPG游戏为例，一个一般化的游戏存档应该囊括以下内容： 角色信息：指一切表征虚拟角色成长路线的信息，如生命值、魔法值、经验值等等。 道具信息：指一切表征虚拟道具数量或者作用的信息，如药品、道具、装备等等。 场景信息：指一切和游戏场景相关的信息，如场景名称、角色在当前场景中的位置坐标等等。 事件信息：指一切和游戏事件相关的信息，如主线任务、支线任务、触发性事件等等。 &emsp;&emsp;从以上信息划分的层次来看，我们可以发现在游戏存档中要储存的信息相对是比较复杂的，那么我们这里不得不说说Unity3D中的数据持久化方案PlayerPrefs。该方案采用的是一种键值型的数据存储方案，支持int、string、float三种基本数据类型，通过键名来获取相对应的数值，当值不存在时将返回一个默认值。这种数据存储方案本质上是将数据写入到一个Xml文件。这种方案如果用来存储简单的信息是没有问题的，可是如果用它来存储游戏存档这样负责的数据结构就显得力不从心了。一个更为重要的问题是在数据持久化的过程中我们希望得到是一个结构化的【游戏存档】实例，显然此时松散的PlayerPrefs是不能满足我们的要求的。因此我们想到了将游戏数据序列化的思路，常见的数据序列化思路主要有Xml和JSON两种形式，在使用Xml的数据序列化方案的时候通常有两种思路，即手动建立数据实体和数据字符间的对应关系和基于XmlSerializer的数据序列化。其中基于XmlSerializer的数据序列化是利用了[Serializable]这样的语法特性来帮助.NET完成数据实体和数据字符间的对应关系，两种思路本质上一样的。可是我们知道Xml的优点是可读性强，缺点是冗余信息多，因此在权衡了两种方案的利弊后，我决定采用JSON来作为数据序列化的方案，而且JSON在数据实体和数据字符间的对应关系上有着天然的优势，JSON所做的事情不就是将数据实体转化为字符串和从一个字符串中解析出数据实体吗？所以整个方案基本一气呵成。好了，下面我们来看具体的代码实现过程吧！ ##一、JSON的序列化和反序列化&emsp;&emsp;这里我使用的是Newtonsoft.Json这个类库，相信大家都是知道的了！因此，序列化和反序列化特别简单。1234567891011121314151617181920212223242526272829/// &lt;summary&gt; /// 将一个对象序列化为字符串 /// &lt;/summary&gt; /// &lt;returns&gt;The object.&lt;/returns&gt; /// &lt;param name=&quot;pObject&quot;&gt;对象&lt;/param&gt; /// &lt;param name=&quot;pType&quot;&gt;对象类型&lt;/param&gt; private static string SerializeObject(object pObject) &#123; //序列化后的字符串 string serializedString = string.Empty; //使用Json.Net进行序列化 serializedString = JsonConvert.SerializeObject(pObject); return serializedString; &#125; /// &lt;summary&gt; /// 将一个字符串反序列化为对象 /// &lt;/summary&gt; /// &lt;returns&gt;The object.&lt;/returns&gt; /// &lt;param name=&quot;pString&quot;&gt;字符串&lt;/param&gt; /// &lt;param name=&quot;pType&quot;&gt;对象类型&lt;/param&gt; private static object DeserializeObject(string pString,Type pType) &#123; //反序列化后的对象 object deserializedObject = null; //使用Json.Net进行反序列化 deserializedObject=JsonConvert.DeserializeObject(pString,pType); return deserializedObject; &#125; ##二、Rijandel加密/解密算法&emsp;&emsp;因为我们这里要做的是一个游戏存档的方案设计，因为考虑到存档数据的安全性，我们可以考虑采用相关的加密/解密算法来实现对序列化后的明文数据进行加密，这样可以从一定程度上保证游戏存档数据的安全性。因为博主并没有深入地研究过加密/解密方面的内容，所以这里仅仅提供一个从MSDN上获取的Rijandel算法，大家感兴趣的话可以自行去研究。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/// &lt;summary&gt; /// Rijndael加密算法 /// &lt;/summary&gt; /// &lt;param name=&quot;pString&quot;&gt;待加密的明文&lt;/param&gt; /// &lt;param name=&quot;pKey&quot;&gt;密钥,长度可以为:64位(byte[8]),128位(byte[16]),192位(byte[24]),256位(byte[32])&lt;/param&gt; /// &lt;param name=&quot;iv&quot;&gt;iv向量,长度为128（byte[16])&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; private static string RijndaelEncrypt(string pString, string pKey) &#123; //密钥 byte[] keyArray = UTF8Encoding.UTF8.GetBytes(pKey); //待加密明文数组 byte[] toEncryptArray = UTF8Encoding.UTF8.GetBytes(pString); //Rijndael解密算法 RijndaelManaged rDel = new RijndaelManaged(); rDel.Key = keyArray; rDel.Mode = CipherMode.ECB; rDel.Padding = PaddingMode.PKCS7; ICryptoTransform cTransform = rDel.CreateEncryptor(); //返回加密后的密文 byte[] resultArray = cTransform.TransformFinalBlock(toEncryptArray, 0, toEncryptArray.Length); return Convert.ToBase64String(resultArray, 0, resultArray.Length); &#125; /// &lt;summary&gt; /// ijndael解密算法 /// &lt;/summary&gt; /// &lt;param name=&quot;pString&quot;&gt;待解密的密文&lt;/param&gt; /// &lt;param name=&quot;pKey&quot;&gt;密钥,长度可以为:64位(byte[8]),128位(byte[16]),192位(byte[24]),256位(byte[32])&lt;/param&gt; /// &lt;param name=&quot;iv&quot;&gt;iv向量,长度为128（byte[16])&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; private static String RijndaelDecrypt(string pString, string pKey) &#123; //解密密钥 byte[] keyArray = UTF8Encoding.UTF8.GetBytes(pKey); //待解密密文数组 byte[] toEncryptArray = Convert.FromBase64String(pString); //Rijndael解密算法 RijndaelManaged rDel = new RijndaelManaged(); rDel.Key = keyArray; rDel.Mode = CipherMode.ECB; rDel.Padding = PaddingMode.PKCS7; ICryptoTransform cTransform = rDel.CreateDecryptor(); //返回解密后的明文 byte[] resultArray = cTransform.TransformFinalBlock(toEncryptArray, 0, toEncryptArray.Length); return UTF8Encoding.UTF8.GetString(resultArray); &#125; ##三、完整代码&emsp;&emsp;好了，下面给出完整代码，我们这里提供了两个公开的方法GetData()和SetData()以及IO相关的辅助方法，我们在实际使用的时候只需要关注这些方法就可以了！123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159/** * Unity3D数据持久化辅助类 * 作者:秦元培 * 时间:2015年8月14日 **/using UnityEngine;using System.Collections;using System;using System.IO;using System.Text;using System.Security.Cryptography;using Newtonsoft.Json;public static class IOHelper&#123; /// &lt;summary&gt; /// 判断文件是否存在 /// &lt;/summary&gt; public static bool IsFileExists(string fileName) &#123; return File.Exists(fileName); &#125; /// &lt;summary&gt; /// 判断文件夹是否存在 /// &lt;/summary&gt; public static bool IsDirectoryExists(string fileName) &#123; return Directory.Exists(fileName); &#125; /// &lt;summary&gt; /// 创建一个文本文件 /// &lt;/summary&gt; /// &lt;param name=&quot;fileName&quot;&gt;文件路径&lt;/param&gt; /// &lt;param name=&quot;content&quot;&gt;文件内容&lt;/param&gt; public static void CreateFile(string fileName,string content) &#123; StreamWriter streamWriter = File.CreateText(fileName); streamWriter.Write(content); streamWriter.Close(); &#125; /// &lt;summary&gt; /// 创建一个文件夹 /// &lt;/summary&gt; public static void CreateDirectory(string fileName) &#123; //文件夹存在则返回 if(IsDirectoryExists (fileName)) return; Directory.CreateDirectory(fileName); &#125; public static void SetData(string fileName,object pObject) &#123; //将对象序列化为字符串 string toSave = SerializeObject(pObject); //对字符串进行加密,32位加密密钥 toSave = RijndaelEncrypt(toSave, &quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;); StreamWriter streamWriter = File.CreateText(fileName); streamWriter.Write(toSave); streamWriter.Close(); &#125; public static object GetData(string fileName,Type pType) &#123; StreamReader streamReader = File.OpenText(fileName); string data = streamReader.ReadToEnd(); //对数据进行解密，32位解密密钥 data = RijndaelDecrypt(data, &quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;); streamReader.Close(); return DeserializeObject(data,pType); &#125; /// &lt;summary&gt; /// Rijndael加密算法 /// &lt;/summary&gt; /// &lt;param name=&quot;pString&quot;&gt;待加密的明文&lt;/param&gt; /// &lt;param name=&quot;pKey&quot;&gt;密钥,长度可以为:64位(byte[8]),128位(byte[16]),192位(byte[24]),256位(byte[32])&lt;/param&gt; /// &lt;param name=&quot;iv&quot;&gt;iv向量,长度为128（byte[16])&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; private static string RijndaelEncrypt(string pString, string pKey) &#123; //密钥 byte[] keyArray = UTF8Encoding.UTF8.GetBytes(pKey); //待加密明文数组 byte[] toEncryptArray = UTF8Encoding.UTF8.GetBytes(pString); //Rijndael解密算法 RijndaelManaged rDel = new RijndaelManaged(); rDel.Key = keyArray; rDel.Mode = CipherMode.ECB; rDel.Padding = PaddingMode.PKCS7; ICryptoTransform cTransform = rDel.CreateEncryptor(); //返回加密后的密文 byte[] resultArray = cTransform.TransformFinalBlock(toEncryptArray, 0, toEncryptArray.Length); return Convert.ToBase64String(resultArray, 0, resultArray.Length); &#125; /// &lt;summary&gt; /// ijndael解密算法 /// &lt;/summary&gt; /// &lt;param name=&quot;pString&quot;&gt;待解密的密文&lt;/param&gt; /// &lt;param name=&quot;pKey&quot;&gt;密钥,长度可以为:64位(byte[8]),128位(byte[16]),192位(byte[24]),256位(byte[32])&lt;/param&gt; /// &lt;param name=&quot;iv&quot;&gt;iv向量,长度为128（byte[16])&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; private static String RijndaelDecrypt(string pString, string pKey) &#123; //解密密钥 byte[] keyArray = UTF8Encoding.UTF8.GetBytes(pKey); //待解密密文数组 byte[] toEncryptArray = Convert.FromBase64String(pString); //Rijndael解密算法 RijndaelManaged rDel = new RijndaelManaged(); rDel.Key = keyArray; rDel.Mode = CipherMode.ECB; rDel.Padding = PaddingMode.PKCS7; ICryptoTransform cTransform = rDel.CreateDecryptor(); //返回解密后的明文 byte[] resultArray = cTransform.TransformFinalBlock(toEncryptArray, 0, toEncryptArray.Length); return UTF8Encoding.UTF8.GetString(resultArray); &#125; /// &lt;summary&gt; /// 将一个对象序列化为字符串 /// &lt;/summary&gt; /// &lt;returns&gt;The object.&lt;/returns&gt; /// &lt;param name=&quot;pObject&quot;&gt;对象&lt;/param&gt; /// &lt;param name=&quot;pType&quot;&gt;对象类型&lt;/param&gt; private static string SerializeObject(object pObject) &#123; //序列化后的字符串 string serializedString = string.Empty; //使用Json.Net进行序列化 serializedString = JsonConvert.SerializeObject(pObject); return serializedString; &#125; /// &lt;summary&gt; /// 将一个字符串反序列化为对象 /// &lt;/summary&gt; /// &lt;returns&gt;The object.&lt;/returns&gt; /// &lt;param name=&quot;pString&quot;&gt;字符串&lt;/param&gt; /// &lt;param name=&quot;pType&quot;&gt;对象类型&lt;/param&gt; private static object DeserializeObject(string pString,Type pType) &#123; //反序列化后的对象 object deserializedObject = null; //使用Json.Net进行反序列化 deserializedObject=JsonConvert.DeserializeObject(pString,pType); return deserializedObject; &#125;&#125; &emsp;&emsp;这里我们的密钥是直接写在代码中的，这样做其实是有风险的，因为一旦我们的项目被反编译，我们这里的密钥就变得很不安全了。这里有两种方法，一种是把密钥暴露给外部方法，即在读取数据和写入数据的时候使用同一个密钥即可，而密钥可以采取由机器MAC值生成的方法，这样每台机器上的密钥都是不同的可以防止数据被破解；其次可以采用DLL混淆的方法让反编译者无法看到代码中的内容，这样就无法获得正确的密钥从而无法获得存档里的内容了。 ##四、最终效果好了，最后我们来写一个简单的测试脚本：123456789101112131415161718192021222324252627282930313233343536373839404142434445using UnityEngine;using System.Collections;using System.Collections.Generic;public class TestSave : MonoBehaviour &#123; /// &lt;summary&gt; /// 定义一个测试类 /// &lt;/summary&gt; public class TestClass &#123; public string Name = &quot;张三&quot;; public float Age = 23.0f; public int Sex = 1; public List&lt;int&gt; Ints = new List&lt;int&gt; () &#123; 1, 2, 3 &#125;; &#125; void Start () &#123; //定义存档路径 string dirpath = Application.persistentDataPath + &quot;/Save&quot;; //创建存档文件夹 IOHelper.CreateDirectory (dirpath); //定义存档文件路径 string filename = dirpath + &quot;/GameData.sav&quot;; TestClass t = new TestClass (); //保存数据 IOHelper.SetData (filename,t); //读取数据 TestClass t1 = (TestClass)IOHelper.GetData(filename,typeof(TestClass)); Debug.Log(t1.Name); Debug.Log(t1.Age); Debug.Log(t1.Ints); &#125; &#125; &emsp;&emsp;脚本执行结果： p1 &emsp;&emsp;加密后游戏存档： p2 &emsp;&emsp;好了，这就是今天的内容了，希望大家能够喜欢，有什么问题可以给我留言，谢谢！&emsp;&emsp;感谢风宇冲Unity3D教程宝典之两步实现超实用的XML存档一文提供相关思路！ 喜欢我的博客请记住我的名字：秦元培，我的博客地址是：http://qinyuanpei.com转载请注明出处，本文作者：秦元培， 本文出处：http://blog.csdn.net/qinyuanpei/article/details/39717795","tags":[{"name":"游戏开发","slug":"游戏开发","permalink":"http://qinyuanpei.github.io/tags/游戏开发/"},{"name":"JSON","slug":"JSON","permalink":"http://qinyuanpei.github.io/tags/JSON/"},{"name":"加密","slug":"加密","permalink":"http://qinyuanpei.github.io/tags/加密/"}]},{"title":"SDL游戏开发系列第二话：基本图形的绘制","date":"2015-07-27T08:48:59.000Z","path":"posts/3789971938/","text":"&emsp;&emsp;各位朋友，大家好，我是秦元培，欢迎大家关注我的博客，我的博客地址是：http://qinyuanpei.com。话题紧接上回，在上回我们讲到了SDL的下载、安装和配置并对SDL游戏有了初步的了解。我们知道游戏开发中最为基础的内容是图形的绘制，因此在我们学习SDL游戏开发的过程中我们同样要从最简单的图形绘制开始学习。在2D游戏开发中，精灵（Sprite）是一个基础而核心的内容，具体来讲精灵首先是一张2D图片，精灵的绘制从本质上是图片的绘制，所以这是一个基础的内容。因为精灵在2D游戏中承担着GameObject的重要角色，所以一个图形引擎对精灵的支持好坏会决定游戏设计的最终效果。今天这篇文章主要是通过使用SDL中的SDL_LoadBMP()、SDL_CreateTextureFromSurface()和SDL_RenderCopy()这三个方法来实现在SDL中基本图形的绘制，从整体上尚属较为简单的内容。可是从学习SDL游戏开发的角度来看，一切都值得我们深入地去研究。好了，这就开始吧！ 使用SDL_loadBMP加载位图&emsp;&emsp;从SDL_LoadBMP()这个方法的名称，我们就可以看出这是一个读取BMP位图的方法。BMP是Windows操作系统中最早的图形格式，这种图形格式的容量较大，经常出现在Win32 API中。好了，言归正传，我们下面来看看整个绘制过程： 1、首先我们使用SDL_LoadBMP()方法来加载一张BMP位图： 12//读取一张BMP位图SDL_Surface* m_pSurface=SDL_LoadBMP(\"background.bmp\"); 2、接下来我们使用SDL_CreateTextureFromSurface()方法将SDL_Surface类型转化为SDL_Texture类型 1234//获取SDL纹理SDL_Texture* m_pTexture=SDL_CreateTextureFromSurface(g_pRenderer,m_pSurface);//释放m_pBackgroundSurfaceSDL_FreeSurface(m_pSurface); 注意到在这里m_pSurface扮演了一个临时演员的角色。当我们获得了SDL纹理后，它的演员生涯便就此结束了，因此我们需要使用SDL_FreeSurface()方法来释放它的内存。 3、接下来是关键性的一个步骤，我们首先来关注SDL_RenderCopy()的方法定义: 1SDL_RenderCopy(SDL_Renderer * renderer,SDL_Texture * texture,const SDL_Rect * srcrect,const SDL_Rect * dstrect); 如你所见，该方法的第一个参数和第二个参数我们已经相当熟悉了，即SDL渲染器和SDL纹理。这里想说的是第三个参数srcrect和第四个参数dstrect，这两个参数都是SDL_Rect类型，表示一个矩形范围，它有四个参数，即矩形左上角横坐标、矩形左上角纵坐标、矩形宽度、矩形高度。那么该如何理解这两个参数呢？ #SDL绘图中的精灵裁剪&emsp;&emsp;这里我是这样理解的：第一个参数srcrect表示一个裁剪范围，即我们希望绘制图形的一个范围。例如我们现在有一张大小为640*480的图片，当我们使用(0,0,640,480)这样一个矩形对图片进行裁剪时，我们将获得整张图片；当我们使用(320,240,320,240)这个矩形对图片进行裁剪的时，我们将获得整张图片右下角1/4的部分。依次类推。相反地，dstrect则更加类似于一个画布（Canvas）的概念，即我们可以在一个多大的矩形范围内去绘制这样一张图片。 &emsp;&emsp;在这里，我们可以联想到2D图形绘制中的SpriteSheet，即“雪碧图”这个概念。在游戏开发中我们常常会使用TexturePacker这样的工具来将零散的小图打包成一张大图，因为这样可以提高游戏运行的效率，该工具最终导出的文件由.plist文件和合成的大图两部分组成，其中的.plist文件中记录了每张小图的位置信息，因此将这个概念引申到这里来，你就会理解这里提到的精灵裁剪，即srcrect这个矩形的作用是选择“大图”中的“小图”，而dstrect这个矩形的作用是决定将选出的“小图”绘制在一个多大的范围内。 &emsp;&emsp;一个经典的例子是我们现在一个有一张1124x676的图片，我们希望将其绘制到一个800x640的窗口作为背景图片，那么我们的代码可以这样写：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/* 添加对SDL的引用 */#include&lt;SDL.h&gt;/* 声明SDL窗口 */SDL_Window *g_pWindow;/* 声明SDL渲染器 */SDL_Renderer *g_pRenderer;/* 声明程序入口函数main */int main(int agrc,char *args[])&#123; //初始化SDL int SDLInit=SDL_Init(SDL_INIT_EVERYTHING); if(SDLInit&gt;=0) &#123; //创建一个SDL窗口 g_pWindow=SDL_CreateWindow(\"SDL Game Development-02\", SDL_WINDOWPOS_CENTERED,SDL_WINDOWPOS_CENTERED, 800,640, SDL_WINDOW_SHOWN); if(g_pWindow!=0)&#123; //创建SDL渲染器 g_pRenderer=SDL_CreateRenderer(g_pWindow,-1,0); &#125; &#125; //设置背景色 SDL_SetRenderDrawColor(g_pRenderer,255,255,255,255); //渲染器清空 SDL_RenderClear(g_pRenderer); //读取一张BMP位图 SDL_Surface* m_pSurface=SDL_LoadBMP(\"background.bmp\"); //获取SDL纹理 SDL_Texture* m_pTexture=SDL_CreateTextureFromSurface(g_pRenderer,m_pSurface); //释放m_pBackgroundSurface SDL_FreeSurface(m_pSurface); //构造SDL矩形 SDL_Rect* m_pSrcRect=new SDL_Rect(); m_pSrcRect-&gt;x=0; m_pSrcRect-&gt;y=0; m_pSrcRect-&gt;w=1124; m_pSrcRect-&gt;h=676; SDL_Rect* m_pTargetRect=new SDL_Rect(); m_pTargetRect-&gt;x=0; m_pTargetRect-&gt;y=0; m_pTargetRect-&gt;w=800; m_pTargetRect-&gt;h=640; //绘制SDL纹理 SDL_RenderCopy(g_pRenderer,m_pTexture,m_pSrcRect,m_pTargetRect); //显示绘制结果 SDL_RenderPresent(g_pRenderer); //注意这里增加秒的延迟是为了看到渲染的结果 //在实际的开发中不应该出现这样的代码因为在运行期间会导致窗口的卡顿 //正确的做法是使用循环来处理这样一个渲染的过程 SDL_Delay(5000); //退出 SDL_Quit(); return 0;&#125; &emsp;&emsp;好了，现在运行这段代码，在运行这段代码前请确保完成了SDL的配置、在Debug目录中存放有一张名为background.bmp的位图文件以及SDL2.dll。如果你准确无误地完成以上注意事项，那么你将毫无意外地看到这样一个画面： SDL游戏开发 #工程示例&emsp;&emsp;现在让我们为这个示例增加点有趣的东西，我们知道在游戏设计中一般背景图片的大小是和游戏设计的窗口大小保持一致的，因为这样能够避免图片拉伸的问题。假定我们目前使用的精灵图片素材都是单个精灵的素材，那么我们可以设计这样一个方法来更加自由地绘制图片：123456789101112131415161718192021222324/* 实现绘制BMP位图的方法 */void DrawBMP(SDL_Renderer* renderer,const char* fileName,int positionX,int positionY,int textureWidth,int textureHeight)&#123; //读取一张BMP位图 SDL_Surface* m_pSurface=SDL_LoadBMP(fileName); //获取SDL纹理 SDL_Texture* m_pTexture=SDL_CreateTextureFromSurface(renderer,m_pSurface); //释放m_pBackgroundSurface SDL_FreeSurface(m_pSurface); //构造SDL矩形 SDL_Rect* m_pSrcRect=new SDL_Rect(); m_pSrcRect-&gt;x=0; m_pSrcRect-&gt;y=0; m_pSrcRect-&gt;w=textureWidth; m_pSrcRect-&gt;h=textureHeight; SDL_Rect* m_pTargetRect=new SDL_Rect(); m_pTargetRect-&gt;x=positionX; m_pTargetRect-&gt;y=positionY; m_pTargetRect-&gt;w=textureWidth; m_pTargetRect-&gt;h=textureHeight; //绘制SDL纹理 SDL_RenderCopy(renderer,m_pTexture,m_pSrcRect,m_pTargetRect); &emsp;&emsp;在认为背景图片大小和窗口大小一致的前提下，我们修改下代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/* 添加对SDL的引用 */#include&lt;SDL.h&gt;/* 声明SDL窗口 */SDL_Window *g_pWindow;/* 声明SDL渲染器 */SDL_Renderer *g_pRenderer;/* 声明相关方法 */void DrawBMP(SDL_Renderer* renderer,const char* fileName,int positionX,int positionY,int textureWidth,int textureHeight);/* 声明程序入口函数main */int main(int agrc,char *args[])&#123; //初始化SDL int SDLInit=SDL_Init(SDL_INIT_EVERYTHING); if(SDLInit&gt;=0) &#123; //创建一个SDL窗口 g_pWindow=SDL_CreateWindow(\"SDL Game Development-02\", SDL_WINDOWPOS_CENTERED,SDL_WINDOWPOS_CENTERED, 1124,676, SDL_WINDOW_SHOWN); if(g_pWindow!=0)&#123; //创建SDL渲染器 g_pRenderer=SDL_CreateRenderer(g_pWindow,-1,0); &#125; &#125; //设置背景色 SDL_SetRenderDrawColor(g_pRenderer,255,255,255,255); //渲染器清空 SDL_RenderClear(g_pRenderer); //在绘制背景图片时因为我们已通过画图软件获得了该图片的大小为1124*676 //并且保证图片的大小和窗口大小一致因此我们可以直接构造一个(0,0,1024,676)的矩形来绘制 DrawBMP(g_pRenderer,\"background.bmp\",0,0,1124,676); //接下来我们在窗口中心绘制一个大小为161*400的美少女 DrawBMP(g_pRenderer,\"girl.bmp\",1124/2-161/2,676/2-400/2,161,400); //显示绘制结果 SDL_RenderPresent(g_pRenderer); SDL_Delay(10000); //退出 SDL_Quit(); return 0;&#125;/* 实现绘制BMP位图的方法 */void DrawBMP(SDL_Renderer* renderer,const char* fileName,int positionX,int positionY,int textureWidth,int textureHeight)&#123; //读取一张BMP位图 SDL_Surface* m_pSurface=SDL_LoadBMP(fileName); //获取SDL纹理 SDL_Texture* m_pTexture=SDL_CreateTextureFromSurface(renderer,m_pSurface); //释放m_pBackgroundSurface SDL_FreeSurface(m_pSurface); //构造SDL矩形 SDL_Rect* m_pSrcRect=new SDL_Rect(); m_pSrcRect-&gt;x=0; m_pSrcRect-&gt;y=0; m_pSrcRect-&gt;w=textureWidth; m_pSrcRect-&gt;h=textureHeight; SDL_Rect* m_pTargetRect=new SDL_Rect(); m_pTargetRect-&gt;x=positionX; m_pTargetRect-&gt;y=positionY; m_pTargetRect-&gt;w=textureWidth; m_pTargetRect-&gt;h=textureHeight; //绘制SDL纹理 SDL_RenderCopy(renderer,m_pTexture,m_pSrcRect,m_pTargetRect);&#125; SDL游戏开发 &emsp;&emsp;现在我们再来运行程序，可以发现在背景图片上绘制了一个美少女，并且这个美少女处于窗口的中心。好了，通过今天的这部分内容我们可以实现在屏幕任意位置绘制图片，这里要注意一个前提，即图片表示的是单个精灵，在绘制过程中不存在裁切和缩放的问题。作为一个有节操的程序员，我们怎么能为了目前的这点成果而止步不前呢？注意到窗口标题上出现了未响应的字样，这是因为我们这里使用了SDL_Delay()这个方法的缘故，该方法会造成程序在运行过程中的卡顿。那么怎么解决这个问题呢？这里就需要涉及到SDL中的事件机制，可能这里大家会有点迷茫，可是我们暂时只需要用到SDL_PollEvent这个方法，这个方法可以帮助我们判断是否触发了某个事件，比如我们需要判断用户是否点击了窗口右上角的关闭按钮：123456SDL_Event m_event;if(SDL_PollEvent(&amp;m_event))&#123; if(m_event.type==SDL_QUIT) SDL_Quit();&#125; &emsp;&emsp;考虑到游戏渲染是一个循环的过程，因此我们只需要在工程示例中增加事件处理的相关代码，就可以解决因为使用SDL_Delay方法而带来的卡顿问题。好了，今天的内容暂时就研究到这里，我们注意到这里的图片都是静态的缺乏某种交互感，而且窗口中心绘制的美少女的有白色背景的，如果我们希望这里透明该怎么做呢？欲知后事如何，且听下回分解，敬请期待SDL游戏开发系列第三话：说说SDL中的扩展库。","tags":[{"name":"游戏","slug":"游戏","permalink":"http://qinyuanpei.github.io/tags/游戏/"},{"name":"SDL","slug":"SDL","permalink":"http://qinyuanpei.github.io/tags/SDL/"},{"name":"图形","slug":"图形","permalink":"http://qinyuanpei.github.io/tags/图形/"},{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://qinyuanpei.github.io/tags/游戏引擎/"}]},{"title":"SDL游戏开发系列第一话：Hello SDL","date":"2015-07-25T15:19:01.000Z","path":"posts/183718218/","text":"&emsp;&emsp;各位读者朋友大家好，我是秦元培，欢迎大家关注我的博客，我的博客地址是http://qinyuanpei.com。从今天起博主将带领大家一起走进SDL游戏开发的世界，如果说此前的Unity3D游戏开发系列文章让大家感受到的是游戏引擎工具化开发的方便与快捷，那么这一次就让我们以SDL库为基础，通过了解游戏开发中的底层图形渲染、输入事件响应等内容来全面认识游戏引擎，博主为SDL游戏开发系列文章建立了专栏，大家可以通过这里获取所有的系列文章，希望大家能够喜欢！好了，作为SDL游戏开发系列的第一篇文章，按照技术性文章写作的国际惯例这将是一篇介绍SDL入门内容的文章，因此这篇文章叫做：Hello SDL。 ###什么是SDL&emsp;&emsp;SDL（Simple DirectMedia Layer）是一套开放源代码的跨平台多媒体开发库，使用C语言写成。SDL提供了数种控制图像、声音、输出入的函数，让开发者只要用相同或是相似的代码就可以开发出跨多个平台如Linux、Windows、Mac OS X等的应用软件。目前SDL可用于游戏、模拟器、媒体播放器等多媒体应用领域的开发，SDL最为著名的案例是曾赢得Linux组游戏开发大奖的游戏《文明：权利的召唤》。或许大家对这个游戏会感到陌生吧，可是如果我提到一个Linux下经典单机游戏《仙剑奇侠传》的开源实现SDLPal相信大家就没有不知道的了吧？这款经典的单机游戏所以能够移植到Linux平台下就是因为使用SDL。好了，在对SDL有了大概的认识后，我们来看看SDL有哪些值得我们去研究的优良特性吧！ SDL提供了从图像、视频、音频、事件、线程、计时器的API，功能特别强大。 SDL具有良好的跨平台性能，支持Windows、Linux及Android和IOS，是开发跨平台多媒体应用的神兵利器。 SDL内置了OpenGL相关函数，使SDL开发3D应用成为可能，因此SDL是一个同时支持2D和3D开发的强力工具。 通过使用SDL_image、SDL_ttf、SDL_mixer、SDL_net等外部扩展库，可以轻松实现JPG、PNG、TIFF图像的加载使用，TrueType字体的使用，MP3文件的使用、网络相关的使用等。 SDL支持C++、C#、Java、 Lisp、Lua、Objective C、Pascal、Perl、 PHP、Python、Ruby等近20种编程语言。 SDL是GNU LGPL 2开源协议下发布的开源软件，该协议允许用户将SDL以动态链接库的形式免费地用于商业游戏软件的开发。 ###SDL的下载、安装和配置&emsp;&emsp;SDL开发相关的资源都可以从http://www.libsdl.org/来获取。目前SDL存在1.2和2.0两个版本，从效率上来说SDL2.0支持硬件加速效率较SDL1.2有了较好的提升，从稳定性上来讲SDL2.0尚处于发展阶段，因此可能其中的Bug较SDL1.2可能会多些。博主这里选择的SDL2.0，下面是相关的下载链接： SDL源代码——下载 SDL二进制库——Win_x86、Win_x64、Mac SDL开发包——VC++、GCC、Mac &emsp;&emsp;博主选择的开发环境是Visual Studio2012，因此下载VC++的SDL开发包。我们将下载得到的SDL开发包解压到本地，可以发现SDL开发包中已经为我们准备好了相关的include文件夹和lib文件夹。其中include文件夹下存放的是SDL的各种头文件，lib文件夹下存放的是编译好的动态链接库（.dll）和依赖库（.lib），如果读者朋友有能力或是希望自行编译SDL源代码的，请先去编译源代码。这里我们为了节省时间，就直接使用编译好的文件了,请大家不要鄙视我啊，哈哈。好了，下面我们来以一个VC++项目为例来讲解SDL的配置： 1、使用Visual Studio创建一个空的VC++项目 2、右键单击项目【属性】打开项目属性页找到【配置属性】-&gt;【VC++目录】然后将包含目录和库目录分别定位到SDL开发包中的include目录和lib目（x86和x64视系统情况而定） 3、在【配置属性】-&gt;【链接器】-&gt;【输入】-&gt;【附加依赖项】中增加SDL2.lib和SDL2main.lib 4、将【配置属性】-&gt;【链接器】-&gt;【系统】-&gt;【子系统】设置为窗口 (/SUBSYSTEM:WINDOWS) 5、将SDL2.dll复制到项目的Debug目录中 ###SDL游戏开发的基本流程&emsp;&emsp;SDL游戏开发的一般流程是： 1、使用SDL_Init()方法对SDL进行初始化。其中该初始化方法的参数类型为int类型，可以从SDL_INIT_HAPTIC、SDL_INIT_AUDIO、SDL_INIT_VIDEO、SDL_INIT_TIMER、SDL_INIT_JOYSTICK、SDL_INIT_EVERYTHING、SDL_INIT_NOPARACHUTE七个类型中选择，分别表示力反馈子系统、音频子系统、视频子系统、计时器子系统、摇杆子系统、全部和忽略致命信号。 2、在SDL初始化成功后使用SDL_CreateWindow()方法创建一个SDL窗口（SDL_Window）。在这里我们可以设置窗口的名称、对齐方式、窗口宽度和窗口高度。 3、在SDL窗口创建成功后使用SDL_CreateRenderer()方法创建一个SDL渲染器（SDL_Renderer）。其中SDL渲染器有SDL_RENDERER_SOFTWARE、SDL_RENDERER_ACCELERATED、SDL_RENDERER_PRESENTVSYNC、SDL_RENDERER_TARGETTEXTURE四种类型分别表示软件渲染、硬件加速、屏幕同步刷新渲染和支持渲染纹理。 4、使用SDL_RenderClear()方法清空SDL渲染器、使用SDL_RenderPresent()方法将渲染的结果显示出来 ###工程示例&emsp;&emsp;下面以一个简单的示例来向大家演示SDL游戏开发的一般流程：12345678910111213141516171819202122232425262728293031323334/* 添加对SDL的引用*/#include&lt;SDL.h&gt;/* 声明SDL_Window */SDL_Window *g_pWindow;/* 声明SDL_Renderer */SDL_Renderer *g_pRenderer;/* 定义入口函数main */int main(int argc,char *args[])&#123; /* SDL三部曲——1:初始化SDL */ int sdlInit=SDL_Init(SDL_INIT_EVERYTHING); if(sdlInit&gt;=0)&#123; /* 当SDL初始化完成后创建一个标题为\"SDL Game Development——01\" */ /* 窗口对齐方式为居中对齐，窗口大小为640*480的窗口 */ g_pWindow=SDL_CreateWindow(\"SDL Game Development——01\", SDL_WINDOWPOS_CENTERED,SDL_WINDOWPOS_CENTERED, 640,480,SDL_WINDOW_SHOWN); /* SDL三部曲——2:初始化SDL渲染 */ if(g_pWindow!=0)&#123; g_pRenderer=SDL_CreateRenderer(g_pWindow,-1,0); &#125; &#125; /* SDL三部曲——3:绘制窗口 */ SDL_SetRenderDrawColor(g_pRenderer,0,0,0,255); SDL_RenderClear(g_pRenderer); SDL_RenderPresent(g_pRenderer); SDL_Quit(); return 0;&#125; &emsp;&emsp;在以上代码中我们基本遵循了SDL游戏开发的一般流程，即首先对SDL进行初始化，当SDL初始化完成后，我们创建一个标题为”SDL学习示例1”,窗口对齐方式为居中对齐，窗口大小为640*480的窗口，然后创建了模式为软件渲染的SDL渲染器，并设置渲染器的背景色为黑色。作为第一个项目，它简单到纯粹，当我们运行项目，会发现一个黑色的窗口一闪而过，这是因为我们这里在渲染了一次后就使用SDL_Quit()方法退出了，第一篇文章并不会有太复杂的内容，因为它的意义在于让我们对SDL游戏开发有个基本的认识和了解。关于SDL绘制图片、文字以及处理渲染循环等问题我们放到后面的文章中去讲，这篇文章的内容就是这样啦，谢谢大家！","tags":[{"name":"游戏","slug":"游戏","permalink":"http://qinyuanpei.github.io/tags/游戏/"},{"name":"SDL","slug":"SDL","permalink":"http://qinyuanpei.github.io/tags/SDL/"},{"name":"图形","slug":"图形","permalink":"http://qinyuanpei.github.io/tags/图形/"},{"name":"引擎","slug":"引擎","permalink":"http://qinyuanpei.github.io/tags/引擎/"}]},{"title":"《仙剑奇侠传六》游戏感言","date":"2015-07-24T09:21:20.000Z","path":"posts/1118169753/","text":"&emsp;&emsp;目前游戏主线剧情进行到50%左右，在游戏尚未通关前，我对于这一部游戏的感觉始终是一种说不清道不明的情感，作为仙剑系列中唯一一部，从项目立项到宣传曝光再到游戏上市整个过程中持续关注的游戏，它可以说是承载了无数玩家的期待和祝福。和大部分玩家一样，在游戏曝光的第一时刻我们曾经热火朝天地讨论过各种各样可能的设定、曾经为这部游戏的系统玩家想过各种各样的尝试，然而当我面对这款游戏的时候，我的内心平静得像一潭死水。我今天23岁，刚刚从大学毕业的我本应该还没有被这个社会完全改变，可我不知道是我变了还是仙剑变了，这一次打开仙剑的时候，我总有一种恍若隔世的恍惚感。 ###引子&emsp;&emsp;曾经，仙剑一的游戏开始界面是简单到不能再简单的竹简、酒葫芦、剑，这些元素组合起来就仗剑江湖的行侠仗义、白云苍狗的醉梦人生和徐徐道来的温暖故事；曾经，仙剑三的《御剑江湖》伴随着云山雾绕的蜀山像一幅遗留在历史深处的卷轴缓缓地打开让人不由得心头一阵惊艳；曾经，仙三外传开头蜀山掌门大战狼妖，无数道剑气凝成的剑柱从天而降可以让你感受到那种仙家道法的玄妙和奇幻；曾经，仙剑四的《回梦游仙》在耳畔响起的时候卷云台像朵清新脱俗的莲花静静地盛开却在最后一刻明白这朵莲花是一切悲剧的开始；曾经，仙剑五前传的明州码头在夕阳和晚霞的交相辉映中，瑾轩和瑕妹依偎在一起看着落霞与孤鹜齐飞是永远的温馨画面…… &emsp;&emsp;可是仙剑六让我看到了什么呢？我看到了一片经过高斯模糊的绿油油的草地，没错！它真的是一片绿油油的草地，以至于当我打开这个游戏的时候我不得不在心里问自己：这真的是一个古风的仙侠/武侠游戏吗？在仙剑奇侠传六的宣传阶段，我在我的QQ群里、我的博客中不断向大家输送着这样一个概念：仙剑六是仙剑奇侠传系列二十年的突破之作，它一定不会让大家失望的，甚至我不遗余力地和游戏圈子里使用Unity3D引擎开发游戏的朋友们说，看，仙剑六是使用Unity3D引擎开发的，它的画面是历代游戏中最好的，这一次它终于要尝试即时战斗了。然而当我打开这个游戏的时候，我知道自己会被打脸，尤其是当我面对接受了我的这些观点的朋友的时候。 &emsp;&emsp;对于此次仙剑六游戏优化的问题，我不想做详细的说明，我更不想为北软洗白，当我们觉得仙剑奇侠传六之泰坦陨落变成一个笑话的时候，我觉得我们可以说说Unity3D这个游戏引擎了。我承认，Unity3D是个手机游戏引擎；我承认，Unity3D在画面表现上无法和UE、CE这些顶级的游戏引擎相提并论；我承认，现在国内各种各样的Unity3D教程满天飞；我承认，Unity3D入门快、成本低、跨平台性能强…….可是这些都不是你们不用心做仙剑六的理由好吗？在我看来，技术从来都没有优劣之分，真正让技术体现出差异的是使用工具的人。Unity3D本质上并非是一个差劲的游戏引擎，所以以引擎来论仙剑六的成败是不恰当而且不应该的，因为使用Unity3D开发的游戏目前已经相当的多了，比如《蒸汽之城》、《太空冒险》、《新仙剑OL》等等以及无数的手机游戏。可是能将这个引擎用到如此地步的恐怕只有仙剑六吧！目前Unity3D的授权方式是收入超过3万美元即18万人民币左右需要按照一定的比例向Unity3D官方支付费用，我不知道这次的优化问题是否会对仙剑六的销量产生影响，可是我觉得恐怕官方都会认为这款游戏存在影响Unity3D引擎声誉的问题吧！ ###一、画面&emsp;&emsp;首先我们来说说游戏画面，我不知道有多少玩家可以在这款游戏中保证特效全开，总之在我的电脑上看起来整个画面有一种糊糊的感觉，远景看起来比较唯美壮丽，然而当我将镜头拉近的时候我觉得我还是不要计较仙剑奇侠传这个游戏的画面了吧！可是我真的不理解，作为仙剑奇侠传系列的好兄弟轩辕剑系列在使用Unity3D制作了两款游戏这样的背景下，北软为什么就不肯向DOMO小组学习哪怕借鉴相关的经验呢？虽然《轩辕剑六》恶名在外、《穹之扉》销量不佳，可是最起码人家的游戏的画面做得相对仙剑六要好很多好不好，况且人家在处理人物和场景时刻意加强了人物面部的特征，通过渲染景深和整体的光照使得画面透露出一种唯美的风格。可是仙剑六呢？仙剑六中做得最好看的永远都是人物的脸，我不知道北软是不是在有意告诉大家：这是一个看脸、靠脸的时代，所以当我们面对这个游戏的时候我们就发现整个游戏除了脸比较漂亮以外基本没有什么优点，可是事实上不同的人物在不同的场合、年龄他的面部应该都是不一样的啊，北软你把所有人的脸都做的这么漂亮，是想告诉玩家都不用去努力工作、只要拼脸就可以了吗？我不知道使用国外的3A级别的游戏引擎如UE、CE等来表现这种中国古典美的场景是否合适，因为这种类型的引擎更适合写实的渲染，而无疑中国的古风游戏需要的是一种意蕴上的美感的渲染。然而《古剑奇谭》和《轩辕剑》在表现这种场景时处理的相对来说是比较好的，这次的所有场景中我比较喜欢的是与青山，因为这个场景的色彩运用可以让玩家很明显的区分开场景中的不同的区域，反观忘尘寰、归墟、天晴之海、饮马河等场景因为使用的色彩较为接近，因为在玩家探索迷宫的时候常常搞晕，再辅以本次游戏中那个神奇的相机视角，探索迷宫的乐趣真是大大的增强啊！我不理解为什么北软连全局光照这种只需要简单设置下参数的东西都不愿意用，却要花大力气在角色的头顶上放置点光源，你告诉我，放置点光源就是为了让角色的头顶亮一下、脸白一点吗？更不要说启魂邪教总坛里那些支持实时反射的水晶石了？难道你宁可要这种华而不实的效果，都要让玩家的计算机耗费资源去支持它吗？景安正武盟门前的那条河的果冻绿材质就不能让美术想办法替换下吗？难道怕玩家不知道你是使用的Unity3D里的标准材质？ 下面是游戏中主角及配角的面部截图，颜值爆表啊！ 果然还是看脸的 下面是《古剑奇谭二》、《穹之扉》、《仙剑六》三部游戏在特效全开的情况下的画面表现，相信高下立判了吧！ 古剑奇谭2最高画质](http://img.blog.csdn.net/20150723095327020)![穹之扉最高画质 仙剑六最高画质 ###二、建模&emsp;&emsp;好了，下面说说建模的问题，我使用disunity对仙剑六的部分.unity3d文件进行了解包，然后发现每个模型文件的包大概在10M左右，像太空步、循环动画、穿模这种问题我就不说了，反正每次说了你们又不打算改。我就来说说这个游戏里的模型吧？对三个模型进行了解包，然后发现这三个模型的单位都是不一样的，就是说在scale为1、1、1的时候三个模型的大小是不一样的；其次模型的角度需要手动改为-90,180,0，我觉得建模的时候难道不应该制定相关的规范吗？我觉得从Max、Maya里导出到FBX到Unity3D的时候难道不应该规范单位、角度和中心点位置吗？我从来不认为游戏引擎就是美术把模型做好了给程序用就行了，我觉得美术在建模的时候更应该去关注模型在这个引擎下的渲染效果，如怎么调整材质、怎么打灯光等等的问题，这些问题不应该推给程序而且不能推给程序。从模型贴图来看，美术想到了诸如法线贴图等等的次世代特性，可是到了实际使用的时候，我看到的结果的是整个游戏里基本清一色的使用了Diffuse着色器，那请问这样做这些贴图有什么意义？既然你根本用不到为什么还要放到游戏里？而且我在模型文件中经常看到诸如Object01或者A_toufa、B_yifu这样的命名，我是一个程序员，对命名比较敏感，我觉得出现汉语拼音式的命名，说明建模的人是特别不专业的。然后我想说的是这次整体美术风格的问题，难道大家不觉得天晴之海的建筑风格偏欧式了吗？这是一个中国的古风游戏啊！难道大家不觉得盈辉堡的道路和房子都是一样的颜色吗？我在地图里转了半天才找到路啊！此次的配角如赢旭危和朔漩的建模普遍要比主角团好看多了，难道你们要开始学《古剑奇谭二》在游戏中潜伏隐藏主角团吗？我不知道一个2015年的游戏出现NPC配音时嘴巴不动是出于什么考虑？NPC不重要吗？NPC戏份没有主角团多可以忍、长得没有主角团帅可以忍，可是你剥夺人家说话的权利是什么鬼？还有骆驼移动的时候没有移动动画直接悬空移动又是想干什么？一个骆驼值得你使用刚体这样的移动方式去移动吗？关于游戏读条慢的情况，我自己测试了下、同时找了相关的资料去查阅，Unity3D场景的异步加载的确有坑存在，可是我相信只要运用合适的方法是可以规避这个问题的，因为目前仅仅解了部分AssetBundle包的内容，所以对程序内部的一些东西还有待确定，等确定后会继续更新到这里。 朔璇模型 赢旭危模型 ###三、剧情&emsp;&emsp;剧情、配音、配乐这里放到一起说，因为这是仙剑六引以为豪的地方，此次的剧情主线有两条，即双越身世之谜和洛家双生子早逝之谜，将这两条线交织在一起的是横道众和柷敔间的矛盾冲突，这样的设定明显是继承了仙五前的多线程叙事方式，这样的叙事方式应该是值得肯定的。但是我不能理解整个游戏到底是以谁为叙事中心的，正如仙剑五是以主角姜云凡为叙事中心的，他所看到的一切推进着整个剧情的深入，再入仙剑五前传是以主角夏侯瑾轩为叙事中心的，围绕着为姜承洗刷冤屈、为瑕妹治病两条主线将所有相关的人或事联系了起来。可是仙剑六我真没看出来是以谁为中心的，整个主角团是仙剑史上最冷漠、最分裂的团队，将大家联系到一起的唯一理由就是存在感爆表的神农九泉，然而这并没有什么卵用，大家都是站在自己的立场上做着自己关心的事情。 &emsp;&emsp;比如越今朝是霸道总裁“只有我一个人可以叫你祈”。一路上不是摸头就是捏脸，可惜手压根没有放到脸上去；再比如越祈是天真傻“我听今朝的”。一路上吃面吃得我都饿了，可是那碗鸡蛋面就是一张贴图啊，吃半天空气最后居然吃完了，我要向仙剑六的四位程序员致敬；再比如闲卿是典型的双标狗，一面要讨好老婆洛昭言和世侄小绣儿，一面还要做出一副闲适淡泊的样子，我都忍不住要为你的演技点赞；再比如耳光绣明绣，我觉得要么是美术和策划有仇，故意将这样一个凶狠的角色画成甜美可人的女神范儿，要么就是编剧经常看琼瑶剧比较热衷于打人耳光，一个武侠游戏有什么不满直接亮兵器不就好了，要是当年月如被逍遥在扬州城外欺负了直接打李逍遥一个耳光，我觉得这个角色恐怕要失去不少忠实粉丝吧;再比如说技术宅居士方这货总是一副“你们都是对的，怪我咯”的态度，我至今都想不明白他有什么不对的地方，既然大家都不拿你当朋友，你凭什么要为这样一群人牺牲豆包啊。我一直喜欢仙剑营造的那种朋友间比较温暖的情感，比如仙剑四里小紫英一句“承君此诺必守一生”就会让人觉得温暖，即使以后大家分开了彼此的心中还可以相互牵挂。可是仙剑六呢，那晚大家做一起赏月喝酒本来应该是彼此相互了解和认识的机会，结果大家都忙着去约会了，留下居十方一个人在哪里喝闷酒，甚至他喝醉了酒吐露心事主角团中竟然无一人听见，我严重怀疑编剧每次和同学聚会的时候都是那个抢着麦克风嘶吼却从来不会有人去安慰他的那个人，编剧啊，己所不欲勿施于人啊。我一直认为一个RPG游戏的核心在于代入感，就是说你要让玩家觉得他就是游戏中的主角。比如我们玩仙剑一的时候就感觉自己是李逍遥，仙五前谢叔单挑姜世离的时候我们就感觉自己是谢叔，这就是代入感。 &emsp;&emsp;可是仙剑六呢，居然巧妙的避开了这一点，搞得从头到尾都像在看电影，不，应该是叫做在看幻灯片。我不知道仙六是不是借鉴了《古剑奇谭二》的叙事方式，整个叙述视角更像是以上帝俯视人间的视角在讲整个故事，如果说《古剑奇谭二》成就了流月城，那么仙剑六便成就了衡道众，而且编剧觉得为了和《古剑奇谭二》拉开差距，刻意让站在对立面的衡道众认识到自己的错误并对主角一行人提供了补偿。我承认，这让仙剑六在立意上有了深度，可是我接下来要说的就是你们的不对了。我们玩仙剑一的时候比武招亲、蜀山剑法、林家绝学、苗疆蛊术、五灵仙术我们从来不会觉得存在违和感，因为这些东西都是东方文化中已有或者说可以找到起源追朔的东西，可是仙剑六的编剧你告诉我整个仙剑六除了鲲鹏能够在庄子的《逍遥游》中找到记载以外，其他的这些是中国传统文化存在的吗？是，时空穿越早就有了，可是回魂仙梦和血濡回魂都无法改变已经发生的事情；是，在天上飞早就有了，可是蜀山仙剑派御剑飞行早在武侠小说、志怪小说中有记载，所以蜀山的御剑术不会存在丝毫的违和感，可是你搞个二十一世纪都未必有的飞行器是什么鬼，古时候尝试上天的人最多是在一个椅子上捆满火药，希望通过反冲力飞到天上去，结果为科学事业献身了，编剧你告诉我这是什么鬼。我真傻，我单单知道黑科技会在仙剑剧里出现，却不知道有一天会在仙剑游戏里出现，你告诉我御界枢的人都是外星人吗？我们使用智能手机、平板电脑不过四五年的样子，编剧你告诉我衡道众里的人是怎么做到的，他们是从未来穿越过去的嘛？好了，下面请允许我替历代仙剑中因为剧情需要而牺牲的各位男主角、女主角、男配角、女配角、小怪以及Boss说句公道话，为什么六代的人可以通过交换实现“不死”的愿望，而六代以前的就只能领便当？我知道编剧一定会说，因为这次我们采用了全新的以神农为中心的世界观，可是编剧好像忘了神农和女娲差不多是同时在宇宙中产生的吧？我觉得五代的Boss魔翳比较冤枉，冒着做坏人的危险、拼着命为魔界找来了水源，结果你说九泉之一的热海同样可以产生水源，我原本只要伤害洛埋名一人就可以取得水源，结果就因为你这奇怪的设定，五代造就了仙剑史上最大的牺牲，编剧啊编剧原来你是真正的幕后黑手，神马黑包子各种连携技全都弱爆了好吗？你把仙剑六的故事设定到仙五前的五六十年里难道不担心这个世界的变化跟不上你的节奏吗？编剧你一句话就让蜀山派这样的神权天授、依靠盘古之心存在于世间的正派组织荡然无存啊，你告诉我御剑术都在江湖上失传了，这是摆明了以后不会再出现蜀山或者御剑术的节奏吗？我乐意看到仙剑六在世界观上的变化，可是这个新的世界观应该是原来以女娲为中心的世界观的一种补充而非推翻啊，你提出了神农九泉的概念，我觉得这个设定可以让仙剑的题材变得新颖些，然并卵这一次就把九泉的故事差不多都讲完了，是想等下一部游戏立项的时候再次推翻这次的设定，编剧啊，你到底是来挖坑的还是扩展仙剑的游戏世界观的啊！ 仙剑六黑科技 ###四、游戏性&emsp;&emsp;下面我们来重点说说游戏性。你问我为什么要说游戏性啊？一个游戏、一个商业游戏不提游戏性你觉得提什么呢？首先我想强调一个观点，认为仙剑六只要剧情好就行了的朋友请向姚仙建议将仙剑做成一个动漫或者电影，这样大家连自动战斗都不用点了对吧！仙剑六的突破挺多的，可惜注重了量而不注重质，这样平均下来仙剑六的突破其实很少很少。首先，我们来说说开放地图的问题，因为地图开放了玩家可以自由探索的地方就多了，可是你要真的想做好开放地图，就应该认真的去设计空气墙而不是等玩家掉坑里出来的时候打开游戏菜单重新回到原点。因为你们在设置空气墙的时候不用心，在过饮马河和去落日部的路上，比如祈妹的隔空移物和今朝的凌空飞剑，我不会告诉你我是直接从两边的石头上跳过去的。抓猫是挺好玩的，可是你告诉我玩家站在树顶纹丝不动、走绳子如履平地是什么鬼，在没有对Unity3D内部集成的Physic物理引擎进行完全充分的了解的情况下，贸然使用这样的技术你确定你能驾驭得好吗？浮金堂我跳了一个下午没有跳过去，然后跳出各种Bug，我终于明白这次为什么有人能玩到70个小时以上啦，恭喜北软你们终于知道了怎样延长一个游戏的时间。这次的开机关让居十方都觉得郁闷，因为每次需要开机关的时候都会提示“开机关这种事情还是让十方去做吧!”，当我终于庆幸有用得着十方的时候，这下轮到我郁闷了，难道小游戏就不能给点提示吗？我总得知道自己要做什么吧！划船我再转了不知多久以后才明白过来怎么控制船的移动方向和角度，这种小问题难道每次都要让大家说吗？这次的迷宫设计有了层次感和立体感，比如启魂邪教总坛的迷宫和机关设计得都不错，天晴之海得迷宫设计得比较好，然而我最喜欢的是与青山这个场景！ 我就放个图，不说话！ 浮金堂跳跃Bug &emsp;&emsp;好了，说完这些小游戏，我们来说说这次仙剑六的战斗系统。我想知道，究竟是什么样的一种考量让你们选择去模仿FF13的战斗模式，难道是为了刻意和《古剑奇谭二》有所不同？然并卵，这次的战斗系统糟糕透了。首先，我是希望仙剑的战斗系统慢慢地向着即时制的方向发展的，因为这是现在的大势所趋吧，尤其是《古剑奇谭》、《雨血》和《御天降魔传》这类游戏正在引领着大家的兴趣往即时方向转变，在这样的背景下仙剑积极地向即时制转变从某种程度上来讲是一种不得不采取的防御性措施。可是我有教过你用一个伪即时制的战斗系统来欺骗大家的感情吗？以前大家对排站好在每个回合里我们可以依次控制多名角色，然后依次释放技能，通过不同角色间策略的调整来将游戏进行下去；现在大家迈着太空步，在每个回合里我们可以控制一名角色，每次可以发动多次行动，其他角色由AI控制，然后场景中各种粒子特效乱飞。当我看到粒子特效贴图的矩形边框时，我的内心是奔溃的。你告诉我这样的战斗系统和回合制有什么区别？当初主企划说为了让大家更好的观赏战斗画面特意将UI做到了右下角，可是你告诉我在一个即时制的游戏里用眼角的余光扫视右下角然后用滚动条从一堆物品中选择需要的物品该有多蛋疼，等你选好了，队友或者玩家可能已经死了。所以我们的数值策划为明绣配置逆天的治疗数值，这样一来大家就不用吃药了。呵呵，是你们该吃药了吧，你告诉我一个游戏玩到现在我都没记住几个技能的名称，以后问起来大家提到万剑诀、天剑、酒神、真元护体、天罡战气、五灵归宗、乾坤一掷、气疗术、气指剑、万物归烬、仙风云体、千方残光剑等等经典招式的时候，我希望你们不要说我们厚此薄彼就好。我相信有好多妹子已经习惯开着自动战斗直接看剧情的习惯了吧，如果这样仙剑还不如买小说或者拍动漫呢，正好这次所有的过场动画都是2D动画的形式，可是你告诉我2D动画是一种风格、3D建模是一种风格、小剧情表情是一种风格，一个游戏里三种风格，你是打算同时照顾动漫和游戏两个不同群体的玩家吗？然并卵，你这样做了不见得人家会领情，人家会说你抄袭、撞梗，你说你又是何苦呢？我给仙剑六战斗系统提点意见吧，希望可以支持玩家自定义快捷键，比如玩家可以挑选自己喜欢的技能和常用的物品，每次使用都会消耗行动点数，行动点数目消耗完了就触发技能动画，这样至少可以让点鼠标变得高端些，就像英雄联盟说白了就是Q、W、E三个键各种按，可是你同样可以装X地说这里面涉及到走位和意识。对了，灵脉系统界面能不能点击了以后不要放大，你觉得那样真的好看吗？再说三种培养方式我非得一条路走到黑？ 战斗系统截图1 战斗系统截图2 &emsp;&emsp;好了，熬夜到凌晨三点写完这篇文章，我对仙剑绝对是真爱，我知道一定会有许多人来吐槽我写的这篇吐槽，可我想说的是：你要真的爱它就别总是惯着它，真正的爱从来都不是溺爱！在官方放出第三版补丁后，整个游戏的优化得到了较好的提升，从感官上像个游戏了，如果有朋友还在徘徊不定，不妨在这个时候尝试下吧！以上观点，一家之言，不足为据！","tags":[{"name":"Unity3D","slug":"Unity3D","permalink":"http://qinyuanpei.github.io/tags/Unity3D/"},{"name":"游戏","slug":"游戏","permalink":"http://qinyuanpei.github.io/tags/游戏/"},{"name":"仙剑奇侠传","slug":"仙剑奇侠传","permalink":"http://qinyuanpei.github.io/tags/仙剑奇侠传/"},{"name":"RPG","slug":"RPG","permalink":"http://qinyuanpei.github.io/tags/RPG/"}]},{"title":"Unity3D游戏开发之SQLite让数据库开发更简单","date":"2015-07-09T09:47:06.000Z","path":"posts/582264328/","text":"&emsp;&emsp;各位朋友大家好，欢迎大家关注我的博客，我是秦元培，我是博客地址是http://blog.csdn.net/qinyuanpei。在经历了一段时间的忙碌后，博主终于有时间来研究新的东西啦，今天博客向和大家一起交流的内容是在Unity3D游戏开发中使用SQLite进行数据库开发，坦白来讲，在我的技术体系中Web和数据库是相对薄弱的两个部分，因此正好这段时间项目需要和服务器、数据库进行交互，因此在接下来的文章中博主可能会更加倾向于讲解这方面的内容，希望大家能够喜欢啊！ ##一、什么是SQLite？&emsp;&emsp;SQLite是一款轻型的数据库，是遵守ACID的关系型数据库管理系统，它包含在一个相对小的C库中，以嵌入式作为它的设计目标，它占用资源非常的低，因此适合在嵌入式设备如Android、Ruby on Rails等中使用。它能够支持Windows/Linux/Unix等等主流的操作系统，同时能够跟和C、C++、Ruby、Python、C#、PHP、Java等编程语言相结合。SQLite是一个以文件形式存在的关系型数据库，尽管无法实现分布式和横向扩展，可是作为一个轻量级的嵌入式数据库，它不需要系统提供服务支持，通过SDK直接操作文件避免了对数据库维护的相关事务，从这个角度来讲它是一个出色的数据库。 ##二、为什么要选择SQLite&emsp;&emsp;好了，在了解了SQLite后，我们来了解下SQLite有哪些让我们心动的特性，或者说我们为什么要选择SQLite，因为在这个世界上我们有太多的数据库可以选择，诸如Oracle、MySQL、SQLServer、DB2、NoSQL、MongoDB等等： ACID事务 零配置 – 无需安装和管理配置 储存在单一磁盘文件中的一个完整的数据库 数据库文件可以在不同字节顺序的机器间自由的共享 支持数据库大小至2TB 足够小, 大致13万行C代码, 4.43M 比一些流行的数据库在大部分普通数据库操作要快—SQLite读写效率如此之高，会使用其他数据库的理由是？ 简单, 轻松的API 包含TCL绑定, 同时通过Wrapper支持其他语言的绑定 良好注释的源代码, 并且有着90%以上的测试覆盖率 独立: 没有额外依赖 源码完全的开源, 你可以用于任何用途, 包括出售它 支持多种开发语言，C, C++, PHP, Perl, Java, C#,Python, Ruby等 ##三、Unity3D中的SQLite&emsp;&emsp;在Unity3D中使用SQLite，我们首先要明白这样一件事情，即我们这里的使用的SQLite并非是通常意义上的SQLite.NET,而是经过移植后的Mono.Data.Sqlite。因为Unity3D基于Mono，因此使用移植后的Mono.Data.Sqlite能够减少我们的项目在不同平台上出现各种各样的问题。在Unity3D中使用的SQLite以Mono.Data.Sqlite.dll即动态链接库的形式给出，因此我们需要将这个文件放置在项目目录下的Plugins文件夹中，此外我们需要System.Data.dll或者Mono.Data.dll这两个文件添加到Plugins目录中，因为我们需要的部分数据相关的API或者类都定义在这两个文件当中，这些文件可以从这里直接下载。 PS：博主注意到在网上有使用Mono.Data.SQLiteClient.dll这个库实现在Unity3D操作SQLite数据库的相关文章，博主大概看了下，感觉和使用Mono.Data.Sqlite.dll这个库大同小异，大家喜欢哪个就用哪个吧！哈哈！博主在开源社区找到一个版本库，据说可以同时支持.NET和Mono，如果大家感兴趣欢迎大家去测试啊，哈哈! &emsp;&emsp;在正式开始写代码前，我们首先来回顾下通常情况下数据库读写的基本流程吧！ 定义数据库连接字符串(ConnectionString)完成数据库连接的构造，建立或者打开一个数据库。 定义相关的SQL命令(Command)通过这些命令实现对数据库的增加、删除、更新、读取四种基本功能。 在完成各种数据库操作后及时关闭数据库连接，解除对数据库的连接和引用。 &emsp;&emsp;SQLite作为一款优秀的数据库，在为其编写数据库相关代码时同样遵循这样的流程，考虑到对数据库的增加、删除、更新、读取四种操作具有类似性和统一性，因此在动手写Unity3D脚本前，首先让我们来编写一个SQLite的辅助类SQLiteHelper.cs。该类代码定义如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222using UnityEngine;using System.Collections;using Mono.Data.Sqlite;using System;public class SQLiteHelper&#123; /// &lt;summary&gt; /// 数据库连接定义 /// &lt;/summary&gt; private SqliteConnection dbConnection; /// &lt;summary&gt; /// SQL命令定义 /// &lt;/summary&gt; private SqliteCommand dbCommand; /// &lt;summary&gt; /// 数据读取定义 /// &lt;/summary&gt; private SqliteDataReader dataReader; /// &lt;summary&gt; /// 构造函数 /// &lt;/summary&gt; /// &lt;param name=&quot;connectionString&quot;&gt;数据库连接字符串&lt;/param&gt; public SQLiteHelper(string connectionString) &#123; try&#123; //构造数据库连接 dbConnection=new SqliteConnection(connectionString); //打开数据库 dbConnection.Open(); &#125;catch(Exception e) &#123; Debug.Log(e.Message); &#125; &#125; /// &lt;summary&gt; /// 执行SQL命令 /// &lt;/summary&gt; /// &lt;returns&gt;The query.&lt;/returns&gt; /// &lt;param name=&quot;queryString&quot;&gt;SQL命令字符串&lt;/param&gt; public SqliteDataReader ExecuteQuery(string queryString) &#123; dbCommand = dbConnection.CreateCommand(); dbCommand.CommandText = queryString; dataReader = dbCommand.ExecuteReader(); return dataReader; &#125; /// &lt;summary&gt; /// 关闭数据库连接 /// &lt;/summary&gt; public void CloseConnection() &#123; //销毁Command if(dbCommand != null)&#123; dbCommand.Cancel(); &#125; dbCommand = null; //销毁Reader if(dataReader != null)&#123; dataReader.Close(); &#125; dataReader = null; //销毁Connection if(dbConnection != null)&#123; dbConnection.Close(); &#125; dbConnection = null; &#125; /// &lt;summary&gt; /// 读取整张数据表 /// &lt;/summary&gt; /// &lt;returns&gt;The full table.&lt;/returns&gt; /// &lt;param name=&quot;tableName&quot;&gt;数据表名称&lt;/param&gt; public SqliteDataReader ReadFullTable(string tableName) &#123; string queryString = &quot;SELECT * FROM &quot; + tableName; return ExecuteQuery (queryString); &#125; /// &lt;summary&gt; /// 向指定数据表中插入数据 /// &lt;/summary&gt; /// &lt;returns&gt;The values.&lt;/returns&gt; /// &lt;param name=&quot;tableName&quot;&gt;数据表名称&lt;/param&gt; /// &lt;param name=&quot;values&quot;&gt;插入的数值&lt;/param&gt; public SqliteDataReader InsertValues(string tableName,string[] values) &#123; //获取数据表中字段数目 int fieldCount=ReadFullTable(tableName).FieldCount; //当插入的数据长度不等于字段数目时引发异常 if(values.Length!=fieldCount)&#123; throw new SqliteException(&quot;values.Length!=fieldCount&quot;); &#125; string queryString = &quot;INSERT INTO &quot; + tableName + &quot; VALUES (&quot; + values[0]; for(int i=1; i&lt;values.Length; i++) &#123; queryString+=&quot;, &quot; + values[i]; &#125; queryString += &quot; )&quot;; return ExecuteQuery(queryString); &#125; /// &lt;summary&gt; /// 更新指定数据表内的数据 /// &lt;/summary&gt; /// &lt;returns&gt;The values.&lt;/returns&gt; /// &lt;param name=&quot;tableName&quot;&gt;数据表名称&lt;/param&gt; /// &lt;param name=&quot;colNames&quot;&gt;字段名&lt;/param&gt; /// &lt;param name=&quot;colValues&quot;&gt;字段名对应的数据&lt;/param&gt; /// &lt;param name=&quot;key&quot;&gt;关键字&lt;/param&gt; /// &lt;param name=&quot;value&quot;&gt;关键字对应的值&lt;/param&gt; public SqliteDataReader UpdateValues(string tableName,string[] colNames,string[] colValues,string key,string operation,string value) &#123; //当字段名称和字段数值不对应时引发异常 if(colNames.Length!=colValues.Length) &#123; throw new SqliteException(&quot;colNames.Length!=colValues.Length&quot;); &#125; string queryString = &quot;UPDATE &quot; + tableName + &quot; SET &quot; + colNames[0] + &quot;=&quot; + colValues[0]; for(int i=1; i&lt;colValues.Length; i++) &#123; queryString+=&quot;, &quot; + colNames[i] + &quot;=&quot; + colValues[i]; &#125; queryString += &quot; WHERE &quot; + key + operation + value; return ExecuteQuery(queryString); &#125; /// &lt;summary&gt; /// 删除指定数据表内的数据 /// &lt;/summary&gt; /// &lt;returns&gt;The values.&lt;/returns&gt; /// &lt;param name=&quot;tableName&quot;&gt;数据表名称&lt;/param&gt; /// &lt;param name=&quot;colNames&quot;&gt;字段名&lt;/param&gt; /// &lt;param name=&quot;colValues&quot;&gt;字段名对应的数据&lt;/param&gt; public SqliteDataReader DeleteValuesOR(string tableName,string[] colNames,string[] operations,string[] colValues) &#123; //当字段名称和字段数值不对应时引发异常 if(colNames.Length!=colValues.Length || operations.Length!=colNames.Length || operations.Length!=colValues.Length) &#123; throw new SqliteException(&quot;colNames.Length!=colValues.Length || operations.Length!=colNames.Length || operations.Length!=colValues.Length&quot;); &#125; string queryString = &quot;DELETE FROM &quot; + tableName + &quot; WHERE &quot; + colNames[0] + operations[0] + colValues[0]; for(int i=1; i&lt;colValues.Length; i++) &#123; queryString+=&quot;OR &quot; + colNames[i] + operations[0] + colValues[i]; &#125; return ExecuteQuery(queryString); &#125; /// &lt;summary&gt; /// 删除指定数据表内的数据 /// &lt;/summary&gt; /// &lt;returns&gt;The values.&lt;/returns&gt; /// &lt;param name=&quot;tableName&quot;&gt;数据表名称&lt;/param&gt; /// &lt;param name=&quot;colNames&quot;&gt;字段名&lt;/param&gt; /// &lt;param name=&quot;colValues&quot;&gt;字段名对应的数据&lt;/param&gt; public SqliteDataReader DeleteValuesAND(string tableName,string[] colNames,string[] operations,string[] colValues) &#123; //当字段名称和字段数值不对应时引发异常 if(colNames.Length!=colValues.Length || operations.Length!=colNames.Length || operations.Length!=colValues.Length) &#123; throw new SqliteException(&quot;colNames.Length!=colValues.Length || operations.Length!=colNames.Length || operations.Length!=colValues.Length&quot;); &#125; string queryString = &quot;DELETE FROM &quot; + tableName + &quot; WHERE &quot; + colNames[0] + operations[0] + colValues[0]; for(int i=1; i&lt;colValues.Length; i++) &#123; queryString+=&quot; AND &quot; + colNames[i] + operations[i] + colValues[i]; &#125; return ExecuteQuery(queryString); &#125; /// &lt;summary&gt; /// 创建数据表 /// &lt;/summary&gt; + /// &lt;returns&gt;The table.&lt;/returns&gt; /// &lt;param name=&quot;tableName&quot;&gt;数据表名&lt;/param&gt; /// &lt;param name=&quot;colNames&quot;&gt;字段名&lt;/param&gt; /// &lt;param name=&quot;colTypes&quot;&gt;字段名类型&lt;/param&gt; public SqliteDataReader CreateTable(string tableName,string[] colNames,string[] colTypes) &#123; string queryString = &quot;CREATE TABLE &quot; + tableName + &quot;( &quot; + colNames [0] + &quot; &quot; + colTypes [0]; for (int i=1; i&lt;colNames.Length; i++) &#123; queryString+=&quot;, &quot; + colNames[i] + &quot; &quot; + colTypes[i]; &#125; queryString+= &quot; ) &quot;; return ExecuteQuery(queryString); &#125; /// &lt;summary&gt; /// Reads the table. /// &lt;/summary&gt; /// &lt;returns&gt;The table.&lt;/returns&gt; /// &lt;param name=&quot;tableName&quot;&gt;Table name.&lt;/param&gt; /// &lt;param name=&quot;items&quot;&gt;Items.&lt;/param&gt; /// &lt;param name=&quot;colNames&quot;&gt;Col names.&lt;/param&gt; /// &lt;param name=&quot;operations&quot;&gt;Operations.&lt;/param&gt; /// &lt;param name=&quot;colValues&quot;&gt;Col values.&lt;/param&gt; public SqliteDataReader ReadTable(string tableName,string[] items,string[] colNames,string[] operations, string[] colValues) &#123; string queryString = &quot;SELECT &quot; + items [0]; for (int i=1; i&lt;items.Length; i++) &#123; queryString+=&quot;, &quot; + items[i]; &#125; queryString += &quot; FROM &quot; + tableName + &quot; WHERE &quot; + colNames[0] + &quot; &quot; + operations[0] + &quot; &quot; + colValues[0]; for (int i=0; i&lt;colNames.Length; i++) &#123; queryString+=&quot; AND &quot; + colNames[i] + &quot; &quot; + operations[i] + &quot; &quot; + colValues[0] + &quot; &quot;; &#125; return ExecuteQuery(queryString); &#125;&#125; &emsp;&emsp;SQLiteHelper类主要实现了数据库、数据表的创建以及数据表中记录的增加、删除、更新、读取四种基本功能。该类最初由国外的Unity3D开发者发布在Unity3D官方论坛,后来经宣雨松使用C#进行重写，我在此基础上进行了完善，再此对两位大神的无私付出表示感谢。这里要说明的有三点： 一、在Unity3D编辑器下生成数据库文件(.db)默认位于和Assets目录同级的位置，即项目的工程文件夹中。我们可以通过修改路径在改变数据库文件的存储位置，具体来讲：Windows平台：data source=Application.dataPath/数据库名称.dbIOS平台：data source=Application.persistentDataPath/数据库名称.dbAndroid平台：URL=file:Application.persistentDataPath/数据库名称.db(我想说Android平台就是个奇葩，搞什么特殊化嘛) 二、确保Unity3D编辑器中的.NET版本和MonoDevelop中的.NET版本都为2.0版本，在Unity3D中打包导出的程序可能不会保留数据库文件，因此需要手动将数据库文件拷贝到相应的位置，当然更加合理的方案是将数据库文件存放到StreamingAssets文件夹下，然后在第一次加载游戏的时候将数据库文件复制到对应平台上的存放位置。 三、在使用InsertValues方法时请参考SQLite中字段类型与C#中数据类型的对应关系，博主目前测试了int类型和string类型都没有什么问题，更多类型的数据请大家自行测试然后告诉博主测试的结果，如果大家有兴趣扩展这个辅助类的话可以自行去扩展哦，嘿嘿！ &emsp;&emsp;好了，千呼万唤始出来的时候到了，下面我们以一个实例来完成今天的项目讲解，因为我们已经定义好了SQLite的辅助类，因此我们可以快速地编写出下面的脚本代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566using UnityEngine;using System.Collections;using System.IO;using Mono.Data.Sqlite;public class SQLiteDemo : MonoBehaviour &#123; /// &lt;summary&gt; /// SQLite数据库辅助类 /// &lt;/summary&gt; private SQLiteHelper sql; void Start () &#123; //创建名为sqlite4unity的数据库 sql = new SQLiteHelper(&quot;data source=sqlite4unity.db&quot;); //创建名为table1的数据表 sql.CreateTable(&quot;table1&quot;,new string[]&#123;&quot;ID&quot;,&quot;Name&quot;,&quot;Age&quot;,&quot;Email&quot;&#125;,new string[]&#123;&quot;INTEGER&quot;,&quot;TEXT&quot;,&quot;INTEGER&quot;,&quot;TEXT&quot;&#125;); //插入两条数据 sql.InsertValues(&quot;table1&quot;,new string[]&#123;&quot;&apos;1&apos;&quot;,&quot;&apos;张三&apos;&quot;,&quot;&apos;22&apos;&quot;,&quot;&apos;Zhang3@163.com&apos;&quot;&#125;); sql.InsertValues(&quot;table1&quot;,new string[]&#123;&quot;&apos;2&apos;&quot;,&quot;&apos;李四&apos;&quot;,&quot;&apos;25&apos;&quot;,&quot;&apos;Li4@163.com&apos;&quot;&#125;); //更新数据，将Name=&quot;张三&quot;的记录中的Name改为&quot;Zhang3&quot; sql.UpdateValues(&quot;table1&quot;, new string[]&#123;&quot;Name&quot;&#125;, new string[]&#123;&quot;&apos;Zhang3&apos;&quot;&#125;, &quot;Name&quot;, &quot;=&quot;, &quot;&apos;张三&apos;&quot;); //插入3条数据 sql.InsertValues(&quot;table1&quot;,new string[]&#123;&quot;3&quot;,&quot;&apos;王五&apos;&quot;,&quot;25&quot;,&quot;&apos;Wang5@163.com&apos;&quot;&#125;); sql.InsertValues(&quot;table1&quot;,new string[]&#123;&quot;4&quot;,&quot;&apos;王五&apos;&quot;,&quot;26&quot;,&quot;&apos;Wang5@163.com&apos;&quot;&#125;); sql.InsertValues(&quot;table1&quot;,new string[]&#123;&quot;5&quot;,&quot;&apos;王五&apos;&quot;,&quot;27&quot;,&quot;&apos;Wang5@163.com&apos;&quot;&#125;); //删除Name=&quot;王五&quot;且Age=26的记录,DeleteValuesOR方法类似 sql.DeleteValuesAND(&quot;table1&quot;, new string[]&#123;&quot;Name&quot;,&quot;Age&quot;&#125;, new string[]&#123;&quot;=&quot;,&quot;=&quot;&#125;, new string[]&#123;&quot;&apos;王五&apos;&quot;,&quot;&apos;26&apos;&quot;&#125;); //读取整张表 SqliteDataReader reader = sql.ReadFullTable (&quot;table1&quot;); while(reader.Read()) &#123; //读取ID Debug.Log(reader.GetInt32(reader.GetOrdinal(&quot;ID&quot;))); //读取Name Debug.Log(reader.GetString(reader.GetOrdinal(&quot;Name&quot;))); //读取Age Debug.Log(reader.GetInt32(reader.GetOrdinal(&quot;Age&quot;))); //读取Email Debug.Log(reader.GetString(reader.GetOrdinal(&quot;Email&quot;))); &#125; //读取数据表中Age&gt;=25的所有记录的ID和Name reader = sql.ReadTable (&quot;table1&quot;, new string[]&#123;&quot;ID&quot;,&quot;Name&quot;&#125;, new string[]&#123;&quot;Age&quot;&#125;, new string[]&#123;&quot;&gt;=&quot;&#125;, new string[]&#123;&quot;&apos;25&apos;&quot;&#125;); while(reader.Read()) &#123; //读取ID Debug.Log(reader.GetInt32(reader.GetOrdinal(&quot;ID&quot;))); //读取Name Debug.Log(reader.GetString(reader.GetOrdinal(&quot;Name&quot;))); &#125; //自定义SQL,删除数据表中所有Name=&quot;王五&quot;的记录 sql.ExecuteQuery(&quot;DELETE FROM table1 WHERE NAME=&apos;王五&apos;&quot;); //关闭数据库连接 sql.CloseConnection(); &#125;&#125; &emsp;&emsp;在上面的代码中我们是在Start方法中创建了数据库和数据表，然而在实际使用中我们需要判断数据库和数据表是否存在，因此如果你使用这段脚本提示错误信息，请确保数据库和数据表是否已经存在。好了，下面的截图展示了程序运行的结果： 数据库效果演示 Unity3D效果展示 &emsp;&emsp;作为一个强大的数据库怎么能没有图形化的数据库管理工具呢？所以这里博主向大家推荐一个免安装的小工具SqliteStudio，使用这个工具可以帮助我们方便地管理Sqlite数据库里的数据，这样是不是比较方便呢？哈哈！这个工具可以从这里下载哦！ SQLiteStudio界面演示 &emsp;&emsp;好了，今天的内容就是这样了，为了写这篇文章花了三个晚上准备，希望大家喜欢啊！如果大家觉得这篇文章有用，请继续关注我的博客，我是秦元培，我的博客地址是http://blog.csdn.net/qinyuanpei。 &emsp;&emsp;2015年11月3日更新内容如下：不同平台上的数据库存储路径12345678910111213141516//各平台下数据库存储的绝对路径(通用)//PC：sql = new SQLiteHelper(\"data source=\" + Application.dataPath + \"/sqlite4unity.db\");//Mac：sql = new SQLiteHelper(\"data source=\" + Application.dataPath + \"/sqlite4unity.db\");//Android：sql = new SQLiteHelper(\"URI=file:\" + Application.persistentDataPath + \"/sqlite4unity.db\");//iOS：sql = new SQLiteHelper(\"data source=\" + Application.persistentDataPath + \"/sqlite4unity.db\");//PC平台下的相对路径//sql = new SQLiteHelper(\"data source=\"sqlite4unity.db\");//编辑器：Assets/sqlite4unity.db//编译后：和AppName.exe同级的目录下，这里比较奇葩//当然可以用更随意的方式sql = new SQLiteHelper(\"data source=\"D://SQLite//sqlite4unity.db\");//确保路径存在即可否则会发生错误//如果是事先创建了一份数据库//可以将这个数据库放置在StreamingAssets目录下然后再拷贝到//Application.persistentDataPath + \"/sqlite4unity.db\"路径即可","tags":[{"name":"Unity3D","slug":"Unity3D","permalink":"http://qinyuanpei.github.io/tags/Unity3D/"},{"name":"数据库","slug":"数据库","permalink":"http://qinyuanpei.github.io/tags/数据库/"},{"name":"SQLite","slug":"SQLite","permalink":"http://qinyuanpei.github.io/tags/SQLite/"}]},{"title":"Unity3D游戏开发之从Unity3D项目版本控制说起","date":"2015-07-02T09:35:42.000Z","path":"posts/1320325685/","text":"&emsp;&emsp;各位朋友，大家好，欢迎大家关注我的博客，我是秦元培，我的独立博客地址是http://qinyuanpei.com、CSDN博客地址是http://blog.csdn.net/qinyuanpei。今天我想和大家聊聊Unity3D游戏项目的版本控制。 ##1、为什么要进行版本控制？ &emsp;&emsp;当我一个人写代码的时候，在我的脑海中是不存在版本控制这个概念的，因为我对整个项目的代码如数家珍。可是当我和一群人在一起写代码的时候，我可能并不会清楚团队中有谁修改了哪一行代码，即使是一个变量的名称或者是一个函数的名称，在我毫不知情的情况下，可能这样的修改会使得程序无法运行，这个时候我需要版本控制；尽管Unity3D是一个适合小团队开发的游戏引擎，可是即使再小的团队同样会有不同的分工，当大家需要将各自的工作合并到一个完整的项目中的时候，这个时候我需要版本控制；当我需要了解团队成员实际的编程能力的时候，最好的方法是让他们参与到一个项目的开发中，这样我可以从他提交代码的情况了解他的工作能力，这个时候我需要版本控制；当我希望时时刻刻对项目进行备份，并在某一个关键的时刻将项目恢复到一个正确的状态的时候，复制、黏贴不会让这个工作变得简单，这个时候我需要版本控制。 ##2、怎样在Unity3D中进行版本控制？ &emsp;&emsp;在Unity3D中进行版本控制主要针对Assets和ProjectSetting这两个文件夹，因为除此以外的文件和文件夹都是Unity3D在运行过程中产生的临时文件，这些文件会在使用Unity3D打开项目后重新生成，因此无需对这些文件或文件夹进行版本控制。好了，在了解了Unity3D版本控制中需要关注的主要内容后，接下来我们要关注的是怎样让版本控制的软件对我们提交的内容进行差异化识别，我们知道版本控制的一个核心任务就是将服务器上的文件和本地的文件进行比对，找出哪些文件是最新生成的、哪些文件是被修改过的等等。因此为了方便版本控制软件对文件进行比对，常常需要项目变动的这些因素转化为文本形式，如果熟悉Github的朋友应该知道，Github中判断两个文件的差异就是根据文本(代码)来比较的，因此在Unity3D中使用版本控制同样需要遵循这个原则，好在Unity3D在管理Unity3D项目时已经考虑到了这一点，通常在对Unity3D项目进行版本控制的时候，我们需要做这样的事情： 通过Edit-&gt;Project Settings-&gt;Editor菜单打开编辑器设置选项，将Version Control选项下的Mode设为Visual Meta Files，这样Unity3D将为项目中的每个文件或者每个文件夹生成对应的.Meta文件。该文件是一个文本文件，记录了对应文件的相关信息，版本控制软件可以以此来对文件版本进行对比和合并操作。 Unity3D中的资源默认是以二进制的形式进行组织的，这种组织方式对版本控制来说是不合适的，因此需要通过通过Edit-&gt;Project Settings-&gt;Editor菜单打开编辑器设置选项，将Asset Serialization下的Mode设为Force Text。 通过Edit-&gt;Prefences-&gt;External Tools找到Revision Control Diff/Merge选项，在安装了版本控制软件后可以在这里找到相关的选项，以博主为例，博主使用的是TortoiseSVN，这里的选项是TortoiseMegre。目前Unity3D支持的版本控制软件有SourceGear DiffMerge、TKDiff、P4Megre、TortoiseMegre、WinMegre、PlasticSCM Megre。 &emsp;&emsp;好了，在完成以上准备工作后，我们就可以开始进行Unity3D项目的版本控制了，目前在Unity3D中我们主要有以下三种方式来对Unity3D项目进行版本控制： ###2.1、使用Asset Server进行版本控制 &emsp;&emsp;Unity3D的Asset Server是一个Unity3D内部集成的版本控制软件，它和我们熟知的SVN类似，适合在小团队内进行版本控制，这是一个收费软件，尽管在某些方面它甚至比SVN还要方便，不过在实际的项目中使用这个的还是比较少的，所以如果大家对这个感兴趣，可以从这里了解它的具体情况，这里我们不打算介绍这个软件的使用。 Unity3D游戏制作（四）——Asset Server搭建 【教程】Asset Server（联合开发） ###2.2、使用Github进行版本控制 &emsp;&emsp;使用Github进行版本控制时可以在Git仓库中添加一个.gitignore文件来对项目中需要同步的文件进行过滤，在文章开始我们已经知道Unity3D项目的版本控制主要针对Assets和ProjectSetting这两个文件，因此.gitignore的内容可以这样填写:12345678Library/Temp/*.sln*.csproj*.sln*.userprefs*.unityproj*.DS_Store &emsp;&emsp;这样每次提交文件的时候Github将忽略这些文件的更改。关于Github的使用及其相关命令可以查看这里： 总结自己的Git常用命令 Git远程操作详解 &emsp;&emsp;Github中每个仓库的容量限制为1G，适合小项目的版本控制，对于大型项目的版本控制应该考虑使用SVN。 ###2.3、使用SVN进行版本控制 &emsp;&emsp;使用SVN进行版本控制时可以通过右键菜单将某些文件和文件夹添加到忽略的文件列表中，这样SVN在每次提交文件的时候将忽略这些文件的更改。这块儿其实和Github的.gitignore是相同的。SVN常用的软件组合是 TortoiseSVN(客户端)+VisualSVN Server(服务端)，具体内容请参考这2篇文章：SVN使用教程总结和客户端TortoiseSVN的安装及使用方法 ##3、小结 &emsp;&emsp;不管使用什么版本控制软件，建立相关的代码提交规范和流程控制规范都是必要的，因此在团队中应该有一个人负责对团队成员提交的代码进行审核和规范化，这样可以减少因为因为代码提交而产生的各种问题。好了，今天这篇文章先写到这里了，希望大家喜欢！","tags":[{"name":"Unity3D","slug":"Unity3D","permalink":"http://qinyuanpei.github.io/tags/Unity3D/"},{"name":"版本控制","slug":"版本控制","permalink":"http://qinyuanpei.github.io/tags/版本控制/"},{"name":"SVN","slug":"SVN","permalink":"http://qinyuanpei.github.io/tags/SVN/"},{"name":"Github","slug":"Github","permalink":"http://qinyuanpei.github.io/tags/Github/"}]},{"title":"Unity3D游戏开发之路：一月工作总结","date":"2015-06-24T07:42:48.000Z","path":"posts/1059499448/","text":"&emsp;&emsp;不知不觉已经在公司上班一个月了，在这一个月里每一天发生的事情是我平凡而普通的生活。作为一名有节操的程序员，当我大学的同学开始称我为程序员的时候，我知道我即将在这条路上踏下一个属于开始的足迹。和我大学的同学相比，可能我会显得幸运而孤独吧！我不用像他们一样到各种工厂里采样、监测，可是与此同时我会因为离大家越来越远而感到孤独。每天下班做公交车回到住处，简单地料理着我一个人的生活，不紧不慢却永远是一个人在摸黑赶路，这是我自己选择的路，我从来不曾后悔，即使在这段时间和美术各种闹别扭，我相信这些都会是暂时的，以后总会变得越来越好。 &emsp;&emsp;第一份工作没有想象中的高大上，这是一个融合了3D漫游、Web和电子商务的综合项目，可我想说我在努力地做好这件事情。当互联网+的概念被人们所熟知以后，传统行业和互联网的结合让人们对未来的生活充满了遐想，因为在这个过程中不断涌现出想要迫切进入互联网+时代的传统行业。可是当传统行业试图进入互联网行业的时候，我不知道传统行业经营者心中到底对互联网行业了解多少。我的第一份工作在家人的口中被演绎出了三个不同的版本，我想这就是传统行业对互联网行业认识的一种缩影吧，那就是传统行业并不了解互联网行业，当他们想要做互联网+的时候可能更多的是脑海中一闪而过的热情吧！ &emsp;&emsp;我的一位朋友告诉我，当你处在传统行业和互联网行业的十字路口的时候，你首先要虚心地了解和掌握传统行业的运作模式，然后再尝试将其和互联网结合起来。可是更为实际的情况是当这些传统行业的经营者有了进入互联网行业的想法以后，可能并不会从互联网的行业来看待这个想法，甚至片面的认为这个项目已然成竹在胸我们需要的仅仅是两三个懂技术的人就好了。这种想法其实是特别可怕的，以公司为例，从我进公司以来，公司从未对即将要做的项目进行过技术上的评估和立项讨论，公司的大部分美术甚至都不知道有这样一个项目存在、更不知道做好的模型要运用到一个怎样的技术上去以及最终会以什么样的方式呈现给用户。我所看到的情况就是公司里没日没夜的做模型。我想这就是领导脑袋一热的结果吧，大概知道要做一个什么样的东西，可是对具体怎么实施这个项目、实施这个项目需要哪些资源却没有详细的思考。我进公司这么长时间，基本没有看到过成文的策划或者是方案，更多的时候是大家在一块儿做，然后做的过程中发现有什么问题再返回去改，领导的态度从来没有准，觉得什么东西可以借鉴过来就要求程序和美术去实现，计划朝令夕改内心深处就不知道自己想做什么。我在公司从法律上来讲应该是一名普通员工，可是在很多时候我不得不担当项目管理者的角色。或许在这样的情况下，我可能会收获比普通员工更为丰富的除技术以外的经验，可是从长远发展的角度来看，只会让我内心更加厌倦目前的生活，希望早一天离开这家公司！ #1、项目该谁说了算？&emsp;&emsp;在一个没有策划的团队里，美术和程序就像水火不容的两股势力此消彼长。虽然说作为一名有节操的程序员，我的内心是拒绝让策划来领导程序的。因为在游戏网游化的今天，在国内基本是找不到多少对历史、人文、宗教等领域都有研究的策划的。在过去开发一款游戏，可能在游戏的世界观的构建上都需要花费很长的时间去研究相关的资料，可是在策划办公软件化的今天，策划关注的重点早已不再是游戏的世界观这些深层次的内容了，大家的关注点在什么地方呢？可能都在关注游戏的盈利和各种游戏系统数值的设计上吧，这一点我不想做太多的说明，因为大家都明白是怎么回事啦！好了，那么现在的问题是我们处在一个没有策划的团队里，如果程序按照美术的思路去做，可能程序会在修改了若干次项目以后对美术的要求失去信心，因为相对于程序解决问题而言，作为美术的普通人提出需求的难度显然更低。可是如果按程序的思路去做，可能美术不大会接受程序的审美，因为从我自己的角度来讲，程序更喜欢纯粹而简洁的东西、更看重能否解决问题，好不好看通常都是在考虑了这些问题后再去考虑的。 &emsp;&emsp;我进公司以后，基本经历了这样两种做事方式的洗礼，刚开始技术这边和我说了大概思路，然后我做出了第一个原型(1.0版本),结果这个思路和公司的思路完全是两个东西，因此1.0版本就在这样被扼杀在襁褓中。接下来，美术提出了先做UI,然后我们在等待她们做UI的过程中重新审视了这个项目，那段时间天天往隔壁办公室跑，搞得那个办公室里的妹子每次看到我进去都要抬起头看一下。每天跑来跑去做什么呢？答案是沟通，和领导沟通、和美术沟通，目的是在相互沟通的基础上加深对项目需求的理解。等到美术的UI做出来以后，我们就准备做UI了，结果做到一半的时候，领导说UI设计不合格，被打回去重新做，然后我们花了一周时间开会讨论，我从一开始没有资格参与公司会议变成了每次会议都要参加，我不知道这对我是好事还是坏事，说好事吧是因为我终于有发言权了，说坏事吧是因为经常和美术争得面红耳赤，总之每次开完会我都忍不住要吐槽下。 &emsp;&emsp;那么好了，各位看官，说到这里我无非是想告诉大家一个简单到不能再简单的道理：凡事预则立，不预则废。这就是说我们在做一件事情前一定要做好规划，游戏开发是一个特别考验团队合作的工作，如果在这个过程中我们没有在项目立项前做好充足的准备，就会很容易出现上面的问题。当我了解到仙剑项目立项就需要三个月的时候，我深深地感受到了这些传统行业经营者们的脑门一拍的决定是多么的不靠谱啊。在知乎上曾经看到过说”项目万事俱备，再差个程序员就好了”的类似言论，其实说这句话的往往就是这些自命不凡的传统行业经营者们，当你觉得一个项目仅仅需要若干个程序员就够了的时候，恰恰说明你还不够懂互联网行业！ #2、猪一样的队友&emsp;&emsp;我身边许多玩LOL的人都在吐槽打匹配的时候遇到的都是猪一样的队友，这种情况在项目开发中则更为常见。我不知道美术出身的领导怎么会认为程序员越多项目进度就越能赶上。做项目不是大家一块儿做模型，每个人分给几个然后用着破解版的3DsMax就搞定了。程序在我看来更应该在保证人员配备合理的基础上保证质量。 &emsp;&emsp;首先第一条，人员配备合理就是说程序员的数量要合理，其次大家的层次差别应该不会太大。因为人多了的话，对项目代码的影响可能更大，尤其是当大家编程的风格和技术水平存在差异的时候，体现在项目中就是各种未知的Bug。为什么要求大家的层次差别不大呢，因为层次差别太大，首先团队内沟通就是问题，以我为例，我手下的两个人都是培训班培训出来的，基本上就是老师给一套视频然后照着视频做出一款游戏就结束了，我一直反感用视频的方式来学习游戏开发，因为你是在学习一个游戏引擎而不是在学习一个工具软件，虽然Unity3D提供了可视化编辑器，可是在我眼里它始终都是一个游戏引擎，而非一个类似Office或者是3D软件的东西。那么我想说的是什么呢？我想说的是不要把编程当作一种固定的套路，经常有人直接抄我博客里的代码直接运行项目，然后出了各种问题再来问我怎么回事？碰到这种情况我首先问的第一句话是你能不能明白这个代码是干什么的？如果对方不理解，我一般会先让它搞懂这些代码的意义。 &emsp;&emsp;我们公司里的美术都不愿意碰Unity3D，因为他们觉得这个游戏引擎会增加他们学习软件的各种成本，可是事实是这个游戏引擎比我见过的Max、Maya、Blender等软件都简单啊，而且Unity3D免费版的就可以开发简单地游戏，比之美术口中各种不择手段的盗版、破解软件不知道要干净了多少？归根到底一句话，美术不愿意尝试新的东西，美术总认为Max里的模型导出到Unity3D后材质啊、灯光啊会丢，美术总认为Max渲染的效果要比Unity3D好许多，可是既然你选择了这个引擎来做项目，我觉得美术是有责任来了解这个引擎的，你让程序员帮你拼UI我可以接受，可是你让程序员帮你打灯光、修改材质、摆场景，这是程序员该做的事情嘛?我说虚幻四这样的引擎都是由策划来编辑关卡的，为什么你们美术就不能尝试了解下这个引擎呢？得到的答案是我们要做模型，显然当美术的眼睛只盯着手头的那几样工具软件的时候，你和他们间的差距已经拉开，如果有能力、有时间的话，不妨尝试下将编程以外的能力整合到自身的体系中，未来是属于全能型人才的！ #3、怎样让项目流程化&emsp;&emsp;我觉得像游戏这样负责的软件工程，在立项之初就应该明确美术、策划、程序各自的责任。我的想法是美术来制作素材、程序来编写相关逻辑和外部工具、策划使用外部工具来编辑关卡。 &emsp;&emsp;在我来公司前，曾看过一位前辈写过的关于这个项目的一个Demo，当初这个Demo里只有两个场景，我最初是对这位前辈颇为敬重的，因为感觉这个Demo的表现还不错，甚至觉得如果能够得到这个前辈指点一二，实乃三生有幸啊。可是当我和这位前辈聊过以后以及看过他写的代码，我对他的敬重慢慢地变成了鄙夷。这是为什么呢？因为他向领导提议使用硬代码来编写项目，通过研究他写的项目，我发现他的项目确实使用硬代码写成的，你能想象在一个脚本中并列7个if仅仅是因为它们的tag不同嘛，你能想象在一个脚本中的命名都是汉语拼音的变量定义嘛。 &emsp;&emsp;抛开他写的项目不说，从规模和负责程度上目前这个项都比他的Demo有难度，首先我们大概需要制作35个场景涉及到上千种模型和贴图而非Demo中的两个场景，其次我们最终的发布平台是Web平台而非Demo中的PC平台。写硬代码意味着放弃复用和扩展性，顾及目前而不考虑以后。可是我们这个项目肯定是需要扩整规模的，难道每次添加一个新的场景都需要把代码重新写一遍，因此这个方案在和他交流的时候我当着他的面就给Pass了，然后他说我们先做个Demo看看，因为在前面我们已经积累了部分代码，所以在这部分代码的基础上我们迅速地完成了一个较为灵活的框架。整个框架是将模型单独打包后和贴图一起存放在服务器上，因为模型和贴图对不同的户型来说都是通用的，因为使用配置文件设计了一个类似数据库的结构，这样当我们在程序中需要某些模型和贴图的时候只需要下载就可以了，因为模型和贴图都被存放在服务器上，本地仅仅存放相关的户型模型和配置文件，因此项目的体积被大大地压缩，从而可以解决Web平台浏览器的压力，因为所有的场景都是使用配置文件来定义，因此当需要更新项目的时候，只需要更新服务器上的模型和贴图以及配置文件即可，提高了项目更新得速度。总体来讲，我对我设计的这个架构表示满意，因为它让硬代码的优越感荡然无存。同时为了减少人工编写配置文件、打包等过程的工作量，通过为Unity3D编写插件的方式实现了整个过程的半自动化。为什么是半自动化啊？因为人在做事情的时候没有统一、规范的习惯或者说难以统一和规范。我一直强调统一和规范，可是美术总认为程序的要求过于苛刻，可是事实上懂得编程的人都明白计算机程序不过是对某个过程的一种模拟，而且这个过程是有限状态的，因此当美术说需要XXX功能的时候，程序员的内心其实是拒绝的，因为为了这点需求，他可能需要写十几行重复的代码，为了满足用户的懒惰和弱智，领导让我们将户型内的物体尽量全部实现动态化，要给用户最大的自由，结果却是剥夺了程序员的自由写了若干个if或者是重复调用相同的方法，这简直是恶魔啊！ &emsp;&emsp;好了，写了这么多，大家可能觉得这不符合我作为一个有节操的程序员的风格，说好的每周一篇技术博客呢？其实技术运用的好坏，完全取决于运用技术的人，所以我们不能仅仅关注技术的高低，更要关注怎样让整个团队高效率、高沟通率的执行下去，因为千里之堤，毁于蚁穴啊，虽然团队间沟通这些东西看似都是些政治或者是形式的东西，可是实际上会占到整个项目开发中相当大的一部分，所以希望大家在看了今天的博客后能够有所启发吧，好了，睡觉，哈哈！今天居然写到了这个时候！","tags":[{"name":"Unity3D","slug":"Unity3D","permalink":"http://qinyuanpei.github.io/tags/Unity3D/"},{"name":"工作","slug":"工作","permalink":"http://qinyuanpei.github.io/tags/工作/"},{"name":"生活","slug":"生活","permalink":"http://qinyuanpei.github.io/tags/生活/"}]},{"title":"Unity3D游戏开发之使用AssetBundle和Xml实现场景的动态加载","date":"2015-06-15T07:24:17.000Z","path":"posts/1467630055/","text":"&emsp;&emsp;各位朋友，大家好，我是秦元培，欢迎大家关注我的博客，我的博客地址是http://qinyuanpei.com。 今天我想和大家聊聊在Unity3D中关于场景的动态加载的问题。众所周知在Unity3D游戏开发过程中，因为受到游戏容量、平台性能和热更新等诸多因素的限制，我们可能无法将所有的游戏场景打包到项目中然后相对”静态”地加载，那么这个时候就需要我们使用动态加载的方式来将游戏场景加载到场景中。博主在研究了Unity3D动态加载的相关资料后发现，目前Unity3D中实现动态加载场景的方式主要有以下两种方式： 使用BuildStreamedSceneAssetBundle()方法将场景打包为AssetBundle：这种方法将生成一个流式的.unity3d文件，从而实现按需下载和加载，因此这种方式特别适合Web环境下游戏场景的加载，因为在Web环境下我们可以希望的是玩家可以在玩游戏的同时加载游戏。可是因为这种打包方式仅仅是保证了场景中的GameObject与本地资源的引用关系而非是将本地资源打包，因此从减少游戏容量的角度来说并不是十分实用，而且当我们使用WWW下载完AssetBundle后，需要使用Application.Load()方法来加载场景，我们知道在Unity3D中加载一个关卡(场景)是需要在BuildSetting中注册关卡的，因此在使用这种方式动态加载的时候请注意到这一点。 将场景内的所有物体打包为AssetBundle配合相关配置文件动态生成场景：这种方法的思路是使用一个配置文件来记录下当前场景中所有物体的位置、旋转和缩放信息，然后再根据配置文件使用Instantiate方法逐个生成即可。这种思路是考虑到需要在一个场景中动态替换GameObject或者是动态生成GameObject的情形，使用这种方法首先要满足一个条件，即：场景内所有的物体都是预制件(Prefab)。这是由Unity3D的机制决定的，因为Prefab是一个模板，当你需要动态生成一个物体的时候就需要为其提供一个模板(Prefab)。 &emsp;&emsp;如果你对这两种方式没有什么疑问的话，那么我觉得我们可以正式开始今天的内容了。既然今天的题目已然告诉大家是使用AssetBundle和Xml文件实现场景的动态加载，我相信大家已经明白我要使用那种方式了。好了，下面我们正式开始吧！ ##准备工作&emsp;&emsp;在实现场景的动态加载前，我们首先要在本地准备好一个游戏场景，然后做两件事情： 将场景内的所有GameObject打包为AssetBundle 将场景内所有的GameObject的信息导出为Xml文件做这两件事情的时候，相当于我们是在准备食材和菜谱，有了食材和菜谱我们就可以烹制出美味佳肴了。可是在做着两件事情前，我们还有一件更为重要的事情要做，那就是我们需要将场景中使用到的GameObject制作成预制体(Prefab)。因为在博主的印象中，Unity3D打包的最小粒度应该是Prefab，所以为了保险起见，我还是建议大家将场景中使用到的GameObject制作成预制体(Prefab)。那么问题来了，当我们将这些Prefab打包成AssetBundle后是否还需要本地的Prefab文件？这里博主一直迷惑，因为理论上当我们将这些Prefab打包成AssetBundle后，我们实例化一个物体的时候实际上是在使用AssetBundle的Load方法来获取该物体的一个模板，这个模板应该是存储在AssetBundle中的啊！因为我的笔记本使用的是免费版的Unity3D无法对此进行测试，所以如果想知道这个问题结果的朋友可以等我下周到公司以后测试了再做讨论(我不会告诉你公司无耻地使用了破解版)，当然如果有知道这个问题的答案的朋友欢迎给我留言啊，哈哈！这里就是想告诉大家要准备好场景中物体的预设体(Prefab),重要的事情说三遍!!! ##将场景内物体打包为AssetBundle&emsp;&emsp;Unity3D打包的相关内容这里就不展开说了，因为在官方API文档中都能找到详细的说明，虽然说Unity5.0中AssetBundle打包的方式发生了变化，不过考虑到大家都还在使用4.X的版本，所以等以后我用上了Unity5.0再说吧，哈哈！好了，下面直接给出代码：12345678910111213[MenuItem(&quot;Export/ExportTotal----对物体整体打包&quot;)]static void ExportAll()&#123; //获取保存路径 string savePath=EditorUtility.SaveFilePanel(&quot;输出为AssetBundle&quot;,&quot;&quot;,&quot;New Resource&quot;,&quot;unity3d&quot;); if(string.IsNullOrEmpty(savePath)) return; //获取选择的物体 Object[] objs=Selection.GetFiltered(typeof(Object),SelectionMode.DeepAssets); if(objs.Length&lt;0) return; //打包 BuildPipeline.BuildAssetBundle(null,objs,savePath,BuildAssetBundleOptions.CollectDependencies|BuildAssetBundleOptions.CompleteAssets); AssetDatabase.Refresh();&#125; ##将场景内物体信息导出为Xml文件&emsp;&emsp;导出场景内物体信息需要遍历场景中的每个游戏物体，因为我们在制作场景的时候通常会用一个空的GameObject作为父物体来组织场景中的各种物体，因此我们在导出Xml文件的时候仅仅考虑导出这些父物体，因为如果考虑子物体的话，可能会涉及到递归，整个问题将变得特别复杂。为了简化问题，我们这里仅仅考虑场景中的父物体。好了，开始写代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152[MenuItem(&quot;Export/ExportScene----将当前场景导出为Xml&quot;)]static void ExportGameObjects()&#123; //获取当前场景完整路径 string scenePath=EditorApplication.currentScene; //获取当前场景名称 string sceneName=scenePath.Substring(scenePath.LastIndexOf(&quot;/&quot;)+1,scenePath.Length-scenePath.LastIndexOf(&quot;/&quot;)-1); sceneName=sceneName.Substring(0,sceneName.LastIndexOf(&quot;.&quot;)); //获取保存路径 string savePath=EditorUtility.SaveFilePanel(&quot;输出场景内物体&quot;,&quot;&quot;,sceneName,&quot;xml&quot;); //创建Xml文件 XmlDocument xmlDoc=new XmlDocument(); //创建根节点 XmlElement scene=xmlDoc.CreateElement(&quot;Scene&quot;); scene.SetAttribute(&quot;Name&quot;,sceneName); scene.SetAttribute(&quot;Asset&quot;,scenePath); xmlDoc.AppendChild(scene); //遍历场景中的所有物体 foreach(GameObject go in Object.FindObjectsOfType(typeof(GameObject))) &#123; //仅导出场景中的父物体 if(go.transform.parent==null) &#123; //创建每个物体 XmlElement gameObject=xmlDoc.CreateElement(&quot;GameObject&quot;); gameObject.SetAttribute(&quot;Name&quot;,go.name); gameObject.SetAttribute(&quot;Asset&quot;,&quot;Prefabs/&quot;+ go.name + &quot;.prefab&quot;); //创建Transform XmlElement transform=xmlDoc.CreateElement(&quot;Transform&quot;); transform.SetAttribute(&quot;x&quot;,go.transform.position.x.ToString()); transform.SetAttribute(&quot;y&quot;,go.transform.position.y.ToString()); transform.SetAttribute(&quot;z&quot;,go.transform.position.z.ToString()); gameObject.AppendChild(transform); //创建Rotation XmlElement rotation=xmlDoc.CreateElement(&quot;Rotation&quot;); rotation.SetAttribute(&quot;x&quot;,go.transform.eulerAngles.x.ToString()); rotation.SetAttribute(&quot;y&quot;,go.transform.eulerAngles.y.ToString()); rotation.SetAttribute(&quot;z&quot;,go.transform.eulerAngles.z.ToString()); gameObject.AppendChild(rotation); //创建Scale XmlElement scale=xmlDoc.CreateElement(&quot;Scale&quot;); scale.SetAttribute(&quot;x&quot;,go.transform.localScale.x.ToString()); scale.SetAttribute(&quot;y&quot;,go.transform.localScale.y.ToString()); scale.SetAttribute(&quot;z&quot;,go.transform.localScale.z.ToString()); gameObject.AppendChild(scale); //添加物体到根节点 scene.AppendChild(gameObject); &#125; &#125; xmlDoc.Save(savePath);&#125; &emsp;&emsp;好了，在这段代码中我们以Scene作为根节点，然后以每个GameObject作为Scene的子节点，重点在Xml文件中记录了每个GameObject的名称、Prefab、坐标、旋转和缩放等信息。下面是一个导出场景的Xml文件的部分内容：123456789101112131415161718192021&lt;Scene Name=\"DoneStealth\" Asset=\"Assets/Done/DoneScenes/DoneStealth.unity\"&gt; &lt;GameObject Name=\"char_robotGuard_002\" Asset=\"Prefabs/char_robotGuard_002.prefab\"&gt; &lt;Transform x=\"-18.99746\" y=\"0\" z=\"37.2443\" /&gt; &lt;Rotation x=\"0\" y=\"0\" z=\"0\" /&gt; &lt;Scale x=\"1\" y=\"1\" z=\"1\" /&gt; &lt;/GameObject&gt; &lt;GameObject Name=\"fx_laserFence_lasers_003\" Asset=\"Prefabs/fx_laserFence_lasers_003.prefab\"&gt; &lt;Transform x=\"-17.90294\" y=\"1.213998\" z=\"24.07678\" /&gt; &lt;Rotation x=\"0\" y=\"90.00001\" z=\"0\" /&gt; &lt;Scale x=\"1\" y=\"1\" z=\"3.735847\" /&gt; &lt;/GameObject&gt; &lt;GameObject Name=\"door_generic_slide_001\" Asset=\"Prefabs/door_generic_slide_001.prefab\"&gt; &lt;Transform x=\"-15.91264\" y=\"-0.001293659\" z=\"7.006886\" /&gt; &lt;Rotation x=\"0\" y=\"90.00001\" z=\"0\" /&gt; &lt;Scale x=\"1\" y=\"1\" z=\"1\" /&gt; &lt;/GameObject&gt; &lt;GameObject Name=\"door_generic_slide_003\" Asset=\"Prefabs/door_generic_slide_003.prefab\"&gt; &lt;Transform x=\"-7.910765\" y=\"-0.001293659\" z=\"37.01304\" /&gt; &lt;Rotation x=\"0\" y=\"90.00001\" z=\"0\" /&gt; &lt;Scale x=\"1\" y=\"1\" z=\"1\" /&gt; &lt;/GameObject&gt; &emsp;&emsp;在这里我们假设所有的Prefab是放置在Resources/Prefabs目录中的，那么此时我们便有了两种动态加载场景的方式 通过每个GameObject的Asset属性，配合Resources.Load()方法实现动态加载 通过每个GameObject的Name属性，配合AssetBundle的Load()方法实现动态加载这两种方法大同小异，区别仅仅在于是否需要从服务器下载相关资源。因此本文的主题是使用AssetBundle和Xml实现场景的动态加载，因此，接下来我们主要以第二种方式为主，第一种方式请大家自行实现吧！ ##动态加载物体到场景中&emsp;&emsp;首先我们来定义一个根据配置文件动态加载AssetBundle中场景的方法LoadDynamicScene123456789101112131415161718192021222324252627282930313233343536373839404142/// &lt;summary&gt;/// 根据配置文件动态加载AssetBundle中的场景/// &lt;/summary&gt;/// &lt;param name=&quot;bundle&quot;&gt;从服务器上下载的AssetBundle文件&lt;/param&gt;/// &lt;param name=&quot;xmlFile&quot;&gt;AssetBundle文件对应的场景配置文件&lt;/param&gt;public static void LoadDynamicScene(AssetBundle bundle,string xmlFile)&#123; //加载本地配置文件 XmlDocument xmlDoc=new XmlDocument(); xmlDoc.LoadXml(((TextAsset)Resources.Load(xmlFile)).text); //读取根节点 XmlElement root=xmlDoc.DocumentElement; if(root.Name==&quot;Scene&quot;) &#123; XmlNodeList nodes=root.SelectNodes(&quot;/Scene/GameObject&quot;); //定义物体位置、旋转和缩放 Vector3 position=Vector3.zero; Vector3 rotation=Vector3.zero; Vector3 scale=Vector3.zero; //遍历每一个物体 foreach(XmlElement xe1 in nodes) &#123; //遍历每一个物体的属性节点 foreach(XmlElement xe2 in xe1.ChildNodes) &#123; //根据节点名称为相应的变量赋值 if(xe2.Name==&quot;Transform&quot;) &#123; position=new Vector3(float.Parse(xe2.GetAttribute(&quot;x&quot;)),float.Parse(xe2.GetAttribute(&quot;y&quot;)),float.Parse(xe2.GetAttribute(&quot;z&quot;))); &#125;else if(xe2.Name==&quot;Rotation&quot;) &#123; rotation=new Vector3(float.Parse(xe2.GetAttribute(&quot;x&quot;)),float.Parse(xe2.GetAttribute(&quot;y&quot;)),float.Parse(xe2.GetAttribute(&quot;z&quot;))); &#125;else&#123; scale=new Vector3(float.Parse(xe2.GetAttribute(&quot;x&quot;)),float.Parse(xe2.GetAttribute(&quot;y&quot;)),float.Parse(xe2.GetAttribute(&quot;z&quot;))); &#125; &#125; //生成物体 GameObject go=(GameObject)GameObject.Instantiate(bundle.Load(xe1.GetAttribute(&quot;Name&quot;)),position,Quaternion.Euler(rotation)); go.transform.localScale=scale; &#125; &#125;&#125; &emsp;&emsp;因为该方法中的AssetBundle是需要从服务器下载下来的，因此我们需要使用协程来下载AssetBundle：1234567891011121314IEnumerator Download()&#123; WWW _www = new WWW (&quot;http://localhost/DoneStealth.unity3d&quot;); yield return _www; //检查是否发生错误 if (string.IsNullOrEmpty (_www.error)) &#123; //检查AssetBundle是否为空 if(_www.assetBundle!=null) &#123; LoadDynamicScene(_www.assetBundle,&quot;DoneStealth.xml&quot;); &#125; &#125;&#125; &emsp;&emsp;好了，现在运行程序，可以发现场景将被动态地加载到当前场景中:)，哈哈 ##小结 使用这种方式来加载场景主要是为了提高游戏的性能，如果存在大量重复性的场景的时候，可以使用这种方式来减小游戏的体积，可是这种方式本质上是一种用时间换效率的方式，因为在使用这种方法前，我们首先要做好游戏场景，然后再导出相关的配置文件和AssetBundle，从根本上来讲，工作量其实没有减少。 当场景导出的Xml文件中的内容较多时，建议使用内存池来管理物体的生成和销毁，因为频繁的生成和销毁是会带来较大的内存消耗的。说到这里的时候，我不得不吐槽下公司最近的项目，在将近300个场景中只有30个场景是最终发布游戏时需要打包的场景，然后剩余场景将被用来动态地加载到场景中，因为领导希望可以实现动态改变场景的目的，更为郁闷的是整个场景要高度DIY,模型要能够随用户拖拽移动、旋转，模型和材质要能够让用户自由替换。从整体上来讲，频繁地销毁和生成物体会耗费大量资源，因此如果遇到这种情况建议还是使用内存池进行管理吧！ &emsp;&emsp;好了，今天的内容就是这样子了，如果大家对此有什么疑问，欢迎给我留言，谢谢大家！","tags":[{"name":"Unity3D","slug":"Unity3D","permalink":"http://qinyuanpei.github.io/tags/Unity3D/"},{"name":"动态加载","slug":"动态加载","permalink":"http://qinyuanpei.github.io/tags/动态加载/"},{"name":"AssetBundle","slug":"AssetBundle","permalink":"http://qinyuanpei.github.io/tags/AssetBundle/"}]},{"title":"Unity3D游戏开发之快速打造流行的关卡系统","date":"2015-06-11T08:11:01.000Z","path":"posts/1424645834/","text":"&emsp;&emsp;各位朋友，大家好，欢迎大家关注我的博客，我是秦元培，我的博客地址是blog.csdn.net/qinyuanpei。今天想和大家分享的是目前在移动平台上较为流行的关卡系统，关卡系统通常是单机手机游戏如《愤怒的小鸟》、《保卫萝卜》中对游戏内容的组织形式，玩家可通过已解锁的关卡(默认第一关是已解锁的)获取分数进而解锁新的关卡，或者是通过付费购买解锁新的关卡。那么好了，在今天的文章中博主将带领大家快速实现一个可扩展的关卡系统，这个实例的灵感来自博主最近的工作经历，希望对大家学习Unity3D游戏起到一定帮助性的作用。 #原理&emsp;&emsp;在本地配置一个Xml文件，在这个文件中定义当前游戏中关卡的相关信息，通过解析该文件并和UI绑定最终实现一个完整的关卡系统。 ##1、定义关卡&emsp;&emsp;首先我们来定义一个关卡的基本结构：1234567891011121314151617public class Level&#123; /// &lt;summary&gt; /// 关卡ID /// &lt;/summary&gt; public string ID; /// &lt;summary&gt; /// 关卡名称 /// &lt;/summary&gt; public string Name; /// &lt;summary&gt; /// 关卡是否解锁 /// &lt;/summary&gt; public bool UnLock = false;&#125; &emsp;&emsp;在这里，我们假定关卡的名称和该关卡在Unity3D中场景名称一致。其中最为重要的一个属性是UnLock，该值是一个布尔型变量，表明该关卡是否解锁，因为在游戏中，只有解锁的场景是可以访问的。 ##2、定义关卡配置文件&emsp;&emsp;从关卡的基本结构Level可以定义出如下的配置文件，这里使用Xml作为配置文件的存储形式：12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;levels&gt; &lt;level id=&quot;0&quot; name=&quot;level0&quot; unlock=&quot;1&quot; /&gt; &lt;level id=&quot;1&quot; name=&quot;level1&quot; unlock=&quot;0&quot; /&gt; &lt;level id=&quot;2&quot; name=&quot;level2&quot; unlock=&quot;0&quot; /&gt; &lt;level id=&quot;3&quot; name=&quot;level3&quot; unlock=&quot;0&quot; /&gt; &lt;level id=&quot;4&quot; name=&quot;level4&quot; unlock=&quot;0&quot; /&gt; &lt;level id=&quot;5&quot; name=&quot;level5&quot; unlock=&quot;0&quot; /&gt; &lt;level id=&quot;6&quot; name=&quot;level6&quot; unlock=&quot;0&quot; /&gt; &lt;level id=&quot;7&quot; name=&quot;level7&quot; unlock=&quot;0&quot; /&gt; &lt;level id=&quot;8&quot; name=&quot;level8&quot; unlock=&quot;0&quot; /&gt; &lt;level id=&quot;9&quot; name=&quot;level9&quot; unlock=&quot;0&quot; /&gt;&lt;/levels&gt; &emsp;&emsp;和关卡结构定义类似，这里使用0和1来表示关卡的解锁情况，0表示未解锁，1表示解锁，可以注意到默认情况下第一个关卡是解锁的，这符合我们在玩《愤怒的小鸟》这类游戏时的直观感受。那么好了，在完成了关卡的结构定义和配置文件定义后，接下来我们开始思考如何来实现一个关卡系统，因为此处并不涉及到Unity3D场景中的具体逻辑，因此我们在关卡系统中主要的工作就是维护好主界面场景和各个游戏场景的跳转关系，我们可以注意到这里要完成两件事情，即第一要将配置文件中的关卡以一定形式加载到主界面中，并告诉玩家哪些关卡是已解锁的、哪些关卡是未解锁的，当玩家点击不同的关卡时可以得到不同的响应，已解锁的关卡可以访问并进入游戏环节，未解锁的关卡则需要获得更多的分数或者是通过付费来解锁关卡；第二是要对关卡进行编辑，当玩家获得了分数或者是支付一定的费用后可以解锁关卡进入游戏环节。这两点综合起来就是我们需要对关卡的配置文件进行读写，因为我们注意到一个关卡是否解锁仅仅取决于unlock属性，那么好了，明白了这一点后我们来动手编写一个维护关卡的类。 ##3、编写一个维护关卡的类&emsp;&emsp;这里直接给出代码，因为从严格的意义上来说，这段代码并非我们此刻关注的重点，可能这让大家感到难以适应，因为文章明明就是在教我们实现一个关卡系统，可是此刻博主却说这部分不重要了，请大家稍安勿躁，因为这里有比代码更为深刻的东西。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778using UnityEngine;using System.Collections;using System.Collections.Generic;using System.Xml;public static class LevelSystem &#123; /// &lt;summary&gt; /// 加载Xml文件 /// &lt;/summary&gt; /// &lt;returns&gt;The levels.&lt;/returns&gt; public static List&lt;Level&gt; LoadLevels() &#123; //创建Xml对象 XmlDocument xmlDoc = new XmlDocument(); //如果本地存在配置文件则读取配置文件 //否则在本地创建配置文件的副本 //为了跨平台及可读可写，需要使用Application.persistentDataPath string filePath = Application.persistentDataPath + &quot;/levels.xml&quot;; if (!IOUntility.isFileExists (filePath)) &#123; xmlDoc.LoadXml (((TextAsset)Resources.Load (&quot;levels&quot;)).text); IOUntility.CreateFile (filePath, xmlDoc.InnerXml); &#125; else &#123; xmlDoc.Load(filePath); &#125; XmlElement root = xmlDoc.DocumentElement; XmlNodeList levelsNode = root.SelectNodes(&quot;/levels/level&quot;); //初始化关卡列表 List&lt;Level&gt; levels = new List&lt;Level&gt;(); foreach (XmlElement xe in levelsNode) &#123; Level l=new Level(); l.ID=xe.GetAttribute(&quot;id&quot;); l.Name=xe.GetAttribute(&quot;name&quot;); //使用unlock属性来标识当前关卡是否解锁 if(xe.GetAttribute(&quot;unlock&quot;)==&quot;1&quot;)&#123; l.UnLock=true; &#125;else&#123; l.UnLock=false; &#125; levels.Add(l); &#125; return levels; &#125; /// &lt;summary&gt; /// 设置某一关卡的状态 /// &lt;/summary&gt; /// &lt;param name=&quot;name&quot;&gt;关卡名称&lt;/param&gt; /// &lt;param name=&quot;locked&quot;&gt;是否解锁&lt;/param&gt; public static void SetLevels(string name,bool unlock) &#123; //创建Xml对象 XmlDocument xmlDoc = new XmlDocument(); string filePath=Application.persistentDataPath + &quot;/levels.xml&quot;; xmlDoc.Load(filePath); XmlElement root = xmlDoc.DocumentElement; XmlNodeList levelsNode = root.SelectNodes(&quot;/levels/level&quot;); foreach (XmlElement xe in levelsNode) &#123; //根据名称找到对应的关卡 if(xe.GetAttribute(&quot;name&quot;)==name) &#123; //根据unlock重新为关卡赋值 if(unlock)&#123; xe.SetAttribute(&quot;unlock&quot;,&quot;1&quot;); &#125;else&#123; xe.SetAttribute(&quot;unlock&quot;,&quot;0&quot;); &#125; &#125; &#125; //保存文件 xmlDoc.Save (filePath); &#125;&#125; &emsp;&emsp;这里我们首先将关卡配置文件levels.xml放置在Resources目录下，这是因为我们可以使用Resources.Load()这种方式来加载本地资源，这种方式对于Unity3D来说有着得天独厚的优势： 它使用相对于Resources目录的相对路径，所以在使用的时候不用考虑是相对路径还是绝对路径的问题 它使用名称来查找一个本地资源，所以在使用的时候不用考虑扩展名和文件格式的问题 它可以是Unity3D支持的任意类型，从贴图到预制体再到文本文件等等，可以和Unity3D的API完美地结合 &emsp;&emsp;说了这么多它的优点，我们自然要痛心疾首地说说它的缺点，它的缺点是什么呢？那就是不支持写入操作，这当然不能责怪Unity3D，因为当Unity3D导出游戏的时候会将Rsources目录下的内容压缩后再导出，我们当然不能要求在一个压缩后的文件里支持写入操作啦，所以我们是时候来总结下Unity3D中资源读写的常见方案了，那么Unity3D中常见的资源读写方案由哪些呢？ 1、Resources.Load:只读，当我们的资源不需要更新且对本地存储无容量要求的时候可以采用这种方式2、AssetBundle：只读，当我们的资源需要更新且对本地存储有容量要求的时候可以采用这种方式3、WWW:只读，WWW支持http协议和file协议，因此可以WWW来加载一个网络资源或者本地资源4、PlayerPrefs：可读可写，Unity3D提供的一种的简单的键-值型存储结构，可以用来读写float、int和string三种简单的数据类型，是一种较为松散的数据存储方案5、序列化和反序列化：可读可写，可以使用Protobuf、序列化为Xml、二进制或者JSON等形式实现资源读写。6、数据库：可读可写，可以使用MySQL或者SQLite等数据库对数据进行存储实现资源读写。 &emsp;&emsp;好了，在了解了Unity3D中资源读写的常见方案后，我们接下来来讨论下Unity3D中的路径问题：1、Application.dataPath：这个路径是我们经常使用的一个路径，可是我们真的了解这个路径吗？我看这里要打个大大的问号，为什么这么说呢？因为这个路径在不同的平台下是不一样的，从官方API文档中可以了解到这个值依赖于运行的平台： Unity 编辑器：&lt;工程文件夹的路径&gt;/Assets Mac：&lt;到播放器应用的路径&gt;/Contents IOS: &lt;到播放器应用的路径&gt;/&lt;AppName.app&gt;/Data Win：&lt;.exe文件目录&gt;\\Data Web：&lt;.unity3d文件的绝对路径&gt;&emsp;&emsp;这个路径是在PC上支持读写的，可是因为到了不同的平台上文件的路径发生变动，因此我们在程序中设置的路径可能就变成了一个错误的路径。在网上大家找到类似的内容，这一点是网上说的最多、坑最多的一块儿，希望大家在以后遇到这个问题的时候能够留心点，尽量能不用这个路径就不用这个路径吧！什么?不用这个路径，那该用什么路径呢？呵呵，不要着急啊，下面隆重向大家推荐Application.persistentDataPath这个路径。2、Application.persistentDataPath：这个路径是Unity3D中的一个数据持久化路径，呵呵，千万不要问我什么叫做数据持久化路径，我不会告诉你我今天这篇文章的关键就是数据持久化啊！总之呢，我们把握住一点，这个路径是可以在移动平台上使用的一个可以读写的路径，当然在路径这块儿可能同样会碰到和Application.dataPath类似的问题，因为博主写这篇文章的时候并没有对移动平台进行测试，这一点希望大家能够注意啊，这并不是我偷懒，实在是公司最近的事情比较多，没有时间做进一步的测试，不过除了路径的问题以外，我可以向大家保证，这个路径是可以读写的，所以如果我们在开发Unity3D游戏过程中需要在本地存储某些文件的话，这个路径是个不错的选择。 &emsp;&emsp;好了，现在我们回到维护关卡的这个类中，大家可以注意到我在加载配置文件的时候做了这样一个处理：如果本地(指游戏外部)存在配置文件则直接读取配置文件，否则使用Resources.Load()方法加载Resources目录下的配置文件，并在本地创建一个配置文件的副本。这样做的目的是为了方便对配置文件进行修改，因为Resources目录下的配置文件在导出游戏后是没有路径的，我们没有办法用常规的访问文件的方式来读取这个文件，这个时候我们就用到Application.persistentDataPath这个路径，因为我们在本地创建了副本，所以只要读取副本文件就可以对其进行读取和修改了。那么，接下来，我们来写一个Main文件作为项目的入口文件吧！ ##4、编写入口文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556using UnityEngine;using System.Collections;using System.Collections.Generic;using UnityEngine.UI;using System.Xml.Serialization;public class Main : MonoBehaviour &#123; //关卡列表 private List&lt;Level&gt; m_levels; void Start () &#123; //获取关卡 m_levels = LevelSystem.LoadLevels (); //动态生成关卡 foreach (Level l in m_levels) &#123; GameObject prefab=(GameObject)Instantiate((Resources.Load(&quot;Level&quot;) as GameObject)); //数据绑定 DataBind(prefab,l); //设置父物体 prefab.transform.SetParent(GameObject.Find(&quot;UIRoot/Background/LevelPanel&quot;).transform); prefab.transform.localPosition=new Vector3(0,0,0); prefab.transform.localScale=new Vector3(1,1,1); //将关卡信息传给关卡 prefab.GetComponent&lt;LevelEvent&gt;().level=l; prefab.name=&quot;Level&quot;; &#125; //人为解锁第二个关卡 //在实际游戏中玩家需要满足一定条件方可解锁关卡 //此处仅作为演示 LevelSystem.SetLevels (&quot;level1&quot;, true); &#125; /// &lt;summary&gt; /// 数据绑定 /// &lt;/summary&gt; void DataBind(GameObject go,Level level) &#123; //为关卡绑定关卡名称 go.transform.Find(&quot;LevelName&quot;).GetComponent&lt;Text&gt;().text=level.Name; //为关卡绑定关卡图片 Texture2D tex2D; if(level.UnLock)&#123; tex2D=Resources.Load(&quot;nolocked&quot;) as Texture2D; &#125;else&#123; tex2D=Resources.Load(&quot;locked&quot;) as Texture2D; &#125; Sprite sprite=Sprite.Create(tex2D,new Rect(0,0,tex2D.width,tex2D.height),new Vector2(0.5F,0.5F)); go.transform.GetComponent&lt;Image&gt;().sprite=sprite; &#125;&#125; &emsp;&emsp;在这段脚本中，我们首先加载了关卡信息，然后将关卡信息和界面元素实现绑定，从而实现一个简单的关卡选择界面，并人为地解锁了第二个关卡。好吧，如果这是一个正式游戏的配置关卡配置文件，相信大家都知道怎么免费玩解锁的关卡了吧，哈哈！当然，我不推荐大家这样做，因为作为一个程序员，当你全身心地投入到一个项目中的时候，你就会明白完成一款软件或者游戏需要投入多少精力，所以大家尽量还是不要想破解或者盗版这些这些事情，毕竟作为开发者可能他的出发点是想做出来一个让大家都喜欢的产品，可是更现实的问题是开发者一样要生活，所以请善待他们吧。好了，言归正传，这里的UI都是基于UGUI实现的，不要问我为什么不用NGUI，因为我就是喜欢UGUI！我们知道我们需要为每个关卡的UI元素绑定一个响应的事件，因此我们需要为其编写一个LevelEvent的脚本：1234567891011121314151617181920212223using UnityEngine;using System.Collections;using UnityEngine.UI;using UnityEngine.EventSystems;public class LevelEvent : MonoBehaviour&#123; //当前关卡 public Level level; public void OnClick() &#123; if(level.UnLock)&#123; //假设关卡的名称即为对应场景的名称 //Application.LoadLevel(level.Name); Debug.Log (&quot;当前选择的关卡是:&quot;+level.Name); &#125;else&#123; Debug.Log (&quot;抱歉!当前关卡尚未解锁!&quot;); &#125; &#125;&#125; &emsp;&emsp;记得在本文开始的时候，博主提到了一个假设，就是关卡的名称和其对应的游戏名称一致的假设，相信到此处大家都知道为什么了吧！为了让每个关卡的UI元素知道自己对应于哪个关卡，我们设置了一个level变量，这个变量的值在加载关卡的时候已经完成了初始化，所以此时我们可以在这里知道每个关卡的具体信息，从而完成事件的响应。好了，今天的内容就是这样了，我们来看看最终的效果吧！ DEMO1 DEMO2 &emsp;&emsp;可以注意到在第二次打开游戏后，第二个关卡已经解锁了，说明我们在最开始设计的两个目标都达到了，那么内容就是这样子啦，如果大家有什么好的想法或者建议，欢迎在文章后面给我留言，谢谢大家！","tags":[{"name":"Unity3D","slug":"Unity3D","permalink":"http://qinyuanpei.github.io/tags/Unity3D/"},{"name":"游戏","slug":"游戏","permalink":"http://qinyuanpei.github.io/tags/游戏/"},{"name":"关卡系统","slug":"关卡系统","permalink":"http://qinyuanpei.github.io/tags/关卡系统/"}]},{"title":"Unity3D游戏开发之路：一周工作总结","date":"2015-06-11T08:02:45.000Z","path":"posts/719322223/","text":"&emsp;&emsp;大家好，欢迎大家关注我的博客，我是秦元培，我的博客地址是http://blog.csdn.net/qinyuanpei。到公司上班已经一周了，趁着今天周末休息的时间，想将最近在工作和生活中的感受和想法写下来，因为生命就是一个不断积累、厚积薄发，最终实现自我超越的一个过程。作为第一份工作，尽管没有想象中那样理想，可我还是在很努力的工作。工作后接手的第一个项目是一个房地产的漫游展示项目，因为这家公司之前是做影视后期的，所以在决定做这个项目后，公司领导层对这个项目具体要做到什么样的效果并没有一个明确的认识，所以在项目开展前期无论是在对项目所使用的技术的熟悉程度上还是项目整体的策划上，都没有一个具体的的可操作的方案。因为公司领导是美术出身，所以从我进了公司以后，整个公司上下一直沉浸在一种加班加点赶制模型的压抑氛围当中。 &emsp;&emsp;我进公司的第一天，公司负责技术的人向我演示了一个视频，告诉我项目做出来大概就是这样一个样子，然后就让我开始写所谓的”框架”，因为他对Unity3D的技术并不熟悉，所以基本上从我上班开始，所有和Unity3D相关的工作都由我一个人来完成，让我这样一个新入职的人来担当”主程”，我感到受宠若惊而压力山大，不过因为他和我年龄相差不大，一直都比较尊重我的想法，所以Unity3D这块整个项目就比较放心地交给了我来做，这样的结果就是我大概花了一周时间就写好了整体的框架[偷笑：)]。可是在设计整个项目的过程中，因为美术都忙着建模，所以UI设计这块儿基本上都是空白，作为一个刚进公司不久没有什么话语权的新人，在这种情况下我只能自己先大致做出来一个DEMO，然后再听取领导的意见反复进行修改，可是如果这样，到了项目后期如果因为项目需求发生变动，可能UI设计就需要重新制作，我个人是比较讨厌做UI，因为UI有时候会因为参数设置不合理等等的原因造成无法调试的错误，这样你折腾了大半天找了可能出现的各种错误，最终却发现是因为一个参数设置不合理，这该有多蛋疼啊！我比较喜欢Cocos Studio这种制作UI的方式，就是让美术直接在UI编辑器里做好UI然后导出为程序可以解析的数据类型，这样程序只需要负责将这些数据解析出来为它们绑定相关的UI事件就好了。然而现实是残酷的，在这个项目中，因为楼盘、户型、家装等等因素的不可控性，所以在设计UI的时候全部都是以动态加载的形式来处理的，因为你并不能确定这些UI里显示的元素到底有多少个，这样我在设计这个框架的时候是这样考虑的，就是把所有需要人力来调整、控制的部分(如模型摆放、场景设计等等)都手动完成，所以和UI相关的部分(如UI元素的动态加载、模型的加载、本地配置文件等等)都通过动态加载来实现，因为在整个项目中第三部分的家装会涉及到大量的模型，所以这部分考虑的是将模型文件打包成AssetBundle文件从服务器加载。 &emsp;&emsp;我不知道公司领导当初是怎么样确定使用Unity3D来做这个项目，因为考虑到虚拟展示的需要，这个项目最终展示给用户的是一个网页，这样就更需要考虑资源组织的问题，就这样在工作的第一周时间内我想到了以前在学校做游戏的时候都没”舍得”使用的技术方案，基本的思路是本地的游戏文件最终仅仅保留一个主场景文件(MainMenu.cs)，主场景负责维护从楼盘到户型再到家装的所有逻辑，各个场景中的动态的部分则是通过Resource.Load()和AssetBundle来实现，将这些场景放到服务器上，主场景将决定具体加载哪一个场景。因为整个项目主要分成楼盘、户型、家装这三个部分，这些场景除了模型以外逻辑都是一样的，因此将这部分的逻辑都写成公用的脚本，在制作这些场景时只需要将脚本拖拽到某些物体上就可以了。因为需要从服务器上获取符合筛选要求的楼盘信息，因此还需要编写服务器端的相关逻辑，目前项目组中还没有服务器端的程序，这部分我表示无能为力啊，哈哈。如果希望将最终的网页做得漂亮些，可能还需要前端工程师的加入吧，目前这块同样是空白！好吧，做项目的时候即使是程序员都会有分身乏术的时候，成为全栈工程师是我的梦想，可是目前做不到啊！我不知道在游戏开发中程序和美术的关系怎么样，反正在我目前的项目组里我这个程序的存在感实在是太弱了啊，可能是项目组程序的比例太低，可能是我和大家还不熟悉吧，不过昨天居然有个美术跑过来问我能不能教他Unity3D，因为他觉得建模做得再好做出来的模型终究是死的，哈哈，瞬间感觉有种相见恨晚的感觉啊。好了，这些闲话先聊到这里吧，今天想和大家分享的是我在开发过程中遇到的某些坑，因为我是一个程序员，归根到底我和大家要聊的还是程序嘛！ ##一、下载AssetBundle时遇到”跨域”的问题&emsp;&emsp;这个问题主要是因为服务器上缺少一个叫做crossdomain.xml的文件，这是由Adobe提出的以保证Flash能够跨域访问文件的一种策略，当发生这个错误时具体的表现就是你可以通过浏览器从服务器上下载AssetBundle文件，可是当你试图在Unity里使用WWW访问该文件时就会报错，具体的错误信息我已经不记得了，不过错误信息中特别明确的指出了是因为缺少crossdomain.xml这个文件，所以解决的方案就是在服务器根目录里增加这样一个文件，文件的内容如下：12345&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;cross-domain-policy&gt; &lt;site-control permitted-cross-domain-policies=\"master-only\" /&gt; &lt;allow-access-from domain=\"*\" to-ports=\"*\"/&gt;&lt;/cross-domain-policy&gt; &emsp;&emsp;具体使用的时候需要将*号部分分别替换成允许跨域访问的地址和端口，因为我是用WAMP这个软件搭建的本地服务器，所以这里都采用的是默认值，具体怎么去设置这里的内容还需要大家自己去探索，不过这里就是像告诉大家使用Unity3D做网页游戏或者是从服务器上下载文件是一定要考虑这个问题的啊！ ##二、动态生成的UI Prefab被拉伸的问题&emsp;&emsp;这个问题出现在动态生成UI元素的过程中，就是生成物体以后物体的大小和位置会发生变化，这个问题在宣雨松的博客中曾经读到过，不过当时他并没有说清楚产生这个问题的原因，所以当同样的问题发生在我身上的时候我果断选择和他一样，哈哈，解决方法是把物体的localScale设为(1,1,1)、localPosition设为(0,0,0)，当然按照我的传统如果大家知道是为什么的话还是告诉我吧！ ##三、AssetBundle的mainAsset问题&emsp;&emsp;这个问题产生在最初确定AssetBundle打包是将单个物体打包还是将多个物体一起打包的时候，后来发现mainAsset取决于bool BuildAssetBundle (Object mainAsset,Object[] assets,string pathName, BuildAssetBundleOptionsoptionsBuildAssetBundleOptions.CollectDependencies | BuildAssetBundleOptions.CompleteAssets,BuildTarget targetPlatform= BuildTarget.WebPlayer)这个方法中的第一个参数，就是说指定了一个参数则可以通过mainAsset来获取AssetBundle中的主物体，否则只能通过Load方法传入一个名称来获取指定物体。这里想说一件诡异的事情，比如说我们选中两个物体然后将其打包，但是通过LoadAll方法获取到的物体的数目却不是两个，因为打包的时候GamObject和Transform是分开打包的，父物体下的子物体同样是被分开打包的，因此这个方法使用起来并不是那么地尽如人意，这点希望大家注意！ ##四、场景打包为AssetBundle的问题&emsp;&emsp;我们知道在Unity中可以通过BuildStreamedSceneAssetBundle方法将场景打包为AssetBundle文件，然后按照如下方法加载到游戏中。场景打包的方法如下所示：1234static function MyBuild()&#123; var levels : String[] = [\"Assets/Level1.unity\"]; BuildPipeline.BuildStreamedSceneAssetBundle( levels, \"Streamed-Level1.unity3d\", BuildTarget.WebPlayer); &#125; &emsp;&emsp;接下来我们就可以通过WWW方法将其加载到游戏中12345678910111213141516171819function Start () &#123; // Download compressed scene. If version 5 of the file named \"Streamed-Level1.unity3d\" was previously downloaded and cached. // Then Unity will completely skip the download and load the decompressed scene directly from disk. var download = WWW.LoadFromCacheOrDownload (\"http://myWebSite.com/Streamed-Level1.unity3d\", 5); yield download; // Handle error if (download.error != null) &#123; Debug.LogError(download.error); return; &#125; // In order to make the scene available from LoadLevel, we have to load the asset bundle. // The AssetBundle class also lets you force unload all assets and file storage once it is no longer needed. var bundle = download.assetBundle; // Load the level we have just downloaded Application.LoadLevel (\"Level1\"); &emsp;&emsp;注意到最后一行我们是使用LoadLevel方法来加载一个场景的，该方法需要一个参数，它是我们在Unity3D中注册过的关卡，即在编译游戏的时候需要将其加入到关卡列表中。那么现在问题来了，这个Level11到底是本地的场景还是下载的场景啊，既然我们选择了从服务器上加载一个场景，那么本地应该是不会有这个场景了，那么游戏关卡列表中就不会有这个关卡，因此如果调用最后一样代码应该会提示找不到这个关卡。我在这里纠结了好久，最后发现是这样，就是现在本地做好关卡，然后将其加入到关卡列表中，当本地关卡打包成AssetBundle后，从本地删除当前关卡，依然可以从服务器上加载这个场景。这是我自己做实验的结果，不知道对不对，希望有知道这个的朋友能够告诉我这样到底对不对，因为这种方法感觉有些猥琐啊，哈哈。 &emsp;&emsp;好了，今天的内容就是这样了，因为目前项目暂时就发现了这些问题，所以更多的关于Unity3D的内容需要等到项目慢慢推进的过程中去发现了，希望大家能够喜欢啊！","tags":[{"name":"Unity3D","slug":"Unity3D","permalink":"http://qinyuanpei.github.io/tags/Unity3D/"},{"name":"游戏开发","slug":"游戏开发","permalink":"http://qinyuanpei.github.io/tags/游戏开发/"},{"name":"工作","slug":"工作","permalink":"http://qinyuanpei.github.io/tags/工作/"}]},{"title":"毕业就像指尖流沙","date":"2015-05-16T08:45:05.000Z","path":"posts/3461518355/","text":"&emsp;&emsp;毕业就像指尖流沙，而我是那从指尖流过的沙子。我不知道该怎样来总结我的大学，即使我努力地寻找、努力地回避，我依然觉得大学对我而言就是这样一个讽刺的过程，曾经努力地想要摆脱这个专业最后却留了下来，最初对这个专业的热情随着时间一天天地消逝，到最后却发现自己夹在某种缝隙中左右为难。 &emsp;&emsp;或许大家都认为我这个人比较冷淡，可是对我而言，我只是想做一个简简单单的人而已，我不会因为即将毕业就表现出某种殷切的神情，在我的心里我当做朋友的会一直当作朋友，即使以后大家都鲜有机会再聚在一起，我讨厌酒桌上的朋友，所以我不会用喝酒这件事情来作为我们彼此情感的见证。我是一个不善于卖弄和殷勤的人，可能我心直口快，可能我又爱又恨，可是那是因为我想做一个表里如一的人。朋友对我而言，一直是我所珍视的人，我觉得君子之交淡如水这样的关系就很好，我不是一个善于表演的人，不管是和大家一起拍VCR还是和大家在一起的时候，我想我喜欢的是大家在一起的时光，而不是在一起喝酒的时候。 &emsp;&emsp;我承认，因为长期做编程设计的这样一个习惯，让我的思维方式里只有0和1，只有对和错。可是人却是一种奇怪的感情动物，我有时候甚至会觉得自己更喜欢计算机而不是人，人在一个人的时候会感到孤独，可是当大家都聚在一起的时候真的会快乐吗？人与人之间的关系实在是微妙而复杂，即使是互联网甚至物联网都不能与之匹敌。我知道在中国人的思维里，这种想法特别地正常，因为中国就是这样一个人情社会，有时候我会听到别人跟我说，你自己怎么样并不重要，真正重要的是你处在一个什么样的圈子里。虽然在我阅读过的书籍里、接触过的人的话语里都有类似的结论，可是道理终究是道理，当你试图去将这个道理真正实践的时候，你会发现一切是如此的艰难。 &emsp;&emsp;大家或许觉得我对这个班没有什么感情，可是人和人相处不能单纯地看重对方目前、以后可能会对你有什么样的帮助，因为这不叫朋友叫做关系，我眼中的朋友是那种即使自身没有什么强大的社会资源，可当你需要帮助的时候，他仍然会真心实意地为你付出，我对于朋友和关系的界定实在是困难，因此当我面对这场不知是送别还是交友的毕业聚会的时候，我会突然陷入某种迷茫，即使麦克风音量开到最大、嗓子喊到声嘶力竭，当一切都结束了的时候能够留下什么呢？终有一天大家都会奔向各自的前程，去做自己想做的事情，就像慕容紫英一样，百年蹉跎岁月不过转瞬，当朋友们都不再需要他照顾的时候，他会义无反顾地踏上自己的路，他心里记得那句“承君此诺，必守一生”，可是千百年后当昆仑山上下起雪的时候，这世上留给他又有什么呢？他终究是一个人，上天怜悯他却不曾心疼他，当心中信念坍塌的时候，我不知道他是不是和我一样有过这种迷茫？ &emsp;&emsp;昨天我和班里大部分的人喝了酒，目的单纯而简单，就是想感谢大家在这四年里对我的帮助，就是想记住和大家在一起的这段时光，我是一个随和的人，所以我不会强迫别人喝多少酒，因为喝酒就是一种助兴的形式而已，真正让我们铭记于心的不是这顿酒，而是我们彼此在各自的生命里出现过。或许我就是这样一个尚不成熟的人吧，或许以后我会变成让大家、让每一个人都喜欢的样子，或许我以后依然会是这个样子……生命中有太多的或许让人无法预料，可你的生命会是什么样子完全取决于你的选择，我不想为未来埋下太多的伏笔，我就是一个普通的、平凡的人，仅此而已……","tags":[{"name":"梦想","slug":"梦想","permalink":"http://qinyuanpei.github.io/tags/梦想/"},{"name":"人生","slug":"人生","permalink":"http://qinyuanpei.github.io/tags/人生/"},{"name":"毕业","slug":"毕业","permalink":"http://qinyuanpei.github.io/tags/毕业/"}]},{"title":"Unity3D游戏开发之MMD For Unity插件研究","date":"2015-04-19T23:31:30.000Z","path":"posts/4088452183/","text":"&emsp;&emsp;今天想来说说MMD。MMD是MikuMikuDance的简称，是由日本人樋口优开发的一组3D动画制作软件。该软件最初希望能够将3D建模软件完成的VOCALOID的初音未来等角色模型制作成可以随着音乐跳舞的动画，因此称为MMD。作者在此基础上开发了能够将歌曲让初音未来等角色歌唱的MikuMikuVoice。2011年9月11日，樋口优宣布停止MMD新版本的开发工作。不过人们对制作MMD的热情丝毫没有减少，在动漫、游戏等领域总是能够不断看到MMD的影子。例如MMD/宇月和千本樱/夏侯瑾轩都是较为典型的MMD。 &emsp;&emsp;好了，相信现在大家都对MMD有了一定的了解了，作为一名单机游戏爱好者，我目前最为遗憾的两件事情： 不会制作游戏MV(或者说视频) 不会制作MMD(因为我是个程序嘛) &emsp;&emsp;在我看来以同人形式去发掘一个作品中优秀的东西，这件事情本身就是一件让人觉得快乐的事情，因为可能某一个人和你有相同的想法，当它看到你的东西的时候，发觉你想表达的东西就是它想要表达的。我每次玩完一款游戏以后都会去网上搜集比较好的MV，因为我觉得随着人一天天地慢慢长大，有时候你发觉自己再没有时间去玩游戏的时候，通过看视频能让你想起很多的事情，有时候看着别人做的MV会哭，我便觉得当时的经历其实挺值的去回味的。好了，说了这么多毫不相干的事情，差点忘了今天的正事。首先我们来了解下一个完整的制作MMD的过程： 使用Maya、Blender或者3DsMax等3D软件建模(或者从游戏中提取) 使用PMDEditor或者PMXEditor对模型进行绑骨、动作和表情制作等操作 将处理过的.pmd或者.pmx模型导入MikuMikuDance完成场景、音乐完成动画制作 &emsp;&emsp;从这样一个过程我们了解到，制作MMD还是需要一定的技术门槛的，因为并不是每一个人都能够完成模型的绑骨、动画这些任务的。这篇文章不提供以上软件的下载和使用方法，因为我们接下来的内容基本与以上软件无关，我们的重点依然是Unity3D，因为我是一个游戏开发者嘛，哈哈。好了，下面的内容基于两点假设： 你有一个PMD或者PMX模型 你有一个VMD的动作文件 &emsp;&emsp;首先，第一步我们需要一个Unity3D插件MMD4Unity,将这个插件导入项目后，为了使整个项目结构较为清晰，我们将这个插件的文件夹命名为MMDPlugins。在MMDFiles文件中我们准备了三个文件: 模型文件：初音.pmd 动作文件：动作1.vmd和动作2.vmd &emsp;&emsp;好了，现在我们注意到Unity3D菜单栏上会增加一个Plugin菜单项，我们单击这个菜单项会发现MMD Loader和XFile Importer这两个项目，这里我们选择MMD Loader这个菜单项： MMD1 &emsp;&emsp;这两个子菜单项的意义十分地明确了，PMD Loader负责加载PMD模型并将其转化为Unity3D可以识别的模型文件，VMD负责将一个动作文件套用到一个模型上。所以： 1、通过PMD Loader打开加载PMD文件的窗口，建议这里将ShaderType设置为Default，因为如果使用MMD的Shader的话，待会转换出来的模型可能会存在找不到材质的问题。接下来我们点击Convert，稍等片刻就会在场景中看到一个模型(prefab)文件。 MMD2 MMD3 2、接下来通过VMD Loader打开加载VMD文件的窗口，选择场景中的模型文件和项目资源中的XMD动作文件，点击Convert，大概有1分钟多一点的样子就好了。此时我们选择场景中的模型文件，找到它的Animation组件，然后点击Animation右侧的按钮为其指定一个动画文件，因为刚刚我们已经为它添加了一个动作，所以我们可以很容易的在项目资源中找到名为初音_动作2的动画片段(AnimationClip)。 MMD4 &emsp;&emsp;好了，现在我们就来看看这个MMD的效果吧！ MMD5 &emsp;&emsp;哈哈，感觉效果还不错吧！ &emsp;&emsp;现在来说说我在使用这个插件过程中遇到的问题： 在转换PMD模型的时候如果选择Default转换出的模型可以找到对应的材质，可是模型是错误的；如果选择MMDShader，转换出的模型会找不到对应得材质，比如说我在尝试转换下面这个模型的时候，因为MMD对模型的精细程度的要求，所以模型会被分得很细，因此像这个模型当贴图数目较少的时候，就没有办法自动对应贴图，所以这快目前还是个问题吧！ 如果使用的是PMX模型，可以用PMEditor这个软件转换下格式，转成PMD格式后，后然后再按照本文的方法去做就可以了。 PMD转换出来的模型没有办法选择其中的某一个部分，因此在操作模型的时候可能会不太方便吧，以前都是选择某一部分然后给模型贴图，现在这招不行了啊。 &emsp;&emsp;好了，今天的内容就是这样了，有什么问题大家给我留言哦！","tags":[{"name":"Unity3D","slug":"Unity3D","permalink":"http://qinyuanpei.github.io/tags/Unity3D/"},{"name":"单机游戏","slug":"单机游戏","permalink":"http://qinyuanpei.github.io/tags/单机游戏/"},{"name":"MMD","slug":"MMD","permalink":"http://qinyuanpei.github.io/tags/MMD/"}]},{"title":"在Sublime Text3下安装Package Control","date":"2015-04-17T12:54:41.000Z","path":"posts/570137885/","text":"&emsp;&emsp;Sublime Text,是这个地球上最好的代码编辑器，没有之一。因为在过去的一段时间里，我使用的版本是SublimeText2，所以听说Sublime Text3版本稳定后，决定开始尝鲜。哈哈，我就是这么一个”喜新厌旧”的人！Sublime的强大不仅仅在它优雅的外表，更为重要的是她无可匹敌的扩展性，就是说我们可以通过插件来扩展它的功能，这对于一个喜欢DIY的人来说简直是无法抗拒的诱惑。不过在接收这些诱惑前，我们需要一个工具Package Control，它是Sublime里最为基础、最为重要的插件，好了，现在问题来了，Sublime怎么安装Package Control！ &emsp;&emsp;在Sublime Text2下我们可以通过CTRL+~打开控制台，然后输入代码：12345678910import urllib2,os; pf='Package Control.sublime-package'; ipp = sublime.installed_packages_path(); os.makedirs( ipp ) if not os.path.exists(ipp) else None; urllib2.install_opener( urllib2.build_opener( urllib2.ProxyHandler( ))); open( os.path.join( ipp, pf), 'wb' ).write( urllib2.urlopen( 'http://sublime.wbond.net/' +pf.replace( ' ','%20' )).read()); print( 'Please restart Sublime Text to finish installation') &emsp;&emsp;可是到了Sublime Text3下，因为版本不同的关系，内部API发生变化，因此需要使用新的代码：123456import urllib.request,os; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), 'wb').write(urllib.request.urlopen( 'http://sublime.wbond.net/' + pf.replace(' ','%20')).read()) &emsp;&emsp;当代码因为某些原因无法正常工作的时候，我们可以手动安装Package Control： 下载PackageControl或者通过Github获取 1git clone git@github.com:wbond/package_control.git 通过Preferences-&gt;Browser Packages进入Installed Packages目录 重新启动Sublime，然后Enjoy it！","tags":[{"name":"编辑器","slug":"编辑器","permalink":"http://qinyuanpei.github.io/tags/编辑器/"},{"name":"Sublime","slug":"Sublime","permalink":"http://qinyuanpei.github.io/tags/Sublime/"},{"name":"IDE","slug":"IDE","permalink":"http://qinyuanpei.github.io/tags/IDE/"}]},{"title":"在Windows下使用Visual Studio编译Lua5.3","date":"2015-04-16T14:50:35.000Z","path":"posts/3642630198/","text":"&emsp;&emsp;Lua5.3已经发布好长时间了，可是因为LuaForWindows的Lua版本无法和官方保持一致，所以想尝试下编译Lua5.3的源代码，因为作为一名合格的程序员，是应该要懂得编译原理的相关内容的啊(可是我真的没有学过编译原理啊!…..)。好了，那么今天博主将在文章中和大家分享自己编译Lua5.3的过程，希望能够对大家学习和使用Lua有些帮助吧！ &emsp;&emsp;我们知道Lua由三部分组成，即 Lua链接库 Lua解释器 Lua编译器 &emsp;&emsp;因此，对于Lua源代码的编译主要就是编译Lua链接库、Lua解释器和Lua编译器 #编译Lua链接库 使用Visual Studio创建一个VC++项目，项目命名为Lua53，项目类型为静态库、不设置预编译头。 删除Visual Studio自动创建的.cpp文件及其对应的.h文件。 将下载的Lua代码解压，将src目录下的全部文件拷贝到项目中，然后删除lua.c、luac.c和lua.hpp这三个文件。 编译项目会得到一个Lua53.lib的文件，这就是我们编译得到的Lua链接库。 #编译Lua解释器&emsp;&emsp;我们知道Lua解释器是一个可以直接运行Lua代码的可执行文件，因此 在同一个解决方案下继续创建VC++项目，项目命名为Lua，项目类型为控制台应用程序、需设置预编译头。 删除Visual Studio自动创建的.cpp文件及其对应的.h文件。 将下载的Lua代码解压，将src目录下的全部文件拷贝到项目中，然后删除luac.c这个文件。 设置当前项目依赖于Lua53项目 编译项目会得到一个Lua.exe文件，这就是我们编译得到的Lua解释器。 &emsp;&emsp;运行该程序，我们可以看到下面的结果： Lua解释器程序 &emsp;&emsp;好了，现在我们来写一个简单的Lua程序：12io.write(\"Hello I get a powerful program language called Lua \\n\")io.write(string.format(\"This Lua is %s and now is %s \\n\",_VERSION,os.date())) &emsp;&emsp;程序运行结果为： Hello I get a powerful program language called LuaThis Lua is Lua5.3 and now is 04/16/15 16:06:43 #编译Lua编译器&emsp;&emsp;和Lua类似地， 在同一个解决方案下继续创建VC++项目，项目命名为Lua，项目类型为控制台应用程序、需设置预编译头。 删除Visual Studio自动创建的.cpp文件及其对应的.h文件。 将下载的Lua代码解压，将src目录下的全部文件拷贝到项目中，然后删除lua.c这个文件。 设置当前项目依赖于Lua53项目 编译项目会得到一个Luac.exe文件，这就是我们编译得到的Lua解释器。 &emsp;&emsp;使用Lua编译器需要在环境变量中增加对Lua编译器路径地引用，比如Luac.exe放在D:\\Program Files\\Lua\\build\\这个目录下，就在PATH这个变量中增加：1D:\\Program Files\\Lua\\build; &emsp;&emsp;因为每个人的Lua编译器存放的位置都不同，所以这个就不再赘述了。 &emsp;&emsp;好了，今天的内容就是这样了。 #链接 本文编译的Lua 官方编译的Lua","tags":[{"name":"Lua","slug":"Lua","permalink":"http://qinyuanpei.github.io/tags/Lua/"},{"name":"编译","slug":"编译","permalink":"http://qinyuanpei.github.io/tags/编译/"},{"name":"Visual Studio","slug":"Visual-Studio","permalink":"http://qinyuanpei.github.io/tags/Visual-Studio/"}]},{"title":"贝塞尔曲线学习笔记","date":"2015-04-08T12:25:28.000Z","path":"posts/2186770732/","text":"&emsp;&emsp;贝塞尔曲线(Bezier Curve)是由法国工程师皮埃尔·贝塞尔(Pierre Bezier)于1962年提出的一种曲线。在数学的数值分析领域中，贝塞尔曲线是计算机图形学中相当重要的参数曲线，其主要意义在于无论是直线还是曲线都能在数学上予以描述。最早贝塞尔曲线被用来对汽车主体进行设计，现在贝塞尔曲线被广泛地运用到计算机图形软件(如Photoshop、Flash等)中，是计算机图形领域重要的一个数学曲线。 #贝塞尔曲线主要内容&emsp;&emsp;贝塞尔曲线就是这样的一条曲线，它是依据四个位置任意的点坐标绘制出的一条光滑曲线。在历史上，研究贝塞尔曲线的人最初是按照已知曲线参数方程来确定四个点的思路设计出这种矢量曲线绘制法。贝塞尔曲线的有趣之处更在于它的皮筋效应，也就是说，随着点有规律地移动，曲线将产生皮筋伸引一样的变换，带来视觉上的冲击。1962年，法国数学家Pierre Bezier第一个研究了这种矢量绘制曲线的方法，并给出了详细的计算公式，因此按照这样的公式绘制出来的曲线就用他的姓氏来命名是为贝塞尔曲线。贝塞尔曲线按照阶数可以从一次扩展到n次，这里例举出常见的一次贝塞尔曲线、二次贝塞尔曲线和三次贝塞尔曲线。 ##一次贝塞尔曲线&emsp;&emsp;一次贝塞尔曲线，即线性贝塞尔曲线，其定义是:给定点P0、P1，贝塞尔曲线是两点间的一条直线。线性贝塞尔曲线由下列公式给出： B(t)=P0+(P1-P0)t=(1-t)P0+tP1,其中t是一个0到1之间的数值 &emsp;&emsp;该公式等同于对P1,P0两点进行线性插值。 一次贝塞尔曲线 ##二次贝塞尔曲线&emsp;&emsp;二次贝塞尔曲线的路径由给定点P0、P1、P2的函数B(t)给出: B(t)=(1-t)^2 * P0+2t(1-t)P1+t^2P2,其中t是一个0到1之间的数值 &emsp;&emsp;为构建二次贝塞尔曲线，可以中介点Q0和Q1作为由0至1的t: 由P0至P1的连续点Q0，描述一条线性贝塞尔曲线。 由P1至P2的连续点Q1，描述一条线性贝塞尔曲线。 由Q0至Q1的连续点B(t)，描述一条二次贝塞尔曲线。 二次贝塞尔曲线原理图 二次贝塞尔曲线演示效果 ##三次贝塞尔曲线&emsp;&emsp;P0、P1、P2、P3四个点在平面或在三维空间中定义了三次方贝塞尔曲线。曲线起始于P0走向P1，并从P2的方向来到P3。P0和P1之间的间距，决定了曲线在转而趋进P3之前，走向P2方向的“长度有多长”。三次贝塞尔曲线的公式是: B(t)=P0(1-t)^3+3P1t(1-t)^2+3P2t^2(1-t)+P3t^3,其中t是一个0到1之间的数值 三次贝塞尔曲线原理图 &emsp;&emsp;三次贝塞尔曲线的绘制这里采取的是一种已知曲线参数方程来确定四个点的方法，这种方法称为矢量曲线绘制法。这里以二维平面为例(如需三维空间同理构造出z(t)即可): x(t)=axt^3+bxt^2+cxt+x0y(t)=ayt^3+byt^2+cyt+y0 &emsp;&emsp;因为x0、y0已知，因此我们可以用下列公式计算出剩余三个点的坐标: x1 = x0 + cx / 3x2 = x1 + ( cx + bx ) / 3x3 = x0 + cx + bx + ax y1 = y0 + cy / 3y2 = y1 + ( cy + by ) / 3y3 = y0 + cy + by + ay &emsp;&emsp;在x0、y0已知的前提下，可以通过变换得到: cx = 3 ( x1 - x0 )bx = 3 ( x2 - x1 ) - cxax = x3 - x0 - cx - bx cy = 3 ( y1 - y0 )by = 3 ( y2 - y1 ) - cyay = y3 - y0 - cy - by &emsp;&emsp;因此只要给定四个点，总能构造出一条三次贝塞尔曲线，这种方法是一种较为实用和可靠的方法。 三次贝塞尔曲线效果演示 &emsp;&emsp;下面我们来看一个简单的示例，该示例以Unity3D为基础建立，希望对大家理解贝塞尔曲线有所帮助。 代码示例(尝试着实现了下，发现暂时有些问题，等实现了再更新上来吧！) 2015年12月19日更新：在《CG Programming in Unity》一书中提到了贝塞尔曲线，实现了一个基础版本的贝塞尔曲线绘制，即在给定P0和P2的前提下，由用户通过滑杆对P1进行控制，可以实时预览当前曲线的样式，感兴趣的朋友可以阅读该书的第9章部分。下面给出代码示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182using UnityEngine;using System.Collections;public class QuadraticBezier : MonoBehaviour &#123; /// &lt;summary&gt; /// 3个基础点 /// &lt;/summary&gt; public Vector3 P0; public Vector3 P1; public Vector3 P2; /// &lt;summary&gt; /// 调整第二个参数的水平分量 /// &lt;/summary&gt; private float paramX = 0.5f; /// &lt;summary&gt; /// 调整第二个参数的垂直分量 /// &lt;/summary&gt; private float paramY = 0.5f; /// &lt;summary&gt; /// 线条宽度 /// &lt;/summary&gt; public float LineWidth = 0.15f; /// &lt;summary&gt; /// 线条颜色 /// &lt;/summary&gt; public Color LineColor = Color.white; /// &lt;summary&gt; /// 顶点数目 /// &lt;/summary&gt; public int PointsCount = 10; /// &lt;summary&gt; /// 线渲染器 /// &lt;/summary&gt; private LineRenderer lineRenderer; void Start () &#123; //初始化线渲染器 lineRenderer = this.GetComponent&lt;LineRenderer&gt;(); if(lineRenderer == null) lineRenderer = this.gameObject.AddComponent&lt;LineRenderer&gt;(); lineRenderer.useWorldSpace = true; lineRenderer.SetColors(LineColor,LineColor); lineRenderer.material = new Material(Shader.Find(\"Particles/Additive\")); lineRenderer.SetWidth(LineWidth,LineWidth); lineRenderer.SetVertexCount(PointsCount); &#125; void Update() &#123; //根据滑杆参数计算P1 P1 = new Vector3(Mathf.Abs(P0.x-P2.x) * paramX, Mathf.Abs(P0.x-P2.x) * paramY, 0); //绘制曲线 for (int i = 0; i &lt; PointsCount; i++) &#123; float t = i / (PointsCount - 1.0f); Vector3 position = (1.0f - t) * (1.0f - t) * P0 + 2.0f * (1.0f - t) * t * P1 + t * t * P2; lineRenderer.SetPosition(i, position); &#125; &#125; void OnGUI() &#123; GUILayout.Label(string.Format(\"第一个参数：P0=(&#123;0&#125;,&#123;1&#125;,&#123;2&#125;)\", P0.x, P0.y, P0.z)); GUILayout.Label(string.Format(\"第二个参数：P1=(&#123;0&#125;,&#123;1&#125;,&#123;2&#125;)\", P1.x, P1.y, P1.z)); GUILayout.Label(\"请拖动下面的滑杆调整第二个参数P1观察曲线变化\"); paramX = GUILayout.HorizontalSlider(paramX, 0, 1); paramY = GUILayout.HorizontalSlider(paramY, 0, 1); GUILayout.Label(string.Format(\"第三个参数：P2=(&#123;0&#125;,&#123;1&#125;,&#123;2&#125;)\", P2.x, P2.y, P2.z)); &#125;&#125; 在这段代码中通过两个参数来调整P1，这里取Z分量为0主要是方便研究，扩展到三维空间需要给定第三个参数来对应的调整。这个示例的运行效果如下：","tags":[{"name":"数学","slug":"数学","permalink":"http://qinyuanpei.github.io/tags/数学/"},{"name":"贝塞尔曲线","slug":"贝塞尔曲线","permalink":"http://qinyuanpei.github.io/tags/贝塞尔曲线/"},{"name":"计算机图形","slug":"计算机图形","permalink":"http://qinyuanpei.github.io/tags/计算机图形/"}]},{"title":"Unity3D游戏开发之使用disunity提取Unity3D游戏资源","date":"2015-04-03T13:29:18.000Z","path":"posts/1082185388/","text":"&emsp;&emsp;各位朋友，大家好，我是秦元培。今天博主想和分享的是使用disunity提取Unity3D游戏素材。这个工具呢，博主在Unity3D游戏开发之反编译AssetBundle提取游戏资源这篇文章中其实已经提到过了，不过因为有些朋友对如何使用这个工具依然存在问题，所以博主决定特地写一篇文章来讲解如何使用disunity来提取Unity3D游戏中的素材。 准备工作 disunity:负责对Unity3D的数据文件进行解包 Unity3D:负责将导出的数据文件显示出来 Bleander或者3DsMax:负责Unity3D数据文件的转换处理，二选一即可。个人推荐Blender。 Java:负责为disunity提供编译环境 测试文件 《新仙剑OL》下载 《轩辕剑6外传穹之扉》 《雨血前传:蜃楼》下载 提取流程&emsp;&emsp;好了，在确定做好所有的准备工作后，我们就可以正式开始今天的内容了！ 编译disunity&emsp;&emsp;虽然我们可以从disunity的项目主页中下载release版本，不过为了保险起见，博主依然建议大家自行编译disunity。编译的方法是在命令行中切换到disunity的目录，然后执行命令:1java -jar disunity.jar &emsp;&emsp;如果大家的Java环境没有任何问题的话，那么接下来我们就应该可以看到:1[Info] DisUnity v0.3.4 &emsp;&emsp;以及各种关于这个工具的使用方法和参数选项。那么好了，现在我们就来熟悉下disunity这个工具的常用命令。disunity命令的基本形式是:1disunity [CommandName] [CommandOptions] disunity命令 dump:将一个二进制的对象转化成人类可以阅读的文本信息。 dump-struct:将一个二进制的对象转化为结构化的信息。 extract:将Unity3D的数据文件转化为常见的文本、声音、图片等信息。 extract-raw:将Unity3D的数据文件转化为可序列化的对象，在extract命令不被支持的情况下使用。 extract-txt:和dump命令类似输出转换结果到命令行。 extract-struct:和dump-struct命令类似输出转换结果到命令行。 info:输出Unity3D的数据文件和AssetBundle文件的变量信息。 bundle-extract:释放所有的被打包到AssetBundle中的文件。 bundle-inject:将从AssetBundle中打包的文件重新打包 &emsp;&emsp;暂时先介绍这些，因为其它的命令我们基本用不到，如果需要深入研究这些命令，可以参考disunity项目中的README.md文件。 解析《新仙剑OL 》的AssetBundle文件&emsp;&emsp;这里我们以游戏目录/assetbundles/NPC/Models/下的s049.unity3d_CC9026FB为例来讲解游戏模型的提取。 模型文件提取&emsp;&emsp;首先我们将这个文件的扩展名改为s049.unity3d，因为这是它原始的扩展名，是Unity3D中导出AssetBundle的一种文件格式。好了，我们将这个文件放在一个无中文路径的目录下，这里以C:\\Users\\Robin\\Desktop即桌面为例。注意首先进入disunity的目录，然后执行命令：1disunity extract C:\\Users\\Robin\\Desktop\\s049.unity3d &emsp;&emsp;接下来会在桌面生成一个名为s049的文件夹，在这个文件夹中找到Mesh的子文件夹，会得到一个s049.obj的文件，这个文件就是我们提取到的模型文件。 模型贴图提取好了，下面我们再来看看怎么提取这个模型文件对应的贴图，在游戏目录/assetbundles/NPC/Texture/下有一个名为s049_1.unity3d_1D2446B9的文件，这就是s049这个模型对应的贴图了。同样地，我们将其重命名为s049_1.unity3d然后执行命令：1disunity extract C:\\Users\\Robin\\Desktop\\s049_1.unity3d &emsp;&emsp;接下来在桌面上生成一个名为s049_1的文件夹，在这个文件夹中找到Texture2D的子文件夹，会得到一个名为s049_1.dds的贴图文件，这就是我们要提取的模型s049的贴图文件。 将模型和贴图合并我们打开Blender并将s049.obj文件导入，然后将场景中默认的灯光和摄像机都删除，因为我们只需要一个模型文件，我们发现在Blender中已经可以看到模型了，因为Unity3D中使用的是FBX模型，所以我们这里将模型文件导出为FBX备用。因为Unity3D可以识别dds类型的贴图，所以对贴图我们不用做任何处理。 童年林月如的模型 &emsp;&emsp;打开Unity3D将童年林月如的模型和贴图一起导入，将童年林月如的模型拖入到游戏场景中，因为模型的尺寸没有经过调整，所以模型刚开始可能会比较小，我们可以在Unity3D进行局部的调整。接下来我们会发现模型没有贴图，只要选择这个模型然后在属性窗口为它附上s049_1.dds的贴图文件即可。下面是童年林月如的模型导入Unity3D以后的效果: 童年林月如导入Unity3D后的效果 解析《新仙剑OL》的assets文件&emsp;&emsp;和AssetBundle不同，assets文件是整个Unity3D项目中项目资源的打包集合，比如说Asset文件下的资源都会被打包到这里，所以说解析assets文件可能会有更大的收获吧！因为所有的Unity3D游戏都会有这样的文件，而AssetBundle文件只有在使用了这项技术的游戏项目中才有。比如说在Unity3D中有一个重要的Resource文件夹，这个文件夹打包后被被打包成resources.assets文件。这里我们以xianjian_Data/resources.assets文件为例。首先执行命名:1disunity extract C:\\Users\\Robin\\Desktop\\resources.assets &emsp;&emsp;接下来会在桌面生成一个resources的文件夹，打开这个文件夹我们会发现三个子文件夹，分别是Shader、TextAsset和Texture2D。解析的结果似乎有点失望，不过在TextAsset文件夹下我们会找到一个叫做ResourceFiles.txt的文件，这是一个纯文本文件，我们可以直接打开，打开后我们发现它的内容是一个Xml文件，并且在这个Xml文件中定义了游戏中使用的各种资源的路径，不过这些资源都是以AssetBundle的形式来定义的。这说明什么呢？这说明《新仙剑OL》的场景和界面资源是通过动态加载的方式加载到游戏当中的，而这些资源则是通过这个Xml文件来配置和管理的，这符合我们平时在Unity3D游戏开发中的观点和方法。通过这个文件，我们找到了assetbundles/config/movieconfig.unity3d这个文件，这是一个负责维护游戏中场景过场动画的文件。下面我们就来尝试解析这个文件，不过游戏制作方对config文件夹下的内容进行了加密，因为在这个文件夹下面是两个AssetBundle文件，博主尝试用extract和bundle-extract两个命令进行解析，可是得到的只是些文本文件，对我们继续研究没有什么帮助。那么好了，现在我们能够进行解析的只有xinjian_Data/sharedassets0.assets文件了：1disunity extract C:\\Users\\Robin\\Desktop\\sharedassets0.assets &emsp;&emsp;这个解出来的话是些没有什么用的贴图文件，看来如果要提取音乐或者图片的话，还需要进行更加深入的研究才行啊。 解析《雨血前传.蜃楼》的assets文件&emsp;&emsp;因为解析《新仙剑OL》的assets文件没有得到什么有用的东西，所以我们接下来来尝试解析《雨血前传.蜃楼》的assets文件。这款游戏是博主比较喜欢的一款游戏，基于Unity3DY引擎，而且这款游戏是作为Unity3D官方范例来推广的，因此研究这款游戏对我们提高Unity3D的资源打包机制会比较有帮助。好了，我们直接上手：1disunity extract C:\\Users\\Robin\\Desktop\\resources.assets &emsp;&emsp;哈哈，这款游戏果然没有让我们失望，我们得到了什么呢？ 蜃楼中各种Boss的头像 蜃楼中游戏连招视频1 蜃楼中游戏连招视频2 #总结 不同的游戏采用的资源配置方案都不同，不过一般可以从resources.assets这个文件入手作为突破点。 如果能拿到游戏中数据配置方案，对于我们提取游戏中的素材会有较大的帮助，因为这样方向性会更强些。 通过AssetBundle动态加载到场景中最好还是采用一个配置表来进行配置，这样便于我们管理和维护整个游戏项目。 如果没有服务器段的干预，理论上只要修改了本地的AssetBundle文件就可以实现对游戏内容和数据的更改，换句话说，可以做外挂和修改器。","tags":[{"name":"Unity3D","slug":"Unity3D","permalink":"http://qinyuanpei.github.io/tags/Unity3D/"},{"name":"穹之扉","slug":"穹之扉","permalink":"http://qinyuanpei.github.io/tags/穹之扉/"},{"name":"disunity","slug":"disunity","permalink":"http://qinyuanpei.github.io/tags/disunity/"},{"name":"反编译","slug":"反编译","permalink":"http://qinyuanpei.github.io/tags/反编译/"}]},{"title":"Unity3D游戏开发之反编译AssetBundle提取游戏资源","date":"2015-04-02T20:37:52.000Z","path":"posts/2799263488/","text":"&emsp;&emsp;各位朋友，大家好，欢迎大家关注我的博客，我是秦元培，我的博客地址是http://www.qinyuanpei.com。今天我们来说说通过反编译Unity3D的AssetBundle来提取游戏资源，博主写这篇文章的目的并非是要教大家如何去破解一款基于Unity3D引擎开发的游戏，而是想通过今天这篇文章来告诉大家如何在开发Unity3D游戏的过程中保护自己的游戏资源。 漫话Unity3D的AssetBundle&emsp;&emsp;对于AssetBundle，其实博主是在以前的文章中是有提到的。不知道大家还记不记得，博主曾经在写游戏开发和Lua的不解之缘这个系列文章的时候，提到并且使用过AssetBundle这种技术。具体来说呢，AssetBundle在Unity3D中是一种用于资源打包盒资源动态加载的解决方法，比如我们平时玩的单机游戏容量一般都比较大，这是因为制作人员在制作游戏的时候将所有的项目资源都整合到了一起。可是如果我们用AssetBundle来做这个游戏的话，我们就可以只在发布的游戏中提供支持游戏功能的核心部分，而将游戏当中的场景、模型等资源以AssetBundle的形式打包然后放到服务器上，这样当游戏客户端处于联网的时候就可以从服务器上下载这些资源，从而实现游戏资源的动态加载，由此可见AssetBundle可以帮助我们减少游戏的容量。如果是在需要安装包的场合下，那么游戏包容量的大小无疑会为游戏加些印象分。 为什么这幅图总让我想起仙剑四里四人在即墨那晚的时光呢？ &emsp;&emsp;比如最近《轩辕剑6外传穹之扉》这部单机游戏发布了，从各大游戏网站的评测到和一样我喜欢单机游戏的各位朋友们的亲身体验，大家一致的认为这部游戏整体表现还不错，应该考虑玩一玩。这样难免让博主有些心动，可是看到17个G的游戏容量时还是犹豫了下。DOMO小组从《轩辕剑6》就开始使用Unity3D引擎，在经历了第一部游戏的失败后，或许此次DOMO小组会将游戏优化的比较好吧。这里如果有喜欢单机游戏的朋友不妨去玩玩看，毕竟我们学习游戏开发的初衷就是做出好游戏，如果不热爱游戏又怎么能做出好游戏呢？好了，扯得有点远了，这里我们注意到一个重要的因素就是游戏容量，如果DOMO采用AeestBundle的话，游戏的容量肯定会减少很多。可是这样一来，它就不是单机游戏了嘛，对吧！ &emsp;&emsp;在Unity3D中AssetBundle是专业版中的一个功能，在免费版的Unity3D中是无法使用这个功能的，不知道在Unity5中这个功能是不是划分到了个人版中。好了，下面我们来看看如何使用AssetBundle。我们主要从使用AssetBundle打包和加载AssetBundle这两个方面来说： 使用Assetbundle打包&emsp;&emsp;使用AssetBundle打包主要通过BuildPipeline.BuildAssetBundle()这个方法来实现，该方法原型为：123bool BuildAssetBundle (Object mainAsset,Object[] assets,string pathName, BuildAssetBundleOptions optionsBuildAssetBundleOptions.CollectDependencies | BuildAssetBundleOptions.CompleteAssets,BuildTarget targetPlatform= BuildTarget.WebPlayer) &emsp;&emsp;在这个方法中，第一个参数是一个Object类型，表示一个激活的物体;第二个参数是一个Object[]类型，表示所有选中的物体;第三个参数是一个string类型，表示要导出的资源包的路径，资源包的扩展名可以是assetbundle或者unity3d;第四个参数表示的是打包选项，默认是完全打包和依赖打包。这里重点解释下这两个概念，完全打包是指所有资源都参与打包，比如说一个模型带有贴图和动画，那么打包模型的时候贴图和动画都会被作为资源打包。而依赖打包是相对于Prefab来说的，比如说PrefabA中引用了PrefabB这个对象，那么打包的时候这两个对象都会被打包，并且它们之间的这种依赖关系会在打包后继续保持；第五个参数是平台的选择，因为Unity3D是一个跨平台的游戏引擎，而各个平台现在的情况又不尽相同，因此现在Unity3D采取的方案是各个平台只能使用自己平台对应的AssetBundle，这一点希望大家在使用的时候注意啊。好了，现在我们来看一个简单的例子：12345678910111213141516171819/// &lt;summary&gt;/// 输出AssetBundle/// &lt;/summary&gt;/// &lt;param name=&quot;type&quot;&gt;平台类型&lt;/param&gt;static void ExportToAssetBundle(ExportType type,BuildTarget target)&#123; //获取存储路径 string savePath=EditorUtility.SaveFilePanel(&quot;输出为AssetBundle&quot;,&quot;&quot;,&quot;New Resource&quot;,&quot;unity3d&quot;); if(savePath==string.Empty) return; //获取选中的对象 Object[] selection=Selection.GetFiltered(typeof(Object),SelectionMode.DeepAssets); if(selection.Length==0) return; //打包 if(type==ExportType.All)&#123; BuildPipeline.BuildAssetBundle(null,selection,savePath,BuildAssetBundleOptions.CollectDependencies,target); &#125;else&#123; BuildPipeline.BuildAssetBundle(obj,null,savePath,BuildAssetBundleOptions.CollectDependencies,target); &#125;&#125; &emsp;&emsp;这是一个简单的导出AssetBundle资源包的方法，它有两个参数，第一个参数表示是一个枚举类型，定义为ExportType，取Single时表示打包一个特定的激活物体，比如说一个模型、一个场景等等;取All时表示打包所有选中的物体，比如一个场景。第二个参数表示打包的平台，这个不用多说了。因为博主的免费版的Unity3D不支持AssetBundle，所以这里没法给大家演示了，具体效果请自行测试，有问题的话给博主留言就是了。 加载AssetBundle&emsp;&emsp;加载AssetBundle是一个从网络中下载资源的过程，因此需要使用Unity3D的WWW功能，这是一个简单的网络协议的封装，可以像浏览器一样访问某个URL地址或者是本地地址，访问WEB地址需要使用HTTP协议，访问本地地址需要使用File协议。我们来看一个具体的例子：12345678910111213141516/// &lt;summary&gt;/// 加载一个unity3d格式的文件/// WEB地址——http://server.com/xxx.unity3d/// 本地地址——file://.unity3d文件的绝对路径/// &lt;/summary&gt;IEnumerator LoadUnity3DFile(string url)&#123; WWW www=new WWW(url); yield return www; if(www.error!=null)&#123; Debug.Log(www.error); &#125;else&#123; AssetBundle bundle=www.assetBundle; Instantiate(bundle.mainAsset,Vector3.zero,Quaternion.identity); &#125;&#125; &emsp;&emsp;在这里我们直接使用bundle.assetBundle获取了全部的资源，如果只需要获取资源中的一部分，则只需要通过bundle.Load()方法就可以了，这里需要传入资源的名称。当我们使用完资源后可以通过bundle.Unload()方法来卸载资源，达到释放内存的目的。 #从反编译《新仙剑OL》看AssetBundle打包&emsp;&emsp;好了，下面我们以《新仙剑OL》这款游戏的AssetBundle的反编译来探索下在使用AssetBundle打包应该注意哪些问题。《新仙剑OL》这款游戏呢，是采用Unity3D引擎开发的一款横跨客户端游戏和网页游戏的网络游戏，游戏以《仙剑奇侠传》初代游戏剧情为主，玩家将第三人称视角再次跟随主人公展开一段荡气回肠的感人故事。这款游戏总体来说还不错吧，因为毕竟是网游，我们不能用单机游戏的视角去评价，具体的原因大家都是知道的。 &emsp;&emsp;好了，为什么我们要选择这款游戏呢？ 第一，这款游戏的客户端只有30余M,体积小适合拿来研究(这就是AssetBundle的好处啊)* 第二，博主是一位仙剑玩家，一直希望有一天《仙剑奇侠传1》能够用3D技术重现，这个游戏满足了博主的好奇心 第三，网络上已经有朋友对这个游戏的打包进行了研究，这里感谢网友朋友提供部分.unity3d文件及相关文件。 &emsp;&emsp;我们选择的解包工具是一款叫做disunity的命令行工具，经过博主的尝试，这个工具真心强悍啊，可以解开.unity3d文件和.assets文件，可以拿到的数据形式有贴图、声音、模型等。具体的情况大家可以在稍后看到。 &emsp;&emsp;首先我们找到《新仙剑OL》的安装目录，然后我们就能发现一个叫做assetbundles的文件夹，这是怕大家不知道吗？这太明显了吧！我们打开文件夹会发现Charachers、NPC、Scene等等文件夹，继续往下找我们发现了好多的.unity3d文件，不过这些文件都是以.unity3d然后跟些随机字符串的形式存在的。根据网友朋友们的提示，这些文件就是.unity3d文件，不过游戏制作组为了干扰我们故意接了下随机字符在后面(呵呵，还有比这更弱的加密方式吗？)。博主看到这里的第一感觉就是想先用加载AssetBundle的方式来看看能不能将这些AssetBundle读取出来，因此果断改了文件扩展名，然后开始在Unity3D中读取，结果程序报错看来是我们想的简单了啊。没办法的办法，强行解包吧！在命令行中输入：1disunity extract C:\\Users\\Robin\\Desktop\\s049.unity3d &emsp;&emsp;接下来程序会在桌面上生成一个上s049的文件夹，打开文件夹一看，尼玛，竟然直接拿到了模型的网格数据(.obj)和贴图数据(.dds)以及相关的Shader。这让我突然间有点不能接受啊，马上打开Blender将网格数据导入，结果童年的林月如就出现在了我们的面前： 林月如灰模 &emsp;&emsp;因为博主不会在Blender中给模型贴图，所以我们到Unity3D中完成贴图，首先需要将模型导出为FBX格式。好了，将模型导入Unity3D后，将贴图赋给模型，童年的林月如就闪亮登场了，哈哈！ 林月如贴图效果 &emsp;&emsp;好了，再来一张，不过这张没有贴图，需要大家自己来辨别这是谁啊，哈哈！ 柳梦璃灰模 &emsp;&emsp;通过disunity这个工具我们还能获取更多的资源，剩下的内容就由大家自己去探索吧。通过这部分的研究，我们可以总结出以下观点，希望大家在使用AsssetBundle这项技术时注意： 尽量在一个AssetBundle中打包多个资源，这样做的好处是别人没法通过加载AssetBundle拿到你做好的Prefab。 尽量将一个预制件分割成不同的部分分别存放，这样做的好处是即使别人拿到了你的预制件却是不完整的。 尽量利用动态脚本来加载场景而不是将整个场景打包，即使将整个场景打包，要把贴图和模型分开放置(因此如此，我虽然拿到了游戏的场景贴图，可是没有用啊) 尽量利用加密的方法来隐藏本地的AssetBundle或者使用不易察觉的存储位置作为AssetBundle的存储位置，不要用明文数据进行存储。 &emsp;&emsp;好了，今天的内容就是这样了，希望大家喜欢，AssetBundle打包是一个值得去深入研究的问题，今天博主提出的这些观点不过是对《新仙剑OL》这个游戏的打包提出de一些看法，如果大家有不同的看法，欢迎一起来交流！","tags":[{"name":"Unity3D","slug":"Unity3D","permalink":"http://qinyuanpei.github.io/tags/Unity3D/"},{"name":"游戏开发","slug":"游戏开发","permalink":"http://qinyuanpei.github.io/tags/游戏开发/"},{"name":"AssetBundle","slug":"AssetBundle","permalink":"http://qinyuanpei.github.io/tags/AssetBundle/"},{"name":"资源提取","slug":"资源提取","permalink":"http://qinyuanpei.github.io/tags/资源提取/"}]},{"title":"Unity3D游戏开发之编辑器扩展程序开发实例","date":"2015-03-31T00:53:22.000Z","path":"posts/70687890/","text":"&emsp;&emsp;各位朋友大家好，欢迎关注我的博客，我的博客地址是http://www.qinyuanpei.com。今天我们来说说如何在Unity3D中为编辑器开发扩展程序。提到扩展程序，相信大家都不会陌生了。不管是Google的Chrome浏览器还是经典的FireFox，这些浏览器最为人所称道的就是它支持各种各样的扩展。扩展程序是一种插件，它遵循插件式设计的原则，可以随时在宿主程序中安装、卸载而不会影响宿主程序的正常运行。我们知道在Unity3D中有各种各样的插件，如NGUI、2DToolKit、EasyTouch等等都是一种扩展程序。扩展程序在丰富宿主程序功能的基础上，可以帮助宿主程序完成大量额外的工作。可以说正是因为Unity3D拥有大量的插件和资源支持，Unity3D才能够受到大家如此的追捧。可是作为一个有节操的程序员，如果仅仅会使用工具，那么我们和普通用户有什么区别啊，所以在今天的文章中博主将通过三个具体的实例来教大家如何为Unity3D的编辑器开发扩展程序，希望对大家学习Unity3D技术有所帮助！ 常用的命名空间和类&emsp;&emsp;开发Unity3D编辑器扩展程序的命名空间主要是UnityEditor，在该命名空间下常用的类有EditorGUI、EditorGUILayout、EditorWindow(可能还有其它的类，不过到目前为止博主就用过这些，如果有其它的类，欢迎大家来补充啊)。为Unity3D编辑器开发的扩展程序同样是一种脚本，通常需要将脚本文件放在项目资源文夹下的Editor文件夹中，即Assets/Editor。不过该脚本不再继承自MonoBehaviour，具体的内容我们会放到后面的实例中来讲Unity3D编辑器扩展程序的形式通常有两种，一种是没有界面的(如案例1)、一种是有界面的(如案例2、案例3)。对于没有界面的这种扩展程序，我们只需要定义一个类(无需继承任何父类)然后再这个类中定义一个静态的方法就可以了;而对于有界面的这种扩展程序，我们需要让定义的这个类继承EditorWindow并实现OnGUI()方法,因为在OnGUI()方法中我们将会对扩展程序的界面进行绘制，不过无需担心啦，因此扩展程序的界面绘制和Unity3D脚本中的OnGUI()方法是相似的，我们要做的就是要熟悉常见的控件。好了，下面进入今天的实战环节，大家准备好了吗？ Unity3D编辑器扩展程序开发实例案例1 快速修改贴图类型&emsp;&emsp;Unity3D4.6版本的一个重要更新就是UGUI和Unity2D的支持，因为有了对Unity2D的支持，所以Unity3D的贴图类型就增加了一个Sprite的类型。如果导入到Unity3D中的贴图是那种打好的小图的图集，那么Unity3D能够自动识别为Sprite类型。可是对于那种单张的贴图，Unity3D默认还是按照默认的设置来处理，因此如果每次需要用到这些图片，就必须手动地将其TextureType设为sprite，如果贴图数量比较少，那么手动修改也没有什么了。可是如果项目中的贴图数量较多的话，这样一张一张地去调整TextureType可能会浪费大量的时间啊！怎么办呢？简单！写代码！12345678910111213141516171819202122232425262728293031323334using UnityEngine;using UnityEditor;using System.Collections;public class ImportSprite&#123; /// &lt;summary&gt; /// 批量将贴图格式转换为Sprite /// &lt;/summary&gt; [MenuItem(&quot;Tools/ConvertToSprite&quot;)] static void ConvertToSprite() &#123; //获取所有被选中的物体 Object[] selection=(Object[])Selection.objects; //合法性处理 if(selection.Length==0) return; //批量导入贴图 foreach(Object obj in selection) &#123; //取得每一张贴图 Texture texture=(Texture)obj; //获得贴图路径 string localpath=AssetDatabase.GetAssetPath(texture); //贴图导入 TextureImporter importer=(TextureImporter)AssetImporter.GetAtPath(localpath); //设置贴图类型 importer.textureType=TextureImporterType.Sprite; //导入项目资源 AssetDatabase.ImportAsset(localpath); &#125; //刷新项目资源 AssetDatabase.Refresh(); &#125;&#125; &emsp;&emsp;我们将这个脚本放到Editor文件夹中，如果不出现什么意外的话，Unity3D的菜单栏中会增加一个Tools的菜单项，该菜单项目前只有一个子菜单项ConvertToSprite。好了，现在我们要做的事情就是在项目资源文件夹中选中要转换成sprite类型的贴图，然后单击Tools-&gt;ConvertToSprite。很快(具体有多快可以自己在编辑器窗口中去尝试，总之就是很快就对了，哈哈)所有的贴图的都如我们所愿地被转换成了sprite类型，此时此刻你有没有懊悔当年手动创建的92个空物体，反正博主是后悔当初做塔防游戏的时候手动创建了92个空物体，如果那个时候我知道Unity3D可以做这些事情，我打死都不会手动去创建92个空物体的，现在想想都佩服当时自己的勇气啊。好了，作为第一个编辑器扩展程序，我们稍微总结下主要的内容： 在Unity3D中我们可以通过TextureImporter、ModelImporter、AudioImporter、MovieImporter等来分别向Unity3D中导入贴图、模型、音频、视频等等，经过设置后最终通过AssetDatabase.ImportAsset()来将其添加到项目中热完全，最后需要使用AssetDatabase.Refresh()方法来刷新本地资源，使导入的资源生效。 Selection.objects取得的物体无法区分是从场景中选取的还是从项目资源文件夹中选取的，如果需要从场景中来选取，建议使用Selection.transforms来代替。案例2 动态生成Prefab&emsp;&emsp;首先让我们来回顾一下大家平时制作Prefab的流程： 在项目资源文件夹中选取素材拖放到场景中 在场景中调整名称、位置、缩放、组件等等 将物体拖放到Prefabs文件夹下生成Prefab尽管这是Unity3D官方推荐的一种做法，可是如果我们现在有大量的Prefab要制作怎么办呢？一个最直观的例子就是游戏里的敌人。在一个中等规模的游戏中，敌人的种类通常很多，而且每一个敌人的行为可能都不相同。然后从宏观的角度来看，敌人的大部分特征都是相同的，因此我们这里考虑使用程序动态生成Prefab，这里假定Prefab不需要附加脚本，因为如何给Prefab附加脚本博主还没有研究出来。好了，下面我们来看代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778using UnityEngine;using UnityEditor;using System.Collections;public class PrefabWrap : EditorWindow &#123; //预设物体名称 private string prefabName; //预设物体tag private static string prefabTag; //预设物体Layer private static int prefabLayer; //当前插件窗口实例 private static PrefabWrap instance; /// &lt;summary&gt; /// 显示插件窗口 /// &lt;/summary&gt; [MenuItem(&quot;Tools/PrefabWrapTool&quot;)] static void PrefabWrapTool() &#123; //获取当前窗口实例 instance=EditorWindow.GetWindow&lt;PrefabWrap&gt;(); //显示窗口 instance.Show(); &#125; /// &lt;summary&gt; /// 在OnGUI方法中实现界面定制 /// &lt;/summary&gt; private void OnGUI() &#123; //绘制一个文本框 prefabName=EditorGUILayout.TextField(&quot;预设物体名称:&quot;,prefabName); //绘制预设物体标签选择框 prefabTag=EditorGUILayout.TagField(&quot;预设物体tag:&quot;,prefabTag); //绘制预设物体层级选择框 prefabLayer=EditorGUILayout.LayerField(&quot;预设物体Layer:&quot;,prefabLayer); //绘制一个按钮 if(GUILayout.Button(&quot;生成预设物体&quot;,GUILayout.Height(20))) &#123; if(prefabName!=string.Empty) &#123; CreatePrefab(prefabName); &#125; &#125; &#125; /// &lt;summary&gt; /// 批量创建Prefab /// &lt;/summary&gt; static void CreatePrefab(string name) &#123; //获取所有被选中的物体 Object[] selection=(Object[])Selection.objects; //合法性处理 if(selection.Length==0) return; //批量处理 foreach(Object obj in selection) &#123; //生成预设 GameObject prefab=(GameObject)PrefabUtility.CreatePrefab(&quot;Assets/Prefabs/&quot;+name+&quot;.prefab&quot;,(GameObject)obj); //设置tag和Layer prefab.tag=prefabTag; prefab.layer=prefabLayer; //导入项目 AssetDatabase.ImportAsset(AssetDatabase.GetAssetPath(prefab)); &#125; //刷新本地资源 AssetDatabase.Refresh(); &#125; //当界面发生变化时重绘 void OnInspectorUpdate() &#123; Repaint(); &#125;&#125; &emsp;&emsp;首先我们让这个脚本继承自EditorWindow，这样它将在Unity3D中显示一个窗口。在OnGUI()方法中我们定义了窗口需要绘制的内容为一个文本框、两个选择框和一个按钮，当单击按钮后会执行CreatePrefab()方法。当界面发生变化的时候，需要对窗口进行重绘。最终的程序演示效果如下： 动态生成Prefab效果演示 &emsp;&emsp;当我们在场景中选择好物体后，只要填好预设物体的名称、tag、Layer就可以直接生成Prefab了，不过这里有个问题，因为生成Prefab必须要传入一个GameObject，因此如果直接选择项目资源文件夹里的内容可能会报错，因为你选择的不是一个GameObject。博主做这样一个功能的初衷原本是想直接为每一个精灵图片生成预设文件，现在看来需要寻找其它的方法了，不过基本思路是创建一个空物体，然后向这个空物体中增加子物体，如果大家对此有兴趣的话，可以结合本文的方法自行去尝试。 案例3 快速为Sprite设置图集tag&emsp;&emsp;接下来这个案例呢，同样是和贴图有关的内容。我们知道在没有UGUI以前，我们使用NGUI的时候要做的第一件事情就是把要用到的贴图打成图集，现在在Unity3D里面我们可以通过贴图的Packing Tag来实现图集打包，就是说具有相同Packing Tag的物体会被打到一张大图上，这样做的好处是节省资源。如果大家对这部分内容不太熟悉，可以了解下我的这篇文章。既然明白了原理，那么我们为什么不来尝试着通过程序将这件事情一次完成呢？好了，直接给出代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081using UnityEngine;using UnityEditor;using System.Collections;public class PackageTools : EditorWindow &#123; /// &lt;summary&gt; /// 图集标签 /// &lt;/summary&gt; private string tagName; /// &lt;summary&gt; /// 当前实例 /// &lt;/summary&gt; private static PackageTools instance; /// &lt;summary&gt; /// 在OnGUI方法中实现界面定制 /// &lt;/summary&gt; private void OnGUI() &#123; //绘制一个文本框 tagName=EditorGUILayout.TextField(&quot;PackageTagName:&quot;,tagName); //绘制一个按钮 if(GUILayout.Button(&quot;Package&quot;,GUILayout.Height(20))) &#123; if(tagName!=string.Empty) &#123; PackgeTextureWidthTag(tagName); &#125; &#125; &#125; /// &lt;summary&gt; /// 显示插件窗口 /// &lt;/summary&gt; [MenuItem(&quot;Tools/ShowPackageTools&quot;)] static void ShowPackageTools() &#123; //获取当前窗口实例 instance=EditorWindow.GetWindow&lt;PackageTools&gt;(); //显示窗口 instance.Show(); &#125; /// &lt;summary&gt; /// 快速为图片生成图集 /// &lt;/summary&gt; static void PackgeTextureWidthTag(string tagName) &#123; //获取所有被选中的物体 Object[] selection=(Object[])Selection.objects; //合法性处理 if(selection.Length==0) return; //批量处理贴图 foreach(Object obj in selection) &#123; //取得每一张贴图 Texture texture=(Texture)obj; //获得贴图路径 string localpath=AssetDatabase.GetAssetPath(texture); //贴图导入 TextureImporter importer=(TextureImporter)AssetImporter.GetAtPath(localpath); //判断贴图类型,只有贴图类型为Sprite且精灵类型为SpriteMode if(importer.textureType==TextureImporterType.Sprite) &#123; importer.spritePackingTag=tagName; //导入项目资源 AssetDatabase.ImportAsset(localpath); &#125; &#125; //刷新本地资源 AssetDatabase.Refresh(); &#125; //当界面发生变化时重绘 void OnInspectorUpdate() &#123; Repaint(); &#125;&#125; &emsp;&emsp;因为打包图集只需要一个参数，因此这个打包工具只需要一个文本框和一个按钮，整个过程和案例2是一样的，这里就不做分析了。这个扩展程序的演示效果如下： 图集打包效果演示 &emsp;&emsp;好了，这就是今天的内容了，今天的内容基本上涵盖了为Unity3D开发扩展程序的基本内容，我们接下来要做的就是积极地在平时生活、工作和学习中寻找问题和解决问题，”授人以鱼不如授人以渔”，向他人传授知识和技能，这件事情本身对博主而言就是是快乐的，博主希望今天的内容大家能够喜欢。好了，谢谢大家！","tags":[{"name":"Unity3D","slug":"Unity3D","permalink":"http://qinyuanpei.github.io/tags/Unity3D/"},{"name":"编辑器","slug":"编辑器","permalink":"http://qinyuanpei.github.io/tags/编辑器/"},{"name":"扩展","slug":"扩展","permalink":"http://qinyuanpei.github.io/tags/扩展/"}]},{"title":"从\"复活\"和\"暂停/恢复\"谈游戏数据配置管理","date":"2015-03-27T02:12:58.000Z","path":"posts/3356910090/","text":"&emsp;&emsp;随着游戏制作技术的不断发展，在经历了从2D到3D、从单机到网游、从PC游戏到移动游戏的种种演变后，玩家对于游戏质量的要求越来越高，游戏制作的难度相应地增加，整个游戏研发的体系开始变得庞大而复杂，由此就产生了游戏数据配置和管理的相关问题。本文将从游戏中的”复活”和”暂停/恢复”这两个应用场景的角度来谈谈在游戏开发中如何对游戏中的数据进行管理和配置。 为什么要谈游戏数据的配置和管理&emsp;&emsp;不知道大家是不是会和博主有一样的想法，就是当你回头来思考游戏开发的时候，你常常会发现，如果忽略游戏的画面、情节、特效等等这些游戏中的可视化的东西，那么其实游戏从本质上来说就是一个大型的有限状态机(FSM)，而我们通常所做的事情基本就是在维护这个有限状态机里面的各种状态，从游戏加载到游戏开始、从游戏开始到游戏中各种事件的发生再到各种事件影响到整个有限状态机的状态，我们通常所做的事情无外乎是在维护各种状态。这种感觉在RPG游戏中可能会更明显些，因为在RPG中玩家可能是在场景中行走或者奔跑、可能是在和场景中的某个NPC进行对话、可能是在和面前的敌人进行战斗、可能是在和杂货店的老板讨价还价……可以说在整个游戏当中无时无刻不在进行游戏状态的切换，那么在不同的状态间切换的时候，什么最为重要呢？答案是数据。什么是数据呢？玩家的生命值、魔法值、战斗力、防御力，物品的用途、价格、数量，游戏的剧情、对话、音乐等等这些都是数据。当我们在状态间进行切换的时候，其实真正改变的就是这些数据。由此可见，面对复杂而庞大的游戏体系，如何对游戏中的数据进行配置和管理是一件值得我们去思考的问题。 从应用场景来看游戏数据的配置与管理&emsp;&emsp;首先我们来从游戏当中的两个常见的应用场景:”复活”和”暂停/恢复”来看看游戏数据配置和管理的重要性。这里以博主的一款跑酷游戏为例： 游戏截图 应用场景——“复活”&emsp;&emsp;”复活”是一个在游戏中特别常见的功能，复活这一设定的好处在于无需重新开始游戏就能再次回到游戏当中，当然这只是我们最为直观的一个感受，更为深刻的原因是，游戏者巧妙地利用了玩家在游戏任务失败那一刻的心理。现在生活中每一个人都喜欢胜利，这种心理到了游戏世界中同样是适用的，因为游戏的目的无非就是让玩家有种成就感以获得快乐。可是当游戏任务失败的时候，玩家会竭尽全力不断尝试去打败Boss以获得游戏的胜利，因此在游戏中有这样一个设定，可以引导玩家在游戏中形成消费的习惯，这样游戏就能从玩家身上盈利。好了，我们来看看一个基本的”复活”的逻辑吧！12345678910111213141516171819private void Update()&#123; //如果玩家的生命值大于0则游戏正常进行 if(Player.Hp&gt;0) &#123; //游戏状态为Normal GameManager.Instance.GameState=GameStateEnum.Normal; //执行正常的游戏逻辑 DoNormalEvent(); &#125;else &#123; //游戏状态为Over GameManager.Instance.GameState=GameStateEnum.Over; //显示GameOver ShowGameOver(); //玩家复活 ReLive() &#125;&#125; &emsp;&emsp;玩家复活需要做两件事情： 将游戏的状态从Over调整到Normal 将玩家的状态从死亡调整到正常 &emsp;&emsp;调整游戏的状态特别容易，因为GameManager是一个典型的单例模式，因此我们可以直接将GameState从Over变成Noral。可是对于玩家状态的调整，我们却遇到了困难。问题出在什么地方呢？问题出在我们将玩家的生命值等一系列属性都写在了PlayerController这个类中，如果我们将玩家的属性全部都设为Private，那么我们将无法从外部来调整这些属性。比如我们想让玩家满血复活，可是因为这些属性都是私有的，我们无法从外部访问，所以我们在给玩家恢复生命值的时候，无法获得玩家当前的生命值以及最大生命值。可是如果我们将玩家的属性全部都设为Public，我们可能不得不去面对在编辑器窗口中为每一个属性去赋值，因为一旦我们试图调整游戏双方力量的平衡时，这将是我们不得不去面对的问题，更为致命的玩家的属性并不是永远不变的，比如在RPG游戏中玩家的生命值等属性会随着角色等级的提升而不断增加。因此不管我们将这些属性设为Public还是Private，我们都无法保证每次访问到的这些数据都是最新的数据。换句话说，我们不能想当然地在脚本中将玩家的属性写成一个不变的值，因为这些数据随时都在发生着变化，当然如果像敌人和Boss这种数值相对稳定的情况，我们可以直接在脚本中将其写成一个固定值，不过我并不推荐大家这样做。由此可见，游戏中数据配置和管理的一个重要作用是维持各个状态间的正常切换。如图是雨血前传.蜃楼中的复活界面，每次复活需要消耗一个复活玉： 2015-03-27 &emsp;&emsp;那么博主在这款跑酷游戏里面是怎样做这个复活的呢？因为博主当时在设计这个游戏的时候考虑不周，直接将玩家的生命值写成了100，所以在复活玩家时候，同样是先将游戏的状态调整过来，然后再将相关的GUI窗口隐藏，然后将玩家的生命值重新设置为100，重新生成玩家就好了。正是因为感觉这段时间做游戏缺乏一种良好的游戏架构，所以每次游戏做到最后都是自己把逼到了绝路上，留给了自己一个自己都不想再去维护的烂摊子，这样显然是不好的，所以以后需要在正式动手写代码前做好规划，相信这样就能够保证游戏的质量了吧！任何东西学习到一定阶段都会遭遇瓶颈，尽管打破这种瓶颈的过程是痛苦的，可是如果不去打破它，那么你永远都只能停留在这个位置。 应用场景——“暂停/恢复”&emsp;&emsp;和”复活”一样，”暂停/恢复”同样是一个在游戏中常见的功能，该功能是给了玩家暂时离开游戏的一种选择，可以保证玩家在做其它事情的时候不会影响到游戏的进程。比如在仙剑奇侠传、古剑奇谭等游戏中，玩家可以按下ESC键调出游戏设置界面，在玩家进入游戏设置界面的这段时间，游戏世界里的时间似乎是静止的，场景中的敌人不会因为玩家在查看系统设置界面就去主动偷袭玩家，因为这种情况下游戏是暂停的。而当玩家退出系统设置界面后，游戏恢复为正常状态。到了移动互联网时代，游戏中出现”暂停/恢复”的情况更为普遍，这是由移动互联网时代人们玩游戏更注重休闲和娱乐这样的性质来决定的。记得天天酷跑刚刚在微信上线的那段时间，我身边好多同学都在上课的时候玩，可是因为这游戏一跑起来就根本停不下来，所以经常是一次游戏玩下来一节课就结束了。博主不提倡这样啊，玩游戏归玩游戏，可是什么事情都要有个度啊，不然就会变成玩物丧志。好了，我们分析这个案例的目的无非就是想告诉大家在游戏里增加这样一个”暂停/恢复”的功能还是十分必要的。好了，现在我们来分析下在这个应用场景中发生状态转换的时候都会牵扯到那些数据吧！ &emsp;&emsp;首先游戏暂停后，场景内所有的物体都会停止运动，此时游戏中每个物体的状态都发生了变化，不过因为在Unity3D中控制游戏暂停/的恢复主要是通过调整Time.timeScale的值来实现的。当Time.timeScale取值为0时，游戏暂停；当Time.timeScale取值为1时，游戏恢复正常。不过需要注意的是Time.timeScale会对Unity3D中所有的时间产生影响如FixedUpdate()、协程、Destroy()、动画组件等等，所以如果对暂停后的游戏状态有特殊要求的话，建议还是通过其它的方法来实现吧！这里没有提到Update()和LaterUpdate()这是因为这两个方法不会受到影响。我们来看这样一段代码：1234567891011121314//游戏是否暂停private bool isPause=false;//暂停/恢复游戏的方法private void Resume()&#123; if(!isPause)&#123; Time.timeScale=0; isPause=true; &#125;else&#123; Time.timeScale=1; isPause=false; &#125;&#125; &emsp;&emsp;通过这段代码我们就能够实现一个基本的游戏”暂停/恢复”的功能。在游戏管理类GameManager中我们定义了一个玩家的得分。正常情况下，当玩家没有死亡的时候会在GUI中更新玩家的得分，而玩家的得分是直接采用在Update()中累加的方式实现的，因此玩家的得分会在游戏暂停后继续更新，这当然是不符合实际情况的，因此可以在这个增量前乘上一个Time.deltaTime就可以解决这个问题了。博主举这个例子无非就是想告诉大家使用这种方法来暂停游戏会存在这样的问题，希望大家以后注意啊！ 跑酷游戏复活界面 游戏数据配置和管理的思路和方法&emsp;&emsp;既然我们在今天的的文章中主要阐述的就是游戏数据配置和管理，那么下面我们就来说说游戏数据配置和管理的常见的思路和方法。根据游戏中数据变动的相对大小，我们将游戏中的数据分为静态数据和动态数据两类。 静态数据&emsp;&emsp;静态数据是指在游戏中基本不变或者不需要变动的数据。比如游戏中Boss的等级和生命值一般都是确定的，因此这种类型的数据可以称为静态数据。同样地，游戏中NPC对话的内容是一种静态数据，因为NPC的对话内容是在设计剧情的时候就设计好的无需再对它进行修改。那么对于静态数据，我们可以考虑下列方法： 将静态数据作为常量定义在一个类中，这样做的好处是无需对每一个脚本进行修改。 将静态数据存储在文件当中，这样做的好处是可以对数据进行管理，缺点是需要针对不同的文件编写解析接口，游戏开发中常用的数据存储形式有：Json、Xml、Excel、CSV等。 将静态数据存储在数据库当中，如SQLIite等，可是这样做的缺点同样很明显，从本地读取数据库会消耗大量的资源，而且数据库文件一旦丢失，整个游戏都将无法运行。 动态数据&emsp;&emsp;动态数据是指在游戏中会不断变化的数据，比如玩家的得分、玩家的生命值、玩家的经验值等等。动态数据的处理方式除作为常量写在类中以外，其它的都和静态数据是一样的，在此就不再多说了。 #总结&emsp;&emsp;可能今天这篇文章显得唠叨些，甚至从技术的角度来看，这篇文章都没有讲到什么有价值的技术要点。可是在博主看来，不管一项技术有多么伟大，如果没有良好的架构或者说结构，那么当这个项目的规模到了一定程度以后，这个项目就会出现问题。因为根据破窗户理论，当你看到窗户破了而不去及时修补的话，那么时间一长你破掉的就是整个房子了。回顾博主这么长时间的游戏开发，其实做过的好多游戏到最后之所以没有做完，都是因为到最后项目基本失控、变成了一个连自己都不愿意去维护的项目，这样的情况是可怕的。平时是你一个人做项目，可能你觉得这些都没有什么，可是当你和别人一起去完成这样一个项目的时候，你的这些问题都会成为整个团队的问题。博主一直想知道自己做游戏和团队在一起做游戏会有什么不同，因为博主感觉自己在这一块确实不是掌握得很好。虽然说架构这种事情你做多了才会有经验，可是你现在发现了问题，为什么不在现在改掉呢？架构真的很重要，致那些因为架构死去的项目，真正的项目应该死在实践中，因为架构的问题最终变得不可收拾的，这件事情本身就是可耻的。好了，今天就说这么多了。","tags":[{"name":"游戏","slug":"游戏","permalink":"http://qinyuanpei.github.io/tags/游戏/"},{"name":"数据","slug":"数据","permalink":"http://qinyuanpei.github.io/tags/数据/"},{"name":"状态","slug":"状态","permalink":"http://qinyuanpei.github.io/tags/状态/"}]},{"title":"为Hexo开发一个网易云音乐的文章插件","date":"2015-03-24T10:32:39.000Z","path":"posts/828223375/","text":"&emsp;&emsp;当你打开这篇文章的时候，你听到一首熟悉的旋律，那是因为在你的心里始终装着一张泛黄的CD，你从来不愿意打开它，即使外表早已积满了灰尘，你依然视它如新的一般，我们喜欢把它叫做时光或者说是青春。 &emsp;&emsp;正如你所看到的，我在博客文章中插入了网易云音乐的播放器。这是一个基于Flash技术实现的组件。因为博主特别喜欢网易云音乐这个音乐产品，所以博主想将这个播放器带入到我的博客。在博客中使用这个播放器，只要在文章中添加如下代码：12&lt;embed src=\"http://music.163.com/style/swf/widget.swf?sid=29713754&amp;type=2&amp;auto=1&amp;width=278&amp;height=32\" width=\"298\" height=\"52\" allowNetworking=\"all\"&gt;&lt;/embed&gt; &emsp;&emsp;可是这样的结构对于一个写博客的人来说还是显得臃肿了，能不能让这个结构更简单写呢？简单到这样：1[music:29713754] &emsp;&emsp;因为在这段代码中真正和音乐有关的只有sid这个参数，所以我们我们只需要关注这个参数就好了。那么，现在我们其实就是在做这样一件事情，我们在文章中插入这样一个[key:value]的结构，然后通过程序将它替换成相应的HTML结构，这样就实现了在Hexo的文章中使用[key:value]结构来编写简单插件的功能，如果经历过使用wordpress建站的朋友一定知道，在wordpress中存在许多这样的类似插件，可以帮助写作者简化某些输入内容。好了，那么今天我们就来试着为hexo编写这样一个小插件吧！为了避免将插件写到网页里的时候出现错误，我们首先在NodeJS中测试，测试程序如下：12345678910111213141516171819202122232425//定义测试内容var str=\"这是一条测试内容以测试这个程序是否能够正确运行,现在让我们来听一首《匆匆那年》[music:29713754]\";//获得匹配内容var dicts=str.match(/\\[(.*?):(.*?)\\]/g);if(dicts.length==0) return;//对每一个匹配项进行处理for(var i=0;i&lt;dicts.length;i++)&#123; //对匹配项进行分割,拆分结果为'[music'和'29713754]' //我TM就郁闷了，在这里写成'/:/'报错 //可是写成/:/就顺利通过 var dict=dicts[i].split(/:/); //获得键名 var key=dict[0].substring(1,dict[0].length); //获得ID var id=dict[1].substring(0,dict[1].indexOf(']')); //判断键名的类型 if(key=='music') &#123; str=str.replace(dicts[i],'&lt;embed src=\"http://music.163.com/style/swf/widget.swf?sid='+ id + '&amp;type=2&amp;auto=1&amp;width=278&amp;height=32\" width=\"298\" height=\"52\" allowNetworking=\"all\"&gt;&lt;/embed&gt;'); &#125; &#125; //输出结果 console.log(str); &emsp;&emsp;这段代码主要就是通过正则表达式来匹配文章正文中所有的[key:value]结构，然后根据key来确定当前结构表什么类型，根据id来确定当前类型的参数，尽管这里只提到了一个music的类型，不过我相信只要大家开动脑筋、发挥想像相信会有更好的想法产生吧！这段代码博主在本地使用NodeJS测试了没有不过什么问题，大家可以在截图中清楚地看到[music:29713754]已经被替换称了网易云音乐的Flash组件，这样在网页中就会显示出网易云音乐的播放器，我们就能听到这熟悉而温暖的旋律了。 NodeJS程序演示效果 &emsp;&emsp;不过真的想要吐槽下JavaScript。本来JavaScript就是弱类型了吧，NodeJS再给弄一个除了报错什么都不会的命令行，因此在本地调试JavaScript代码实在是太困难了。昨天为了写出一个正确的正则表达式奋战到三点钟，后来终于给写出来了，实在压抑不住内心的喜悦匆匆忙忙地就往模板里面放，结果刚放进去再重新生成页面地时候博客就华丽地挂了，尝试了若干次无果后，果断放弃然后用备份地主题文件进行了覆盖替换。总之，经过这次事情，我是再不想接触Javacript了，你不让我面向对象我可以容忍，因为JavaScript本来就不是一门面向对象的语言。可是你总得让我知道我写的这个变量是个什么类型吧？因为这个插件的编写涉及到JavaScript、NodeJS、Hexo所以整个过程中编程的效率特别低，因为在没有文档、没有语法提示的情况下来写这样一段代码，在我看来完全就是摸着石头过河啊！ &emsp;&emsp;好了，停止吐槽！我们接下来看看这段代码怎样和Hexo整个到一起。按照博主的理解既然我们要对文章的内容中的[key:value]结构进行替换，我们首先应该知道文章的内容在哪里。经过这么长时间对Hexo的学(zhe)习(teng),我们知道文章的内容是定义在layout_partial下的article.ejs这个文件中，在这个文件中有一个叫做item的变量,这个item的真实身份其实是Hexo中定义的一个全局变量post。顾名思义，这个post就是我们发表的文章啦，它有一个重要的属性叫做content，就是我们这里要用到的东西了。我们来article.ejs这个文件中定义的一段代码：1234567891011121314&lt;div class=\"entry\"&gt; &lt;% if (item.excerpt &amp;&amp; index)&#123; %&gt; &lt;%- item.excerpt %&gt; &lt;% &#125; else &#123; %&gt; &lt;% if (!index)&#123; %&gt; &lt;% if (!index &amp;&amp; item.toc)&#123; %&gt; &lt;%- partial('extra/toc') %&gt; &lt;% &#125; %&gt; &lt;%- item.content %&gt; &lt;% &#125; else &#123; %&gt; &lt;%- item.content.substring(0,item.content.indexOf('\\n')) %&gt; &lt;% &#125; %&gt; &lt;% &#125; %&gt;&lt;/div&gt; &emsp;&emsp;这段代码是关于文章的内容的，因此我们要对文章内容进行修改的话，就要先读懂这块儿的代码。这块儿代码首先判断文章是不是处于首页位置(index)，接着判断文章中有没有ReadMore标记(excerpt)。如果文章在首页位置(index)且存在ReadMore标记(excerpt)，那么文章显示的是ReadMore标记前的内容(item.excerpt);如果文章没有ReadMore标记(excerpt)且文章在首页位置(index)，那么文章显示的整篇文章(item.content);如果文章在首页(index)可是没有ReadMore标记(excerpt)，那么选取文章的第一段作为文章的摘要来显示。这就是博主的博客目前采用的方案了，如果大家对这部分感兴趣的话，可以看看自己的博客使用的主题是如何定义这部分内容的，然后在此基础上做些调整以满足个性化的需求。 &emsp;&emsp;好了，那么在了解了这部分内容后，我们应该马上就能想到，我们需要掉正的代码应该是在第9行这个位置，即当文章不在首页的时候要显示的内容。好了，按照我们在测试程序中的写法，我们可以写出如下代码：1234567891011121314151617&lt;% var dicts=item.content.match(/\\[(.*?):(.*?)\\]/g); %&gt;&lt;% if(dicts.length==0)&#123; %&gt; &lt;%- item.content %&gt;&lt;% &#125; else &#123; %&gt; &lt;% for(i=0;i&lt;dicts.length;i++) %&gt; &lt;% &#123; %&gt; &lt;% var dict=dicts[i].split(/:/); %&gt; &lt;% var key=dict[0].substring(1,dict[0].length); %&gt; &lt;% var id=dict[1].substring(0,dict[1].length-1); %&gt; &lt;% if(key==&apos;music&apos;) %&gt; &lt;% &#123; %&gt; item.content=item.content.replace(dicts[i],&apos;&lt;embed src=&quot;http://music.163.com/style/swf/widget.swf?sid=&apos;+ id + &apos;&amp;type=2&amp;auto=1&amp;width=278&amp;height=32&quot; width=&quot;298&quot; height=&quot;52&quot; allowNetworking=&quot;all&quot;&gt;&lt;/embed&gt;&apos;) &lt;% &#125; %&gt; &lt;% &#125; %&gt; &lt;%- item.content %&gt;&lt;% &#125; %&gt; &emsp;&emsp;相信经过博主的一番介绍，大家已经对这段代码相当熟悉了吧，这里就是先做判断，判断文章内容中是否有[key:vaule]这样的结构，如果没有就直接输出item.content;如果有就需要对其进行替换后再输出item.content。好了，现在我们用这段代码替换掉第9行代码，然后再次输出网页。可是结果让我们白忙活了一场，因为Hexo在输出网页的时候会报错，可能是因为博主写的JavaScript脚本Hexo无法解析吧！好了，从昨天下午开始差不多都在想着怎样解决这个问题，到现在还是没有一点头绪，文章里讲述的方法可以作为一种尝试，如果有兴趣、有精力、有能力解决这个问题的人，可以去进一步深入地探索这个问题。今天的内容就是这样了，睡觉！ 2015年11月10日更新:&emsp;&emsp;昨天抽空研究了下Hexo的插件机制，发现在Hexo中提供了一种标签插件，可以帮助我们快速完成这种需求，所以就记录在这里。首先，它的原理是根据这样一个简单的标记来进行处理，当我们输入默认的这样的标记的时候它会被渲染为普通的引用标记，当我们在这个标记内传入参数后就可以利用程序进行处理。例如我们编写这样的简单的JS文件：1234567891011121314151617181920212223242526272829303132/*** hexo-tag-cloudmusic* https://github.com/qinyuanpei/hexo-tag-cloudmusic.git* Copyright (c) 2015, qinyuanpei* Licensed under the MIT license.*/hexo.extend.tag.register('cloudmusic', function(args)&#123; var sid = args[0]; var config = hexo.config.cloudmusic || &#123;&#125;; var widgetType = hexo.config.widgetType || 'flash'; var widgetSize = config.widgetSize || 'small'; var autoPlay = config.autoPlay || 1; var width = config.width || 278; var height = config.height || 32; if(widgetType == 'iframe')&#123; if(widgetSize=='small')&#123; return '&lt;iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=298 height=52 src=\"http://music.163.com/outchain/player?type=2&amp;id=' + sid + '&amp;auto=' + autoPlay +'&amp;height=32\"&gt;&lt;/iframe&gt;'; &#125;else if(widgetSize=='big')&#123; return '&lt;iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=351 height=86 src=\"http://music.163.com/outchain/player?type=2&amp;id=' + sid + '&amp;auto=' + autoPlay + '&amp;height=66\"&gt;&lt;/iframe&gt;'; &#125;else if(widgetSize=='custom')&#123; return '&lt;iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=' + width +' height=' + height +' src=\"http://music.163.com/outchain/player?type=2&amp;id=' + sid + '&amp;auto=' + autoPlay + '&amp;height=66\"&gt;&lt;/iframe&gt;'; &#125; &#125;else&#123; if(widgetSize=='small')&#123; return '&lt;embed src=\"http://music.163.com/style/swf/widget.swf?sid=' + sid + '&amp;type=2&amp;auto=' + autoPlay + '&amp;width=278&amp;height=32\" width=\"298\" height=\"52\" allowNetworking=\"all\"&gt;&lt;/embed&gt;'; &#125;else&#123; return '&lt;embed src=\"http://music.163.com/style/swf/widget.swf?sid=' + sid + '&amp;type=2&amp;auto=' + autoPlay + '&amp;width=320&amp;height=66\" width=\"340\" height=\"86\" allowNetworking=\"all\"&gt;&lt;/embed&gt;'; &#125; &#125;&#125;); &emsp;&emsp;大家可以看到这个JS文件本质上就是根据传入的sid来拼接生成网易云音乐的widget代码，这样当我们需要在博客中引用网易云音乐的时候只需要采用下面的标记： &emsp;&emsp;这个项目我目前发布在我的Github上，欢迎大家Start和Fork!","tags":[{"name":"插件","slug":"插件","permalink":"http://qinyuanpei.github.io/tags/插件/"},{"name":"网易","slug":"网易","permalink":"http://qinyuanpei.github.io/tags/网易/"},{"name":"云音乐","slug":"云音乐","permalink":"http://qinyuanpei.github.io/tags/云音乐/"},{"name":"Hexo","slug":"Hexo","permalink":"http://qinyuanpei.github.io/tags/Hexo/"}]},{"title":"使用Coding.NET和Hexo实现网页游戏的发布","date":"2015-03-24T08:54:48.000Z","path":"posts/1150071886/","text":"&emsp;&emsp;本文将尝试借助Coding.NET的项目演示功能，通过对Hexo中支持的发布类型进行扩充，实现可以在Hexo中发布网页游戏，从而方便博主展示游戏作品和帮助读者了解游戏效果。 为什么要这样做&emsp;&emsp;博主是一名至今为止都还没有做出一款完整游戏(指已上线)的游戏开发者,可是即使这样，博主依然愿意将自己在游戏开发过程中的感悟和体会分享给大家，因为博主在学习编程的路上摸索了这么久，首先要感谢的就是那些愿意在互联网上分享技术的人们，不管是Github上愿意将项目开源的那些技术大牛，还是在博客圈子里不断探索追逐梦想的人们，如果没有他们不求回报的辛勤付出，我是绝对不可能在环境科学这样一个专业中学好编程技术的。作为一名开源技术的追逐者，我们应该抱着”既取之，必与之”来回馈开源社区。况且将自己的知识分享给其他人，不仅可以敦促自己不断地学习，更能促进相互之间的学习，所以说写博客其实本来就是一件百利而无一害的事情。 &emsp;&emsp;好了，说了这么多，其实博主的想法就是能够在博客中增加项目演示的需求。博主经常在博客上写一些游戏开发的技术文章，每次都会在文章最后给出这篇文章中具体实现了一种怎样的效果。如果是静态图片当然没有什么争议，可是我们知道游戏或者说程序是一种动态的东西，所以如果采用静态图片似乎不能完全展示出具体的效果。而游戏作为一种可互动的产品，它更加强调玩家的互动和代入感，所以能够为玩家提供一个可控的操作环境就显得特别重要。以往在CSDN博客都是利用GIFCam录制屏幕Gif动画来展示效果的，可是受制于CSDN每次上传图片必须小于2M的容量限制的要求，所以使用Gif基本只能让读者了解一个大概。现在博客采用七牛云存储来存储博客中的图片，这是在使用CSDN博客时所不能相提并论的，所以现在博主的博客基本上是以这个独立博客为主，CSDN博客只是负责将独立博客的内容更新过去，博主每隔一段时间会去维护下CSDN博客，所以如何有时候没有及时回复大家的评论，还希望大家能够谅解啊。 &emsp;&emsp;那么，在Gif动画的基础上，有没有比这个方案更好的方案呢？博主的想法是直接将游戏嵌入到博客当中，这样读者在学习了技术上的实现以后可以立即体验到实际到操作游戏的感觉，从而更快地了解游戏的实现。因为博主认为只有真正热爱游戏的人才能够设计出好的游戏，所以博主最近打算在博客中开设一个专门推荐好游戏的栏目，这样可以让我们一边玩游戏、一边学习技术，这样的想法可好？哈哈，好了下面我们来说说怎样实现这个目标！ 怎样实现这样的目标Coding.NET是一个类似于Github的网站，提供了免费的项目托管服务。和Github不同的是Coding.NET为所有的Web项目提供了提供一个在线的演示环境，就是说只要Coding.NET支持你的项目，那么你的项目就可以托管在这个网站上面进行演示。基于这样一种机制，博主便想到下面两种实现的思路： 思路1因为Unity3D可以将项目导出为WebPlayer项目，在Unity5.0中更是提供了WebGL的支持，可以将Unity3D游戏导出为网页游戏。既然可以导出网页游戏，那么我们就可以将网页项目托管到Coidng.NET上，然后iframe框架引用到博客当中。不过这种方法可能会影响到网页的加载速度和搜索引擎优化，因为所有的搜索引擎都讨厌iframe。所以这种思路果断放弃咯！ 思路2将Unity3D导出的.unity3d文件托管到七牛云存储上，然后通过在Hexo中增加一个新的模版，来实现.unity3d文件和模版文件的对接，模板文件采用Unity3D的WebPlayer插件进行编写，在实现目的的基础上保证整个页面布局美观大方。这种方法的优点是完全原生，没有第三方依赖关系。缺点是页面是针对某一个Hexo主题的，没有办法做到一次编写、完全通用的效果。好了，下面我们就以这种思路来开始实现这个伟(zhuang)大(bi)的目标吧！ 模板修改&emsp;&emsp;首先我们的目的是要实现在博客中集成游戏的功能，因此我们的游戏是不能作为博客的文章出现的首页，我们知道在Hexo中可以通过hexo new page[PageName]这个命令来生成一个自定义页面，而且生成的自定义页面不会出现在博客首页，只有通过链接才可以访问到这个页面，因此我们可以从这里作为突破口。在输入hexo new page[PageName]命令后我们发现在hexo的source文件夹下会生成一个以PageName命名的文件夹，在这个文件夹中有一个index.md的文件，通过修改这个文件的内容就能实现自定义页面。可是我们发现一个问题，每次生成一个新的页面就需要创建一个新的文件夹，这样的结构对我们管理游戏项目十分不便。怎么办呢？首先我们在source文件夹下创建一个games的文件夹，然后再该文件夹下创建一个子文件夹，子文件夹的命名可以任意(此处以example为例)关键是要在这个子文件夹里需要放置我们前面通过命令生成的index.md文件，此时我们就可以通过http://YourSite.com/games/example来访问这个页面了，此后如果需要发布新的游戏，可以将example文件夹复制一份然后重命名即可。好了，下面我们来重点说下这个index.md里的内容。通过查看Unity3D生成的网页文件我们了解到一个完整的Unity3D游戏需要两个东西，一个是描述页面结构的HTML，一个是.unity3d文件。这里面麻烦点的是HTML，开始觉得蛮容易的，后来发现修改模板实在困难，所以不得不放弃这种思路了。 思路3&emsp;&emsp;博主是最近了解到，Github除了可以用xxx.github.io这种方式搭建博客外，还可以通过gh-pages分支来实现，换句话说只要我们把静态的网页放到项目的gh-pages下，Github就能帮你把页面显示出来，因此我们就可以将Unity3D导出的网页版本游戏放到Github上，从而实现游戏的在线演示。好吧，满满的罪恶感啊，要是有一天Github被GFW了，我就是那个断送它的人啊！ 效果演示","tags":[{"name":"游戏","slug":"游戏","permalink":"http://qinyuanpei.github.io/tags/游戏/"},{"name":"Hexo","slug":"Hexo","permalink":"http://qinyuanpei.github.io/tags/Hexo/"},{"name":"部署","slug":"部署","permalink":"http://qinyuanpei.github.io/tags/部署/"}]},{"title":"C#中Socket通信编程的异步实现","date":"2015-03-22T09:37:04.000Z","path":"posts/2041685704/","text":"&emsp;&emsp;本文将在C#中Socket同步通信的基础上，分析和研究Socket异步编程的实现方法，目的是深入了解Socket编程的基本原理，增强对网络游戏开发相关内容的认识。 什么是Socket编程的异步的实现&emsp;&emsp;所谓Socket编程的异步实现是指按照异步过程来实现Socket编程，那么什么是异步过程呢，我们把在完成了一次调用后通过状态、通知和回调来告知调用者的方式成为异步过程，换句话说，在异步过程中当调用一个方法时，调用者并不能够立刻得到结果，只有当这个方法调用完毕后调用者才能获得调用结果。这样做的好处是什么呢？答案是高效。相信大家还记得我们在《C#中Socket通信编程的同步实现》这篇文章中使用多线程来实现简单聊天的案例吧，在这个案例中我们需要开启两个线程来不断监听客户端的连接和客户端的消息，这样的效率肯定是很低的。那么现在好了，我们可以通过异步过程来解决这个问题，下面我们就来看看如何实现Socket的异步通信。 如何实现Socket异步通信服务端基本流程 创建套接字 绑定套接字的IP和端口号——Bind() 使套接字处于监听状态等待客户端的连接请求——Listen() 当请求到来后，使用BeginAccept()和EndAccept()方法接受请求，返回新的套接字 使用BeginSend()/EndSend和BeginReceive()/EndReceive()两组方法与客户端进行收发通信 返回，再次等待新的连接请求 关闭套接字 代码示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192using System;using System.Collections.Generic;using System.Text;using System.Net;using System.Net.Sockets;namespace AsyncServer&#123; public class AsyncTCPServer &#123; public void Start() &#123; //创建套接字 IPEndPoint ipe = new IPEndPoint(IPAddress.Parse(&quot;127.0.0.1&quot;), 6065); Socket socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); //绑定端口和IP socket.Bind(ipe); //设置监听 socket.Listen(10); //连接客户端 AsyncAccept(socket); &#125; /// &lt;summary&gt; /// 连接到客户端 /// &lt;/summary&gt; /// &lt;param name=&quot;socket&quot;&gt;&lt;/param&gt; private void AsyncAccept(Socket socket) &#123; socket.BeginAccept(asyncResult =&gt; &#123; //获取客户端套接字 Socket client = socket.EndAccept(asyncResult); Console.WriteLine(string.Format(&quot;客户端&#123;0&#125;请求连接...&quot;, client.RemoteEndPoint)); AsyncSend(client, &quot;服务器收到连接请求&quot;); AsyncSend(client, string.Format(&quot;欢迎你&#123;0&#125;&quot;,client.RemoteEndPoint)); AsyncReveive(client); &#125;, null); &#125; /// &lt;summary&gt; /// 接收消息 /// &lt;/summary&gt; /// &lt;param name=&quot;client&quot;&gt;&lt;/param&gt; private void AsyncReveive(Socket socket) &#123; byte[] data = new byte[1024]; try &#123; //开始接收消息 socket.BeginReceive(data, 0, data.Length, SocketFlags.None, asyncResult =&gt; &#123; int length = socket.EndReceive(asyncResult); Console.WriteLine(string.Format(&quot;客户端发送消息:&#123;0&#125;&quot;, Encoding.UTF8.GetString(data))); &#125;, null); &#125; catch (Exception ex) &#123; Console.WriteLine(ex.Message); &#125; &#125; /// &lt;summary&gt; /// 发送消息 /// &lt;/summary&gt; /// &lt;param name=&quot;client&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;p&quot;&gt;&lt;/param&gt; private void AsyncSend(Socket client, string p) &#123; if (client == null || p == string.Empty) return; //数据转码 byte[] data = new byte[1024]; data = Encoding.UTF8.GetBytes(p); try &#123; //开始发送消息 client.BeginSend(data, 0, data.Length, SocketFlags.None, asyncResult =&gt; &#123; //完成消息发送 int length = client.EndSend(asyncResult); //输出消息 Console.WriteLine(string.Format(&quot;服务器发出消息:&#123;0&#125;&quot;, p)); &#125;, null); &#125; catch (Exception e) &#123; Console.WriteLine(e.Message); &#125; &#125; &#125;&#125; 客户端基本流程 创建套接字并保证与服务器的端口一致 使用BeginConnect()和EndConnect()这组方法向服务端发送连接请求 使用BeginSend()/EndSend和BeginReceive()/EndReceive()两组方法与服务端进行收发通信 关闭套接字 代码示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182using System;using System.Collections.Generic;using System.Text;using System.Net;using System.Net.Sockets;namespace AsyncClient&#123; public class AsyncTCPClient &#123; /// &lt;summary&gt; /// 连接到服务器 /// &lt;/summary&gt; public void AsynConnect() &#123; //端口及IP IPEndPoint ipe = new IPEndPoint(IPAddress.Parse(&quot;127.0.0.1&quot;), 6065); //创建套接字 Socket client = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); //开始连接到服务器 client.BeginConnect(ipe, asyncResult =&gt; &#123; client.EndConnect(asyncResult); //向服务器发送消息 AsynSend(client,&quot;你好我是客户端&quot;); AsynSend(client, &quot;第一条消息&quot;); AsynSend(client, &quot;第二条消息&quot;); //接受消息 AsynRecive(client); &#125;, null); &#125; /// &lt;summary&gt; /// 发送消息 /// &lt;/summary&gt; /// &lt;param name=&quot;socket&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;message&quot;&gt;&lt;/param&gt; public void AsynSend(Socket socket, string message) &#123; if (socket == null || message == string.Empty) return; //编码 byte[] data = Encoding.UTF8.GetBytes(message); try &#123; socket.BeginSend(data, 0, data.Length, SocketFlags.None, asyncResult =&gt; &#123; //完成发送消息 int length = socket.EndSend(asyncResult); Console.WriteLine(string.Format(&quot;客户端发送消息:&#123;0&#125;&quot;, message)); &#125;, null); &#125; catch (Exception ex) &#123; Console.WriteLine(&quot;异常信息：&#123;0&#125;&quot;, ex.Message); &#125; &#125; /// &lt;summary&gt; /// 接收消息 /// &lt;/summary&gt; /// &lt;param name=&quot;socket&quot;&gt;&lt;/param&gt; public void AsynRecive(Socket socket) &#123; byte[] data = new byte[1024]; try &#123; //开始接收数据 socket.BeginReceive(data, 0, data.Length, SocketFlags.None, asyncResult =&gt; &#123; int length = socket.EndReceive(asyncResult); Console.WriteLine(string.Format(&quot;收到服务器消息:&#123;0&#125;&quot;, Encoding.UTF8.GetString(data))); AsynRecive(socket); &#125;, null); &#125; catch (Exception ex) &#123; Console.WriteLine(&quot;异常信息：&quot;, ex.Message); &#125; &#125; &#125;&#125; 从总体上来讲Socket异步编程的逻辑性更加明确了，因为我们只需要为每一个过程写好回调函数就好了。那么这个示例的效果如何呢？我们来看看它的演示效果： Socket异步编程效果演示 总结&emsp;&emsp;和Socket同步编程的案例相比，今天的这个案例可能只是对Socket异步编程内容的一个简单应用，因为博主到现在为止都还没有写出一个可以进行交互聊天的程序来。在Socket的异步编程中，服务端不需要为一个客户端单独创建一个线程来维护其连接，可是这样带来的一个问题就是博主不知道该如何实现一个多客户端的异步编程的实例。如果有朋友知道如何实现的话，还希望能够告诉我，毕竟学习就是一个相互促进的过程啊。好了，最后想说的是博主这段时间研究Socket异步编程中关于异步方法调用的写法问题。我们知道Socket异步编程中的方法是成对出现的，每一个方法都有一个回调函数，对于回调函数，这里有两种写法，以BeginConnect方法为例：123m_Socket.BeginConnect(this.m_ipEndPoint, new AsyncCallback(this.ConnectCallBack), this.m_Socket);//其中ConnectCallBack是一个回调函数 或者1234m_Socket.BeginConnect(this.m_ipEndPoint,asyncResult=&gt;&#123; //在这里添加更多代码&#125;,null) &emsp;&emsp;博主为什么要在这里说这两种写法呢，有两个原因： 第二种写法更为简洁，无需去构造容器传递Socket和消息，因为它们都是局部变量。如果我们使用第一种方法，因为主函数和回调函数是两个不同的函数，因此如果想要共享变量就需要通过IAsyncResult接口来访问容器中的值，这样显然增加了我们的工作量。 第二种写法更为优雅，这似乎是C#语言中某种高级语法，具体叫什么我忘了，反正在Linq中经常看到这种写法的影子。 &emsp;&emsp;综合以上两个观点，博主还是建议大家使用第二种写法，博主打算有空的话将之前写的程序再重新写一遍，看看能不能找出代码中的问题。好了，今天的内容就是这样了，谢谢大家，希望大家喜欢！","tags":[{"name":"Socket","slug":"Socket","permalink":"http://qinyuanpei.github.io/tags/Socket/"},{"name":"通信","slug":"通信","permalink":"http://qinyuanpei.github.io/tags/通信/"},{"name":"异步","slug":"异步","permalink":"http://qinyuanpei.github.io/tags/异步/"}]},{"title":"C#中Socket通信编程的同步实现","date":"2015-03-15T15:05:56.000Z","path":"posts/3959327595/","text":"&emsp;&emsp;本文通过分析和总结C#中Socket通信编程的关键技术，按照同步实现的方式实现了一个简单的Socket聊天程序，目的是通过这个程序来掌握Socket编程，为进一步开发Unity3D网络游戏打下一个坚实的基础。 Socket编程基础&emsp;&emsp;关于Socket编程基础部分的内容，主要是了解和掌握.NET框架下为Socket编程提供的相关类和接口方法。.NET中常见的网络相关的API都集中在System.Net和System.Net.Socket这两个命名空间下，大家可以通过MSDN去了解这两个命名空间下相关的类和方法。这里援引一位朋友总结的一篇文章http://www.cnblogs.com/sunev/archive/2012/08/05/2604189.html，大家可以从这里获得更为直观的认识。 什么是Socket编程的同步实现&emsp;&emsp;本文的目的是按照同步实现的方式来实现一个简单的Socket聊天程序，因此在解决这个问题前，我们首先来看看什么是Socket编程的同步实现。所谓Socket编程的同步实现就是指按照同步过程的方法来实现Socket通信。从编程来说，我们常用的方法或者函数都是同步过程。因为当我们调用一个方法或者函数的时候我们能够立即得到它的返回值。可是我们知道在Socket通信中，我们不能保证时时刻刻连接都通畅、更不能够保证时时刻刻都有数据收发，因为我们就需要不断去读取相应的值来确定整个过程的状态。这就是Socket编程的同步实现了，下面我们来看具体的实现过程。 如何实现Socket同步通信服务端&emsp;&emsp;服务端的主要职责是处理各个客户端发送来的数据，因此在客户端的Socket编程中需要使用两个线程来循环处理客户端的请求，一个线程用于监听客户端的连接情况，一个线程用于监听客户端的消息发送，当服务端接收到客户端的消息后需要将消息处理后再分发给各个客户端。 基本流程 创建套接字 绑定套接字的IP和端口号——Bind() 将套接字处于监听状态等待客户端的连接请求——Listen() 当请求到来后，接受请求并返回本次会话的套接字——Accept() 使用返回的套接字和客户端通信——Send()/Receive() 返回，再次等待新的连接请求 关闭套接字 代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228using System;using System.Collections.Generic;using System.Text;using System.Net;using System.Net.Sockets;using System.Threading;namespace TCPLib&#123; public class TCPServer &#123; private byte[] result = new byte[1024]; /// &lt;summary&gt; /// 最大的监听数量 /// &lt;/summary&gt; private int maxClientCount; public int MaxClientCount &#123; get &#123; return maxClientCount; &#125; set &#123; maxClientCount = value; &#125; &#125; /// &lt;summary&gt; /// IP地址 /// &lt;/summary&gt; private string ip; public string IP &#123; get &#123; return ip; &#125; set &#123; ip = value; &#125; &#125; /// &lt;summary&gt; /// 端口号 /// &lt;/summary&gt; private int port; public int Port &#123; get &#123; return port; &#125; set &#123; port = value; &#125; &#125; /// &lt;summary&gt; /// 客户端列表 /// &lt;/summary&gt; private List&lt;Socket&gt; mClientSockets; public List&lt;Socket&gt; ClientSockets &#123; get &#123; return mClientSockets; &#125; &#125; /// &lt;summary&gt; /// IP终端 /// &lt;/summary&gt; private IPEndPoint ipEndPoint; /// &lt;summary&gt; /// 服务端Socket /// &lt;/summary&gt; private Socket mServerSocket; /// &lt;summary&gt; /// 当前客户端Socket /// &lt;/summary&gt; private Socket mClientSocket; public Socket ClientSocket &#123; get &#123; return mClientSocket; &#125; set &#123; mClientSocket = value; &#125; &#125; /// &lt;summary&gt; /// 构造函数 /// &lt;/summary&gt; /// &lt;param name=&quot;port&quot;&gt;端口号&lt;/param&gt; /// &lt;param name=&quot;count&quot;&gt;监听的最大树目&lt;/param&gt; public TCPServer(int port, int count) &#123; this.ip = IPAddress.Any.ToString(); this.port = port; this.maxClientCount=count; this.mClientSockets = new List&lt;Socket&gt;(); //初始化IP终端 this.ipEndPoint = new IPEndPoint(IPAddress.Any, port); //初始化服务端Socket this.mServerSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); //端口绑定 this.mServerSocket.Bind(this.ipEndPoint); //设置监听数目 this.mServerSocket.Listen(maxClientCount); &#125; /// &lt;summary&gt; /// 构造函数 /// &lt;/summary&gt; /// &lt;param name=&quot;ip&quot;&gt;ip地址&lt;/param&gt; /// &lt;param name=&quot;port&quot;&gt;端口号&lt;/param&gt; /// &lt;param name=&quot;count&quot;&gt;监听的最大数目&lt;/param&gt; public TCPServer(string ip,int port,int count) &#123; this.ip = ip; this.port = port; this.maxClientCount = count; this.mClientSockets = new List&lt;Socket&gt;(); //初始化IP终端 this.ipEndPoint = new IPEndPoint(IPAddress.Parse(ip), port); //初始化服务端Socket this.mServerSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); //端口绑定 this.mServerSocket.Bind(this.ipEndPoint); //设置监听数目 this.mServerSocket.Listen(maxClientCount); &#125; /// &lt;summary&gt; /// 定义一个Start方法将构造函数中的方法分离出来 /// &lt;/summary&gt; public void Start() &#123; //创建服务端线程，实现客户端连接请求的循环监听 var mServerThread = new Thread(this.ListenClientConnect); //服务端线程开启 mServerThread.Start(); &#125; /// &lt;summary&gt; /// 监听客户端链接 /// &lt;/summary&gt; private void ListenClientConnect() &#123; //设置循环标志位 bool flag = true; while (flag) &#123; //获取连接到服务端的客户端 this.ClientSocket = this.mServerSocket.Accept(); //将获取到的客户端添加到客户端列表 this.mClientSockets.Add(this.ClientSocket); //向客户端发送一条消息 this.SendMessage(string.Format(&quot;客户端&#123;0&#125;已成功连接到服务器&quot;, this.ClientSocket.RemoteEndPoint)); //创建客户端消息线程，实现客户端消息的循环监听 var mReveiveThread = new Thread(this.ReceiveClient); //注意到ReceiveClient方法传入了一个参数 //实际上这个参数就是此时连接到服务器的客户端 //即ClientSocket mReveiveThread.Start(this.ClientSocket); &#125; &#125; /// &lt;summary&gt; /// 接收客户端消息的方法 /// &lt;/summary&gt; private void ReceiveClient(object obj) &#123; //获取当前客户端 //因为每次发送消息的可能并不是同一个客户端，所以需要使用var来实例化一个新的对象 //可是我感觉这里用局部变量更好一点 var mClientSocket = (Socket)obj; // 循环标志位 bool flag = true; while (flag) &#123; try &#123; //获取数据长度 int receiveLength = mClientSocket.Receive(result); //获取客户端消息 string clientMessage = Encoding.UTF8.GetString(result, 0, receiveLength); //服务端负责将客户端的消息分发给各个客户端 this.SendMessage(string.Format(&quot;客户端&#123;0&#125;发来消息:&#123;1&#125;&quot;,mClientSocket.RemoteEndPoint,clientMessage)); &#125; catch (Exception e) &#123; //从客户端列表中移除该客户端 this.mClientSockets.Remove(mClientSocket); //向其它客户端告知该客户端下线 this.SendMessage(string.Format(&quot;服务器发来消息:客户端&#123;0&#125;从服务器断开,断开原因:&#123;1&#125;&quot;,mClientSocket.RemoteEndPoint,e.Message)); //断开连接 mClientSocket.Shutdown(SocketShutdown.Both); mClientSocket.Close(); break; &#125; &#125; &#125; /// &lt;summary&gt; /// 向所有的客户端群发消息 /// &lt;/summary&gt; /// &lt;param name=&quot;msg&quot;&gt;message&lt;/param&gt; public void SendMessage(string msg) &#123; //确保消息非空以及客户端列表非空 if (msg == string.Empty || this.mClientSockets.Count &lt;= 0) return; //向每一个客户端发送消息 foreach (Socket s in this.mClientSockets) &#123; (s as Socket).Send(Encoding.UTF8.GetBytes(msg)); &#125; &#125; /// &lt;summary&gt; /// 向指定的客户端发送消息 /// &lt;/summary&gt; /// &lt;param name=&quot;ip&quot;&gt;ip&lt;/param&gt; /// &lt;param name=&quot;port&quot;&gt;port&lt;/param&gt; /// &lt;param name=&quot;msg&quot;&gt;message&lt;/param&gt; public void SendMessage(string ip,int port,string msg) &#123; //构造出一个终端地址 IPEndPoint _IPEndPoint = new IPEndPoint(IPAddress.Parse(ip), port); //遍历所有客户端 foreach (Socket s in mClientSockets) &#123; if (_IPEndPoint == (IPEndPoint)s.RemoteEndPoint) &#123; s.Send(Encoding.UTF8.GetBytes(msg)); &#125; &#125; &#125; &#125;&#125; &emsp;&emsp;好了，现在我们已经编写好了一个具备接收和发送数据能力的服务端程序。现在我们来尝试让服务端运行起来：12345678910111213141516171819202122232425using System;using System.Collections.Generic;using System.Text;using TCPLib;using System.Net;using System.Net.Sockets;namespace TCPLib.Test&#123; class Program &#123; static void Main(string[] args) &#123; //指定IP和端口号及最大监听数目的方式 TCPLib.TCPServer s1 = new TCPServer(&quot;127.0.0.1&quot;, 6001, 10); //指定端口号及最大监听数目的方式 TCPLib.TCPServer s2 = new TCPServer(6001, 10); //执行Start方法 s1.Start(); &#125; &#125;&#125; &emsp;&emsp;现在我们来看看编写客户端Socket程序的基本流程 客户端&emsp;&emsp;客户端相对于服务端来说任务要轻许多，因为客户端仅仅需要和服务端通信即可，可是因为在和服务器通信的过程中，需要时刻保持连接通畅，因此同样需要两个线程来分别处理连接情况的监听和消息发送的监听。 基本流程 创建套接字保证与服务器的端口一致 向服务器发出连接请求——Connect() 和服务器端进行通信——Send()/Receive() 关闭套接字 代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158using System;using System.Collections.Generic;using System.Text;using System.Net;using System.Net.Sockets;using System.Threading;namespace TCPLib&#123; public class TCPClient &#123; /// &lt;summary&gt; /// 定义数据 /// &lt;/summary&gt; private byte[] result = new byte[1024]; /// &lt;summary&gt; /// 客户端IP /// &lt;/summary&gt; private string ip; public string IP &#123; get &#123; return ip; &#125; set &#123; ip = value; &#125; &#125; /// &lt;summary&gt; /// 客户端端口号 /// &lt;/summary&gt; private int port; public int Port &#123; get &#123; return port; &#125; set &#123; port = value; &#125; &#125; /// &lt;summary&gt; /// IP终端 /// &lt;/summary&gt; private IPEndPoint ipEndPoint; /// &lt;summary&gt; /// 客户端Socket /// &lt;/summary&gt; private Socket mClientSocket; /// &lt;summary&gt; /// 是否连接到了服务器 /// 默认为flase /// &lt;/summary&gt; private bool isConnected = false; /// &lt;summary&gt; /// 构造函数 /// &lt;/summary&gt; /// &lt;param name=&quot;ip&quot;&gt;IP地址&lt;/param&gt; /// &lt;param name=&quot;port&quot;&gt;端口号&lt;/param&gt; public TCPClient(string ip, int port) &#123; this.ip=ip; this.port=port; //初始化IP终端 this.ipEndPoint = new IPEndPoint(IPAddress.Parse(this.ip), this.port); //初始化客户端Socket mClientSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); &#125; public void Start() &#123; //创建一个线程以不断连接服务器 var mConnectThread = new Thread(this.ConnectToServer); //开启线程 mConnectThread.Start(); &#125; /// &lt;summary&gt; /// 连接到服务器 /// &lt;/summary&gt; private void ConnectToServer() &#123; //当没有连接到服务器时开始连接 while (!isConnected) &#123; try &#123; //开始连接 mClientSocket.Connect(this.ipEndPoint); this.isConnected = true; &#125; catch (Exception e) &#123; //输出Debug信息 Console.WriteLine(string.Format(&quot;因为一个错误的发生，暂时无法连接到服务器，错误信息为:&#123;0&#125;&quot;,e.Message)); this.isConnected = false; &#125; //等待5秒钟后尝试再次连接 Thread.Sleep(5000); Console.WriteLine(&quot;正在尝试重新连接...&quot;); &#125; //连接成功后 Console.WriteLine(&quot;连接服务器成功，现在可以和服务器进行会话了&quot;); //创建一个线程以监听数据接收 var mReceiveThread = new Thread(this.ReceiveMessage); //开启线程 mReceiveThread.Start(); &#125; /// &lt;summary&gt; /// 因为客户端只接受来自服务器的数据 /// 因此这个方法中不需要参数 /// &lt;/summary&gt; private void ReceiveMessage() &#123; //设置循环标志位 bool flag = true; while (flag) &#123; try &#123; //获取数据长度 int receiveLength = this.mClientSocket.Receive(result); //获取服务器消息 string serverMessage = Encoding.UTF8.GetString(result, 0, receiveLength); //输出服务器消息 Console.WriteLine(serverMessage); &#125; catch (Exception e) &#123; //停止消息接收 flag = false; //断开服务器 this.mClientSocket.Shutdown(SocketShutdown.Both); //关闭套接字 this.mClientSocket.Close(); //重新尝试连接服务器 this.isConnected = false; ConnectToServer(); &#125; &#125; &#125; /// &lt;summary&gt; /// 发送消息 /// &lt;/summary&gt; /// &lt;param name=&quot;msg&quot;&gt;消息文本&lt;/param&gt; public void SendMessage(string msg) &#123; if(msg==string.Empty || this.mClientSocket==null) return; mClientSocket.Send(Encoding.UTF8.GetBytes(msg)); &#125; &#125;&#125; &emsp;&emsp;同样地，我们现在来运行客户端程序，这样客户端就可以和服务端进行通信了：1234567891011121314151617181920212223242526272829using System;using System.Collections.Generic;using System.Text;using TCPLib;using System.Net;using System.Net.Sockets;namespace TCPLib.Test&#123; class Program &#123; static void Main(string[] args) &#123; //保证端口号和服务端一致 TCPLib.TCPClient c = new TCPClient(&quot;127.0.0.1&quot;,6001); //执行Start方法 c.Start(); while(true) &#123; //读取客户端输入的消息 string msg = Console.ReadLine(); //发送消息到服务端 c.SendMessage(msg); &#125; &#125; &#125;&#125; &emsp;&emsp;注意要先运行服务端的程序、再运行客户端的程序，不然程序会报错，嘿嘿！好了，下面是今天的效果演示图： 聊天窗口效果演示 客户端下线效果演示 总结&emsp;&emsp;今天我们基本上写出了一个可以使用的用例，不过这个例子目前还存在以下问题： 这里仅仅实现了发送字符串的功能，如何让这个程序支持更多的类型，从基础的int、float、double、string、single等类型到structure、class甚至是二进制文件的类型？ 如何让这个用例更具有扩展性，我们发现所有的Socket编程流程都是一样的，唯一不同就是在接收到数据以后该如何去处理，因为能不能将核心功能和自定义功能分离开来？ 在今天的这个用例中，数据传输的缓冲区大小我们人为设定为1024，那么如果碰到比这个设定更大的数据类型，这个用例该怎么来写？ 好了，这就是今天的内容了，希望大家喜欢，同时希望大家关注我的博客！ 2016年1月24日更新：&emsp;&emsp;要解决“支持更多类型的问题”，可以从两种思路来考虑，即实现所有类型到byte[]类型的转换或者是实现所有类型到string类型的转换，对于第二种思路我们通常称之为序列化，序列化可以解决所有类型到string类型的转换问题，唯一可能需要考量的一个部分就是缓冲区的大小问题。 &emsp;&emsp;要解决“将核心功能和自定义功能分离”这个问题，可以考虑使用委托机制来实现，委托机制可以理解为一个函数的指针，在需要将函数的控制权交给用户来处理的场景中，委托都是一种有效而明智的选择。","tags":[{"name":"Socket","slug":"Socket","permalink":"http://qinyuanpei.github.io/tags/Socket/"},{"name":"通信","slug":"通信","permalink":"http://qinyuanpei.github.io/tags/通信/"},{"name":"同步","slug":"同步","permalink":"http://qinyuanpei.github.io/tags/同步/"},{"name":"多线程","slug":"多线程","permalink":"http://qinyuanpei.github.io/tags/多线程/"}]},{"title":"使用Unity3D创建一个幸运转盘","date":"2015-03-12T19:13:38.000Z","path":"posts/3449402269/","text":"&emsp;&emsp;今天我们来做点和游戏无关的事情吧！博主最近情绪一直比较低落，因为在找工作的过程中遇到了些挫折。当一个人内心缺乏斗志的时候，通常会难以静下心来认真地做事情，所以这段时间博主并不打算再去为大家分享新的游戏案例，希望大家能够谅解啊。 &emsp;&emsp;好了，博主今天想和大家分享的是一个叫做幸运转盘的案例。我们知道平时在节假日商场为了促销商品，通常都会推出诸如转盘抽奖这样的游戏。在学了概率以后，虽然我们都知道中奖是一个小概率事件，可是人们对买彩票中奖这样的事情仍然乐此不疲。就像腾讯通过今年的春晚成功地为微信支付培养了大量忠实用户一样，虽然大家抢红包抢到的钱都不算多，可是大家都还是愿意去抢红包啊。为什么呢？呵呵，不就图一乐嘛。好了，那么下面我们一起乐一乐吧，因为激动人心的抽奖环节就要开始了！ &emsp;&emsp;首先我们来看看在Unity3D中如何实现转盘抽奖： 转盘游戏示意图 &emsp;&emsp;从这张图片我们可以看出，转盘抽奖有两部分组成：转盘是可以旋转的、转盘指针是固定不动的。那么，好了，抽奖无非就是让转盘转起来然后再停下来嘛，直接给出代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152using UnityEngine;using System.Collections;public class LuckyRoll : MonoBehaviour &#123; //幸运转盘 private Transform mRoolPanel; //初始旋转速度 private float mInitSpeed; //速度变化值 private float mDelta=0.5f; //转盘是否暂停 private bool isPause=true; void Start () &#123; //获取转盘 mRoolPanel=this.transform.FindChild(&quot;Background&quot;); &#125; //开始抽奖 public void OnClick() &#123; if(isPause) &#123; //随机生成一个初始速度 mInitSpeed=Random.Range(100,500); //开始旋转 isPause=false; &#125; &#125; void Update() &#123; if(!isPause) &#123; //转动转盘(-1为顺时针,1为逆时针) mRoolPanel.Rotate(new Vector3(0,0,-1) * mInitSpeed * Time.deltaTime); //让转动的速度缓缓降低 mInitSpeed-=mDelta; //当转动的速度为0时转盘停止转动 if(mInitSpeed&lt;=0) &#123; //转动停止 isPause=true; &#125; &#125; &#125;&#125; &emsp;&emsp;这里我们随机给出一个速度mInitSpeed，然后让它按照mDelta的速率缓慢的减少，当mInitSpeed的数值为0时表示转盘停止转动。好了，我们来看看最后的效果： 转盘游戏演示 &emsp;&emsp;从现在的效果来看，这个案例基本上成功了，所以以后如果碰到需要这种抽奖活动的场合，大家就可以跟美术协调好，快速地制作出这样一个幸运转盘来向身边的人们炫耀了。不过这个案例同样存在问题： 基于随机数的转盘转动不受玩家控制，玩家无法参与到互动当中，可以考虑触摸操作，这样可以根据玩家的操作来模拟转动，提高游戏的真实性和可玩性。 因为抽奖的结果是由美术设计在转盘上的，所以程序无法根据转盘停止后指针的位置直接判断出玩家抽奖的结果以及本次抽奖是否为有效的抽奖(指针恰好停留在两个扇形区域的分界线上)。 因为这里转盘的旋转并没有严格地按照实际情况下转盘的受力情况来设计，因此可以说这个游戏中的概率分布可能不是均匀的，因此计算机里使用的随机数是伪随机数。 &emsp;&emsp;好了，暂时就发现这些问题，如果有朋友知道如何模拟触屏操作和阻尼运动，可以在这篇文章后面给我留言，今天的内容就是这样了，希望大家会喜欢！ 2015年3月31日更新：&emsp;&emsp;今天找到了关于转盘游戏概率设计的相关内容，所以经过整理后补充在这里：首先这种转盘游戏概率设计的前提是转盘固定不动，转盘指针绕中心位置旋转，与这篇文章中的恰好相反。如下图所示，在这个转盘游戏的设计中主要遵循基本的三角函数,这里以指针默认位置朝上来讲解该原理。如果指针的默认位置在其它位置上的，可以此类推。 转盘游戏示意图 x+=xcosᶱy+=ycosᶱ &emsp;&emsp;好了，现在我们就可以通过调整指针的角度来实现抽奖游戏了。比如我们将转盘平均分成8份，指针角度为0表示奖品A,指针角度为45度表示奖品B等等，以此类推。这样的话，我们只要调整指针的角度就可以控制抽奖的结果。可是在实际生活中，指针不可能一次就指到对应的奖品上去，通常会在旋转若干圈后慢慢地停下来。因此我们可以使用下列公式： 指针角度=360*圈数+(目标角度与初始角度的差值) &emsp;&emsp;这里的圈数可以通过随机数来生成，这样可以让每次抽奖更加随机些，当然为了增加抽奖的真实感，我们可以采用这篇文章中提到的减速的方法来实现一个缓停的效果。那么问题来了，如果转盘上的奖项不是均匀分布的怎么呢？这种情况可以根据转盘上圆心角的大小为每一个奖项设定一个范围，然后在这个范围内随机生成一个角度来计算指针的角度，好了，下面给出代码实现：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980using UnityEngine;using System.Collections;using System.Collections.Generic;public class LuckyRoll2 : MonoBehaviour &#123; //对奖项进行封装 private class WrapItem &#123; public WrapItem(string name,float rank,float ang1,float ang2) &#123; this.ItemName=name; this.ItemRank=rank; this.MinAngle=ang1; this.MaxAngle=ang2; &#125; //奖项名称 public string ItemName&#123;get;set;&#125; //奖项概率 public float ItemRank&#123;get;set;&#125; //最大角度 public float MaxAngle&#123;get;set;&#125; //最小角度 public float MinAngle&#123;get;set;&#125; &#125; //全部的奖项 private List&lt;WrapItem&gt; allItems; void Start () &#123; //初始化奖品 allItems=new List&lt;WrapItem&gt;() &#123; //圆心角为5°，概率为10%，以此类推 new WrapItem(&quot;奖品1&quot;,10,0,30), new WrapItem(&quot;奖品2&quot;,15,30,90), new WrapItem(&quot;奖品3&quot;,20,90,165), new WrapItem(&quot;奖品4&quot;,25,165,255), new WrapItem(&quot;奖品5&quot;,30,255,360), &#125;; //模拟抽奖10次 for(int i=0;i&lt;10;i++) &#123; Debug.Log(Roll()); &#125; &#125; /// &lt;summary&gt; /// 抽奖方法 /// &lt;/summary&gt; private string Roll() &#123; //抽奖结果 string result=&quot;&quot;; //概率总精度为100 float totalRank=100; foreach(WrapItem item in allItems) &#123; //产生一个0到100之间的随机数 float random =Random.Range(0,totalRank); //将该随机数和奖品的概率比较 if(random&lt;=item.ItemRank) &#123; //抽奖结果 result=item.ItemName; //为转盘指针随机生成旋转角度 float angle=Random.Range(item.MinAngle,item.MaxAngle); //旋转转盘指针,此处略 break; &#125;else &#123; totalRank-=item.ItemRank; &#125; &#125; return &quot;抽奖结果为:&quot;+result; &#125;&#125; &emsp;&emsp;好了，这里我们没有写转盘旋转的功能，这部分内容大家自己去实现好了，因为在Unity3D里面实现这样一个功能实在是太简单了。今天我们主要关注的内容是概率，所以我们重点对概率做了些研究，这里我们来讨论下算法中的概率计算问题，首先奖品1、奖品2、奖品2、奖品4、奖品5的概率分别为10%、15%、20%、25%、30%，其概率之和为100。因此 奖品1：从0~100中随机抽取一个数，这个数值小于10的概率显然是10%，这是第一轮数组遍历。 奖品2：在第一轮数组遍历没有返回的情况下，进入第二轮遍历，此时从0~90中随机抽取一个数，其概率为(1-(10/100)(15/(100-10))=15%。同样的，抽到奖品3的概率为(1-(25/100))(20/(100-25))=20%，以此类推。 好了，这部分内容终于补充到这篇文章里了，对于这个问题的研究基本上可以告一段落，不得不说概率对于游戏开发来说还是蛮重要的啊，有时间学习下数学吧，反正咱底子不弱啊，哈哈。 &emsp;&emsp;下面给出程序演示效果： 转盘游戏概率设计效果演示 参考资料大家快来玩转盘抽奖游戏(走在网页游戏开发的路上)(七)php+jquery实现转盘抽奖概率可任意调整","tags":[{"name":"游戏","slug":"游戏","permalink":"http://qinyuanpei.github.io/tags/游戏/"},{"name":"概率","slug":"概率","permalink":"http://qinyuanpei.github.io/tags/概率/"},{"name":"转盘","slug":"转盘","permalink":"http://qinyuanpei.github.io/tags/转盘/"}]},{"title":"使用Love2D引擎开发贪吃蛇游戏","date":"2015-03-10T10:51:19.000Z","path":"posts/426338252/","text":"&emsp;&emsp;今天来介绍博主最近捣腾的一个小游戏“贪吃蛇”。“贪吃蛇”这个游戏相信大家都不会感到陌生吧。今天博主将通过Love2D这款游戏引擎来为大家实现一个简单的贪吃蛇游戏,在本篇文章当中我们将会涉及到“贪吃蛇”的基本算法、Lua语言编程等基本的内容，希望能够对大家开发类似的游戏提供借鉴和思考，文章中如有不足之处，还希望大家能够谅解，因为博主的游戏开发基本就是这样慢慢摸索着学习，所以难免会有不足的地方。 游戏算法&emsp;&emsp;我们首先来看看贪吃蛇是怎么移动的？ 贪吃蛇游戏算法演示1 贪吃蛇游戏算法演示2 贪吃蛇游戏算法演示3 贪吃蛇游戏算法演示4 &emsp;&emsp;通过这四张图的演示，我们可以发现这样一个规律： 蛇的移动其实是将蛇身体的最后一个元素移动到第一个元素的位置 &emsp;&emsp;那么完成这样一个工作需要两个步骤： 1、将在蛇头位置插入一个新的元素2、移除蛇尾位置的最后一个元素 &emsp;&emsp;好了，了解了蛇的移动后我们再来考虑一个问题，怎样判断蛇吃到了食物？思路和蛇的移动类似，主要考虑在蛇头插入的这个元素和食物的关系，如果这个元素的坐标和食物的坐标是相同的，那么就可以认为蛇吃到了食物，此时蛇的身体应该是变长的，所以只要在蛇头位置插入一个元素就可以了。反之，如果蛇没有吃到食物，那么蛇应该是移动的，所以就可以按照移动的方法来处理了。那么在蛇头位置插入的这个元素该如何确定呢？我们来看下面这段程序：1234567891011121314151617181920212223--计算下一个目标点function getNextPoint() --计算下一个目标点 snake=&#123;&#125; if(dir==0) then snake.x=snakes[1].x snake.y=snakes[1].y-20 end if(dir==1) then snake.x=snakes[1].x snake.y=snakes[1].y+20 end if(dir==2) then snake.x=snakes[1].x-20 snake.y=snakes[1].y end if(dir==3) then snake.x=snakes[1].x+20 snake.y=snakes[1].y end return snakeend &emsp;&emsp;这里定义了getNextPoint()的方法，目的是计算在蛇头位置添加的下一个元素，这里我们注意到根据蛇的移动方向(dir)的不同，其中0表示上、1表示下、2表示左、3表示右，计算出下一个元素的位置，因为在这个游戏中网格大小是20，所以这里可以直接根据坐标来计算一个元素的位置。snakes是一个table，保存的是当前的蛇的全部元素的坐标。通过维护这个table，我们就可以利用绘图的函数绘制出蛇的身体，这样蛇就可以移动起来了。我们来看看蛇是怎样移动的：123456789101112131415161718--核心算法——蛇的移动function SnakeUpdate() --获取元素个数 local n=table.maxn(snakes) if(table.maxn(snakes)&gt;0) then if(getNextPoint().x==foodX and getNextPoint().y==foodY) then --将下一个目标点的位置插入表中 table.insert(snakes, 1, getNextPoint()) --将食物状态设置为BeEated foodState=\"BeEated\" else --将下一个目标点的位置插入表中 table.insert(snakes, 1, getNextPoint()) --移除最后一个元素 table.remove(snakes,n+1) end endend &emsp;&emsp;在这里我们定义了一个foodState变量以保存食物的状态，当食物的状态为BeEated的时候表示食物被蛇吃掉了，此时应该重新生成一个食物的坐标，此时事物的状态将变成WaitToEat。食物的坐标保存在foodX和foodY这两个变量中，大家可以到完整的代码中去查看。 游戏状态我们知道蛇碰到四周墙壁的时候就会死亡，此时游戏结束。这个比较简单，只要判断蛇头的坐标和屏幕的关系就可以了。因为在这个游戏中屏幕的尺寸为640X640，所以判断游戏是否结束的代码可以这样写：123456--判断游戏状态 if(snakes[1].x&lt;=0 or snakes[1].x&gt;=640 or snakes[1].y&lt;=0 or snakes[1].y&gt;=640) then gameState=0 else gameState=1 end &emsp;&emsp;这里gameState为0表示游戏结束，gameState为1表示游戏正常进行。 完整代码&emsp;&emsp;在完成了这些核心的算法以后，剩下的事情就交给Love2D引擎来绘制吧，最后给出完整的程序代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176--定义窗口宽度和高度local w=640local h=640--定义网格单元大小local unitSize=20;--方块的初始位置local initX=320local initY=320--移动方向local dir=1--贪吃蛇集合local snakes=&#123;&#125;--食物状态--WaitToEat：绘制食物--BeEated：随机生成食物local foodState=\"WaitToEat\"--游戏状态--0：游戏结束--1：游戏正常local gameState=1--食物的位置local foodX=0local foodY=0--Love2D加载事件function love.load() --设置窗口标题 love.window.setTitle(\"Love2D-贪吃蛇游戏\") --设置窗口大小 love.window.setMode(w,h) --定义字体 myFont=love.graphics.newFont(30) --设置字体 love.graphics.setFont(myFont) --设置背景色 love.graphics.setBackgroundColor(255,255,255,255) --设置线条类型为平滑 love.graphics.setLineStyle(\"smooth\") --设置线宽 love.graphics.setLineWidth(0.1) --蛇的初始化(蛇的长度为5) for i=1,5 do snake=&#123;&#125; snake.x=initX +(i-1) * 20 snake.y=initY snakes[i]=snake end --食物初始化 foodX=love.math.random(32-1)*20 foodY=love.math.random(32-1)*20end--Love2D绘制事件function love.draw() --绘制竖线 love.graphics.setColor(0,0,0,255) for i=0,w,unitSize do love.graphics.line(0,i,h,i) end --绘制横线 for j=0,h,unitSize do love.graphics.line(j,0,j,w) end --绘制蛇 for i=1,table.maxn(snakes) do love.graphics.setColor(0,0,255,255) love.graphics.rectangle(\"fill\",snakes[i].x,snakes[i].y,20,20) end --绘制食物 if(foodState==\"WaitToEat\") then love.graphics.setColor(255,0,0,255) love.graphics.rectangle(\"fill\",foodX,foodY,20,20) end --如果游戏结束则显示GameOver if(gameState==0) then love.graphics.setColor(255,0,0,255) love.graphics.print(\"Game Over\",250,300) endend --function love.update(dt) --判断游戏状态 if(snakes[1].x&lt;=0 or snakes[1].x&gt;=640 or snakes[1].y&lt;=0 or snakes[1].y&gt;=640) then gameState=0 else gameState=1 end --如果游戏状态为正常 if(gameState==1) then SnakeUpdate() FoodUpdate() endend--核心算法——蛇的移动function SnakeUpdate() --获取元素个数 local n=table.maxn(snakes) if(table.maxn(snakes)&gt;0) then if(getNextPoint().x==foodX and getNextPoint().y==foodY) then --将下一个目标点的位置插入表中 table.insert(snakes, 1, getNextPoint()) --将食物状态设置为BeEated foodState=\"BeEated\" else --将下一个目标点的位置插入表中 table.insert(snakes, 1, getNextPoint()) --移除最后一个元素 table.remove(snakes,n+1) end endend--随机生成食物function FoodUpdate() --如果食物被蛇吃掉则重新生成食物 if(foodState==\"BeEated\") then foodX=love.math.random(32-1)*20 foodY=love.math.random(32-1)*20 foodState=\"WaitToEat\" endend--根据玩家按下的键位定义不同的方向function love.keypressed(key) if(key==\"a\") then dir=2 end if(key==\"d\") then dir=3 end if(key==\"w\") then dir=0 end if(key==\"s\") then dir=1 endend--计算下一个目标点function getNextPoint() --计算下一个目标点 snake=&#123;&#125; if(dir==0) then snake.x=snakes[1].x snake.y=snakes[1].y-20 end if(dir==1) then snake.x=snakes[1].x snake.y=snakes[1].y+20 end if(dir==2) then snake.x=snakes[1].x-20 snake.y=snakes[1].y end if(dir==3) then snake.x=snakes[1].x+20 snake.y=snakes[1].y end return snakeend &emsp;&emsp;将代码压缩成.love文件后就可以运行了，我们来看看最终的效果： Demo1 Demo2 &emsp;&emsp;本文的项目作为开源项目托管在Github上，可以通过Github来获取项目源代码。谢谢大家，今天的内容就是这样了。","tags":[{"name":"游戏开发","slug":"游戏开发","permalink":"http://qinyuanpei.github.io/tags/游戏开发/"},{"name":"Love2D","slug":"Love2D","permalink":"http://qinyuanpei.github.io/tags/Love2D/"},{"name":"贪吃蛇","slug":"贪吃蛇","permalink":"http://qinyuanpei.github.io/tags/贪吃蛇/"}]},{"title":"当梦想照进现实","date":"2015-03-10T10:45:51.000Z","path":"posts/3321992673/","text":"&emsp;&emsp;回到学校将近一周了，工作依然没有着落。每天穿梭在校园里，看着身边熙熙攘攘的人群来来往往，面对着许许多多陌生的面孔，看着太阳每天的起起落落，听着校园广播吟唱那些恍若隔世的时光。我深切地感受到作为一名即将毕业的大四学生，此时此刻站在这里是多么的多余。 &emsp;&emsp;我一直想到外面去看看，因为我觉得只有到外面去才能找到让我梦想扎根的地方。我和家里人说了我的这个想法，家里建议我先在宁夏找工作，如果在宁夏实在找不到工作再考虑出去。我听从了这个建议，可是当我开始找工作的时候，我却突然发现自己错了。如果说以前想去外面是因为觉得外面的工作找起来容易的话，那么此时此刻当我在宿舍里写下这篇文章的时候，这无疑是一种赤裸裸的讽刺了，因此我发现我在银川都找不到合适的工作。第一次推开一家公司的门，我以为只要我的技术达到了应聘的要求我就可以胜任这份工作，可是我错了，环境科学这个专业会牢牢地拴住我一辈子。当我在网上投递简历的时候，我以为我的专业对我的求职不会产生什么影响，可是我又错了，我都没想到我的简历会因为专业不符合要求而被直接忽略。在这一瞬间，我突然好后悔当初的决定，我后悔选择了宁夏大学这样一个本地的211 ，我后悔选择了环境科学这样一个我从来没有喜欢过却要羁绊我一生的专业。 &emsp;&emsp;三叔从我大三的时候就开始关注我的工作问题，他当年农校毕业后工作辗转多次终于在镇上做了一个司法所的所长，有次他跟我说起当年农校里同学现在的情况时，提出了一个叫做不务正业的观点，就是说当年农校里的那些同学现在都是在做着和农校时候学到无关的工作。我不知道这样的现象是不是中国教育的一个缩影，因此我不能评价这种想法到底是对还是错。可是当我那天把去年买的教材送给一名前来借书的学弟的时候，我突然沉默了好久。我的父母含辛茹苦地供我上大学，即使是这样一个我从来没有喜欢的专业，可是我却轻而易举地将这种付出像丢垃圾一样撇在一边，到底环境科学专业对我意味着什么？到底这大学四年对我意味着什么？是我一直在努力想要想明白却始终想不明白的问题。 &emsp;&emsp;我就是想单纯地去解决技术上的问题，然后通过技术让我们的生活更加美好。我一直觉得这样的想法会成为我一生都去奋斗的信仰，可是当我回顾四周的时候看到有的人早已找到工作，我真的不明白，到底是我想要的太多不肯放下身段去做些没有技术含量的工作，还是这个世界的价值存在某种扭曲：一个人要花费四年的时光去做些一辈子里只能做一次的事情，可是当付出了那么多以后突然发现生命里早已有了定数，你想要试图改变的可能仅仅因为环境科学这四个字就变成空想，你最终踏上的注定是和大部分一样平凡的生命。 &emsp;&emsp;此时此刻，我处在环境科学和游戏的夹缝里，环境科学我本不喜欢，从来没有想要在这个领域谋生的打算，可是当我想要做些什么的时候，我却在这座城市里渐渐迷失了方向。网页开发、电子商务、设备维护这些仅仅是计算机行业中的一部分工作，可是大部分人都认为这就是我喜欢的计算机行业，这是吗？我在心里暗暗问自己。我去那家公司应聘的时候，公司里有个人建议我到外面去报个培训班，因为他觉得我在大学里学的和企业需求完全是两回事，可是我作为一个应届毕业生，我原本就是希望到公司里去学习实际的项目经验的，你为什么就要要求我有两到三年的经验呢，我想就算是研究生都不可能天天待在公司里慢慢积累经验吧。我没有抱怨的意思，我只是想让自己快些找到合适的工作，我实在不想继续在这样纠结下去了，希望明天到招聘会上会有所收获吧！","tags":[{"name":"梦想","slug":"梦想","permalink":"http://qinyuanpei.github.io/tags/梦想/"},{"name":"现实","slug":"现实","permalink":"http://qinyuanpei.github.io/tags/现实/"},{"name":"毕业季","slug":"毕业季","permalink":"http://qinyuanpei.github.io/tags/毕业季/"}]},{"title":"HTML5游戏开发技术基础整理","date":"2015-03-08T19:14:44.000Z","path":"posts/2038378679/","text":"&emsp;&emsp;随着HTML5标准最终敲定，HTML5将有望成为游戏开发领域的的热门平台。HTML5游戏能够运行于包括iPhone系列和iPad系列在内的计算机、智能手机以及平板电脑上，是目前跨平台应用开发的最佳实施方案。本文系根据[HML5 Canvas游戏开发实战]一书中的内容整理而成，是了解和学习HTML5游戏开发的基础内容，希望能够帮助到那些和博主一样致力于游戏开发的朋友们！ JavaScript中的面向对象编程&emsp;&emsp;对于游戏开发来说，面向对象编程(OOP)是一种重要而且必要的方法，所以在了解HTML5游戏开发前，首先应该了解JavaScript中的面向对象编程。JavaScript是一种基于对象的语言，可它并不是一种真正的面向对象的编程语言，因为在JavaScript的语法中不存在类(Class)的概念。下面我们将分析和解决在JavaScript中实现封装、继承等面向对象的问题。 在JavaScript中函数(function)就是就是一个类(class)1234//声明一个函数function MyClass()&#123;&#125;//实例化一个对象var cls1 = new MyClass(); 使用this关键字就可以为类增加属性12345678910//声明一个类并定义其构造函数function MyClass(name,age)&#123; this.name = name; this.age = age;&#125;;//实例化一个对象var cls1 = new MyClass(\"张三\",20)//输出cls1的两个属性值alert(\"name=\" + cls1.name + \"&amp;\" + cls1.age) 使用prototype属性可以为类添加方法12345678910111213141516171819202122//声明一个类并定义其构造函数function MyClass(name,age)&#123; this.name = name; this.age = age;&#125;;//为MyClass增加方法MyClass.prototype=&#123; toString:function() &#123; alert(\"name=\" + this.name + \"&amp;\" + this.age) &#125;, getName:function() &#123; alert(\"name=\" + this.name) &#125;, getAge:function() &#123; alert(\"age=\" + this.age) &#125;&#125;; 使用apply方法实现属性和方法的继承12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//定义一个父类Peoplefunction People()&#123; this.type=\"人\"&#125;;//为父类定义一个方法People.prototype=&#123; getType:function() &#123; alert(\"type=\" + this.type) &#125;&#125;;//定义一个子类Studentfunction Student(name,age,sex)&#123; //继承父类的属性type People.apply(this,arguments); this.name = name; this.age = age; this.sex = sex;&#125;;//声明一个Student实例var stu = new Student(\"张三\",20,\"男\")；//输出typealert(stu.type)//下面我们来了解下如何继承父类的方法，继承父类方法主要通过循环使用父对象的prototype进行复制来实现，如//重新定义子类Studentfunction Student(name,age,sex)&#123; //继承父类的属性type People.apply(this,arguments); //继承父类的方法，略显抽象 var prop; for(prop in People.prototype) &#123; var proto = this.constructor.prototype; if(!proto[prop]) &#123; proto[prop] = People.prototype[prop]; &#125; proto[prop][\"super\"] = People.prototype; &#125; //属性定义 this.name = name; this.age = age; this.sex = sex;&#125;;//实例化Student对象var stu = new Student(\"张三\",20,\"男\");stu.getType(); 静态类的实现1234567891011function staticClass()&#123; staticClass.name = \"张三\"; staticClass.toString=function &#123; alert(\"name=\" + staticClass.name ) &#125;;&#125;;alert(staticClass.name);staticClass.toString(); Canvas绘图基础HTML5提供了图像、视频、音频、表单、位置、本地数据库、离线存储、websocket等各种全新的特性，对于HTML游戏开发而言，我们主要关注图像、音频、本地数据库以及websocket等，首先我们来了解下Canavs绘图的基础内容。 &emsp;&emsp;Canvas是HTML5为我们提供的一张画布，可以让我们在HTML上直接绘制图形，因此Canvas可以作为HTML5游戏开发的基本元素，即HTML5游戏引擎的底层都是以Canvas元素来驱动的。Canvas本身没有绘图的能力，需要借助于JavaScript来实现绘图的功能。使用Canvas元素只需要在网页中添加canvas标记即可，如1&lt;canvas id=\"myCanavs\" width=\"800\" height=\"480\"&gt;&lt;/canvas&gt; &emsp;&emsp;接下来我们通过JavaScript来获取这个Canvas并通过相关API实现绘图环境的初始化12345678//获取Canvas元素var canvas = document.getElementById('myCanvas');//检查canvas合法性if(canvas &amp;&amp; canvas.getContext)&#123; //获取当前上下文 var ctx = canvas.getContext('2d') &#125; &emsp;&emsp;因为目前Canvas只支持2D绘图，因此，这里的参数暂时只能为2d。因为Cnavas绘图的API都封装在ctx这个实例中，因此下面的所有操作都是基于ctx来实现的： 使用Canvas绘制线123456789101112//设置线宽ctx.lineWidth = 10;//设置画笔颜色ctx.strokeStyle = \"red\";//创建一个路径ctx.beginPath();//路径起点ctx.moveTo(10,10);//路径终点ctx.lineTo(150,50);//绘制路径ctx.stroke(); 使用Cnavas绘制矩形12345678//设置线宽ctx.lineWidth=5;//设置画笔颜色ctx.strokeStyle-\"red\"//创建路径ctx.beginPath();//绘制矩形ctx.strokeRect(10,10,70,40); &emsp;&emsp;或者1234//定义矩形ctx.rect(10,10,70,40);//绘制矩形ctx.stroke(); 如果需要对矩形进行填充1234//创建路径ctx.beginPath()//绘制矩形ctx.fillRect(10,10,70,40) 使用Canvas绘制圆123456//创建路径ctx.beginPath();//定义圆ctx.arc(100,100,50,0,360*Math.PI/180,true);//绘制圆ctx.stroke(); &emsp;&emsp;同样地，可以使用fill进行填充绘制123456//创建路径ctx.beginPath();//定义圆ctx.arc(100,100,50,0,360*Math.PI/180,true);//绘制圆ctx.fill(); 使用Canvas绘制圆角矩形绘制圆角矩形需要arcTo函数配合lineTo来完成12345678910111213//创建路径ctx.beginPath();ctx.moveTo(40,20);ctx.lineTo(100,20);ctx.arcTo(100,20,120,40,20);ctx.lineTo(120,70);ctx.arcTo(120,90,100,90,20);ctx.lineTo(40,90);ctx.arcTo(20,90,100,70,20);ctx.lineTo(20,40);ctx.arcTo(20,20,40,20,20);//绘制圆角矩形ctx.stroke(); 使用Canvas绘制复杂图形&emsp;&emsp;在HTML5中可以通过quadraticCurveTo函数绘制二次贝塞尔曲线，通过bezierCurveTo函数绘制三次贝塞尔曲线,具体代码请参考API文档。 使用Canvas绘制文字1234//设置字体ctx.font=\"30px Arial\";//绘制文字ctx.strokeText(\"Hello HTML5\",100,50); 使用Canvas绘制图片&emsp;&emsp;绘制图片使用drawImage函数，其函数原型如下：1drawImage(image,dx,dy); &emsp;&emsp;其中image可以是HTML中的标签或者是JavaScript中的Image对象。如12//定义一个img标签&lt;img id=\"img_source\" src=\"source.jpg\" width=\"240\" height=\"240\"/&gt; &emsp;&emsp;接下来通过getElementById来取得图像数据，并将其绘制出来12var img=document.getElementById(\"img_source\");ctx.draw(img,200,200); &emsp;&emsp;如果直接使用JavaScript代码123var img=new Image();img.src=\"source.jpg\";ctx.draw(img,200,200) 图形的平移操作&emsp;&emsp;使用translate函数实现在水平和垂直方向上的平移 图形的旋转操作&emsp;&emsp;使用rotate函数实现旋转，需要注意的是传入的参数是弧度 图形的伸缩操作&emsp;&emsp;使用scale函数实现伸缩，当参数为负值时表示在该方向上翻转 图形高级特效&emsp;&emsp;这里主要介绍线性渐变、径向渐变、颜色反转、灰度。 ####线性渐变1234567//创建一个线性渐变容器var grd=ctx.createLinearGradient(0,0,200,0);//添加颜色grd.addColorStop(0.2,\"#00ff00\");grd.addColorStop(0.8,\"#ff0000\");//应用渐变ctx.fillStyle=grd; ####径向渐变1234567//创建一个径向渐变容器var grd=ctx.createRadialGradient(100,100,10,100,100,50);//添加颜色grd.addColorStop(0,\"#00ff00\");grd.addColorStop(,\"#ff0000\");//应用渐变ctx.fillStyle=grd; ####颜色反转&emsp;&emsp;遍历每个像素并对RGB值进行取反 ####灰度&emsp;&emsp;灰度计算公式：gary=red0.3+green0.59+blue*0.11 &emsp;&emsp;基础的内容就是这些了，以后如果碰到需要HTML5的地方可以回过头来看看。","tags":[{"name":"游戏","slug":"游戏","permalink":"http://qinyuanpei.github.io/tags/游戏/"},{"name":"HTML5","slug":"HTML5","permalink":"http://qinyuanpei.github.io/tags/HTML5/"},{"name":"技术","slug":"技术","permalink":"http://qinyuanpei.github.io/tags/技术/"}]},{"title":"互联网黑洞读书笔记(2)","date":"2015-02-11T15:50:55.000Z","path":"posts/1930050594/","text":"&emsp;&emsp;在移动互联网时代地大潮中，微信无疑是整个行业的弄潮儿。从“微信之父”张小龙最初定义微信这个产品的那一刻开始，就注定微信将走上一条平台化的道路，各种各样可能的商业模式成为人们开始不断探索微信的价值，可是这一切和你有关系吗？ 在中国这种人情社会，越来越脆弱的信任纽带，急需有微信这样的工具来加固；越来越高的交往成本，更急需微信这样的工具来降低。 &emsp;&emsp;微信给中国社会带来的强大震感和冲击，其实仅仅是一个很小的圈子。互联网讲究的是大格局，强调的是跨越时空。可是大部分的中国人都不在这个格局里，我们不具备穿越时空的条件。每个人都有自己的中国梦，可是你扪心自问：你跟别人的中国梦共同的有多少呢？换句话说，我们每一个人都很宅，而微信不过是让我们更宅而已，不管有没有微信，我们都是在过着柴米油盐酱醋茶这样的普通人的生活，而中国人性格里会不由自主的对外界进行自我戒备，我们的圈子其实就那么大。 每个人都不容易，不能再彼此伤害。互联网思维，是一种开明的思维，一种能看到大格局的思维，一种超越自我的思维。 &emsp;&emsp;就像大部分人所理解的互联网一样，互联网的自由精神在带给我们便利的生活的同时，给某些人以可乘之机，使得我们距离互联网近在咫尺而又遥不可及，我们都习惯于互联网带给我们的这种便利，可是在我们内心深处我们仍然将互联网视为洪水猛兽。 在世界范围内，全民制衡历来是种对社会有价值的力量。这种制衡一旦制度变化，就会变得持续而稳定，直接后果就是国家的回归。依次是三种境界：回归社会、回归国民、回归自然。 &emsp;&emsp;我从来不喜欢政治，因为是政治是一种极其微妙的东西，正直且单纯的人永远不适合政治，可是因为互联网的舆论作用，互联网所代表的全民制衡开始不断地和政治发生着反应，互联网精神的终极目标从来都不是取代和颠覆现有的模式，而是希望在和政治博弈的过程中让这个世界更加美好。 因为互联网文明将摧毁一切旧的东西，一切大家习以为常的东西。在互联网面前，每个人都是平等的，大家可以通过网络获取信息、获取服务，互联网发展到今天，当我们每个人都对身边的一切习以为常的时候，互联网却在不断地改变我们与世界接触的方式，这就是创新，这就是变革。 &emsp;&emsp;当互联网以一种新的模式去颠覆现有模式的时候，任何的以政治理由为出发点的干预在我看来都是徒然的，因为干预者之所以干预无非是因为这种变革影响到了其利益，可是不管怎样，政治本身并不具备互联网的思维，国家队的搜索在市场竞争中失败便是最好的例子。 不仅仅上流社会和主流社会漠视互联网，全社会都漠视互联网。 &emsp;&emsp;我们每个人每天都在使用互联网，可是我们真的了解互联网吗？我们不可或缺地依赖着互联网，却从来不对为这个行业努力付出的程序员们表示尊敬，如果有一天这个世界没有了互联网，有多少人的生活会变得混乱不堪？ 互联网的人文属性，决定了盈利模式的地域局限和社会差异。从互联网第一天进入中国，一直到今天，无数美国的盈利模式，都没在中国火起来，这就是互联网的人文属性。 &emsp;&emsp;每一个国家、每一个地区的互联网盈利模式都会存在差异，这就是互联网的人文属性。例如国外用户都有购买付费软件的习惯，可是在中国人们更喜欢盗版甚至破解。中国互联网的一个特点是免费，可是免费从来都是最贵的。如果你需要一个功能，国外用户会选择一个软件，国内用户则会选择XX助手，这就是人文上的差异。 张小龙给了我们三个启示 关系能为技术带来超乎想象的附加值 移动互联网的附加值压迫基于本土实现 新型移动应用在垄断用户数据方面更具魔力 &emsp;&emsp;当我们感慨移动互联网的时候，大数据时代已经悄然来临，在大数据时代每个人的数据都是一个数据云，如果我们能够将这些数据收集起来加以利用的话，那么这可能就是大数据时代留给我们的机会吧。 无论是什么思维，不能解决问题，便没有价值。 &emsp;&emsp;如果要问我为什么想去做一名程序员，我会说因为我喜欢解决问题。 马化腾的故事告诉我们：不回到原点，不立足初始化的逻辑，世界对你而言，将会越来越陌生。 &emsp;&emsp;以前我的叔叔告诉我，就算没有百度，这个世界仍会有千度甚至万度。可是此时此刻我终于明白，复制一种产品相对容易，可是如何发挥自我的优势将产品做到极致，这是制胜的关键，所以我仍然认为没有人可以比李彦宏更了解搜索、做好搜索。微信的成功并非是微信在技术上的成功，而是腾讯懂得重新审视自我、突破自我，这是用户关系上的成功。 其实人生如白驹过隙，到头来不过是关系这两个字而已。 &emsp;&emsp;正如儒家研究人与人间的关系、道家研究人与自己的关系、佛家研究人的今生与前世的关系，归根到底都是关系，人活着所以幸苦，不过是将大量的时间用到了维护人与人的关系上去，这就是互联网的本质——关系。 任何形式的大大小小的互联网，无非是让我们彼此、让我们跟世界无限趋近于无缝连接而已。这种连接，就是彼此的回归。 &emsp;&emsp;桌面互联网让我们更好地获取信息、移动互联网让我们更好地获取服务、大数据则让我们更好地获取关系。 有意无意间，机会会变得有限而无限。超越是以别人为目标的颠覆，就是想打垮对方;颠覆是以自己为目标的超越，首先是孵化自己。虽然都是有意的，目标很明确，结果却不同。 &emsp;&emsp;同一价值体系内的超越和颠覆，固然有意义，然而体系与体系间的超越和颠覆却更加致命。 搜索引擎，至今仍然是互联网的制高点，搜索决定访问，离开有效访问，就没有一切，因此搜索确定一切。 &emsp;&emsp;尊重自然搜索、搜索决定一切是现代网络营销的核心，离开这些一切都是徒劳的。","tags":[{"name":"互联网","slug":"互联网","permalink":"http://qinyuanpei.github.io/tags/互联网/"},{"name":"哲学","slug":"哲学","permalink":"http://qinyuanpei.github.io/tags/哲学/"},{"name":"微信","slug":"微信","permalink":"http://qinyuanpei.github.io/tags/微信/"},{"name":"人文","slug":"人文","permalink":"http://qinyuanpei.github.io/tags/人文/"}]},{"title":"使用Mecanim动画系统来控制2D动画","date":"2015-02-11T13:35:58.000Z","path":"posts/2583252123/","text":"各位朋友，大家好，我是秦元培，欢迎大家关注我的博客，我的博客地址是http://blog.csdn.net/qinyuanpei。今天我想和大家分享的话题是在Unity3D中使用Mecanim动画系统来控制2D动画。 相信在大家的印象中，Mecanim动画系统主要运用在3D动画中，因为Mecanim动画系统提供了像动画重定向、人体骨骼动画等3D动画的特性，那么Unity3D的Mecanim动画系统能不能用来控制2D动画呢？如果在以前，博主和大家的理解是一样的，认为Mecanim只能运用到3D动画中，对于2D动画只能使用传统的逐帧动画和骨骼动画。可是前不久有位朋友问我，为什么不使用动画组件来控制2D动画呢？博主心想啊，这Mecanim动画系统真的能控制2D动画吗？经过博主查找大量资料和亲身实践，发现Mecanim是可以用来控制2D动画的，而且由于状态机的引入，我们对动画状态的控制会变得更为简单，从写代码的角度来看，这样可以减少我们的代码量便于维护。那么好了，今天我们就来一起学习下如何使用Mecanim动画系统来控制2D动画吧！ #传统2D动画的实现方式在Unity3D中传统2D动画的实现方式是基于逐帧动画的原理实现的，这种实现方式在Unity3D没有推出Unity2D前甚至在Unity2D推出后相当长的一段时间内，基本上我们最为常用的实现方式，博主在刚开始学习Unity3D的时候通常是以2D形式来展开的，因为博主认为2D和3D在原理上基本是相通的，如果我们掌握了2D游戏的基本原理，那么在实现3D游戏的时候就会相对容易些。我们来看看一个最简单的2D动画的脚本实现：12345678910111213141516171819202122232425262728293031323334353637//精灵渲染器private SpriteRenderer mRenderer;//精灵集合public Sprite[] Sprites;//FPS,即每秒钟的画面帧数public float FPS = 24;//精灵索引private int index = 0;//当前时间private float currentTime = 0;void Start () &#123; mRenderer = GetComponent&lt;SpriteRenderer&gt;();&#125; void Update () &#123; //获取当前时间 currentTime += Time.deltaTime; //如果达到了更新画面的时间 if(currentTime &gt;= 1 / FPS) &#123; //使索引增加 index += 1; //清除时间记录 currentTime = 0; //当索引更新到最后一帧时,索引重置 if(index &gt;= Sprites.Length) &#123; index = 0; &#125; &#125; //更新画面 mRenderer.sprite = Sprites[index];&#125; 通过分析，我们可以发现这段脚本存在以下问题： 动画维护困难：每增加一个动画就需要添加一个数组，不仅增加了动画的维护难度，同时降低了脚本的效率。 状态维护困难：因为在Update方法里实现的是一个动画，因此当我们需要在各个动画状态间进行切换的时候，我们需要使用更多的代码来维护相关逻辑。 #使用Mecanim动画系统的实现方式为了解决传统的2D动画实现方式中存在的动画维护困难、状态维护困难这两个问题，我们需要一种更好的方案来实现2D动画的控制，这种方案需要提供较为方便的动画维护功能，即各个动画是独立的，当改变了某一个动画时，其余的动画不会发生改变。其次，这种方案需要提供较为方便的状态维护功能，即各个动画状态切换是方便的，我们可以更好地从这一种状态切换到另一种状态。关于动画状态切换，大家可以去了解下有限状态机(FSM)的概念，这里我们不做深入的探究，这里我们选择Unity3D的Mecanim动画系统，因为Mecanim动画系统正好解决了这两个问题。好了，下面我们来一起学习一个2D动画的实例：首先我们在场景中创建一个名为PlayerController的空物体，然后在该物体的下面增加一个精灵组件(Sprite),并将其命名为PlayerSprite，这样做的好处是Unity3D将为我们自动创建较为规范的命名。好了，现在我们选择PlayerController这个物体，然后通过Window-&gt;Animation菜单打开Animation窗口： 首先我们点击AddCurve按钮，此时将弹出一个对话框让我们保存动画文件，这里我们存储为Player@Idle.anim,并将其保存在项目目录下的Animations\\Player目录下，这样可以方便我们维护和查找特定的动画文件。在保存完动画文件后，此时会弹出如下的界面，我们选择PlayerSprite节点下的SpriteRenderer，然后选择Sprite，因为这里我们的2D动画主要是通过改变SpriteRenderer的Sprite属性来实现的，最后我们点击Sprite节点后面的加号来完成对象的选取。此时会在动画窗口中显示时间轴和刻度线，我们将在这里完成动画的编辑。大家可以注意到默认情况下，动画面板添加了两帧，即第1帧和最后一帧，其总时间是1秒，同时我们注意到这里有一个采样率(Sample),其实这就是当前动画的FPS了。好了，现在我们开始制作第一个动画： 在资源文件夹中，我们可以找到当前动画的图片素材，注意到这个图片中总共有12帧画面，因此我们可以按照0.05s的间隔来分配整个时间轴，所以我们可以这样添加帧： 好了，现在我们就完成了一个Idle动画的制作，现在打开角色的动画控制器PlayerController，这是Unity3D为我们自动创建的一个动画控制器，因为我们现在只有一个Idle动画，所以在Animaotr窗口中我们可以看到只有一个Idle状态，现在我们将这个状态设为默认状态。好了，现在我们可以直接运行游戏，发现在场景中角色开始循环播放Idle动画了。好了，现在让我们重复刚才的步骤，来完成角色的其余动画。 经过一番努力，我们现在已经完成了角色所有动画的制作，现在我们来设计角色的动画状态机： 设计好角色的动画状态机后我们开始来编写脚本，以实现角色动画的控制： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143using UnityEngine;using System.Collections;public class PlayerController : MonoBehaviour &#123; public enum PlayerState &#123; Idle, Move, LightAttack, WeightAttack &#125; public PlayerState State=PlayerState.Idle; //玩家移动速度 public float WalkSpeed = 0.75f; public float RunSpeed = 1.5f; //玩家跳跃力的强度 public float JumpForce = 200f; //位置限制 public float MinX = -5.80f; public float MaxX = 5.80f; public float MinY = -1.80f; public float MaxY = 0.35f; //玩家朝向，默认朝右 public bool isFaceRight = true; //动画组件 private Animator mAnim; //2D刚体 private Rigidbody2D mRig2D; void Start () &#123; mAnim=GetComponent&lt;Animator&gt;(); mRig2D=GetComponent&lt;Rigidbody2D&gt;(); &#125; void Update() &#123; SpriteMove(); SpriteAttack(); SpriteJump(); SpriteIdle(); &#125; /// &lt;summary&gt; /// 精灵Idle /// &lt;/summary&gt; private void SpriteIdle() &#123; //当玩家无任何操作时恢复到Idle状态 if (!Input.anyKey) &#123; mAnim.SetBool(&quot;Jump&quot;, false); mAnim.SetBool(&quot;Attack&quot;, false); mAnim.SetBool(&quot;BigAttack&quot;, false); mAnim.SetBool(&quot;Skill&quot;, false); mAnim.SetBool(&quot;BigSkill&quot;, false); State=PlayerState.Idle; &#125; &#125; /// &lt;summary&gt; /// 精灵攻击 /// &lt;/summary&gt; private void SpriteAttack() &#123; //轻击，键位J if(Input.GetKey(KeyCode.J)) &#123; mAnim.SetBool(&quot;Attack&quot;, true); State=PlayerState.LightAttack; &#125; //重击，键位K if(Input.GetKey(KeyCode.K)) &#123; mAnim.SetBool(&quot;BigAttack&quot;, true); State=PlayerState.WeightAttack; &#125; &#125; /// &lt;summary&gt; /// 精灵跳跃 /// &lt;/summary&gt; private void SpriteJump() &#123; if (Input.GetKey(KeyCode.I)) &#123; mAnim.SetBool(&quot;Jump&quot;, true); mRig2D.AddForce(new Vector2(0, Time.deltaTime * JumpForce), ForceMode2D.Impulse); &#125; &#125; private void SpriteMove() &#123; float h = Input.GetAxis(&quot;Horizontal&quot;); float v = Input.GetAxis(&quot;Vertical&quot;); Vector2 mPos = mRig2D.position; mAnim.SetFloat(&quot;Speed&quot;, Mathf.Sqrt(h * h + v * v)); float mPosX, mPosY; if (Mathf.Sqrt(h * h + v * v) &gt; 0.5f)&#123; mPosX = mPos.x + h * Time.deltaTime * RunSpeed; mPosY = mPos.y + v * Time.deltaTime * RunSpeed; &#125;else&#123; mPosX = mPos.x + h * Time.deltaTime * WalkSpeed; mPosY = mPos.y + v * Time.deltaTime * WalkSpeed; &#125; mRig2D.MovePosition(new Vector2(mPosX, mPosY)); if (h &gt; 0 &amp;&amp; !isFaceRight) &#123; FlipSrite(); &#125; else if (h &lt; 0 &amp;&amp; isFaceRight) &#123; FlipSrite(); &#125; &#125; void FlipSrite() &#123; if(isFaceRight)&#123; transform.rotation=Quaternion.Euler(0,180,0); isFaceRight=false; &#125;else&#123; transform.rotation=Quaternion.Euler(0,0,0); isFaceRight=true; &#125; &#125;&#125; 好了，现在我们可以来看看最终的效果，博主这里是想利用这些素材来制作一个横板过关的游戏，可是因为文章篇幅有限，所以这部分内容只能留到以后再和大家分享了。 #Mecanim动画系统应用扩展好了，到现在为止，基于Mecanim动画系统的2D动画控制基本上讲解完了。下面我们说说Mecaanim动画系统应用扩展。通过前面的学习，我们知道Unity2D使用的Mecanim动画系统主要是通过改变游戏体的属性来实现某种特定的动画效果的，例如我们这里的动画是通过改变角色精灵附加的SpriteRenderer组件的Sprite属性来实现的，因此从本质上来说Unity2D的动画控制器是一种属性动画。总体来说，Unity2D可以实现以下类型的动画： 位移动画：通过Transform组件的Position属性实现 旋转动画：通过Transform组件的Rotation属性实现 伸缩动画：通过Transform组件的Scale属性实现 渐变动画：通过更改指定组件的颜色或材质实现 脚本动画：通过更改指定脚本的变量或字段实现 好了，这就是今天这篇文章的全部内容了，希望大家喜欢！","tags":[{"name":"Unity3D","slug":"Unity3D","permalink":"http://qinyuanpei.github.io/tags/Unity3D/"},{"name":"Mecanim","slug":"Mecanim","permalink":"http://qinyuanpei.github.io/tags/Mecanim/"},{"name":"动画","slug":"动画","permalink":"http://qinyuanpei.github.io/tags/动画/"}]},{"title":"脚本语言编程：Lua脚本编程入门","date":"2015-02-03T16:06:31.000Z","path":"posts/1940333895/","text":"Lua是一门简单而强大的语言，其本身强大的扩展性使得这门语言在游戏设计等领域发挥着重要的作用。博主曾在Unity3D中使用过这门语言，并且针对Lua和Unity、C++等方面的内容进行了学习和讨论。最近因为在【游戏脚本高级编程】这本书中详细介绍了Lua脚本的相关内容，因此在这里记录下博主的读书心得，方便以后在需要的时候查阅。 ###Lua系统构成Lua系统由Lua链接库、Luac编译器、Lua解释器三部分构成。 Lua链接库主要由lua.lib和lua.h这两个文件组成。Lua链接库主要负责对自身进行初始化及关闭操作、装载脚本与执行脚本、提供可调用交互接口。 Luac编译器是一个由命令行驱动的编译器，其名称为Luac。当我们需要使用Luac编译器来编译一个脚本时，只需输入 1&gt;luac &lt;FileName&gt; //FileName为脚本名称 我们可以直接通过Lua链接库来装载脚本并在装载的过程中实现动态编译，可是这样会造成两个问题，即无法在动态编译过程中获取错误信息和动态编译使脚本加载速度变慢，在使用的时候应该注意到这个问题。 Lua解释器是一个由命令行驱动的代码运行环境，我们可以直接在这个环境中运行和测试脚本代码。 ###Lua脚本语法 注释：Lua脚本的注释以–开始，如 1&gt; --这是一句注释 当我们需要对多行脚本进行注释的时候，可以采取手动换行的方式进行多个单行的注释。 变量：Lua脚本中的变量是无类型的、隐式声明、首个字符必须是非数字字符、对大小写敏感。Lua脚本中变量的一个重要特性生支持多重赋值，即允许在赋值运算符的左边同时写下多个变量。如 123456-- 变量个数等于数值个数x,y,z=1,2,3-- 变量个数大于数值个数,z的值为nilx,y,z=1,2-- 变量个数小于数值个数,3这个数值将被忽略x,y=1,2,3 数据类型：在Lua中支持6种数据类型，即数字(number)、字符串(string)、函数(function)、表(table)、用户数据(userdata)、空值(nil)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445数字(number)指整型和浮点型的数据。字符串(string)指字符串类型的数据。函数(function)指一个正式声明的函数的引用。如：function fib(n) if(n&lt;2) then return n else return fib(n-1)+fib(n-2) endend-- 在Lua中函数可以赋值给变量fib2=fib-- 调用fib函数print(fib2(5))表(table)是Lua语言中最简单同时是最复杂的数据结构：简单如普通数组，复杂如链表、字典、类等。-- 我们在构造一个数据集合时，不需要指定数据类型和数据大小-- 完成初始化后的数据集合默认索引从1开始，除非显示地声明索引0处的数值-- 构造一个数字类型的数组IntArray=&#123;1,2,3,4,5&#125;-- 构造一个字符串类型的数组StringArray=&#123;\"A\",\"B\",\"C\",\"D\"&#125;-- 打印IntArray的第一个元素,输出为1print(IntArray[1])-- 显示声明StringArray索引0处的数值StringArray[0]=\"E\"-- 打印StringArray的第一个元素和第二个元素，输出为E,Aprint(StringArray[0],StringArray[1])-- 打印一个越界的数组值，输出为nilprint(IntArray[10])-- 在Lua中表的数据类型可以是不同的table[0]=\"table\"table[1]=1-- 在Lua中表的索引可以是任意类型,因为表是基于键-值原理来工作的Enemy=&#123;&#125;Enemy[\"Name\"]=\"Enemy\"Enemy[\"HP\"]=100Enemy[\"Speed\"]=30-- 特别地，如果Key是一个合法的字符串类型，那么Table[Key]与Table.Key是等价的。Enemy=&#123;&#125;Enemy.Name=\"Enemy\"Enemy.HP=100Enemy.Speed=30用户数据(userdata)是Lua语言中一个特殊的数据类型，它允许在Lua脚本的变量中存放C语言中的指针。空值(nil)是各种语言中通用的一种数据类型，在此不再赘述。在Lua脚本中我们可以使用type()函数来获取任意数据的类型 逻辑与表达式：Lua和大部分的编程类似支持加减乘除等运算，不同的是在Lua中使用~=来表示不等关系。Lua支持的条件逻辑主要有if-then-else以及嵌套的if-then-else，Lua不支持switch结构。Lua支持的循环结构主要有while、for、repea三种结构，如： 12345678910111213141516171819202122-- 这是一个while循环i=0while(i&lt;10) do i++ print(i)end-- 这是一个for循环for i=0,10 do print(i)end -- 这是一个repeat循环repeat print(i) i++until(i&gt;10)-- 这是一个扩展的for循环，类似于Foreach结构,主要用来遍历表(table)for key,value in tables do print(k,value)end ###Lua与C/C++交互Lua与C/C++交互主要通过Lua 提供的C API来完成，其核心是Lua堆栈，一个简单的C++代码调用Lua脚本的示例代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;iostream&gt;using namespace std;#include &lt;iostream&gt;extern \"C\" &#123;#include \"lua.h\"#include \"lualib.h\"#include \"lauxlib.h\"&#125;using namespace std;int main()&#123; //创建Lua环境 lua_State* L=luaL_newstate(); //打开Lua标准库,常用的标准库有luaopen_base、luaopen_package、luaopen_table、luaopen_io、 //luaopen_os、luaopen_string、luaopen_math、luaopen_debug luaL_openlibs(L); //下面的代码可以用luaL_dofile()来代替 //加载Lua脚本 luaL_loadfile(L,\"script.lua\"); //运行Lua脚本 lua_pcall(L,0,0,0); //将变量arg1压入栈顶 lua_getglobal(L,\"arg1\"); //将变量arg2压入栈顶 lua_getglobal(L,\"arg2\"); //读取arg1、arg2的值 int arg1=lua_tonumber(L,-1); int arg2=lua_tonumber(L,-2); //输出Lua脚本中的两个变量 cout &lt;&lt;\"arg1=\"&lt;&lt;arg1&lt;&lt;endl; cout &lt;&lt;\"arg2=\"&lt;&lt;arg2&lt;&lt;endl; //将函数printf压入栈顶 lua_getglobal(L,\"printf\"); //调用printf()方法 lua_pcall(L,0,0,0); //将函数sum压入栈顶 lua_getglobal(L,\"sum\"); //传入参数 lua_pushinteger(L,15); lua_pushinteger(L,25); //调用printf()方法 lua_pcall(L,2,1,0);//这里有2个参数、1个返回值 //输出求和结果 cout &lt;&lt;\"sum=\"&lt;&lt;lua_tonumber(L,-1)&lt;&lt;endl; //将表table压入栈顶 lua_getglobal(L,\"table\"); //获取表 lua_gettable(L,-1); //输出表中第一个元素 cout &lt;&lt;\"table.a=\"&lt;&lt;lua_tonumber(L,-2)&lt;&lt;endl; //调用C++方法首先需要注册该方法 lua_register(L, \"AverageAndSum\", AverageAndSum);&#125;static int AverageAndSum(lua_State *L)&#123; //返回栈中元素的个数 int n = lua_gettop(L); //存储各元素之和 double sum = 0; for (int i = 1; i &lt;= n; i++) &#123; //参数类型处理 if (!lua_isnumber(L, i)) &#123; //传入错误信息 lua_pushstring(L, \"Incorrect argument to 'average'\"); lua_error(L); &#125; sum += lua_tonumber(L, i); &#125; //传入平均值 lua_pushnumber(L, sum / n); //传入和 lua_pushnumber(L, sum); //返回值的个数，这里为2 return 2;&#125; 请确保在计算机中安装了Lua环境，并在VC++目录中添加相关的头文件引用和库文件引用。相应的Lua脚本代码定义如下：12345678910111213141516171819202122232425--在Lua中定义两个变量arg1=15arg2=20--在Lua中定义一个表table=&#123; a=25, b=30&#125;--在Lua中定义一个求和的方法function sum(a,b) return a+bend--在Lua中定义一个输出的方法function printf() print(\"This is a function declared in Lua\")end--在Lua中调用C++中定义并且注册的方法average,sum=AverageAndSum(20,52,75,14)print(\"Average=\".average)print(\"Sum=\".sum)","tags":[{"name":"游戏","slug":"游戏","permalink":"http://qinyuanpei.github.io/tags/游戏/"},{"name":"Lua","slug":"Lua","permalink":"http://qinyuanpei.github.io/tags/Lua/"},{"name":"脚本语言","slug":"脚本语言","permalink":"http://qinyuanpei.github.io/tags/脚本语言/"},{"name":"语法","slug":"语法","permalink":"http://qinyuanpei.github.io/tags/语法/"}]},{"title":"互联网黑洞读书笔记(1)","date":"2015-02-03T09:45:57.000Z","path":"posts/1478979553/","text":"&emsp;&emsp;互联网是什么？当我们都渐渐习惯将互联网当作生活的一部分的时候，面对这样一个问题，我们似乎是迷茫和困惑的。因为当互联网渐渐地开始改变我们生活的那一刻起，我们就在和互联网不断地发生着剧烈反应。 &emsp;&emsp;本书作者仲昭川在互联网经济这一章曾这样描述过互联网： 东方的先哲曾以“天人合一论”兴起了以道德为主线的农业文明，随后西方的民主法治和流水线分工率先把社会重新组合为以金钱为主线的工业文明。而Internet带来的信息革命，又极大地破坏了以这个分析为哲学、以垄断为目标、以金钱为动力的西方体系，人类世界的文明再次转向以神秘为哲学、以分享为目标、以道德为动力的东方体系。 &emsp;&emsp;这样的描述让我们开始重新审视互联网，互联网时代的本质是数据对数据、信息对信息交换，这种经济的特点是，在给了人们更多选择的自由的同时，让更多的东西逐渐从黑暗中走出来，成为公信力引导下的公开博弈，而更加不可思议的是，这种近乎原始时代的信誉体系却是人们主动地、自发地建立并维护的。社会的一切都是价格和价值，而到了互联网时代一切都变成了利益和兴趣。互联网时代更多的是在以价值为导向，而非以技术为导向。因为真正能改变甚至颠覆传统行业的互联网模式，可能并不是建立在一项伟大的技术的基础之上，而是这种新的模式能为人们的生活带来怎样的利用价值，互联网的本质是服务行业，这种属性到了移动互联网时代变得更加地明确了。 IT行业和互联网行业是完全不同的两个行业。这种界定，是科技与人文、技术与关系之间的分野。 &emsp;&emsp;具体的理解是，互联网是一个泛行业或者说全行业，因为对于任何一个行业，只要你有足够的线上用户就可以称之为互联网行业。而在不久的将来，任何行业都将具有互联网行业的属性，因为互联网将深刻地影响到各个行业。可以说互联网的本质就是关系，而且是全新的、广泛的关系、跨越时空的关系;而且是不管什么需求，都要发生关系;而且是跟任何人发生关系，不管是熟人还是陌生人;而且是随时随地发生关系，不管是此时此地还是彼时彼地。而IT是什么呢？IT是科技，解决技术问题，当所有的技术集成到一起并能成功运行的时候就是IT,当所有技术集成到一起而且足够轻的时候就是便携，便携就会产生移动，当人们使用这些便携的IT产品相互发生关系时就是移动互联网。 互联网本来就是要让不同兴趣的人分开，让不同利益的人早点各奔前程 &emsp;&emsp;互联网表面上没有边界，可是实际上互联网中的每个人都有自己的倾向和归属。因此互联网上不同的兴趣、不同的利益，使互联网上到处都输部落，不管聊天群还是网站，本质上都是一群兴趣相投的人组成的部落。 当大家都希望长期地、大范围地、频繁地、深入地发生关系的时候，就会产生对品牌的渴望和依赖。 &emsp;&emsp;因为品牌代表了一种稳定的关系，它包含了实用性、信任度、荣誉感，即品牌权威所说的三种关系：利益关系、情感关系、社会关系。 人类文明发展到今天，基本就分为两类：人文与科技。人文崇尚感受，科技崇尚数理 人文的东西，生来就是为了创造经典并流传后世，一到顶峰就很难被超越，给世人留下了恒久的享受或遗产。人文所对应的，是精神、道义、经验、规范、模式、规则等，诸如此类，人文是人们用来管理、调整并保持欲望的一种手段。 科技的东西，是人们用来满足旧欲望并刺激新欲望的，所以它注定昙花一现，随时准备离场、时刻等待淘汰。那些驻足在时光之海的科技发明，不是因为不伟大，而是因为存活时间太短。 互联网的本质是关系 &emsp;&emsp;你了解关系，就了解相互需求，就知道怎么让对象找你，而不是用大成本去寻找对象。 互联网思维有两个特点：与众不同、与己不同 &emsp;&emsp;与众不同就是要存同求异，因为多元共生的互联网才能有创新和活力。&emsp;&emsp;与己不同就是找出自己的优势和不足，和自己发生关系。","tags":[{"name":"互联网","slug":"互联网","permalink":"http://qinyuanpei.github.io/tags/互联网/"},{"name":"哲学","slug":"哲学","permalink":"http://qinyuanpei.github.io/tags/哲学/"},{"name":"思维","slug":"思维","permalink":"http://qinyuanpei.github.io/tags/思维/"},{"name":"价值","slug":"价值","permalink":"http://qinyuanpei.github.io/tags/价值/"}]},{"title":"当Unity3D游戏开发遇上Excel","date":"2015-01-25T19:41:57.000Z","path":"posts/906436376/","text":"&emsp;&emsp;各位朋友，大家好，我是秦元培，欢迎大家关注我的博客，我的博客地址是http://blog.csdn.net/qinyuanpei。今天我们来聊聊常用办公软件Excel和游戏开发那不为人知的秘密。今天的内容将涉及到Excel在游戏开发中的应用以及如何利用程序解析Excel中的数据。 &emsp;&emsp;作为常用的办公软件的Excel相信大家都不陌生啦。可是如果我们认为Excel只是办公软件的话，那么这就不只是天真而是Out了。事实上Excel和游戏开发有着密切的联系，不知道大家还记不记得那款利用Excel开发出来的三国杀，这可能是Excel第一次以游戏开发的身份出现在大家面前吧。我们知道在游戏开发领域有一种工作叫做策划，就像在软件开发领域有一种工作叫做产品经理一样。而在诸多的策划工作中，数值策划是一个可以直接影响游戏进程的工作，因为数值策划体现了一个游戏在整体数值上的平衡，设计者需要维护好这样一个平衡，确保游戏外的玩家和游戏里的敌人面对的是同一个公平的虚拟世界。 &emsp;&emsp;例如《仙剑奇侠传四》这款游戏中，韩菱纱在游戏后期的速度可以说是完全打破了游戏的平衡性，因为韩菱纱本身的速度就比较快，再加上仙风云体术的加速效果完全对玄霄产生了戏剧性压制，导致在游戏结尾的Boss战中经常是韩菱纱出手N次后才挨到玄霄出手，我们知道韩菱纱的乾坤一掷每次消耗气15，可是因为韩菱纱的速度足够快，所以韩菱纱完全可以通过普通物理攻击快速地积满气进而施展乾坤一掷，这就是游戏的平衡性被打破了呀，更不要说这部游戏里最为经典的千方残光剑Bug了，这同样是游戏平衡性的问题，归根到底是紫英的这个技能在配置数据时出现了错误，这充分说明数据的正确合理与否是会对游戏产生重要影响的。尽管我们可以使用Xml、Json、ini、数据库等存储形式来存储这些数据，可是毫无疑问的是，Excel是Window平台上最好的数据处理软件，因此数值策划更倾向于使用Excel来设计游戏中的数据，面对如此重要的数值策划工作，我们自然希望在解析Excel文件时不会出现错误，可是我们总不能指望着策划把Excel数据转换成我们能处理的数据类型吧，因此就有了博主今天的这篇文章，所以在今天的文章中我们主要的内容就是如何通过程序来解析Excel文件。 ###1、项目需求&emsp;&emsp;最近博主一个朋友向我抱怨，说手头上有好几百个Excel工作表要处理，大概几十万条数据吧。原因是当时公司分配任务时交待不清，等到了向公司交接数据的时候，朋友忽然发现这些Excel文件的表格格式和公司规定的不一样啊。这可急坏了博主的这位朋友，博主的朋友只好不断地的复制、黏贴，因为这些数据是分布在不同的数据表里，朋友整天都忙得焦头烂额，可是即使这样效率还是得不到保证啊，朋友最后找到了博主这里，问我能不能编写程序帮他解决这个问题。因为平时经常与技术圈子里的朋友聊天，所以在博主印象里Excel的解析在游戏开发中还是较为常见的，而且博主知道对于微软的Office办公软件是可以通过VBA编程来实现某些功能的，可是因为博主一直在用国产的WPS，所以对于Excel的解析基本上是停留在一个概念性的认识上，可是朋友的忙不能不帮不是，所以博主决定借着这个机会好好研究下Excel文件的解析。 ###2、解决方案&emsp;&emsp;因为博主在之前并没有过解析Excel文件的经历，所以博主就到Github上淘了些开源项目。和很多人爱逛天猫、淘宝的经历类似，如果你发现有一个人经常喜欢到Github上晃荡、喜欢关注技术类的博客或者资讯、经常再看PDF版的技术文档或书籍，请千万不要怀疑，这个人绝对是程序员。哈哈，好了，玩笑就此打住啊。经过博主对这些开源项目的简单分析和整理，目前，对Excel文件解析的解决方案主要有以下三种： ####1、Microsoft.Office.Interop.Excel&emsp;&emsp;第一种解决方案是基于微软提供的Office API,这组API以COM组件的形式给出，我们可以通过调用该API实现对Excel文件的解析。使用这组API非常简单,博主稍后会为大家给出一个示例代码。微软的Office API特点是使用起来方便，可以使用C#、Visual Basic等语言进行相关开发。可是这种解决方案的的缺点同样很明显，因为COM组件主要依赖于系统，因此使用COM组件需要在系统中注册，这将对代码的可移植性产生影响，而且受制于COM技术，这种解决方案只能运行在Windows平台上，无法实现跨平台，加之解析速度较慢，因此这种方案通常只适合在解析速度要求不高，运行环境为Windows平台的应用场景。 ####2、ExcelReader&emsp;&emsp;第二种解决方案得益于OpenOffice标准,OpenOffice标准可以让我们使用一种标准来解析和处理Excel文件而无需关注Excel文件是来自微软的Misrosoft Office、金山的WPS还是其它的办公软件。如果说第一种解决方案是Windows平台上解析Excel文件的选择之一，那么ExcelRead就是跨平台目标下解析Excel文件的首选方案。尤其像Unity3D这样的跨平台解决方案下，选择一个跨平台的类库或者组件能够保证我们的游戏在各种平台下稳定地运行，所以ExcelRead是博主向大家推荐的一个跨平台的Excel解析方案。 ####3、FastExcel&emsp;&emsp;第三种解决方案FastExcel是博主在解决博主的这位朋友的问题时所采取的方案。FastExcel是一个在开源世界里比较著名的Excel读写的类库，因此使用这个类库可以得到较为广泛的社区支持，而且在FastExcel这个项目的源代码中，作者为我们提供了使用FastExel进行Excel解析的相关示例，具有较高的参考价值，基本上可以在这个示例的基础上写出可以运行的代码。根据示例代码的运行结果使用FastExcel单独读写100000行数据基本上维持在3~4秒，读写速度还是蛮快的。不过FastExcel使用的是迭代器和Linq to Xml来读取Excel文件的，所以当数据表中存在空白单元格时，读写的时候会比较诡异，这一点希望大家注意。 ###3、工程案例&emsp;&emsp;既然今天的主题是Unity3D游戏开发，所以无论我们在前面提出了什么样的解决方案，最后我们都要落实到游戏开发上，所以最后和大家分享的是一个Unity3D配合ExcelReader实现Excel解析的简单案例。为什么要选择ExcelReader呢？因为ExcelReader是一个跨平台的解决方案。好了，下面我们一起来学习这个案例：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273using UnityEngine;using System.Collections;using System.IO;using Excel;using System.Data;public class ExcelScripts : MonoBehaviour &#123; void Start () &#123; FileStream m_Stream=File.Open(Application.dataPath + \"\\\\Excel\\\\UserLevel.xlsx\",FileMode.Open,FileAccess.Read); //使用OpenXml读取Excel文件 IExcelDataReader mExcelReader=ExcelReaderFactory.CreateOpenXmlReader(m_Stream); //将Excel数据转化为DataSet DataSet mResultSets=mExcelReader.AsDataSet(); //读取行数 int rowCount=mResultSets.Tables[0].Rows.Count; //逐行读取,从第一行读以跳过表头 for(int i=1;i&lt;rowCount;i++) &#123; //将读取的Excel数据转化成数据实体 UserLevel mUser=new UserLevel(); mUser.Name=mResultSets.Tables[0].Rows[i][0].ToString(); mUser.Level=mResultSets.Tables[0].Rows[i][1].ToString(); mUser.Description=mResultSets.Tables[0].Rows[i][2].ToString(); mUser.Skill=mResultSets.Tables[0].Rows[i][3].ToString(); //输出Debug信息 Debug.Log(mUser.ToString()); //ADD:更多逻辑 &#125; &#125; //定义一个数据实体类UserLevel private class UserLevel &#123; private string m_Name; public string Name &#123; get &#123; return m_Name;&#125; set &#123; m_Name = value;&#125; &#125; private string m_Level; public string Level &#123; get &#123; return m_Level;&#125; set &#123; m_Level = value;&#125; &#125; private string m_Description; public string Description &#123; get &#123; return m_Description;&#125; set &#123; m_Description = value;&#125; &#125; private string m_Skill; public string Skill &#123; get &#123; return m_Skill;&#125; set &#123; m_Skill = value;&#125; &#125; public override string ToString() &#123; return string.Format(\"Name=&#123;0&#125;&amp;Level=&#123;1&#125;&amp;Description=&#123;2&#125;&amp;Skill=&#123;3&#125;\", m_Name,m_Level,m_Description,m_Skill); &#125; &#125;&#125; &emsp;&emsp;好了，这就是今天这篇文章的全部内容了，希望大家喜欢！","tags":[{"name":"Unity3D","slug":"Unity3D","permalink":"http://qinyuanpei.github.io/tags/Unity3D/"},{"name":"游戏","slug":"游戏","permalink":"http://qinyuanpei.github.io/tags/游戏/"},{"name":"Excel","slug":"Excel","permalink":"http://qinyuanpei.github.io/tags/Excel/"}]},{"title":"Unity3D塔防游戏开发项目讲解(下)","date":"2015-01-21T13:50:48.000Z","path":"posts/1176959868/","text":"各位朋友，大家好，我是秦元培，欢迎大家关注我的博客，我的博客地址是http://blog.csdn.net/qinyuanpei。我们知道一个完整的塔防游戏由地图、敌人、防守单位三个部分组成，在上一篇文章中我们已经对地图这块儿进行了全面的讲解，今天我们来说说敌人和防守单位。 敌人篇敌人自动寻路的实现敌人在游戏中有一个基本的行为，即沿着寻路路径向我方阵地移动并发起攻击。在地图篇中，我们详细地介绍了敌人寻路路径的生成原理。既然有了敌人寻路的路线，那么怎么让敌人沿着路线移动呢？其实只要指定敌人寻路的起点就可以了，因为在寻路路径的设计中，我们使用的是一个类似于链表的结构，这样我们就能根据每个结点获取它的目标结点，从而实现敌人沿着寻路路径移动的效果了。因为敌人寻路的路线是定义在PathNode类中的，因此我们可以写出下面这样的代码：123456789101112131415161718192021222324void Move()&#123; Vector3 mPos1=this.transform.position; Vector3 mPos2=this.StartNode.transform.position; //计算敌人与路径节点间的距离 float mDis=Vector2.Distance(new Vector2(mPos1.x,mPos1.y),new Vector2(mPos2.x,mPos2.y)); if(mDis&lt;0.1F)&#123; if(StartNode.ThatNode==null)&#123; //对防守阵地进行摧毁 GameManager.Instance.PlayerHP-=20; //从敌人列表中移除自身 GameManager.Instance.Enemys.Remove(this); //销毁自身 Destroy(this.gameObject); //销毁血条 Destroy(mHPBar.gameObject); &#125;else&#123; StartNode=StartNode.ThatNode; &#125; &#125; //计算敌人的移动方向 Vector3 mDir=new Vector3(mPos2.x-mPos1.x,mPos2.y-mPos1.y,0).normalized; transform.Translate(mDir * MoveSpeed * Time.deltaTime);&#125; 好了，现在我们来一起分析这段代码。首先，我们计算了敌人与路径结点间的距离，这里我们用0.1来近似地表示敌人已经到了路径结点上，此时如果该结点的目标结点为null则表示此时敌人已经到了最后一个结点处，所以敌人会对我方的阵地造成20点的伤害并销毁敌人。在GameManager我们使用了一个列表来管理和维护当前场景中的所有敌人，因此当当前敌人销毁时需要从列表中移除，GameManager类是一个静态类，负责对游戏的全局维护，这个类我们放到稍后来讲啊。那么如果敌人没有走到最后一个结点怎么办呢？我们只需要将StartNode指向StartNode的目标节点，这样我们就可以对整个路径结点实现遍历。这里是不是有种数据结构的感觉呢？哈哈，数据结构和算法是编程中最基础、最重要的内容，这些内容到了游戏开发领域同样是适用的。那么，好了，既然知道敌人是怎么移动的，现在我们就来对敌人进行移动吧，这里是采用计算移动方向的方式来实现，这个很简单啦。 好了，现在我们来说说敌人的血条吧，我们知道当怪物沿着寻路路径向我方阵地发起攻击的时候，我方防守单位会自动地对敌人进行防御性攻击，那么此时血条就可以显示敌人的实时血量，从而方便玩家根据战场的情况来调整兵力部署情况。我们知道从Unity4.6以后Unity开始使用全新的GUI系统UGUI，因为博主在之前的项目中一直使用NGUI，加上博主不是很喜欢做UI，所以每次用NGUI的时候整个人的心情都是不好的，有段时间被NGUI虐得体无完肤，感觉整个人都不好了。好了，既然现在我们有了新的选择UGUI，那么就让我们先睹为快吧！如图，全新的NGUI位于GameObect-&gt;UI菜单下，基本覆盖了常用的如Button、Image、Slider、ScrollBar等控件，因为UGUI刚推出不久，所以博主希望大家还是能客观、公正的对待UGUI和NGUI，博主认为在短期内这两个GUI系统将处于共存的状态，不存在相互替代的可能性。 好了，UGUI所有的控件都是放到一个叫做Canvas的父控件下的，这一点和NGUI的UIRoot有些类似吧！Canvas提供了三种模式的UI系统，即Screen Space-Overlay、Screen Space-Camera、World Space。第一种Screen Space-Overlay它是完全以当前屏幕的像素大小创建的一个矩形范围，即控件是以屏幕坐标来绘制的；第二种Screen Space-Camera它是根据相机的视线范围来确定的一个矩形范围，其控件是根据Camera的ViewPortPoint坐标来绘制的;第三种从名称我们就可以知道，它是完全3D化的UI,使用的是常用的世界坐标。博主是刚开始研究UGUI,如果有不对的地方还希望大家能够原谅啊。好了，下面我们正式来做血条吧，在这里我们使用的是默认的Slider控件，用Slider控件来制作血条需要将Slider控件自带的滑块删除，然后我们通过改变value就可以实现一个简单的血条了。在UGUI中所有的图片素材都是以Sprite的形式来出现的，所以UGUI可以自己生成图集，不需要像NGUI在做UI前首先要生成图集。这是博主做的一个简单的血条。现在血条做好了，可是问题来了：这UGUI的所有控件都必须要放到Canvas下面啊，所以我们没法像NGUI一样直接把做好的血条放到怪物下面。怎么办呢？既然不能放到怪物下面，那我们就放到Canvas下面吧，不过我们需要自己计算血条的位置。好了，下面来看代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105public class Enemy : MonoBehaviour &#123; //敌人的生命值 public float MaxHP; public float HP; //敌人的初始路径节点 public PathNode StartNode; //敌人的移动速度 public float MoveSpeed=0.15F; //敌人的旋转速度 public float RotateSpeed=0.3F; //敌人血条预制件 public GameObject HPBar; //敌人血条组件 private Slider mHPBar; //public EnemySpawn mSpawn; void Awake() &#123; //在敌人列表中增加一个敌人 GameManager.Instance.Enemys.Add(this.GetComponent&lt;Enemy&gt;()); //查找UI Transform mUiRoot=GameObject.Find(&quot;UIManager&quot;).transform; //计算血条位置 Vector3 mPos=this.transform.FindChild(&quot;EnemyHP&quot;).transform.position; //mPos=Camera.main.WorldToViewportPoint(mPos); mPos.z=-5; //生成血条 GameObject go=(GameObject)Instantiate(HPBar,mPos,Quaternion.identity); //使血条成为Canvas的子物体 go.transform.parent=mUiRoot; //对血条进行放缩 go.GetComponent&lt;RectTransform&gt;().localScale=new Vector3(0.5F,0.30F,1); //获取Slider mHPBar=go.transform.GetComponent&lt;Slider&gt;(); &#125; void Move() &#123; Vector3 mPos1=this.transform.position; Vector3 mPos2=this.StartNode.transform.position; //计算敌人与路径节点间的距离 float mDis=Vector2.Distance(new Vector2(mPos1.x,mPos1.y),new Vector2(mPos2.x,mPos2.y)); if(mDis&lt;0.1F)&#123; if(StartNode.ThatNode==null)&#123; //对防守阵地进行摧毁 GameManager.Instance.PlayerHP-=20; //从敌人列表中移除自身 GameManager.Instance.Enemys.Remove(this); //销毁自身 Destroy(this.gameObject); //销毁血条 Destroy(mHPBar.gameObject); &#125;else&#123; StartNode=StartNode.ThatNode; &#125; &#125; //计算敌人的移动方向 Vector3 mDir=new Vector3(mPos2.x-mPos1.x,mPos2.y-mPos1.y,0).normalized; transform.Translate(mDir * MoveSpeed * Time.deltaTime); &#125; void Rotate() &#123; //初始角度 float mStartAngle=this.transform.eulerAngles.z; transform.LookAt(StartNode.transform); //目标角度 float mTargetAngle=this.transform.eulerAngles.z; //计算旋转量 float mAngle=Mathf.MoveTowardsAngle(mStartAngle,mTargetAngle,RotateSpeed *Time.deltaTime); this.transform.eulerAngles = new Vector3(0,0,mAngle); &#125; void Update () &#123; Move(); UpdateHPBar(); &#125; private void UpdateHPBar() &#123; //更新血条位置 Vector3 mPos=this.transform.FindChild(&quot;EnemyHP&quot;).transform.position; //使血条位于顶层 mPos.z=-5; mHPBar.transform.position=mPos; //更新血量 mHPBar.value=(float)HP/MaxHP; &#125; public void SetDamage(int mValue) &#123; HP-=mValue; if(HP&lt;=0)&#123; Destroy(this.gameObject); Destroy(mHPBar.gameObject); GameManager.Instance.Enemys.Remove(this.GetCopmonent&lt;Enemy&gt;()); &#125; &#125;&#125; 在这里我们做了三件事情： 第一，在Awake方法中我们首先计算出血条的位置然后在这个位置生成血条，并取得相关的变量备用。 第二，在Update方法中增加一个UpdateHPBar方法以实现对血条血量的更新。 第三，增加了一个SetDamage方法，当敌人血量为0时销毁自身、销毁血条、从敌人列表中移除敌人 敌人按波次进攻的实现好了，到现在为止，对于敌人的逻辑我们就全部实现了。可是我们知道在塔防游戏中敌人通常是一波一波出现的，所以我们需要一个敌人生成器EnemySpawn。那么，怎么来生成敌人呢，这里我们使用Xml文件来配置要生成的敌人列表，首先我们来构建一个Xml文件：12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?&gt;&lt;Enemies&gt; &lt;Enemy Wave=\"1\" EnemyName=\"Enemy\" Level=\"1\" Wait=\"0.5\"/&gt; &lt;Enemy Wave=\"2\" EnemyName=\"Enemy\" Level=\"2\" Wait=\"0.45\"/&gt; &lt;Enemy Wave=\"2\" EnemyName=\"Enemy\" Level=\"2\" Wait=\"0.45\"/&gt; &lt;Enemy Wave=\"3\" EnemyName=\"Enemy\" Level=\"3\" Wait=\"0.4\"/&gt; &lt;Enemy Wave=\"3\" EnemyName=\"Enemy\" Level=\"3\" Wait=\"0.4\"/&gt; &lt;Enemy Wave=\"3\" EnemyName=\"Enemy\" Level=\"3\" Wait=\"0.4\"/&gt; &lt;Enemy Wave=\"4\" EnemyName=\"Enemy\" Level=\"4\" Wait=\"0.35\"/&gt; &lt;Enemy Wave=\"4\" EnemyName=\"Enemy\" Level=\"4\" Wait=\"0.35\"/&gt; &lt;Enemy Wave=\"4\" EnemyName=\"Enemy\" Level=\"4\" Wait=\"0.35\"/&gt; &lt;Enemy Wave=\"4\" EnemyName=\"Enemy\" Level=\"4\" Wait=\"0.35\"/&gt; &lt;Enemy Wave=\"5\" EnemyName=\"Enemy\" Level=\"5\" Wait=\"0.3\"/&gt; &lt;Enemy Wave=\"5\" EnemyName=\"Enemy\" Level=\"5\" Wait=\"0.3\"/&gt; &lt;Enemy Wave=\"5\" EnemyName=\"Enemy\" Level=\"5\" Wait=\"0.3\"/&gt; &lt;Enemy Wave=\"5\" EnemyName=\"Enemy\" Level=\"5\" Wait=\"0.3\"/&gt; &lt;Enemy Wave=\"5\" EnemyName=\"Enemy\" Level=\"5\" Wait=\"0.3\"/&gt; &lt;Enemy Wave=\"6\" EnemyName=\"Enemy\" Level=\"99\" Wait=\"0.15\"/&gt;&lt;/Enemies&gt; 从这个Xml文件中我们可以看到这样一个结构：1234567891011121314151617using UnityEngine;using System.Collections;using System.Collections.Generic;using System.Xml;public class SpawnData &#123; //敌人进攻波数 public int Wave; ///敌人名称，我们将根据这个名称来生成不同的敌人 public string EnemyName; //敌人等级，我们将根据这个值来调整敌人的生命值和移动速度 public int Level; public float Wait;&#125; 在SpawnData这个结构中，我们可以得到敌人攻击的波数、敌人的名称、敌人等级、敌人生成需要等待的时间，因为博主在游戏中只有一种敌人，所以敌人的名称都是一样的。好了，现在我们可以开始解析Xml了：1234567891011121314151617181920212223//解析Xml文件void ReadXml()&#123; //创建一个字典以存储敌人列表 mEnemyDatas=new List&lt;SpawnData&gt;(); //加载Xml文档 XmlDocument mDocument=new XmlDocument(); mDocument.LoadXml(ConfigFile.text); XmlElement mRoot=mDocument.DocumentElement; //解析Xml文档 XmlNodeList mNodes=mRoot.SelectNodes(&quot;/Enemies/Enemy&quot;); foreach(XmlNode mNode in mNodes) &#123; //为每一个SpawnData赋值 SpawnData mData=new SpawnData(); mData.Wave=int.Parse(mNode.Attributes[0].Value); mData.EnemyName=mNode.Attributes[1].Value; mData.Level=int.Parse(mNode.Attributes[2].Value); mData.Wait=float.Parse(mNode.Attributes[3].Value); mEnemyDatas.Add(mData); &#125;&#125; 那么好了，在解析完Xml后我们得到了所有的敌人数据，接下来我们只需要按照顺序生成敌人就可以了。具体怎么做呢，我们知道在塔防游戏中生成敌人有两种情况： 一个是要生成的敌人和当前敌人是同一波的，这种情况只要继续生成就好了。 一个是要生成的敌人的波数大于当前波数，这种情况需要等待这一波敌人被消灭完。 好了，现在来写代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124using UnityEngine;using System.Collections;using System.Collections.Generic;using System.Xml;public class EnemySpawn : MonoBehaviour &#123; //敌人寻路起点 public PathNode SpawnPath; //敌人预制件 public GameObject Enemy; //Xml文件 public TextAsset ConfigFile; //存放敌人的数组 private List&lt;SpawnData&gt; mEnemyDatas; //当前敌人进攻波数 private int mWave=0; //当前敌人索引 private int mIndex=0; //当前等待的时间 private float mWait; void Start() &#123; //读取Xml数据 ReadXml(); Debug.Log(mEnemyDatas.Count); //初始化攻击波数 SpawnData mData=mEnemyDatas[mIndex]; //设置攻击波数和等待时间 mWave=mData.Wave; mWait=mData.Wait; GameManager.Instance.AttackWave=mWave; //生成第一个敌人 CreateEnemy(mData); mIndex+=1; &#125; void CreateEnemy(SpawnData mData) &#123; GameObject go=(GameObject)Instantiate(Enemy,SpawnPath.transform.position,Quaternion.identity); Enemy _Enemy=go.GetComponent&lt;Enemy&gt;(); //根据Level计算敌人的生命值和移动速度 _Enemy.MaxHP= (float)mData.Level*0.25F * 100; _Enemy.HP= (float)mData.Level*0.25F * 100; go.GetComponent&lt;Enemy&gt;().MoveSpeed=(float)mData.Level * 0.15F; go.GetComponent&lt;Enemy&gt;().StartNode=SpawnPath; &#125; void Update () &#123; if(mIndex&lt;=mEnemyDatas.Count-1)&#123; SpawnEnemy(); &#125;else &#123; //当索引数目大于敌人列表中的数目时，表示所有敌人以及生成完毕，此时 //如果所有的敌人都被消灭，则表示玩家获胜。 if(GameManager.Instance.Enemys.Count==0)&#123; GameManager.Instance.IsWin=true; Debug.Log(&quot;玩家胜&quot;); &#125; &#125; &#125; private void SpawnEnemy() &#123; //取得下一个生成的敌人的数据 SpawnData mData=mEnemyDatas[mIndex]; //开始计时 mWait-=Time.deltaTime; if(mWait&lt;=0 )&#123; //如果当前是同一波敌人，则继续生成敌人 if(mWave==mData.Wave)&#123; //设置等待时间 mWait=mEnemyDatas[mIndex].Wait; //设置进攻波数 mWave=mEnemyDatas[mIndex].Wave; GameManager.Instance.AttackWave=mWave; //生成一个敌人 if(mData!=null)&#123; CreateEnemy(mData); &#125; mIndex+=1; &#125;//如果是下一波敌人，则需要等待这一波敌人全部死亡后再生成 else if(mWave&lt;mData.Wave &amp;&amp; GameManager.Instance.Enemys.Count==0)&#123; //设置等待时间 mWait=mData.Wait; //设置进攻波数 mWave=mData.Wave; GameManager.Instance.AttackWave=mWave; //生成一个敌人 CreateEnemy(mData); mIndex+=1; &#125; &#125; &#125; //解析Xml文件 void ReadXml() &#123; //创建一个字典以存储敌人列表 mEnemyDatas=new List&lt;SpawnData&gt;(); //加载Xml文档 XmlDocument mDocument=new XmlDocument(); mDocument.LoadXml(ConfigFile.text); XmlElement mRoot=mDocument.DocumentElement; //解析Xml文档 XmlNodeList mNodes=mRoot.SelectNodes(&quot;/Enemies/Enemy&quot;); foreach(XmlNode mNode in mNodes) &#123; //为每一个SpawnData赋值 SpawnData mData=new SpawnData(); mData.Wave=int.Parse(mNode.Attributes[0].Value); mData.EnemyName=mNode.Attributes[1].Value; mData.Level=int.Parse(mNode.Attributes[2].Value); mData.Wait=float.Parse(mNode.Attributes[3].Value); mEnemyDatas.Add(mData); &#125; &#125;&#125; 我们可以注意到，到现在为止敌人相关的内容博主都已经为大家讲解完了，这里博主和大家开了一个小玩笑，不知道大家有没有发现，在敌人的Xml配置文件中博主最后设计了一个等级为99级的敌人，哈哈，这个敌人在游戏中的特点大家要自己从代码中来探索了，大家可以按照博主的思路做出这个塔防游戏然后自己去试试看，相信大家会更加深刻地理解数值平衡的重要性吧！ 防守单位篇防守单位是塔防游戏中玩家可以支配和控制的一种资源，玩家通过合理地分布防守单位的位置来对玩家的防守阵地进行防御，当玩家的防守阵地被摧毁时玩家将无法继续部署防守单位。这就是防守单位在游戏中的主要作用。通常为了增加游戏的可玩性，游戏设计者往往会设计多种防守单位，在博主的这个小游戏中，我们只设计了一种防守单位，更多的防守单位的设计大家可以参考《保卫萝卜》和《植物大战僵尸》这两个游戏。好了，说了这么多，那么防守单位在整个塔防游戏中主要的作用是什么呢？答案就是防守，哈哈，这是一句不折不扣的废话。可是就是这样一句废话，却足以让我们知道防守单位需要对敌人进行自动攻击，这就要涉及到简单的AI算法了。好了，我们来看下面的脚本：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116using UnityEngine;using System.Collections;public class Defender : MonoBehaviour &#123; //目标敌人 private Enemy mTarget; //攻击半径 public float AttackArea=2.5F; //与敌人的距离 private float mDistance=0; //防守单位的旋转速度 public float RotateSpeed=1.5F; //防守单位攻击间隔 public float AttakTime=2.5F; //防守单位攻击间隔 private float mTime=0.0F; //炮弹预设 public GameObject BulletObject; void Start () &#123; //初始化防守单位攻击间隔 mTime=AttakTime; &#125; //查找攻击范围内的敌人 void FindEnemy() &#123; //初始化目标敌人 mTarget=null; //获取敌人列表 ArrayList mEnemys=GameManager.Instance.Enemys; //遍历每个敌人 foreach(Enemy _enemy in mEnemys) &#123; //忽略生命值为0的敌人 if(_enemy.HP==0) continue; //计算防守单位与敌人间的距离 Vector3 mPos1=transform.position; Vector3 mPos2=_enemy.transform.position; float mDis=Vector2.Distance(new Vector2(mPos1.x,mPos1.y),new Vector2(mPos2.x,mPos2.y)); if(mDis&gt;AttackArea)&#123; //Debug.Log(&quot;敌人&quot; + _enemy.transform.name + &quot;未进入攻击范围,距离为:&quot; + mDis); //return; &#125;else&#123; //Debug.Log(&quot;敌人&quot; + _enemy.transform.name + &quot;已进入攻击范围,距离为:&quot; + mDis); //选择最近的敌人 if(mDistance==0 || mDistance &gt; mDis)&#123; mTarget=_enemy; mDistance=mDis; &#125; /*//选择生命值最低的敌人 if(mLife==0 || mLife &gt; _enemy.HP)&#123; mTarget=_enemy; mLife=_enemy.HP; &#125; */ &#125; &#125; mDistance=0; &#125; void RotateTo() &#123; //判断目标敌人是否为空 if(mTarget==null) return; //计算要旋转到敌人方向的角度 Vector3 mPos1=this.transform.position; Vector3 mPos2=mTarget.transform.position; Vector3 mDir=(mPos2-mPos1).normalized; //使得两向量共面 mDir.z=0; //计算两向量角度 float mAngle=getAngle(Vector3.up,mDir); this.transform.eulerAngles=new Vector3(0,0,mAngle) * RotateSpeed; &#125; //根据向量数学计算角度 private float getAngle(Vector3 v1,Vector3 v2) &#123; float mDot=Vector3.Dot(v1,v2); float mv1=Mathf.Sqrt(v1.x*v1.x+v1.y*v1.y+v1.z*v1.z); float mv2=Mathf.Sqrt(v2.x*v2.x+v2.y*v2.y+v2.z*v2.z); if(v2.x&gt;v1.x)&#123; return -Mathf.Acos(mDot/(mv1*mv2))* Mathf.Rad2Deg ; &#125;else&#123; return Mathf.Acos(mDot/(mv1*mv2))* Mathf.Rad2Deg ; &#125; &#125; void Attack() &#123; RotateTo(); if(mTarget==null) return; //以下添加攻击逻辑 mTime-=Time.deltaTime; if(mTime&lt;0)&#123; Vector3 _angle=transform.Find(&quot;Bullet&quot;).eulerAngles; Vector3 _pos=new Vector3(this.transform.position.x,this.transform.position.y,-2); Instantiate(BulletObject,_pos,Quaternion.Euler(_angle)); mTime=AttakTime; &#125; &#125; void Update () &#123; FindEnemy(); Attack(); &#125;&#125; 防守单位的脚本定义在Defender这个类中，主要的行为有两个，即发现敌人后转向敌人、向敌人发射炮弹，这块的代码较为简单，大家自己去领会就好啦。我们知道在塔防游戏中玩家可以通过点击屏幕来自由地增加或移动防守单位，这部分的内容主要是和GUI相关的，因为目前博主对UGUI掌握地还不是很熟，所以就等以后博主有时间了再来补充吧！好了，这个塔防游戏的讲解教程就是这样了，希望大家能够喜欢，我知道大家等这篇下篇已经好久了，哈哈！最后想说的是，博主的独立博客http://qinyuanpei.github.io正式开始使用了，以后发表的文章会在独立博客和CSDN同时更新，希望大家能继续关注博主的博客！谢谢大家","tags":[{"name":"Unity3D","slug":"Unity3D","permalink":"http://qinyuanpei.github.io/tags/Unity3D/"},{"name":"游戏开发","slug":"游戏开发","permalink":"http://qinyuanpei.github.io/tags/游戏开发/"},{"name":"塔防","slug":"塔防","permalink":"http://qinyuanpei.github.io/tags/塔防/"}]},{"title":"剑指Offer读书笔记(1)","date":"2015-01-20T10:04:41.000Z","path":"posts/123663202/","text":"&emsp;&emsp;在此将【剑指Offer】中的经典问题和重要内容整理出来，便于以后遇到类似的问题再次查阅。博主强烈为大家推荐这本书，因为这本书中的题目都来自真实的公司笔试，对于大家求职、找工作会有很大的帮助。 ###1、在定义一个赋值运算符时，通常需要考虑以下四点： 是否将返回值的类型声明为该类型的引用，并在函数结束前返回实例自身的引用(即*this)。只有一个返回引用，才可以允许连续赋值，否则如果函数的返回值是void，应用该赋值运算符将不能做连续赋值。 是否将传入的参数类型声明为常量引用。如果传入的参数不是引用而是实例，那么从形参到实参会调用一次复制构造函数，把参数声明为引用可以避免这样的无谓消耗，能提高代码的效率。同时，我们在赋值运算函数内部不会改变传入的实例状态，因此应该在传入的引用参数前加上const关键字。 是否释放实例已有的内存，如果我们忘记在分配新内存之前释放自身已有的空间，恒旭将出现内存泄漏。 是否判断传入的参数和当前的实例是否是同一个实例。如果是同一个，则不进行赋值运算，直接返回，如果事先不判断就进行赋值，那么在释放实例自身内存的时候就会导致严重的问题，当*this和传入的参数是同一个实例时，一旦释放了自身的内存，传入的参数的内存将同时被释放，因此将再也找不到需要赋值的内容了。 &emsp;&emsp;当我们完整的考虑了上述四个方面以后，我们可以写出如下的代码：1234567891011CMyString&amp; CMyString::operator = (const CMyString &amp;str)&#123; if(this==&amp;str) return; delete []m_pData; m_pData=NULL; m_pData=new char[strlen(str.m_pData)+1]; strcpy(m_pData,str.m_pData); return *this;&#125; ###2、要想在赋值运算符函数中实现异常安全性，我们有两种方法 方法一：先用new分配新内容再用delete释放已有内容。这样只有当分配内容成功后再释放原来的内容，换句话说当分配内存失败时我们可以确定CMyString的实例不会被修改。 方法二：先创建一个临时实例，再交换临时实例和原来的实例 &emsp;&emsp;下面给出第二种方法的实现代码：12345678910111213CMyString&amp; CMyString::operator = (const CMyString &amp;str)&#123; if(this！=&amp;str)&#123; CMyString strTemp(str); char* pTemp=strTemp.m_pData; strTemp.m_pData=m_pData; m_pData=pTemp; &#125; return *this&#125; ###3、对于C++和C#中的struct和class的认识 C++:在C++中如果没有标明成员函数或者成员变量的访问权限级别，则在struct中默认的是public，在class中的默认的private。 C#:在C#中如果没有标明成员函数或者成员变量的访问级别，则struct和class默认都是private，不同的是struct定义的是值类型，其实例在栈上分配内存；class定义的是引用类型，其实例在堆上分配内存。 ###4、在C#中实现单例模式 原理：在C#语法中C#是在调用静态函数时初始化静态变量，.NET运行时可以保证只调用一次静态构造函数，这样我们就可以保证仅初始化一次Instance;下面给出代码示例：12345678910111213public sealed class Singleton&#123; private Singleton() &#123; &#125; private static Singleton instance=new Singleton(); public static Singleton Instance &#123; get&#123; return instance;&#125; &#125;&#125; ###5、C++数组重要概念 数组是最简单的一种数据结构，它占据一块连续的内存并按照顺序存储数据。 在C/C++中，数组和指针是相互关联又有区别的两个概念。当我们声明一个数组时，其数组的名字同时是一个指针，该指针指向数组的第一个元素，因此我们可以使用一个指针来访问数组。可是值得注意的是，C/C++并没有记录数组的大小，因此使用指针访问数组中的元素时要注意不能超出数组的边界。 使用sizeof计算指针的大小时，在32位操作系统中，对于任意指针结果都是4。 二维数组在内存中占据连续的空间。在内存中从上到下存储各行元素，在同一行中按照从左到右的顺序存储。因此我们可以根据行号和列号计算出相对于数组首地址的偏移量，从而找到对应的元素。 ###6、C#中的String类型 在C#中封装字符串的类型Sysytem.String有一个非常特殊的性质，即String中的内容是不能改变的。当尝试改变String中的内容，就会产生一个新的实例。 如果要连续多次修改字符串内容，可以考虑使用StringBuilder。 当我们需要在函数或者方法中返回一个String实例时，我们需要在传入的参数前加上ref或者out标记 ###7、链表 链表是一种动态数据结构，因为在创建链表的时候，不需要知道链表的长度。当插入一个结点时，我们只需要为新结点分配内存，然后调整指针的指向来确保新结点被链接到链表当中。内存分配不是在创建链表时一次性完成，而是每添加一个结点分配一次内存。由于没有闲置的内存，因此链表的空间效率比数组要高。 因为链表中的内存不是一次性分配的，所以我们不能确定链表的内存和数组一样是连续的，因此如果想在链表中找到第i个结点，我们只能从头结点开始，沿着指向下一个结点的指针遍历链表，其效率是O(n)。而在数组中，我们可以根据下标i直接找到第i个元素，其效率是O(1)。 当我们需要从尾到头输出链表时，第一个遍历到的结点最后一个输出，而最后一个遍历到的结点第一个输出，这是典型的后进先出，因此我们可以考虑使用栈来实现这种顺序。下面是具体的代码实现：123456789101112131415161718void PrintListReversingly_Iteratively(ListNode* pHead)&#123; std::stack&lt;ListNode*&gt; nodes; ListNode* pNode=pHead; while(pNode!=NULL) &#123; nodes.push(pNode); pNode=pNode-&gt;m_pNext; &#125; while(!nodes.empty()) &#123; pNode=nodes.top(); printf(\"%d\\t\",pNode-&gt;m_nValue); nodes.pop(); &#125;&#125; ###8、树 除了根节点之外每个结点只有一个父结点，根节点没有父结点。 除了叶节点以外所有结点都有一个或者多个子结点，叶结点没有子结点。父结点和子结点间用指针链接。 二叉树是树的一类特殊结构，在二叉树的每个结点最多只能有两个子结点。二叉树有三种主要的遍历方式，即前序遍历(根、左、右)、中序遍历(左、根、右)、后序遍历(左、右、根)。 二叉搜索树是二叉树的一个特例，其特点是左子节点总是小于或等于根节点，右子结点总是大于或等于根节点。 ###9、栈和队列 栈的特点是后进先出，即最后一个被压入(Push)栈的元素会第一个被弹出(Pop)。 队列的特点是先进先出，即第一个进入队列(入队)的元素将会第一个出来(出队)。 ###10、递归与循环 递归实现的效率无法和循环相比，因此函数调用会造成时间和空间的损失、会造成重复计算、可能会造成栈溢出。在经典的斐波那契数列问题中，我们可以采用下面的方法来代替传统的递归方法：123456789101112131415161718int Fiboncci(int n)&#123; int[] result=new int[]&#123;0,1&#125;; if(n&lt;2) return result[n]; int m=1; int n=0; int k=0; for(int i=2;i&lt;=n;i++) &#123; k=m+n; n=m; m=k; &#125; return k;&#125; ###11、位运算 左移m&lt;&lt;n表示把m左移n位。左移n位的时候，最左边的n位将被丢弃，同时在最右边补上n个0。如： 00001010&lt;&lt;2=00101000 10001010&lt;&lt;3=01010000 右移m&gt;&gt;n表示把m右移n位。右移n位的时候，最右边的n位将被丢弃。此时如果数字是一个无符号数值，则用0填补最左边的n位;如果数字是一个正数，则在右移之后在左边补n个0;如果数字是一个负数，则右移之后在左边补n个1。如： 00001010&gt;&gt;2=00000010 10001010&gt;&gt;3=11110001","tags":[{"name":"技术","slug":"技术","permalink":"http://qinyuanpei.github.io/tags/技术/"},{"name":"读书","slug":"读书","permalink":"http://qinyuanpei.github.io/tags/读书/"},{"name":"面试","slug":"面试","permalink":"http://qinyuanpei.github.io/tags/面试/"},{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://qinyuanpei.github.io/tags/剑指Offer/"}]},{"title":"写给永远单纯的自己","date":"2015-01-01T21:36:24.000Z","path":"posts/2752169106/","text":"&emsp;&emsp;即将到来的是新的一天，我却不能在疲惫中很快入睡，听着耳边再熟悉不过的歌，即使不是大家都喜欢的那种慷慨激昂的曲调，然而在这安静得无从察觉一个人内心世界的夜晚，这样温婉柔和的小调反而更容易让人静下心来想些事情。今天新住的宾馆简约而整洁，最为重要的是终于有了一张属于自己的桌子。以前每次趴在床上画图斑，等到再站起来时背部便开始痛起来。偶尔盘腿坐在床上录数据，等到再站起来时脚已经麻了。这样做的一个坏处是每次都会把中性笔的墨水弄到床单上，虽然顾客是上帝，可是上帝不断地给人类制造麻烦，这样真的好吗？与此同时，开始意识到一个良好的姿势对于健康是多么的重要了。 &emsp;&emsp;此时此刻，床上已经堆满了各种各样的图纸，那些来自我上个星期处理过的内业。所谓内业就是在室内加班，如果公司上下一致通过，理论上是符合SA8000社会责任标准体系的，所以内业是可以借休息的名义来进行的。这两天想了很多的问题，从什么地方说起呢？我想我可以从这些地方来谈谈我的想法吧。 &emsp;&emsp;首先是交流，我承认我是一个不喜欢说话的人。我不喜欢说话，从来不是因为我不敢而是因为我不愿意。我不喜欢看选秀节目、我不喜欢娱乐八卦、我不喜欢猎奇找刺激。我平时最为喜欢的是科技报道、技术博客和游戏资讯，因为此时此刻我站在科技和游戏的一个十字路口。我喜欢古香古色的传统文化，喜欢在书籍中寻找精神的依托，我就是这样一个传统而现代的人。可是这样一个时代注定是一个娱乐化的时代，当你打开电视，你会发现到处都是导师、到处都是明星、到处都是嘉宾，因为我们生活在一个每天都在造星的浮躁时代。我承认再这样一个时代充满了机会，可是当我们每一个人都缺乏耐心来专注于一件事情的时候，这样的机会对于我们又有什么意义呢？ &emsp;&emsp;我今天早上看《我是演说家》这个节目，我觉得这是一个比较有品位的节目，如乐嘉所说，这个节目的收视率可能不会像其它的娱乐节目那样高，可它能让你的内心真正有所触动，因为讲故事的人可能是一个你素不相识的人，可是它讲的故事可能会是你身上正在发生的事情。我从来不怀疑语言的力量，从春秋战国的张仪、苏秦等纵横家到三国时期诸葛亮舌战群儒再到世界上著名的营销专家，语言可以说世界上最锋利的武器，可是当大家都在讨论时下最为流行的娱乐节目时，我忽然觉得自己实在没有开口的必要了。那次领导说我分不清书记和主任，因为我觉得人与人之间的交流应该是随着时间的推移而不断深入的，所谓慢工出细活，我觉得交朋友应该像喝茶一样慢慢地品，像喝酒一样交朋友只能交到酒肉朋友。我们为了赶上工作进度，可能一周会去三四个地方，因此和许多人都只是一面之缘，所以我觉得分不清主任和书记尚属情有可原。 &emsp;&emsp;我每隔一段时间就会去我的博客看看，每次碰到问我问题的朋友我都很热心的回答，因为我觉得人与人之间真的存在某种特殊的联系。我特别喜欢和技术圈子里的这些朋友聊天，因为我觉得在这些人中间可以找到共同的话题，或许大家的经济状况都不宽裕，可是听着每一个人的故事都是一部奋斗史，没有人能随随便便成功，可是每一个人都在用一种近乎纯粹的信仰去努力实现，而不是随波逐流。或许这就是我喜欢这行的真正原因吧，每一天都充满新的挑战，每一天都是在不断创造，我就是喜欢这样的创造性工作，而不繁琐单调的机械重复。回到交流这个问题上，人是一种麻烦的动物，所以在和人打交道的这个问题上，我们把大量的时间浪费在了交流上。我承认团队间的交流十分重要，可是因为人的惰性和私欲，交流有时候会占用大量的时间成本，在这一点上计算机更值得人类学习，因为它忠诚可靠而且一视同仁。 &emsp;&emsp;接下来是工作，我一直坚信伟大的工作和平庸的工作间的区别就是能否让工作的人感到自豪。我的理想并不伟大，我只想某天朋友们聚到一起时候，我惊讶地发现你们的手机或者智能设备上运行着我设计的应用程序或者游戏，然后我平静地告诉你这些都是我设计的，这时候轮到你们惊讶：天啊，它简直堪称完美！在舜土实习已经快一个月了，可是我并没有对自己的工作感到自豪过，即使我能将10个左右的自然村在一个下午全部做完，可是我依然感到这是一份平庸的工作。首先，为了追赶进度，将一个行政村集中到一天来做，相比土地确权工作两天一个自然村的进度，整体质量较为粗放。其次，将希望完全寄托在队长身上，队长如果不配合，工作很难开展，如果队长失去耐心，工作会变得更加艰难。说实话，这些村民生活在山区生活困顿不堪，可是每次到村里都很热心地招待我们，这让我在感受到他们的质朴时更加自责，我们所做的工作从本质上来讲根本没有什么意义，每次和这些队长交流，他们最关心的问题就是他们的土地会不会被收回去，可是他们视如生命的土地却往往只是国土局任意划定的一个范围。作为一个实习生，或许抱怨工作是不合适的，因为无论到任何一个企业，前3~5年所做的始终都是些基础而琐碎的东西，可是不管让员工做什么，都要让员工觉得他此刻的这份工作是有意义的，因为这关系到一个企业的品位。工作固然是为了挣钱，可是如果工作能带给人幸福感和自豪感，那么我相信对于工作和人都是会有好处的吧，因为兴趣才是最好的老师啊。 &emsp;&emsp;今天搬到宾馆准备处理上周没处理完的事情，领导说明天要去的地方已经联系好了，可是公司的图纸还没有打印出来，他问我怎么处理，我就说跟人家实话实说吧，问题出在我们这边啊。然后他就说我傻，可是我觉得很多问题不是想掩盖就能掩盖的了的，就像我们所做的这个工作，一旦那些队长明白过来我们所做的事情的真正意图，那么整个结果就完全取决于对方，因为如果队长本身就告诉你错误的信息，那么你是无法辨别的。很多的技术公司都会形成自己公司内部的框架或者工具类，因为过度依赖第三方的组件很容易受到被动影响。或许乔布斯的专制和傲慢让很多苹果的员工和用户都曾受到伤害，可是他不过是使用了一个最基本的原则，要想不受制于别人，就必须掌控一切的主动权，所以苹果用自己的软件和自己的硬件打造了一个无可匹敌的强大壁垒。当然，逝者长已，可能苹果的产品中那些属于乔布斯个人标志的风格已经渐渐地淡出了我们的视野，可是我们依然会对这位智者表示无比崇高的敬意。 &emsp;&emsp;回到我的工作，这是一个完全没有追求的工作，昨天下午坐在车上和一个刚认识的朋友，他问我为什么不去找个和开发相关的实习工作啊，突然沉默了好半天，最后只能含糊其辞地糊弄过去。记得上次回银川，和一个实习生一起到楼下的打印店裁剪图册，结果半路上问我是什么专业？结果环境科学再次被鄙视了啊，哈哈，我不知道这样是喜还是悲，总之工作还是喜欢的好。以前我爸说我不喜欢这不喜欢那的，我到底喜欢什么啊？那个时候我没有说什么。可是这一刻我想告诉他我喜欢的就是开发。 &emsp;&emsp;最后要说的是做人，在同学的生日上，突然被人说我单纯，我不知道这该庆幸呢还是该感慨啊。今年的我22岁了，可我还是喜欢简简单单的生活。我不喜欢带着面具生活、我不喜欢口是心非、我不喜欢心机深重。我从来不觉得穿上大人的衣服、梳起大人的发型就能让你成熟起来，真正的成熟是要有责任、有担当。虽然不是每一个人都值得你敞开心扉去交往，可是做人坦诚、正直有什么不对吗？难道你希望每天面对人的时候都盘算着怎么玩弄那些可笑的伎俩吗？我承认在这个世界上有太多的事情我都还不懂，可我会努力去尝试着了解。我不喜欢抽烟、不喜欢喝酒，到现在不会划拳等那些酒场上应该会的东西。如果真想喝酒了，围炉小酌几杯便可以了，何必要让饮酒变成这样一件麻烦的事情呢？ &emsp;&emsp;我承认人生在成长的过程中难免会变得世故圆滑，可是难道这就是我们变得不再单纯的理由吗？这个世界上有两样永远不会变的东西，一样是我们头顶灿烂的星空，一样是我们心中崇高的道德准则。我并不觉得成长就要放弃那些曾经坚持过的东西，如果这些东西注定有一天要丢弃掉，那么何苦要将这些观念从小就灌输给我们，一旦有一天当你发现以前坚守的东西都被自己推翻，而你变成了原来自己不喜欢的哪种人，这将无异于信仰的大厦的坍塌，人的成长竟然要以抛弃自己的过去为代价，这未免过于残酷了吧。我从来都不傻，我看得出每个人心中的想法，只是我不愿意那样做，不管这个社会再怎么变，我不会背叛自己，我只是想让自己在这个浮躁的时代里保持自己的这颗简简单单的心。 &emsp;&emsp;众生虽苦，请诸恶莫作。我并不觉得自己比别人高贵多少，所以我始终像保留一份善良，不管是餐厅的服务员还是酒店的保洁员，每一个出来讨生活的人都不容易，所以多一份尊重比上帝的高傲更容易让人接受。而明天毕业后的我同样会有这一天，我真的不想小河变成大楼，我真的不想单纯变成冷漠，许嵩的这首《秋千坠》很多人都没有用心地听，因此这首歌轻快的节奏只会让人记得那段重复的飘啊飘…以单纯的心去面对这个世界，可能会受到伤害。可是事实上，任何伤害都不足摧毁你，伤害和磨练在你自省和反思过后，只能让你的阅历更丰富，看人更包容，生活更感恩。有人靠着阿谀奉承、靠着耍心机生活，可你不必这样，因为坦荡真诚同样是一种人生，在这个世界上能真正改变你的只有你自己，人出于本能对人存有戒备之心固然无可厚非，可是在保护好自我的情况下以坦荡真诚的胸襟去面对这个世界则更加难能可贵。因为我们不能生活给了你一个杯具就随波逐流，只有你和别人不一样，你才能将这个杯具变成洗具，这就是我想要的生活。最后送上杨绛先生的一段话与大家分享： 一个人经过不同程度的锻炼，就获得不同程度的修养、不同程度的效益。好比香料，捣得愈碎，磨得愈细，香得愈浓烈。我们曾如此渴望命运的波澜，到最后才发现：人生最曼妙的风景，竟是内心的淡定与从容……我们曾如此期盼外界的认可，到最后才知道，世界是自己的，与他人毫无关系。 &emsp;&emsp;已经凌晨三点了，可是写完这篇文字我很开心，这些话总是要经过些事情才能领悟出来，没有一个人能突然成长起来，我希望自己能一直单纯下去，单纯的人生不是痴傻无明，而是大智若愚，更好地爱这个父母送给我们的世界。","tags":[{"name":"数学","slug":"数学","permalink":"http://qinyuanpei.github.io/tags/数学/"},{"name":"贝塞尔曲线","slug":"贝塞尔曲线","permalink":"http://qinyuanpei.github.io/tags/贝塞尔曲线/"},{"name":"计算机图形","slug":"计算机图形","permalink":"http://qinyuanpei.github.io/tags/计算机图形/"}]},{"title":"在平凡中蜕变，我的2014","date":"2014-12-30T19:34:34.000Z","path":"posts/124807650/","text":"&emsp;&emsp;如果生命可以轻到像一枚羽毛，我愿意飞过那片时间的海，突然造访那些曾经让我怀念过的日子，看看那时的我是不是和现在一样，从来不曾后悔过当初的选择。2014年12月31日，面对即将到来的2015，我相信这将是我在平凡中蜕变的一年。回首2014，从年初开始学习Unity3D游戏开发到现在，我的博客共积累了230335次访问量和700名粉丝的关注。首先要感谢各位长期以来关注和支持我的博客的朋友，因为你们的关注和支持就是我不断写下去的动力。2014年，当我渐渐地从一名大四学生的角色转换到一个社会人的时候，我开始认识到原来生活的本质就是平凡。或许我们都只是在做着普普通通的工作，或许我们都只是一个普普通通的人，可是因为我们有一颗不甘于平凡的心，所以我们选择在追逐梦想的路上完成一次次的蜕变。整个2014年基本上可以分成三个阶段： #2014年1月~2014年6月&emsp;&emsp;这段时间是大三的第二学期，基本上就是上课看各种各样的技术类书籍，下课有时间就编程，因为这学期有CAD课程，所以有时候会练习画图。在这段时间。第一次接触到了Linux，因为厌倦了在Windows平台上使用盗版和破解软件的现状，我曾一度想换到Linux平台，不过考虑到我仍然有大量的工作要依赖于Windows，所以这样的愿望只能成为一种奢望。在这段时间，我喜欢上了一个叫做Sublime的代码编辑器，通过各种各样的插件，我将它扩展成了一个万能的编辑器，我会用它来写C#、C++、Java、Lua和Python的小程序，现在我依然很喜欢这个代码编辑器。前几天我给它装上了Markdown Preview插件，这样我便可以使用它来编写Markdown文件。五一的时候和同学骑自行车去了滚钟口，这大概是大三的时候最后一次和同学出去玩啦。大概4月底左右，我将《古剑奇谭》系列的第二部游戏通关。6月份我萌生了利用Unity来开发仙剑同人游戏的想法。 #2014年7月~2014年10月&emsp;&emsp;在结束了这学期的考试后，7月份我们在西安和上海进行了为期半个月的野外课程实习。7月份的西安正值酷暑，整个实习过程总是与汗水为伴。不过因为我不喜欢本科的专业，所以这个实习除了让我有机会看看外面的世界开阔眼界以外，并不会有太实际的意义。在实习期间，我研究了动作类游戏中的三连击效果，这是我在实习中做过的唯一一件与专业无关的事情。8月份回到家里，基本上天天宅在家里做游戏，做了两个射击类的小游戏和一个RPG游戏。9月份到了学校，为了给我的仙剑同人游戏项目寻找素材，我研究了《仙剑奇侠传》、《古剑奇谭》等游戏的解包，并从中提取了大量的游戏模型。为了给模型添加动画，开始学习学习Blender软件，不过后来发现给模型绑骨是件相当麻烦的事情，所以只好放弃3D建模的学习。到目前为止，我只能利用CAD和SU建些简单的模型，希望以后有机会再学习这部分的知识吧。然后剩下的时间基本上都是在捣鼓Linux和Github，剩下的就是做游戏啦。期间研究了Unity与Android平台、Lua脚本的交互等问题，根据这些问题写成的文章深受大家的喜爱，这里再次对大家的支持表示感谢。 #2014年11月~2014年12月&emsp;&emsp;这段时间按照双11来划分的话，双11以前是考试，双11以后是实习。考试没什么值得说的，永远是记忆的内容比实用的内容多。不过当我面对最后一次考试的时候，我的心情极其复杂，因为我真的不知道如果再给我四年，我是不是还会这样选择我的人生。实习的过程是段暂的，可是在实习中我收获的东西却很多，我收获了为人处世的道理，同时收获了一份珍贵的友谊，我想这就是我想去经历和体验的东西吧。在实习过程中，我利用空闲时间研究了塔防游戏和静态博客系统Hexo，我的感觉就是编程环境还是Linux操作系统比较给力，像Ruby这样的环境在Windows下安装简直就是在找虐。好了，不吐槽了，我利用Hexo和Github Page搭建了我的独立博客http://qinyuanpei.github.io/以后我的文章会同时在这两个博客上发布，希望喜欢我的文章的朋友能一如既往的关注和支持我！ &emsp;&emsp;2014年即将过去，面对即将到来的2015年，我想做到5件事情： 认真完成本科毕业设计——做好大学里的最后一件事情 找一份自己喜欢的工作——脚踏实地的追逐自己的梦想 努力做一个有责任感的人——给她想要的温暖 努力做一个善良的人——众生虽苦，诸恶莫作 努力做一个有内涵的人——读书、写作、编程、游戏 &emsp;&emsp;欢迎大家关注我的博客： CSDN博客:http://blog.csdn.net/qinyuanpei 独立博客:http://qinyuanpei.github.io/ &emsp;&emsp;最后祝大家在新的一年里事业有成、梦想成真！","tags":[{"name":"感悟","slug":"感悟","permalink":"http://qinyuanpei.github.io/tags/感悟/"},{"name":"平凡","slug":"平凡","permalink":"http://qinyuanpei.github.io/tags/平凡/"},{"name":"2014","slug":"2014","permalink":"http://qinyuanpei.github.io/tags/2014/"}]}]